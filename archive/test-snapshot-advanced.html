<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Avanc√© - Fonction Snapshot avec Authentification</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
        }
        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #6c757d; cursor: not-allowed; }
        
        .log {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 12px;
            max-height: 500px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .config-info {
            background-color: #e7f3ff;
            border: 1px solid #b3d9ff;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .test-section {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .test-section h3 {
            margin-top: 0;
            color: #333;
        }
        
        .key-display {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 11px;
            word-break: break-all;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #007bff;
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ Test Avanc√© - Fonction Snapshot avec Authentification</h1>
        
        <div class="config-info">
            <h3>üîë Cl√©s d'Authentification Configur√©es</h3>
            <p><strong>Anon Key:</strong></p>
            <div class="key-display">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ1MDU2NTcsImV4cCI6MjA3MDA4MTY1N30.xd9Thasg4r8Nrwxx5nFwyGB_ufPIvok4XB-78dilpsw</div>
            <p><strong>Service Role Key:</strong></p>
            <div class="key-display">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NDUwNTY1NywiZXhwIjoyMDcwMDgxNjU3fQ.5m7nLHxHxOkxQf8maZis7Y7jynqu2dWqIzEbgWvOTcE</div>
        </div>

        <div class="test-section">
            <h3>üîß Tests de Fonctionnement avec Authentification</h3>
            <button onclick="testFunctionWithAnonKey()">Test 1: Fonction avec Cl√© Anon</button>
            <button onclick="testFunctionWithServiceRole()">Test 2: Fonction avec Service Role</button>
            <button onclick="testDatabaseAccess()">Test 3: Acc√®s √† la Base de Donn√©es</button>
            <button onclick="testStorageAccess()">Test 4: Acc√®s au Stockage</button>
            <button onclick="clearLogs()">üóëÔ∏è Effacer les Logs</button>
        </div>

        <div class="test-section">
            <h3>üìä V√©rification des Snapshots</h3>
            <button onclick="checkSnapshotsIndex()">V√©rifier l'Index des Snapshots</button>
            <button onclick="checkStorageFiles()">V√©rifier les Fichiers de Stockage</button>
            <button onclick="createTestSnapshot()">Cr√©er un Snapshot de Test</button>
        </div>

        <div class="test-section">
            <h3>üêõ Debug et Test Automatique</h3>
            <button onclick="debugCronFunction()" style="background-color: #dc3545;">üî¥ Debug Cron - Test Manuel</button>
            <button onclick="monitorAutomaticSnapshots()" style="background-color: #28a745;">üü¢ Monitor Snapshots Auto</button>
            <button onclick="forceCronExecution()" style="background-color: #ffc107; color: #000;">üü° Forcer Ex√©cution Cron</button>
            <button onclick="clearLogs()">üóëÔ∏è Effacer les Logs</button>
        </div>

        <div class="test-section">
            <h3>üìù Logs de Test</h3>
            <div id="logs" class="log">üöÄ Test avanc√© de la fonction snapshot initialis√©...\nCliquez sur un bouton pour commencer les tests.</div>
        </div>

        <div class="test-section">
            <h3>üéØ Prochaines √âtapes</h3>
            <ol>
                <li>Ex√©cuter les tests d'authentification pour v√©rifier l'acc√®s</li>
                <li>Tester la cr√©ation d'un snapshot manuel</li>
                <li>V√©rifier que l'infrastructure est accessible</li>
                <li>Attendre les snapshots automatiques du cron</li>
            </ol>
        </div>
    </div>

    <script>
        const SUPABASE_URL = 'https://fiecugxopjxzqfdnaqsu.supabase.co';
        const FUNCTION_URL = `${SUPABASE_URL}/functions/v1/snapshot_staff_table`;
        const ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ1MDU2NTcsImV4cCI6MjA3MDA4MTY1N30.xd9Thasg4r8Nrwxx5nFwyGB_ufPIvok4XB-78dilpsw';
        const SERVICE_ROLE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NDUwNTY1NywiZXhwIjoyMDcwMDgxNjU3fQ.5m7nLHxHxOkxQf8maZis7Y7jynqu2dWqIzEbgWvOTcE';
        
        function log(message) {
            const logsDiv = document.getElementById('logs');
            const timestamp = new Date().toLocaleTimeString();
            logsDiv.textContent += `[${timestamp}] ${message}\n`;
            logsDiv.scrollTop = logsDiv.scrollHeight;
        }

        function clearLogs() {
            document.getElementById('logs').textContent = 'üöÄ Logs effac√©s...\n';
        }

        async function testFunctionWithAnonKey() {
            log('üîë Test 1: Test de la fonction avec cl√© anon...');
            
            try {
                const response = await fetch(FUNCTION_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${ANON_KEY}`
                    }
                });
                
                const responseText = await response.text();
                log(`üìä R√©ponse avec cl√© anon: ${response.status} ${response.statusText}`);
                
                if (response.status === 200) {
                    log('‚úÖ Fonction ex√©cut√©e avec succ√®s avec cl√© anon!');
                    log(`R√©sultat: ${responseText}`);
                } else if (response.status === 401) {
                    log('‚ö†Ô∏è Fonction accessible mais n√©cessite des permissions plus √©lev√©es');
                    log(`D√©tails: ${responseText}`);
                } else {
                    log(`‚ö†Ô∏è R√©ponse inattendue: ${response.status}`);
                    log(`D√©tails: ${responseText}`);
                }
            } catch (error) {
                log(`‚ùå Erreur avec cl√© anon: ${error.message}`);
            }
        }

        async function testFunctionWithServiceRole() {
            log('üîë Test 2: Test de la fonction avec service role...');
            
            try {
                const response = await fetch(FUNCTION_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SERVICE_ROLE_KEY}`
                    }
                });
                
                const responseText = await response.text();
                log(`üìä R√©ponse avec service role: ${response.status} ${response.statusText}`);
                
                if (response.status === 200) {
                    log('‚úÖ Fonction ex√©cut√©e avec succ√®s avec service role!');
                    log(`R√©sultat: ${responseText}`);
                    
                    try {
                        const result = JSON.parse(responseText);
                        if (result.success) {
                            log(`üì∏ Snapshot cr√©√©: ${result.data.snapshotDate}`);
                            log(`üìä Lignes: ${result.data.rowCount}`);
                            log(`üíæ Taille: ${result.data.fileSize} bytes`);
                            log(`üìÅ Chemin: ${result.data.objectPath}`);
                        }
                    } catch (parseError) {
                        log(`‚ö†Ô∏è Impossible de parser la r√©ponse JSON: ${parseError.message}`);
                    }
                } else {
                    log(`‚ùå √âchec avec service role: ${response.status}`);
                    log(`D√©tails: ${responseText}`);
                }
            } catch (error) {
                log(`‚ùå Erreur avec service role: ${error.message}`);
            }
        }

        async function testDatabaseAccess() {
            log('üóÑÔ∏è Test 3: Test d\'acc√®s √† la base de donn√©es...');
            
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/table_snapshots_index?select=*&limit=5`, {
                    headers: {
                        'apikey': ANON_KEY,
                        'Authorization': `Bearer ${ANON_KEY}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    log(`‚úÖ Acc√®s √† la base de donn√©es r√©ussi`);
                    log(`üìä ${data.length} enregistrements trouv√©s dans table_snapshots_index`);
                    
                    if (data.length > 0) {
                        log(`üìÖ Dernier snapshot: ${data[0].snapshot_date}`);
                        log(`üìÅ Chemin: ${data[0].object_path}`);
                        log(`üìä Lignes: ${data[0].row_count}`);
                    }
                } else {
                    log(`‚ùå √âchec d'acc√®s √† la base: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                log(`‚ùå Erreur d'acc√®s √† la base: ${error.message}`);
            }
        }

        async function testStorageAccess() {
            log('üì¶ Test 4: Test d\'acc√®s au stockage...');
            
            try {
                const response = await fetch(`${SUPABASE_URL}/storage/v1/object/list/table-snapshots`, {
                    headers: {
                        'apikey': ANON_KEY,
                        'Authorization': `Bearer ${ANON_KEY}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    log(`‚úÖ Acc√®s au stockage r√©ussi`);
                    log(`üìÅ Bucket table-snapshots accessible`);
                    log(`üìä ${data.length} objets trouv√©s`);
                    
                    if (data.length > 0) {
                        log(`üìÖ Dernier fichier: ${data[0].name}`);
                        log(`üìè Taille: ${data[0].metadata?.size || 'N/A'} bytes`);
                    }
                } else {
                    log(`‚ùå √âchec d'acc√®s au stockage: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                log(`‚ùå Erreur d'acc√®s au stockage: ${error.message}`);
            }
        }

        async function checkSnapshotsIndex() {
            log('üìä V√©rification de l\'index des snapshots...');
            
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/table_snapshots_index?select=*&order=created_at.desc&limit=10`, {
                    headers: {
                        'apikey': ANON_KEY,
                        'Authorization': `Bearer ${ANON_KEY}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    log(`‚úÖ Index des snapshots accessible`);
                    log(`üìä Total: ${data.length} snapshots`);
                    
                    if (data.length > 0) {
                        log(`üìÖ Snapshots r√©cents:`);
                        data.forEach((snapshot, index) => {
                            log(`   ${index + 1}. ${snapshot.snapshot_date} - ${snapshot.row_count} lignes - ${snapshot.object_path}`);
                        });
                    } else {
                        log(`‚ÑπÔ∏è Aucun snapshot trouv√© dans l'index`);
                    }
                } else {
                    log(`‚ùå √âchec d'acc√®s √† l'index: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                log(`‚ùå Erreur d'acc√®s √† l'index: ${error.message}`);
            }
        }

        async function checkStorageFiles() {
            log('üìÅ V√©rification des fichiers de stockage...');
            
            try {
                const response = await fetch(`${SUPABASE_URL}/storage/v1/object/list/table-snapshots`, {
                    headers: {
                        'apikey': ANON_KEY,
                        'Authorization': `Bearer ${ANON_KEY}`
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    log(`‚úÖ Fichiers de stockage accessibles`);
                    log(`üìä Total: ${data.length} fichiers`);
                    
                    if (data.length > 0) {
                        log(`üìÅ Fichiers r√©cents:`);
                        data.slice(0, 5).forEach((file, index) => {
                            log(`   ${index + 1}. ${file.name} - ${file.metadata?.size || 'N/A'} bytes`);
                        });
                        
                        if (data.length > 5) {
                            log(`   ... et ${data.length - 5} autres fichiers`);
                        }
                    } else {
                        log(`‚ÑπÔ∏è Aucun fichier trouv√© dans le bucket`);
                    }
                } else {
                    log(`‚ùå √âchec d'acc√®s aux fichiers: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                log(`‚ùå Erreur d'acc√®s aux fichiers: ${error.message}`);
            }
        }

        async function createTestSnapshot() {
            log('üì∏ Cr√©ation d\'un snapshot de test...');
            
            try {
                const response = await fetch(FUNCTION_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SERVICE_ROLE_KEY}`
                    }
                });
                
                const responseText = await response.text();
                log(`üìä R√©ponse de cr√©ation: ${response.status} ${response.statusText}`);
                
                if (response.status === 200) {
                    log('‚úÖ Snapshot de test cr√©√© avec succ√®s!');
                    log(`R√©sultat: ${responseText}`);
                    
                    // Attendre un peu puis v√©rifier l'index
                    setTimeout(() => {
                        log('üîÑ V√©rification de l\'index apr√®s cr√©ation...');
                        checkSnapshotsIndex();
                    }, 2000);
                } else {
                    log(`‚ùå √âchec de cr√©ation: ${response.status}`);
                    log(`D√©tails: ${responseText}`);
                }
            } catch (error) {
                log(`‚ùå Erreur de cr√©ation: ${error.message}`);
            }
        }

        // === FONCTIONS DE DEBUG ===
        
        async function debugCronFunction() {
            log('üî¥ === DEBUG CRON - TEST MANUEL ===');
            log('üìÖ Heure actuelle: ' + new Date().toLocaleString());
            log('‚è∞ V√©rification de la configuration cron...');
            
            // Test 1: V√©rifier l'accessibilit√© de la fonction
            log('üîç Test 1: Accessibilit√© de la fonction...');
            try {
                const response = await fetch(FUNCTION_URL, {
                    method: 'OPTIONS',
                    headers: { 'Content-Type': 'application/json' }
                });
                log(`   ‚úÖ OPTIONS: ${response.status} ${response.statusText}`);
            } catch (error) {
                log(`   ‚ùå OPTIONS: ${error.message}`);
            }
            
            // Test 2: V√©rifier l'authentification
            log('üîë Test 2: Authentification...');
            try {
                const response = await fetch(FUNCTION_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SERVICE_ROLE_KEY}`
                    }
                });
                log(`   ‚úÖ POST avec service role: ${response.status} ${response.statusText}`);
                
                if (response.ok) {
                    const result = await response.json();
                    log(`   üì∏ Snapshot cr√©√©: ${result.data.snapshotDate} - ${result.data.rowCount} lignes`);
                }
            } catch (error) {
                log(`   ‚ùå POST avec service role: ${error.message}`);
            }
            
            // Test 3: V√©rifier l'√©tat de la base
            log('üóÑÔ∏è Test 3: √âtat de la base de donn√©es...');
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/table_snapshots_index?select=count`, {
                    headers: {
                        'apikey': ANON_KEY,
                        'Authorization': `Bearer ${ANON_KEY}`
                    }
                });
                if (response.ok) {
                    const data = await response.json();
                    log(`   ‚úÖ Base accessible: ${data.length} snapshots dans l'index`);
                } else {
                    log(`   ‚ùå Base: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                log(`   ‚ùå Base: ${error.message}`);
            }
            
            log('üî¥ === FIN DEBUG CRON ===');
        }

        async function monitorAutomaticSnapshots() {
            log('üü¢ === MONITOR SNAPSHOTS AUTOMATIQUES ===');
            log('‚è∞ D√©marrage du monitoring...');
            log('üìä V√©rification initiale...');
            
            // V√©rification initiale
            await checkSnapshotsIndex();
            
            // Monitoring toutes les 30 secondes pendant 5 minutes
            let monitoringCount = 0;
            const maxMonitoring = 10; // 5 minutes (10 x 30 secondes)
            
            const monitoringInterval = setInterval(async () => {
                monitoringCount++;
                log(`üîÑ Monitoring #${monitoringCount}/${maxMonitoring} - ${new Date().toLocaleTimeString()}`);
                
                try {
                    const response = await fetch(`${SUPABASE_URL}/rest/v1/table_snapshots_index?select=*&order=created_at.desc&limit=1`, {
                        headers: {
                            'apikey': ANON_KEY,
                            'Authorization': `Bearer ${ANON_KEY}`
                        }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.length > 0) {
                            const latestSnapshot = data[0];
                            const snapshotTime = new Date(latestSnapshot.created_at);
                            const now = new Date();
                            const timeDiff = Math.round((now - snapshotTime) / 1000); // en secondes
                            
                            log(`   üì∏ Dernier snapshot: ${latestSnapshot.snapshot_date} - ${timeDiff}s ago`);
                            
                            if (timeDiff < 120) { // moins de 2 minutes
                                log(`   ‚úÖ Snapshot r√©cent d√©tect√©! (${timeDiff}s)`);
                            } else {
                                log(`   ‚ö†Ô∏è Snapshot ancien (${timeDiff}s) - cron peut-√™tre en pause`);
                            }
                        }
                    }
                } catch (error) {
                    log(`   ‚ùå Erreur monitoring: ${error.message}`);
                }
                
                if (monitoringCount >= maxMonitoring) {
                    clearInterval(monitoringInterval);
                    log('üü¢ === FIN MONITORING ===');
                    log('üìä R√©sum√©: V√©rifiez les logs de la fonction pour plus de d√©tails');
                }
            }, 30000); // 30 secondes
            
            log('‚è±Ô∏è Monitoring actif - arr√™t automatique dans 5 minutes');
        }

        async function forceCronExecution() {
            log('üü° === FORCER EX√âCUTION CRON ===');
            log('üìÖ Heure actuelle: ' + new Date().toLocaleString());
            log('üöÄ D√©clenchement manuel de la fonction...');
            
            try {
                // D√©clencher la fonction
                const response = await fetch(FUNCTION_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SERVICE_ROLE_KEY}`
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    log('‚úÖ Fonction d√©clench√©e avec succ√®s!');
                    log(`üì∏ Snapshot: ${result.data.snapshotDate} - ${result.data.rowCount} lignes`);
                    log(`üìÅ Fichier: ${result.data.objectPath}`);
                    log(`‚è∞ Timestamp: ${result.data.timestamp}`);
                    
                    // Attendre et v√©rifier l'index
                    log('‚è≥ Attente de 3 secondes pour la synchronisation...');
                    setTimeout(async () => {
                        log('üîÑ V√©rification de l\'index apr√®s d√©clenchement...');
                        await checkSnapshotsIndex();
                        
                        // V√©rifier si le nouveau snapshot est visible
                        try {
                            const indexResponse = await fetch(`${SUPABASE_URL}/rest/v1/table_snapshots_index?select=*&order=created_at.desc&limit=1`, {
                                headers: {
                                    'apikey': ANON_KEY,
                                    'Authorization': `Bearer ${ANON_KEY}`
                                }
                            });
                            
                            if (indexResponse.ok) {
                                const indexData = await indexResponse.json();
                                if (indexData.length > 0) {
                                    const latest = indexData[0];
                                    log(`üìä V√©rification: Snapshot ${latest.snapshot_date} visible dans l'index`);
                                    log(`   üìÅ Chemin: ${latest.object_path}`);
                                    log(`   üìä Lignes: ${latest.row_count}`);
                                    log(`   ‚è∞ Cr√©√©: ${new Date(latest.created_at).toLocaleString()}`);
                                }
                            }
                        } catch (error) {
                            log(`‚ùå Erreur v√©rification index: ${error.message}`);
                        }
                    }, 3000);
                    
                } else {
                    const errorText = await response.text();
                    log(`‚ùå √âchec du d√©clenchement: ${response.status} ${response.statusText}`);
                    log(`D√©tails: ${errorText}`);
                }
            } catch (error) {
                log(`‚ùå Erreur de d√©clenchement: ${error.message}`);
            }
            
            log('üü° === FIN FOR√áAGE CRON ===');
        }

        // Test automatique au chargement
        window.addEventListener('load', () => {
            log('üöÄ Test avanc√© de la fonction snapshot initialis√©...');
            log('üîë Cl√©s d\'authentification configur√©es');
            log('üìã Infrastructure v√©rifi√©e:');
            log('   - Bucket: table-snapshots ‚úÖ');
            log('   - Table: table_snapshots_index ‚úÖ');
            log('   - Fonction: snapshot_staff_table ‚úÖ');
            log('   - Cron: * * * * * ‚úÖ');
            log('\nüéØ Pr√™t pour les tests avanc√©s!');
        });
    </script>
</body>
</html>
