<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test des outils de synchronisation</title>
    <style>
        body { 
            font-family: system-ui, -apple-system, sans-serif; 
            margin: 20px; 
            background: #f5f5f5; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .button { 
            background: #16a34a; 
            color: white; 
            border: none; 
            padding: 12px 24px; 
            border-radius: 6px; 
            cursor: pointer; 
            margin: 5px;
            font-size: 14px;
        }
        .button:hover { background: #15803d; }
        .button.danger { background: #dc2626; }
        .button.danger:hover { background: #b91c1c; }
        .button.warning { background: #eab308; color: #000; }
        .button.warning:hover { background: #ca8a04; }
        .output { 
            background: #1f2937; 
            color: #f3f4f6; 
            padding: 15px; 
            border-radius: 6px; 
            margin: 10px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.4;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        .status { 
            padding: 10px; 
            border-radius: 6px; 
            margin: 10px 0; 
            font-weight: bold;
        }
        .status.success { background: #dcfce7; color: #166534; border: 1px solid #bbf7d0; }
        .status.error { background: #fef2f2; color: #991b1b; border: 1px solid #fecaca; }
        .status.warning { background: #fefce8; color: #92400e; border: 1px solid #fde68a; }
        .status.info { background: #eff6ff; color: #1e40af; border: 1px solid #dbeafe; }
        h1, h2, h3 { color: #1f2937; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîß Test des outils de synchronisation</h1>
        
        <div class="status info">
            <strong>Serveur local:</strong> http://localhost:8001
        </div>
        
        <h2>üîç Diagnostics</h2>
        <div class="grid">
            <button class="button" onclick="runDiagnostic()">Diagnostic complet</button>
            <button class="button" onclick="testConnection()">Test connexion</button>
            <button class="button" onclick="testSubscription()">Test subscription</button>
            <button class="button" onclick="checkFlags()">V√©rifier flags</button>
        </div>
        
        <h2>üõ†Ô∏è Corrections</h2>
        <div class="grid">
            <button class="button warning" onclick="fixRealtime()">Correction auto</button>
            <button class="button danger" onclick="forceReconnect()">Reconnexion forc√©e</button>
            <button class="button warning" onclick="clearFlags()">Vider flags</button>
            <button class="button" onclick="getStatus()">√âtat actuel</button>
        </div>
        
        <h2>üìä R√©sultats</h2>
        <div id="output" class="output">Cliquez sur un bouton pour commencer les tests...</div>
    </div>

    <!-- Chargement des scripts de diagnostic -->
    <script src="realtime-sync-diagnostics.js"></script>
    <script src="realtime-sync-fix.js"></script>
    <script src="supabase-diagnostic.js"></script>
    
    <script>
        const output = document.getElementById('output');
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : 'üìÑ';
            output.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }
        
        function clearOutput() {
            output.textContent = '';
        }
        
        // Capture les logs de la console
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;
        
        console.log = function(...args) {
            originalConsoleLog.apply(console, args);
            log(args.join(' '), 'info');
        };
        
        console.error = function(...args) {
            originalConsoleError.apply(console, args);
            log(args.join(' '), 'error');
        };
        
        // Fonctions de test
        async function runDiagnostic() {
            clearOutput();
            log('üîç D√©marrage du diagnostic complet...');
            
            try {
                if (typeof window.diagnoseRealtime === 'function') {
                    const result = await window.diagnoseRealtime();
                    log('‚úÖ Diagnostic termin√© avec succ√®s', 'success');
                    log('R√©sultats: ' + JSON.stringify(result, null, 2));
                } else {
                    log('‚ùå Fonction diagnoseRealtime non disponible', 'error');
                }
            } catch (error) {
                log('‚ùå Erreur lors du diagnostic: ' + error.message, 'error');
            }
        }
        
        async function testConnection() {
            clearOutput();
            log('üîó Test de connexion Supabase...');
            
            try {
                if (window.realtimeDiagnostics) {
                    const result = await window.realtimeDiagnostics.testSupabaseConnection();
                    log('R√©sultat: ' + JSON.stringify(result, null, 2));
                } else {
                    log('‚ùå Diagnostics non disponibles', 'error');
                }
            } catch (error) {
                log('‚ùå Erreur lors du test: ' + error.message, 'error');
            }
        }
        
        function testSubscription() {
            clearOutput();
            log('üì° Test de subscription realtime...');
            
            try {
                if (window.realtimeDiagnostics) {
                    const result = window.realtimeDiagnostics.testRealtimeSubscription();
                    log('R√©sultat: ' + JSON.stringify(result, null, 2));
                } else {
                    log('‚ùå Diagnostics non disponibles', 'error');
                }
            } catch (error) {
                log('‚ùå Erreur lors du test: ' + error.message, 'error');
            }
        }
        
        function checkFlags() {
            clearOutput();
            log('üèÅ V√©rification des flags de blocage...');
            
            try {
                if (window.realtimeDiagnostics) {
                    const result = window.realtimeDiagnostics.checkBlockingFlags();
                    log('R√©sultat: ' + JSON.stringify(result, null, 2));
                } else {
                    log('‚ùå Diagnostics non disponibles', 'error');
                }
            } catch (error) {
                log('‚ùå Erreur lors de la v√©rification: ' + error.message, 'error');
            }
        }
        
        async function fixRealtime() {
            clearOutput();
            log('üõ†Ô∏è Correction automatique des probl√®mes...');
            
            try {
                if (typeof window.fixRealtime === 'function') {
                    const result = await window.fixRealtime();
                    log('‚úÖ Correction termin√©e', 'success');
                    log('R√©sultats: ' + JSON.stringify(result, null, 2));
                } else {
                    log('‚ùå Fonction fixRealtime non disponible', 'error');
                }
            } catch (error) {
                log('‚ùå Erreur lors de la correction: ' + error.message, 'error');
            }
        }
        
        function forceReconnect() {
            clearOutput();
            log('üîÑ Reconnexion forc√©e...');
            
            try {
                if (typeof window.forceRealtimeReconnect === 'function') {
                    window.forceRealtimeReconnect();
                    log('‚úÖ Reconnexion initi√©e', 'success');
                } else {
                    log('‚ùå Fonction forceRealtimeReconnect non disponible', 'error');
                }
            } catch (error) {
                log('‚ùå Erreur lors de la reconnexion: ' + error.message, 'error');
            }
        }
        
        function clearFlags() {
            clearOutput();
            log('üßπ Vidage des flags de blocage...');
            
            try {
                if (typeof window.clearRealtimeFlags === 'function') {
                    window.clearRealtimeFlags();
                    log('‚úÖ Flags vid√©s', 'success');
                } else {
                    log('‚ùå Fonction clearRealtimeFlags non disponible', 'error');
                }
            } catch (error) {
                log('‚ùå Erreur lors du vidage: ' + error.message, 'error');
            }
        }
        
        function getStatus() {
            clearOutput();
            log('üìä R√©cup√©ration de l\'√©tat actuel...');
            
            try {
                if (typeof window.getRealtimeStatus === 'function') {
                    const status = window.getRealtimeStatus();
                    log('√âtat: ' + JSON.stringify(status, null, 2));
                } else {
                    log('‚ùå Fonction getRealtimeStatus non disponible', 'error');
                }
            } catch (error) {
                log('‚ùå Erreur lors de la r√©cup√©ration: ' + error.message, 'error');
            }
        }
        
        // Auto-diagnostic au chargement
        window.addEventListener('load', () => {
            log('üöÄ Interface de test charg√©e');
            log('üì° Serveur local actif sur http://localhost:8001');
            
            // V√©rifier les outils disponibles
            const tools = [
                'diagnoseRealtime',
                'fixRealtime',
                'forceRealtimeReconnect',
                'getRealtimeStatus',
                'clearRealtimeFlags'
            ];
            
            tools.forEach(tool => {
                if (typeof window[tool] === 'function') {
                    log(`‚úÖ ${tool} disponible`);
                } else {
                    log(`‚ö†Ô∏è ${tool} non disponible`, 'warning');
                }
            });
        });
    </script>
</body>
</html>