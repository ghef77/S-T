<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Blocage Realtime Sync Pendant Undo/Redo</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-table { 
            border-collapse: collapse; 
            margin: 20px 0; 
            width: 100%;
            max-width: 600px;
        }
        .test-table th, .test-table td { 
            border: 2px solid #007bff; 
            padding: 15px; 
            text-align: center;
            background: #f8f9fa;
            font-size: 16px;
        }
        .test-table th { 
            background: #007bff; 
            color: white; 
            font-weight: bold;
        }
        .test-table td:focus { 
            background: #fff3cd; 
            border-color: #ffc107;
            outline: 3px solid #ffc107;
        }
        .instructions {
            background: #e3f2fd;
            padding: 15px;
            margin: 20px;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }
        .status {
            background: #fff3cd;
            padding: 10px;
            margin: 10px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
        }
        .log {
            background: #f8f9fa;
            padding: 15px;
            margin: 20px;
            border-radius: 8px;
            font-family: monospace;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
        }
        .success { color: #28a745; font-weight: bold; }
        .warning { color: #ffc107; font-weight: bold; }
        .error { color: #dc3545; font-weight: bold; }
        .info { color: #17a2b8; font-weight: bold; }
        .realtime { color: #6f42c1; font-weight: bold; }
        button { 
            padding: 12px 20px; 
            margin: 8px; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }
        .btn-primary { background-color: #007bff; color: white; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-warning { background-color: #ffc107; color: black; }
        .btn-danger { background-color: #dc3545; color: white; }
    </style>
</head>
<body>
    <h1>üß™ Test Blocage Realtime Sync Pendant Undo/Redo</h1>
    
    <div class="instructions">
        <h3>üìã Test du Blocage de la Synchronisation Temps R√©el</h3>
        <p><strong>Objectif :</strong> V√©rifier que la synchronisation temps r√©el est bloqu√©e pendant les op√©rations undo/redo.</p>
        <ol>
            <li>Modifiez une cellule pour cr√©er un historique</li>
            <li>Cliquez sur "Undo" pour d√©clencher une op√©ration undo</li>
            <li>Simulez une mise √† jour temps r√©el</li>
            <li>V√©rifiez que la mise √† jour est ignor√©e</li>
            <li>Cliquez sur "Sauvegarde Auto" pour terminer l'op√©ration</li>
            <li>V√©rifiez que la synchronisation temps r√©el est r√©activ√©e</li>
        </ol>
    </div>
    
    <div class="status" id="status">
        <strong>√âtat :</strong> Pr√™t pour le test de blocage realtime sync
    </div>
    
    <table class="test-table">
        <thead>
            <tr>
                <th>Nom</th>
                <th>Pr√©nom</th>
                <th>Email</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td contenteditable="true" data-label="Nom">Dupont</td>
                <td contenteditable="true" data-label="Pr√©nom">Jean</td>
                <td contenteditable="true" data-label="Email">jean@email.com</td>
            </tr>
            <tr>
                <td contenteditable="true" data-label="Nom">Martin</td>
                <td contenteditable="true" data-label="Pr√©nom">Marie</td>
                <td contenteditable="true" data-label="Email">marie@email.com</td>
            </tr>
        </tbody>
    </table>
    
    <div style="margin: 20px;">
        <button onclick="testUndo()" class="btn-warning">‚Ü∂ Undo</button>
        <button onclick="testRedo()" class="btn-warning">‚Ü∑ Redo</button>
        <button onclick="testRealtimeUpdate()" class="btn-primary">üîÑ Simuler Realtime Update</button>
        <button onclick="testAutosave()" class="btn-success">üíæ Sauvegarde Auto</button>
        <button onclick="clearLog()" class="btn-danger">üóëÔ∏è Effacer Log</button>
        <button onclick="showState()" class="btn-info">üìä √âtat Actuel</button>
    </div>
    
    <div class="log" id="log">
        <div class="info">üöÄ Test de blocage realtime sync pendant undo/redo initialis√©</div>
    </div>
    
    <script>
        // ‚úÖ SIMULATION DU SYST√àME UNDO/REDO ET REALTIME SYNC
        let operationHistory = [];
        let redoHistory = [];
        let isPerformingUndoRedo = false;
        let realtimeSyncBlocked = false;
        let testResults = {
            undoOperations: 0,
            redoOperations: 0,
            realtimeUpdates: 0,
            blockedUpdates: 0,
            autosaves: 0
        };
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = type;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function updateStatus(message) {
            document.getElementById('status').innerHTML = `<strong>√âtat :</strong> ${message}`;
        }
        
        // ‚úÖ SIMULATION DE LA FONCTION UNDO
        function testUndo() {
            if (operationHistory.length === 0) {
                log('‚ùå Aucune op√©ration √† annuler', 'error');
                return;
            }
            
            log('üîÑ D√©clenchement de l\'op√©ration Undo...', 'warning');
            isPerformingUndoRedo = true;
            realtimeSyncBlocked = true;
            
            const lastOperation = operationHistory.pop();
            redoHistory.push(lastOperation);
            
            log(`‚úÖ Undo effectu√©: ${lastOperation.description}`, 'success');
            log('‚ö†Ô∏è Synchronisation temps r√©el BLOQU√âE pendant undo/redo', 'warning');
            
            testResults.undoOperations++;
            updateStatus(`Undo: ${testResults.undoOperations}, Realtime bloqu√©: ${realtimeSyncBlocked}`);
        }
        
        // ‚úÖ SIMULATION DE LA FONCTION REDO
        function testRedo() {
            if (redoHistory.length === 0) {
                log('‚ùå Aucune op√©ration √† refaire', 'error');
                return;
            }
            
            log('üîÑ D√©clenchement de l\'op√©ration Redo...', 'warning');
            isPerformingUndoRedo = true;
            realtimeSyncBlocked = true;
            
            const lastRedoOperation = redoHistory.pop();
            operationHistory.push(lastRedoOperation);
            
            log(`‚úÖ Redo effectu√©: ${lastRedoOperation.description}`, 'success');
            log('‚ö†Ô∏è Synchronisation temps r√©el BLOQU√âE pendant undo/redo', 'warning');
            
            testResults.redoOperations++;
            updateStatus(`Redo: ${testResults.redoOperations}, Realtime bloqu√©: ${realtimeSyncBlocked}`);
        }
        
        // ‚úÖ SIMULATION D'UNE MISE √Ä JOUR TEMPS R√âEL
        function testRealtimeUpdate() {
            testResults.realtimeUpdates++;
            
            if (isPerformingUndoRedo) {
                log(`‚ùå Realtime update IGNOR√â (undo/redo en cours) - Update #${testResults.realtimeUpdates}`, 'warning');
                testResults.blockedUpdates++;
                updateStatus(`Realtime bloqu√©: ${realtimeSyncBlocked}, Updates ignor√©s: ${testResults.blockedUpdates}`);
            } else {
                log(`‚úÖ Realtime update trait√© - Update #${testResults.realtimeUpdates}`, 'realtime');
                updateStatus(`Realtime actif, Updates trait√©s: ${testResults.realtimeUpdates}`);
            }
        }
        
        // ‚úÖ SIMULATION DE LA SAUVEGARDE AUTOMATIQUE
        function testAutosave() {
            if (!isPerformingUndoRedo) {
                log('‚ö†Ô∏è Aucune op√©ration undo/redo en cours', 'warning');
                return;
            }
            
            log('üíæ Sauvegarde automatique en cours...', 'info');
            
            // Simuler le temps de sauvegarde
            setTimeout(() => {
                log('‚úÖ Sauvegarde automatique termin√©e', 'success');
                
                // ‚úÖ R√âACTIVER LA SYNCHRONISATION TEMPS R√âEL
                isPerformingUndoRedo = false;
                realtimeSyncBlocked = false;
                
                log('üîÑ Synchronisation temps r√©el R√âACTIV√âE apr√®s sauvegarde', 'success');
                updateStatus(`Sauvegarde termin√©e, Realtime r√©activ√©: ${!realtimeSyncBlocked}`);
                
                testResults.autosaves++;
                
                // Test de validation
                setTimeout(() => {
                    log('üß™ Test de validation: V√©rification que realtime est r√©activ√©...', 'info');
                    testRealtimeUpdate();
                }, 200);
                
            }, 500);
        }
        
        // Afficher l'√©tat actuel
        function showState() {
            log('üìä √âtat actuel du syst√®me:', 'info');
            log(`   - isPerformingUndoRedo: ${isPerformingUndoRedo}`, 'info');
            log(`   - realtimeSyncBlocked: ${realtimeSyncBlocked}`, 'info');
            log(`   - Historique undo: ${operationHistory.length} op√©rations`, 'info');
            log(`   - Historique redo: ${redoHistory.length} op√©rations`, 'info');
            log(`   - Statistiques:`, 'info');
            log(`     * Undo: ${testResults.undoOperations}`, 'info');
            log(`     * Redo: ${testResults.redoOperations}`, 'info');
            log(`     * Realtime updates: ${testResults.realtimeUpdates}`, 'info');
            log(`     * Updates bloqu√©s: ${testResults.blockedUpdates}`, 'info');
            log(`     * Autosaves: ${testResults.autosaves}`, 'info');
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '<div class="info">üöÄ Test de blocage realtime sync pendant undo/redo initialis√©</div>';
        }
        
        // ‚úÖ SIMULATION DE LA CAPTURE DES MODIFICATIONS
        function setupCellEvents() {
            const cells = document.querySelectorAll('.test-table td[contenteditable="true"]');
            
            cells.forEach((cell, index) => {
                let originalValue = cell.textContent;
                
                cell.addEventListener('input', () => {
                    const newValue = cell.textContent;
                    if (newValue !== originalValue) {
                        const operation = {
                            description: `Modification ${cell.getAttribute('data-label')}: "${originalValue}" ‚Üí "${newValue}"`,
                            timestamp: Date.now(),
                            cell: cell,
                            oldValue: originalValue,
                            newValue: newValue
                        };
                        
                        operationHistory.push(operation);
                        originalValue = newValue;
                        
                        log(`üìù Modification captur√©e: ${operation.description}`, 'info');
                        log(`üìä Historique undo: ${operationHistory.length} op√©rations`, 'info');
                    }
                });
            });
        }
        
        // Initialisation
        log('‚úÖ Test de blocage realtime sync pendant undo/redo initialis√© avec succ√®s', 'success');
        log('üéØ Objectif: V√©rifier que realtime sync est bloqu√© pendant undo/redo', 'success');
        log('üí° La synchronisation temps r√©el doit √™tre r√©activ√©e apr√®s autosave', 'info');
        
        // Configurer les √©v√©nements
        setupCellEvents();
        
        // Afficher l'√©tat initial
        log('üìä √âtat initial:', 'info');
        log('   - 2 lignes de test configur√©es', 'info');
        log('   - Syst√®me undo/redo simul√©', 'info');
        log('   - Blocage realtime sync pendant undo/redo', 'info');
        log('   - R√©activation apr√®s sauvegarde automatique', 'info');
        
        updateStatus('Pr√™t pour le test - Modifiez une cellule puis testez undo/redo');
        
        // Test automatique apr√®s 3 secondes
        setTimeout(() => {
            log('üí° Conseil: Modifiez une cellule, puis testez undo ‚Üí realtime update ‚Üí autosave', 'info');
        }, 3000);
    </script>
</body>
</html>
