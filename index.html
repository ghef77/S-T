<!DOCTYPE html>
<html lang='fr'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>S-T synchronisé - Supabase</title>
    
    <!-- Preload critical resources -->
    <link rel="preload" href="https://cdn.tailwindcss.com" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm" as="script">
    
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* CSS Variables for consistent theming */
        :root {
            --primary-color: #15803d;
            --primary-hover: #16a34a;
            --primary-light: #86efac;
            --secondary-color: #3b82f6;
            --secondary-hover: #2563eb;
            --danger-color: #dc2626;
            --danger-hover: #b91c1c;
            --success-color: #16a34a;
            --warning-color: #eab308;
            --border-color: #e5e7eb;
            --border-focus: #3b82f6;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --bg-primary: #ffffff;
            --bg-secondary: #f9fafb;
            --bg-hover: #f3f4f6;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1);
            --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Base styles */
        body { 
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; 
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        /* Table styles */
        #data-table { 
            border-collapse: collapse; 
            border-spacing: 0; 
            margin-bottom: 50px; 
            width: 100%; 
            background-color: var(--bg-primary);
            box-shadow: var(--shadow-md);
            border-radius: 0.5rem;
        }
        
        #data-table th, #data-table td { 
            border: 1px solid var(--border-color); 
            transition: var(--transition);
        }
        
        #data-table thead { 
            position: sticky; 
            top: 0; 
            z-index: 10; 
            background-color: var(--primary-color);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        #data-table thead th {
            padding: 1rem;
            font-size: 0.875rem;
        }
        
        #data-table tbody tr {
            transition: var(--transition);
        }
        
        #data-table tbody tr:hover {
            background-color: var(--bg-hover);
            transform: scale(1.005);
            box-shadow: var(--shadow-sm);
        }
        
        #data-table tfoot {
            position: static;
            background: transparent;
            border-top: 0;
            box-shadow: none;
        }
        /* Floating + button to free vertical space */
        #fab-add {
          position: fixed;
          right: 16px;
          bottom: calc(env(safe-area-inset-bottom, 0px) + 16px);
          z-index: 60;
          width: 56px;
          height: 56px;
          border-radius: 9999px;
          display: flex;
          align-items: center;
          justify-content: center;
          box-shadow: var(--shadow-lg);
        }
        #fab-add:active { transform: scale(0.97); }
        
        /* Mobile-specific FAB button styling */
        @media (max-width: 768px) {
            #fab-add {
                width: 36px;
                height: 36px;
                opacity: 0.5;
                background-color: rgba(34, 197, 94, 0.7);
                backdrop-filter: blur(8px);
                border: 1px solid rgba(255, 255, 255, 0.15);
                transition: all 0.3s ease;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            }
            
            #fab-add:hover,
            #fab-add:focus {
                opacity: 0.9;
                transform: scale(1.05);
                background-color: rgba(34, 197, 94, 0.85);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }
            
            #fab-add:active {
                transform: scale(0.95);
                opacity: 1;
            }
            
            #fab-add svg {
                width: 18px;
                height: 18px;
                color: rgba(255, 255, 255, 0.9);
            }
            
            /* Animation d'apparition subtile */
            #fab-add {
                animation: fadeInSubtle 0.5s ease-out;
            }
            
            @keyframes fadeInSubtle {
                from {
                    opacity: 0;
                    transform: scale(0.8) translateY(10px);
                }
                to {
                    opacity: 0.5;
                    transform: scale(1) translateY(0);
                }
            }
        }
        


        /* Hide the old add-row button area to remove the white bar */
        #data-table tfoot td { padding: 0 !important; height: 0 !important; }
        #data-table tfoot button { display: none !important; }

        /* Snapshot System Styles */
        .snapshot-readonly {
            background-color: #fef3c7 !important;
            color: #92400e !important;
            cursor: not-allowed !important;
        }
        
        .snapshot-readonly:hover {
            background-color: #fde68a !important;
        }
        
        #history-bar {
            display: flex;
            transition: all 0.3s ease;
        }
        
        #history-bar button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #snapshot-banner {
            animation: slideInDown 0.3s ease-out;
            max-width: fit-content;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* History bar responsive design */
        /* Hide history bar and snapshot banner on medium and small screens */
        @media (max-width: 1023px) {
            #history-bar,
            #snapshot-banner {
                display: none !important;
            }
        }
        
        /* Utility classes */
        .hidden {
            display: none !important;
        }
        
        /* Animation classes */
        .sync-pending-animation { 
            animation: pulse 1.5s infinite; 
        }
        
        @keyframes pulse { 
            0% { opacity: 1; } 
            50% { opacity: 0.5; } 
            100% { opacity: 1; } 
        }
        
        /* Sync status dot styles */
        .sync-dot {
            transition: all 0.3s ease;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8);
            flex-shrink: 0;
            display: inline-block;
            border: 1px solid rgba(0, 0, 0, 0.1);
            cursor: help;
        }
        
        .sync-dot.animate-pulse {
            animation: dot-pulse 2s infinite;
        }
        
        @keyframes dot-pulse {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
            }
            50% { 
                opacity: 0.7; 
                transform: scale(1.1);
            }
        }
        
        /* Mobile-specific sync status adjustments */
        @media (max-width: 768px) {
            #sync-status {
                min-width: 1.5rem;
                min-height: 1.5rem;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
            }
            
            .sync-dot {
                width: 0.875rem !important;
                height: 0.875rem !important;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
            
            /* Hide title on small screens */
            #staff-title {
                transition: all 0.3s ease;
            }
            
                        #staff-title.hidden {
                opacity: 0;
                visibility: hidden;
                height: 0;
                margin: 0;
                padding: 0;
                overflow: hidden;
                transform: scale(0.8);
            }
            

        }
        

        
        /* Optimisation de l'espace */
        #table-container {
            max-width: 100%;
        }
        
        #button-bar {
            max-width: 100%;
            justify-content: flex-start;
            overflow-x: auto;
            gap: 0.3rem; /* ensure spacing between buttons */
            padding: 0 !important; /* Remove padding between buttons and container */
        }
        
        #button-bar button {
            margin: 0;
            flex-shrink: 0;
            transform: scale(1.2); /* enlarge by ~20% */
            transform-origin: center;
        }

        /* keep slight press effect while preserving 1.2 scale */
        #button-bar button:active {
            transform: scale(1.176);
        }
        
        /* Réduction des marges sur petits écrans */
        @media (max-width: 768px) {
            #table-container {
                margin: 0.5rem !important;
                padding: 0.5rem !important;
            }
            
            #button-bar {
                padding: 0.5rem !important;
                margin-bottom: 0.5rem !important;
            }
        }
        
        /* Message box styles */
        .message-box {
            position: fixed;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            line-height: 1rem;
            padding: 4px 8px;
            margin-top: 4px;
            border-radius: 0.5rem;
            box-shadow: var(--shadow-lg);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            max-width: 90vw;
            word-wrap: break-word;
        }
        
        .message-box.show { 
            opacity: 1; 
            transform: translateX(-50%) translateY(0); 
        }
        
        .message-box.success { 
            background-color: #d1fae5; 
            color: #065f46; 
        }
        
        .message-box.info { 
            background-color: #dbeafe; 
            color: #1e40af; 
        }
        
        .message-box.error { 
            background-color: #fee2e2; 
            color: #991b1b; 
        }
        
        /* Button bar positioning */
        #button-bar { 
            position: absolute; 
            top: 8px; 
            right: 8px; 
            z-index: 20; 
        }
        
        /* Forcer le positionnement sur tous les écrans non-mobiles */
        @media (min-width: 641px) {
            #button-bar {
                position: absolute !important;
                top: 8px !important;
                right: 8px !important;
                z-index: 20 !important;
                margin: 0 !important;
                margin-bottom: 0 !important;
                padding: 0 !important; /* Remove padding between buttons and container */
            }
        }

        /* Positionnement pour écrans moyens (tablettes) */
        @media (min-width: 641px) and (max-width: 1024px) {
            #button-bar {
                position: absolute !important;
                top: 8px !important;
                right: 8px !important;
                z-index: 20 !important;
                margin: 0 !important;
                margin-bottom: 0 !important;
                transform: none !important;
            }
            
            /* Annuler les marges qui peuvent causer le déplacement */
            #button-bar.mb-3 {
                margin-bottom: 0 !important;
            }

            /* Laisser un petit espace entre la barre et le tableau */
            #button-bar + div {
                margin-top: 6px !important; /* ~ quelques millimètres */
            }
        }

        /* Mobile-safe positioning for the top-right button bar */
        @media (max-width: 640px) {
            #button-bar {
                position: fixed;
                top: calc(env(safe-area-inset-top, 0px) + 8px);
                right: 8px;
                z-index: 50;
                overflow-x: auto;
            }
            
            #table-container { 
                padding-top: 56px; 
            }
            
            /* Empêcher que le bouton de couleur s'écrase en largeur */
            #row-color-picker {
                min-width: 32px !important;
                min-height: 32px !important;
                width: 32px !important;
                height: 32px !important;
                flex-shrink: 0 !important;
            }
        }
        
        /* Sticky first column */
        #data-table td:first-child {
            position: sticky;
            left: 0;
            z-index: 2;
            background-color: white !important;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }

        #data-table th:first-child {
            position: sticky;
            left: 0;
            z-index: 3;
            background-color: var(--primary-color) !important;
        }
        
        /* Frozen column classes for JavaScript */
        .frozen-column.frozen-1 {
            position: sticky !important;
            left: 0 !important;
            z-index: 2 !important;
            background-color: white !important;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }
        
        .frozen-column-header.frozen-1 {
            position: sticky !important;
            left: 0 !important;
            z-index: 3 !important;
            background-color: var(--primary-color) !important;
        }
        
        /* Editable cell styles */
        td.editable-cell:empty::after { 
            content: attr(data-label); 
            color: var(--text-secondary); 
            font-weight: normal; 
        }
        
        /* Texte noir foncé pour toutes les cellules éditables du tableau */
        td.editable-cell {
            color: #1a1a1a !important;
        }
        
        /* Styles spécifiques pour les colonnes importantes avec police plus grande */
        td.editable-cell[data-label="Date de saisie"],
        td.editable-cell[data-label="PEC finale"],
        td.editable-cell[data-label="PEC initiale"],
        td.editable-cell[data-label="Diagnostic_initial"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Numero_tel avec police standard (1.1rem) */
        td.editable-cell[data-label="Numero_tel"],
        td.editable-cell[data-label="numero_tel"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police standard */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Nom_Prénom et DDN en gras pour les cellules éditables */
        td.editable-cell[data-label="Nom_Prénom"],
        td.editable-cell[data-label="DDN"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 700 !important; /* Gras (bold) */
        }
        
        /* Information complementaire en rouge pour les cellules éditables */
        td.editable-cell[data-label="Information complementaire"],
        td.editable-cell[data-label="information complementaire"] {
            color: #dc2626 !important; /* Rouge */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Patient name formatting - support line breaks */
        td.editable-cell[data-label="Nom_Prénom"],
        td.editable-cell[data-label="nom prenom"],
        td.editable-cell[data-label="nom_prénom"],
        td.editable-cell[data-label="nom et prenom"],
        td.editable-cell[data-label="nom et prénom"],
        td.editable-cell[data-label="patient"],
        td.editable-cell[data-label="nom complet"],
        td.editable-cell[data-label="fullname"],
        td.editable-cell[data-label="name"] {
            white-space: pre-line;
            line-height: 1.2;
            vertical-align: top;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }
        
        td.editable-cell[data-label="DDN"]:empty::after { 
            content: 'JJ/MM/YYYY'; 
            color: var(--text-secondary); 
            font-weight: normal; 
        }
        
        /* Row selection */
        tr.selected-row { 
            background-color: #FEF3C7; 
        }

        /* Column text colors and font sizes for specific columns */
        #data-table td[data-label="Date de saisie"],
        #data-table td[data-label="PEC finale"],
        #data-table td[data-label="PEC initiale"],
        #data-table td[data-label="Diagnostic_initial"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Numero_tel avec police standard (1.1rem) */
        #data-table td[data-label="Numero_tel"],
        #data-table td[data-label="numero_tel"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police standard */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Nom_Prénom et DDN en gras */
        #data-table td[data-label="Nom_Prénom"],
        #data-table td[data-label="DDN"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 700 !important; /* Gras (bold) */
        }
        
        /* Information complementaire en rouge */
        #data-table td[data-label="Information complementaire"],
        #data-table td[data-label="information complementaire"] {
            color: #dc2626 !important; /* Rouge */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* Légèrement plus gras */
        }

        /* Column selection visuals */
        #data-table thead th.col-selected {
            outline: 3px solid var(--secondary-color);
            position: relative;
        }
        
        #data-table thead th.col-selected::after {
            content: '✓';
            position: absolute; 
            right: 6px; 
            top: 4px;
            font-weight: 700; 
            font-size: 0.8em; 
            color: var(--text-primary);
        }

        /* Safe areas for iOS/Android */
        body {
            padding-top: env(safe-area-inset-top, 0px);
            padding-bottom: env(safe-area-inset-bottom, 0px);
        }
        
        /* Mobile viewport height management */
        .mobile-viewport-height {
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            min-height: 100vh;
            min-height: 100dvh;
        }
        
        /* Mobile-specific viewport adjustments */
        @media (max-width: 768px) {
            body {
                overflow-x: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
            }
            
            #table-container {
                height: 100vh;
                height: 100dvh;
                height: calc(var(--vh, 1vh) * 100);
                min-height: 100vh;
                min-height: 100dvh;
                min-height: calc(var(--vh, 1vh) * 100);
                overflow: hidden;
            }
            
            /* Optimiser pour la barre de navigation mobile */
            #fab-add {
                position: fixed;
                bottom: 16px;
                right: 16px;
                z-index: 1000;
            }
            
            /* S'assurer que le contenu ne déborde pas */
            .overflow-auto {
                overflow: auto !important;
                -webkit-overflow-scrolling: touch;
            }
            
            /* History bar responsive adjustments */
            #history-bar-container {
                padding: 0.5rem !important;
            }
            
            #history-bar-container button {
                font-size: 0.75rem !important;
                padding: 0.25rem 0.5rem !important;
                min-height: 2rem !important;
            }
            
            #history-bar-container .fa-solid {
                width: 0.875rem !important;
                height: 0.875rem !important;
            }
        }
        
        /* Small screen adjustments (sm breakpoint) */
        @media (max-width: 640px) {
            #history-bar-container {
                gap: 0.25rem !important;
            }
            
            #history-bar-container button {
                padding: 0.25rem 0.375rem !important;
                font-size: 0.7rem !important;
            }
        }
        
        /* History controls row styling */
        .flex.justify-between.items-center.mb-3 {
            gap: 1rem;
        }
        
        /* Toggle button container styling */
        .flex.justify-start {
            min-width: fit-content;
        }
        
        /* Minimal toggle button styling */
        #history-toggle-btn {
            transition: all 0.2s ease-in-out;
        }
        
        #history-toggle-btn:hover {
            transform: scale(1.05);
        }
        
        #history-toggle-btn:active {
            transform: scale(0.95);
        }
        
        /* Perfect centering for FontAwesome icons */
        #history-toggle-btn i {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            text-align: center !important;
            line-height: 1 !important;
            width: 100% !important;
            height: 100% !important;
        }
        
        /* History bar container styling */
        #history-bar-container {
            flex: 1;
            min-width: 0;
            display: flex;
            justify-content: flex-end;
        }
        
        /* Reduced width container styling */
        #history-bar-container > div {
            max-width: 50%;
            min-width: fit-content;
        }
        
        /* Responsive adjustments for history controls */
        @media (max-width: 768px) {
            .flex.justify-between.items-center.mb-3 {
                flex-direction: row;
                align-items: center;
                gap: 0.5rem;
            }
            
            .flex.justify-start {
                align-self: flex-start;
            }
            
            #history-bar-container {
                align-self: flex-end;
            }
        }
        

        
        /* Current snapshot date display styling */
        #current-snapshot-date-display {
            white-space: nowrap;
            flex-shrink: 0;
            transition: all 0.2s ease-in-out;
        }
        
        #current-snapshot-date-display:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
        }
        
        /* Mobile adjustments for date display */
        @media (max-width: 640px) {
            #current-snapshot-date-display {
                font-size: 0.7rem !important;
                padding: 0.25rem 0.375rem !important;
            }
            
            #current-snapshot-date-display .fa-solid {
                width: 0.75rem !important;
                height: 0.75rem !important;
            }
        }
        
        /* Focus styles for accessibility */
        .editable-cell:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: -2px;
            background-color: var(--bg-secondary);
            box-shadow: inset 0 0 0 1px var(--border-focus);
            color: #1a1a1a !important; /* Texte noir foncé quand on écrit */
        }
        
        /* Styles de focus spécifiques pour les colonnes importantes */
        .editable-cell[data-label="Date de saisie"]:focus,
        .editable-cell[data-label="PEC finale"]:focus,
        .editable-cell[data-label="PEC initiale"]:focus,
        .editable-cell[data-label="Diagnostic_initial"]:focus {
            color: #1a1a1a !important; /* Noir foncé maintenu en focus */
            font-size: 1.1rem !important; /* Police plus grande maintenue */
            font-weight: 500 !important; /* Gras maintenu */
        }
        
        /* Numero_tel avec police standard (1.1rem) même en focus */
        .editable-cell[data-label="Numero_tel"]:focus,
        .editable-cell[data-label="numero_tel"]:focus {
            color: #1a1a1a !important; /* Noir foncé maintenu en focus */
            font-size: 1.1rem !important; /* Police standard maintenue */
            font-weight: 500 !important; /* Gras maintenu */
        }
        
        /* Nom_Prénom et DDN en gras même en focus */
        .editable-cell[data-label="Nom_Prénom"]:focus,
        .editable-cell[data-label="DDN"]:focus {
            color: #1a1a1a !important; /* Noir foncé maintenu en focus */
            font-size: 1.1rem !important; /* Police plus grande maintenue */
            font-weight: 700 !important; /* Gras (bold) maintenu */
        }
        
        /* Information complementaire en rouge même en focus */
        .editable-cell[data-label="Information complementaire"]:focus {
            color: #dc2626 !important; /* Rouge maintenu en focus */
            font-size: 1.1rem !important; /* Police plus grande maintenue */
            font-weight: 500 !important; /* Gras maintenu */
        }
        
        /* Texte noir foncé pour toutes les cellules éditables (sauf Information complementaire) */
        .editable-cell:not([data-label="Information complementaire"]) {
            color: #1a1a1a !important;
        }
        
        /* S'assurer que le texte reste noir foncé même après avoir écrit (sauf Information complementaire) */
        .editable-cell:not(:empty):not([data-label="Information complementaire"]) {
            color: #1a1a1a !important;
        }
        
        /* Loading states */
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        
        /* Modern form input styles */
        input[type="text"], 
        input[type="password"], 
        input[type="email"], 
        input[type="number"],
        input[type="date"],
        select {
            padding: 0.75rem 1rem;
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-size: 1rem;
            transition: var(--transition);
            background-color: var(--bg-primary);
        }
        
        input[type="text"]:focus,
        input[type="password"]:focus,
        input[type="email"]:focus,
        input[type="number"]:focus,
        input[type="date"]:focus,
        select:focus {
            outline: none;
            border-color: var(--border-focus);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Style pour le champ mot de passe en erreur */
        .password-error {
            border-color: var(--danger-color) !important;
            background-color: rgba(220, 38, 38, 0.05) !important;
            box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.1) !important;
        }
        
        .password-error::placeholder {
            color: var(--danger-color);
        }
        
        /* Enhanced button styles */
        button {
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        /* Button hover effects */
        button:hover::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        button:hover::before {
            width: 300px;
            height: 300px;
        }
        
        /* Enhanced message box */
        .message-box {
            backdrop-filter: blur(10px);
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Login container enhancements */
        #login-container {
            animation: fadeInUp 0.6s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Table container animations */
        #table-container {
            animation: fadeIn 0.5s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Responsive table */
        @media (max-width: 768px) {
            #data-table {
                font-size: 0.75rem;
            }
            
            #data-table th, #data-table td {
                padding: 0.25rem 0.5rem;
            }
            
            /* Empêcher que le bouton de couleur s'écrase en largeur sur les écrans moyens */
            #row-color-picker {
                min-width: 32px !important;
                min-height: 32px !important;
                width: 32px !important;
                height: 32px !important;
                flex-shrink: 0 !important;
            }
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col h-screen overflow-hidden text-sm md:text-base lg:text-lg">

    <div id="message-box" class="message-box hidden"><p id="message-text" class="font-bold"></p></div>

    <!-- Login container -->
    <div id='login-container' class="bg-white p-8 md:p-10 lg:p-12 rounded-xl shadow-lg w-full max-w-md mx-auto my-auto flex flex-col items-center space-y-4 md:space-y-6 transition-all duration-300 ease-in-out hidden">
        <h2 class="text-2xl md:text-3xl lg:text-4xl font-bold text-gray-800">Accéder au tableau</h2>
        <input type='password' id='password' placeholder='Mot de passe (Appuyez sur Entrée)' class="w-full p-3 md:p-4 lg:p-5 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 transition-colors">
        <div class="flex items-center space-x-2 w-full">
            <input type='checkbox' id='toggle-password' class="w-4 h-4 md:w-5 md:h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500">
            <label for="toggle-password" class="text-sm md:text-base font-medium text-gray-700">Afficher le mot de passe</label>
        </div>
        <button onclick='checkPassword()' class="w-full bg-green-500 text-white font-bold p-3 md:p-4 lg:p-5 rounded-lg shadow-md hover:bg-green-600 transition-colors">Valider</button>
        
        <!-- Indicateur des raccourcis clavier -->
        <div class="text-center text-xs text-gray-500 mt-2">
            <p>💡 <strong>Raccourcis :</strong> Entrée (Valider) • G (Galerie) • N (Nouvelle ligne)</p>
        </div>
        
        <p id='error-message' class="text-red-500 font-medium text-sm md:text-base"></p>
    </div>

    <!-- Bouton d'ajout - visible sur tous les écrans (en dehors du conteneur de tableau) -->
        <button id="fab-add"
                class="bg-green-500 text-white font-bold hover:bg-green-600 transition-colors"
                onclick="addRow()" title="Ajouter une nouvelle ligne" aria-label="Ajouter">
          <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
            <path d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"/>
          </svg>
        </button>
        
    <!-- Table container -->
    <div id='table-container' class="bg-white relative p-2 md:p-4 lg:p-6 pt-4 md:pt-4 lg:pt-6 rounded-xl w-full flex-grow overflow-y-auto hidden transition-all duration-300 ease-in-out flex flex-col m-2 shadow-xl">
        <div class="flex flex-col md:flex-row items-start md:items-center justify-between mb-2 p-2 bg-gradient-to-r from-gray-50 to-gray-100 rounded-lg border border-gray-200">
            <div class="flex-grow">
                <div class="flex flex-wrap items-center gap-2 mb-1">
                    <h2 id="staff-title" class="text-lg md:text-xl font-bold text-gray-800 tracking-tight">S-T</h2>
                
                <!-- Box affichant le nombre de lignes - à côté du titre -->
                <div id="row-count-display" class="flex items-center justify-center px-2 py-1 bg-gray-100 border border-gray-300 rounded-lg text-gray-700 text-lg md:text-xl font-medium min-w-12 ml-2">
                    <span>N=</span>
                    <span id="row-count-number" class="ml-1 font-bold">0</span>
                </div>
                    <span id="sync-status" class="sync-pending-animation px-2 py-1 rounded-full text-xs font-semibold border-2 bg-white shadow-sm">
                        <span class="sync-text">Initialisation...</span>
                        <i class="sync-icon fa-solid fa-check hidden"></i>
                    </span>
                </div>

            </div>
        </div>

        <div id="error-display" class="my-2 text-red-600 font-bold hidden p-2 bg-red-50 rounded-lg border-l-4 border-red-400 text-sm md:text-base"></div>



        <!-- History Controls Row - Toggle button and history buttons on same level -->
        <div class="flex justify-between items-center mb-3">
            <!-- Toggle button container -->
            <div class="w-4 h-4">
                <button id="history-toggle-btn" onclick="toggleHistoryBarSimple()" title="Fermer/Ouvrir la barre d'historique" aria-label="Toggle historique" class="bg-gray-400 text-white p-0 rounded hover:bg-gray-500 transition-colors w-4 h-4 flex items-center justify-center">
                    <i id="history-toggle-icon" class="fa-solid fa-plus w-2 h-2 flex items-center justify-center text-center leading-none"></i>
            </button>
        </div>

            <!-- History Bar Container - This is what gets toggled -->
            <div id="history-bar-container" class="flex justify-end">
                <!-- All buttons in one responsive row with reduced width -->
                <div class="flex flex-wrap items-center gap-2 p-3 bg-blue-50 rounded-lg border border-blue-200 w-1/2">
                    <!-- Navigation buttons - Hidden on small screens -->
                    <div class="hidden md:flex items-center gap-2">
                        <button id="history-back" onclick="goToPreviousSnapshot()" disabled title="Snapshot précédent" aria-label="Snapshot précédent" class="bg-blue-500 text-white px-2 py-1 rounded text-xs hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center">
                            <i class="fa-solid fa-chevron-left w-3 h-3 mr-1"></i>
                            Précédent
            </button>
            
                        <button id="history-date" onclick="openDatePicker()" title="Choisir une date de snapshot" aria-label="Choisir une date" class="bg-blue-600 text-white px-2 py-1 rounded text-xs hover:bg-blue-700 transition-colors font-medium flex items-center justify-center">
                            <span id="current-date-text">Données en direct</span>
                            <i class="fa-solid fa-calendar ml-1 w-3 h-3"></i>
            </button>
            
                        <button id="history-next" onclick="goToNextSnapshot()" disabled title="Snapshot suivant" aria-label="Snapshot suivant" class="bg-blue-500 text-white px-2 py-1 rounded text-xs hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center">
                            <i class="fa-solid fa-chevron-right w-3 h-3 ml-1"></i>
                            Suivant
            </button>
                    </div>
                    
                    <!-- Action buttons - Always visible, smaller on mobile -->
                    <button onclick="refreshTableData()" title="Actualiser le tableau avec les données les plus récentes" aria-label="Actualiser" class="bg-green-600 text-white px-2 py-1 rounded text-xs hover:bg-green-700 transition-colors font-medium flex items-center justify-center">
                        <i class="fa-solid fa-arrows-rotate mr-1 w-3 h-3"></i>
                        <span class="hidden sm:inline">Actualiser</span>
                        <span class="sm:hidden">Act</span>
            </button>
                    
                    <!-- Calendar dropdown for snapshot dates -->
                    <div class="relative">
                        <button id="snapshot-calendar-btn" onclick="toggleSnapshotCalendar()" title="Choisir une date de snapshot" aria-label="Calendrier des snapshots" class="bg-indigo-600 text-white px-2 py-1 rounded text-xs hover:bg-indigo-700 transition-colors font-medium flex items-center justify-center">
                            <i class="fa-solid fa-calendar-days mr-1 w-3 h-3"></i>
                            <span id="calendar-btn-text" class="hidden sm:inline">Calendrier</span>
                            <span class="sm:hidden">Cal</span>
                        </button>
                        
                        <!-- Calendar dropdown -->
                        <div id="snapshot-calendar-dropdown" class="hidden absolute top-full left-0 mt-2 bg-white border border-gray-300 rounded-lg shadow-lg z-50 min-w-64 max-h-96 overflow-y-auto">
                            <div class="p-3 border-b border-gray-200">
                                <h3 class="text-sm font-semibold text-gray-700 mb-2">📅 Snapshots disponibles</h3>
                                <div class="text-xs text-gray-500">Cliquez sur une date pour charger le snapshot</div>
                            </div>
                            <div id="snapshot-dates-list" class="p-2">
                                <!-- Dates will be populated here -->
                            </div>
                        </div>
        </div>

                    <!-- Current Snapshot Date Display - Next to calendar button -->
                    <div id="current-snapshot-date-display" class="flex items-center gap-1 px-2 py-1 bg-gray-100 border border-gray-300 rounded-md text-gray-700 text-xs font-medium ml-2">
                        <i class="fa-solid fa-calendar-day w-3 h-3 text-blue-600"></i>
                        <span id="current-snapshot-date-text">Données en direct</span>
                    </div>
                    

                </div>
            </div>
        </div>

        <div id="button-bar" class="flex flex-nowrap items-center gap-1 mb-3 p-1 bg-gray-50 rounded-lg border border-gray-200 overflow-x-auto">
            <button onclick='saveManually()' title="Sauvegarder" aria-label="Sauvegarder" class='bg-yellow-400 text-gray-800 p-1.5 rounded-lg hover:bg-yellow-500 transition-colors flex items-center justify-center w-7 h-7'>
                <i class="fa-solid fa-save w-3.5 h-3.5"></i>
            </button>
            <button id="undo-button" onclick="undo()" disabled title="Annuler" aria-label="Annuler" class="bg-gray-300 text-gray-700 p-1.5 rounded-lg hover:bg-gray-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-rotate-left w-3.5 h-3.5"></i>
            </button>
            <button id="redo-button" onclick="redo()" disabled title="Rétablir" aria-label="Rétablir" class="bg-gray-300 text-gray-700 p-1.5 rounded-lg hover:bg-gray-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-rotate-right w-3.5 h-3.5"></i>
            </button>
            <button onclick="downloadExcel()" title="Exporter en Excel" aria-label="Exporter en Excel" class="bg-green-600 text-white p-1.5 rounded-lg hover:bg-green-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-file-excel w-3.5 h-3.5"></i>
            </button>
            <button onclick="downloadPDF()" title="Exporter en PDF" aria-label="Exporter en PDF" class="bg-red-600 text-white p-1.5 rounded-lg hover:bg-red-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-file-pdf w-3.5 h-3.5"></i>
            </button>
            <button onclick="downloadImage()" title="Exporter en image (PNG)" aria-label="Exporter en image (PNG)" class="bg-purple-600 text-white p-1.5 rounded-lg hover:bg-purple-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-image w-3.5 h-3.5"></i>
            </button>
            <button onclick="document.getElementById('excel-input').click()" title="Importer depuis Excel" aria-label="Importer depuis Excel" class="bg-blue-600 text-white p-1.5 rounded-lg hover:bg-blue-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-upload w-3.5 h-3.5"></i>
            </button>
            <input id="excel-input" type="file" accept=".xlsx,.xls,.csv" class="hidden" onchange="importExcelFromFile(this.files[0])" />
            
            <!-- Bouton Galerie d'images -->
            <button onclick="openSimpleGallery()" title="Galerie d'images (G)" aria-label="Galerie d'images" class="bg-indigo-600 text-white p-1.5 rounded-lg hover:bg-indigo-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-images w-3.5 h-3.5"></i>
            </button>
            <button onclick="zoomOut()" title="Réduire (−)" aria-label="Réduire" class="bg-gray-700 text-white p-1.5 rounded-lg hover:bg-gray-800 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-minus w-3.5 h-3.5"></i>
            </button>
            <button id="zoom-display" onclick="zoomReset()" title="Réinitialiser à 100%" aria-label="Réinitialiser à 100%" class="bg-gray-500 text-white px-2 py-2 rounded-lg hover:bg-gray-600 transition-colors text-xs w-8 h-8">100%</button>
            <button onclick="zoomIn()" title="Agrandir (+)" aria-label="Agrandir" class="bg-gray-700 text-white p-2 rounded-lg hover:bg-gray-800 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-plus w-4 h-4"></i>
            </button>
            <input id="row-color-picker"
                   type="color"
                   title="Choisir la couleur de surlignage des lignes"
                   class="w-8 h-8 p-1 border border-gray-300 rounded-lg cursor-pointer hover:border-gray-400 transition-colors" />
            <button onclick="clearAllRowColors()" title="Effacer toutes les couleurs" aria-label="Effacer toutes les couleurs" class="bg-gray-200 text-gray-800 p-2 rounded-lg hover:bg-gray-300 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-trash-can w-4 h-4"></i>
            </button>
            <button id="filter-colored-toggle"
                    onclick="toggleColoredFilter()"
                    title="Afficher seulement les lignes colorées"
                    aria-label="Filtrer lignes colorées"
                    class="bg-gray-200 text-gray-800 p-2 rounded-lg hover:bg-gray-300 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-filter w-4 h-4"></i>
            </button>
                        <button id="paint-mode-toggle"
                    onclick="cyclePaintMode()"
                    title="Mode de peinture: Auto/Colorer/Effacer (appuyez sur P pour changer)"
                    aria-label="Basculer le mode de peinture"
                    class="bg-gray-200 text-gray-800 p-2 rounded-lg hover:bg-gray-300 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-palette w-4 h-4"></i>
            </button>
            
            <!-- Bouton Mode Visualisation -->
            <button id="view-mode-toggle"
                    onclick="toggleViewMode()"
                    title="Basculer le mode visualisation (lecture seule)"
                    aria-label="Basculer le mode visualisation"
                    class="bg-blue-200 text-blue-800 p-2 rounded-lg hover:bg-blue-300 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-eye w-4 h-4"></i>
            </button>

        </div>

        <div class="overflow-auto w-full" style="max-width: 100vw; max-height: 85vh;">
            <table id='data-table' class="w-full text-left text-gray-500 text-xs md:text-sm lg:text-base">
                <thead class="text-xs text-white uppercase bg-green-700">
                    <tr>
                        <th scope="col" class="py-2 px-2 md:px-4 rounded-tl-lg frozen-column-header frozen-1">No</th>
                        <th scope="col" class="py-2 px-1 text-center">Effacer<br><input id="select-all" type="checkbox" class="align-middle"></th>
                        <th scope="col" class="py-2 px-2 md:px-4">Date de saisie</th>
                        <th scope="col" class="py-2 px-2 md:px-4">PEC finale</th>
                        <th scope="col" class="py-2 px-2 md:px-4">PEC initiale</th>
                        <th scope="col" class="py-2 px-2 md:px-4">Nom_Prénom</th>
                        <th scope="col" class="py-2 px-2 md:px-4">DDN</th>
                        <th scope="col" class="py-2 px-2 md:px-4">Diagnostic_initial</th>
                        <th scope="col" class="py-2 px-2 md:px-4">information complementaire</th>
                        <th scope="col" class="py-2 px-2 md:px-4 rounded-tr-lg">Numero_tel</th>
                    </tr>
                </thead>
                <tbody id="table-body"></tbody>
                <tfoot class="bg-white border-t-2 border-gray-300">
                    <tr>
                        <td colspan="2" class="py-2 px-2">
                            <button class="bg-green-500 text-white font-bold p-2 rounded-lg hover:bg-green-600 transition-colors text-lg w-10 h-10 flex items-center justify-center mx-auto" onclick="addRow()" title="Ajouter une nouvelle ligne">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"/>
                                </svg>
                            </button>
                        </td>
                        <td colspan="8" class="bg-white"></td>
                    </tr>
                </tfoot>
            </table>
        </div>
        

        

        <div id="confirmation-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 h-full w-full hidden z-50">
            <div class="relative top-1/4 mx-auto p-5 border w-11/12 max-w-sm shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <h3 class="text-lg md:text-xl leading-6 font-medium text-gray-900" id="modal-message"></h3>
                    <div class="mt-4 flex justify-around">
                        <button id="modal-confirm-btn" class="px-4 py-2 bg-red-600 text-white text-base font-medium rounded-md w-24 shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">Oui</button>
                        <button id="modal-cancel-btn" class="px-4 py-2 bg-gray-300 text-black text-base font-medium rounded-md w-24 shadow-sm hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500">Non</button>
                    </div>
                </div>
            </div>
        </div>


    </div>

    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>

    <!-- App -->
    <script type="module">
        // Configuration - In production, these should be environment variables
        const APP_CONFIG = { 
            password: 'p123', 
            version: '2.5.4-enter-on-login' 
        };
        
        const supabaseConfig = { 
            supabaseUrl: 'https://fiecugxopjxzqfdnaqsu.supabase.co', 
            supabaseAnonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ1MDU2NTcsImV4cCI6MjA3MDA4MTY1N30.xd9Thasg4r8Nrwxx5nFwyGB_ufPIvok4XB-78dilpsw', 
            supabaseServiceKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NDUwNTY1NywiZXhwIjoyMDcwMDgxNjU3fQ.5m7nLHxHxOkxQf8maZis7Y7jynqu2dWqIzEbgWvOTcE',
            tableName: 'staffTable', 
            primaryKeyColumn: 'No' 
        };

        // Initialize Supabase client
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';
        const supabase = createClient(supabaseConfig.supabaseUrl, supabaseConfig.supabaseAnonKey);
        
        // Create a separate Supabase client for storage operations with service role key
        const supabaseStorage = createClient(supabaseConfig.supabaseUrl, supabaseConfig.supabaseServiceKey);
        
        // Make Supabase globally available
        window.supabase = supabase;
        window.supabaseStorage = supabaseStorage;
        window.supabaseConfig = supabaseConfig;
        
        // Global state management
        const appState = { 
            isLoggedIn: false, 
            masterSource: 'supabase', 
            dataHash: null, 
            localData: null, 
            serverColumns: null 
        };
        
        // Make app state globally available
        window.appState = appState;
        
        // Application state variables
        let isDirty = false;
        let saveTimeout = null;
        let history = [];
        let historyDebounceTimeout = null;
        
        // Persistent undo/redo stacks (per session)
        let operationHistory = []; // already-declared enhanced history (kept for clarity)
        let redoHistory = [];
        let isPerformingUndoRedo = false;
        let suppressRealtimeUntil = 0; // timestamp until which realtime updates are ignored
        let suppressAutosaveUntil = 0;  // timestamp until which autosave is paused
        let undoRedoSyncTimeout = null; // Timeout for automatic sync after undo/redo
        let isTyping = false;
        let lastEditAt = 0;
        let typingTimer = null;
        let isSyncing = false;
        let realtimeSubscription = null;
        let lastSaveTime = 0; // Timestamp de la dernière sauvegarde
        const REALTIME_COOLDOWN_MS = 2000; // 2 secondes de cooldown après sauvegarde
        
        // Enhanced undo system
        // operationHistory is declared above in the persistent stacks section
        let currentOperation = null; // Current operation being built
        let operationTimeout = null; // Timeout for operation completion
        
        // Operation types for better undo tracking
        const OPERATION_TYPES = {
            CELL_EDIT: 'cell_edit',
            ROW_ADD: 'row_add',
            ROW_DELETE: 'row_delete',
            MULTIPLE_ROWS_DELETE: 'multiple_rows_delete',
            ROW_COLOR: 'row_color',
            BULK_EDIT: 'bulk_edit'
        };
        
        // Autosave configuration
        const AUTOSAVE_DELAY_MS = 3000; // 3 seconds after last edit when idle
        let autosaveTicker = null;
        let lastShownCountdown = null;
        let lastFocusInfo = null;
        let lastCellPos = null;
        
        // Zoom functionality
        let zoomFactor = parseFloat(localStorage.getItem('zoomFactor') || '1');

        // Snapshot System State
        let snapshotMode = 'live'; // 'live' or 'snapshot'
        let currentSnapshotDate = null;
        let availableSnapshots = [];
        let currentSnapshotIndex = -1;
        
        // History bar visibility state (saved in localStorage)

        
        // Make snapshot system globally available
        window.snapshotMode = snapshotMode;
        window.currentSnapshotDate = currentSnapshotDate;
        window.availableSnapshots = availableSnapshots;
        window.currentSnapshotIndex = currentSnapshotIndex;

        window.realtimeSubscription = realtimeSubscription;
        
        // Make other important variables globally available
        window.isViewMode = false; // Will be updated in initializeApp
        window.isInitialLoad = true; // Will be set to false after initialization
        window.isRestoringFocus = false; // Flag to prevent edit events during focus restoration
        
        // Function to refresh calendar display
        function refreshSnapshotCalendar() {
            console.log('🔄 Refreshing snapshot calendar...');
            populateSnapshotCalendar();
            updateHistoryNavigation();
        }
        
        // Function to clean storage and database completely
        async function cleanStorageAndDatabase() {
            try {
                console.log('🧹 Cleaning storage and database completely...');
                
                // First, clean the database
                const { error: dbError } = await supabase
                    .from('table_snapshots_index')
                    .delete()
                    .neq('id', '00000000-0000-0000-0000-000000000000');
                
                if (dbError) {
                    console.error('❌ Error cleaning database:', dbError);
                    return;
                }
                
                console.log('✅ Database cleaned');
                
                // Then, clean the storage bucket
                const { data: storageFiles, error: listError } = await supabaseStorage.storage
                    .from('table-snapshots')
                    .list('', { limit: 1000 });
                
                if (listError) {
                    console.error('❌ Error listing storage files:', listError);
                    return;
                }
                
                if (storageFiles && storageFiles.length > 0) {
                    const fileNames = storageFiles.map(file => file.name);
                    console.log(`🗑️ Removing ${fileNames.length} files from storage...`);
                    
                    const { error: removeError } = await supabaseStorage.storage
                        .from('table-snapshots')
                        .remove(fileNames);
                    
                    if (removeError) {
                        console.error('❌ Error removing storage files:', removeError);
                    } else {
                        console.log('✅ Storage cleaned');
                    }
                } else {
                    console.log('✅ Storage already empty');
                }
                
                // Create a fresh snapshot
                await createDemoSnapshot();
                
                showMessage('Storage et base de données complètement nettoyés', 'success');
                
            } catch (err) {
                console.error('❌ Error cleaning storage and database:', err);
                showMessage('Erreur lors du nettoyage complet', 'error');
            }
        }
        
        // Add logging function
        window.log = function(message, level = 'info') {
            console.log(`[${level.toUpperCase()}] ${message}`);
        };

        
        // Row color management
        let currentRowColor = localStorage.getItem('rowColor') || '#FFF59D';
        let rowColorMap = {};
        let isRowPaintDragging = false;
        let rowPaintAction = 'color';
        let paintMode = localStorage.getItem('rowPaintMode') || 'auto';
        let showOnlyColored = false;
        let isViewMode = localStorage.getItem('viewMode') === 'true'; // Mode visualisation (lecture seule) - restauré depuis localStorage
        let isViewModeProtected = false; // Flag pour protection renforcée sur mobile
        
        // Protection globale: wrapper pour toutes les fonctions de sauvegarde
        function protectedSaveStateToHistory() {
            if (isViewMode && isMobile()) {
                console.log('🔒 Global protection: saveStateToHistory BLOCKED');
                return;
            }
            return saveStateToHistory();
        }
        
        // Initialize from localStorage
        try { 
            lastFocusInfo = JSON.parse(localStorage.getItem('lastFocusInfo') || 'null'); 
            
            // Forcer l'affichage du bouton d'ajout au démarrage (en respectant le mode visualisation)
            const fabAdd = document.getElementById('fab-add');
            if (fabAdd) {
                fabAdd.style.display = 'flex';
                fabAdd.style.visibility = 'visible';
                
                if (isViewMode) {
                    // Mode visualisation : bouton visible mais désactivé
                    fabAdd.style.opacity = '0.5';
                    fabAdd.style.pointerEvents = 'none';
                    fabAdd.style.cursor = 'not-allowed';
                    fabAdd.title = 'Mode visualisation actif - Ajout de lignes désactivé';
                } else {
                    // Mode normal : bouton pleinement fonctionnel
                    fabAdd.style.opacity = '1';
                    fabAdd.style.pointerEvents = 'auto';
                    fabAdd.style.cursor = 'pointer';
                    fabAdd.title = 'Ajouter une nouvelle ligne';
                }
                
                console.log('✅ FAB add button forced visible on startup (respecting view mode)');
            }
        } catch(_) { 
            lastFocusInfo = null; 
        }
        
        try { 
            lastCellPos = JSON.parse(localStorage.getItem('lastCellPos') || 'null'); 
        } catch(_) { 
            lastCellPos = null; 
        }
        
        try { 
            rowColorMap = JSON.parse(localStorage.getItem('rowColors') || '{}'); 
        } catch(_) { 
            rowColorMap = {}; 
        }

        // Enhanced undo system functions
        function startOperation(type, data = {}) {
            // Clear any pending operations first
            if (currentOperation) {
                console.log(`🔄 Completing previous operation: ${currentOperation.type}`);
                completeOperation();
            }
            
            // Clear any operation timeout
            clearOperationTimeout();
            
            // Reset undo/redo sync timeout when starting new operations
            clearUndoRedoSyncTimeout();
            
            // For row operations, check if there are conflicting operations in history
            if (type === OPERATION_TYPES.ROW_ADD || 
                type === OPERATION_TYPES.ROW_DELETE || 
                type === OPERATION_TYPES.MULTIPLE_ROWS_DELETE) {
                
                // Clean up any conflicting row operations in history
                const conflictingOps = operationHistory.filter(op => 
                    op.type === OPERATION_TYPES.ROW_ADD || 
                    op.type === OPERATION_TYPES.ROW_DELETE || 
                    op.type === OPERATION_TYPES.MULTIPLE_ROWS_DELETE
                );
                
                if (conflictingOps.length > 0) {
                    console.log(`🧹 Cleaning up ${conflictingOps.length} conflicting row operations`);
                    operationHistory = operationHistory.filter(op => 
                        op.type !== OPERATION_TYPES.ROW_ADD && 
                        op.type !== OPERATION_TYPES.ROW_DELETE && 
                        op.type !== OPERATION_TYPES.MULTIPLE_ROWS_DELETE
                    );
                }
            }
            
            currentOperation = {
                type: type,
                data: data,
                timestamp: Date.now(),
                tableState: collectTableData(),
                rowColors: { ...rowColorMap }
            };
            
            console.log(`🚀 Started operation: ${type}`, currentOperation);
        }
        
        function addToOperation(data) {
            if (currentOperation) {
                Object.assign(currentOperation.data, data);
                console.log(`📝 Added to operation:`, currentOperation);
            }
            // Only clear redo stack for structural changes, not for cell edits
            if (currentOperation && (currentOperation.type === OPERATION_TYPES.ROW_ADD || 
                                   currentOperation.type === OPERATION_TYPES.ROW_DELETE || 
                                   currentOperation.type === OPERATION_TYPES.MULTIPLE_ROWS_DELETE)) {
                redoHistory = [];
                console.log('🧹 Cleared redo stack for structural change in addToOperation');
            }
            persistHistoryStacks();
        }
        
        function completeOperation() {
            if (currentOperation) {
                // Add final table state
                currentOperation.finalState = collectTableData();
                currentOperation.finalRowColors = { ...rowColorMap };
                
                // Add to operation history
                operationHistory.push(currentOperation);
                
                // Only clear redo stack for operations that change table structure
                // Keep redo stack for cell edits and color changes
                if (currentOperation.type === OPERATION_TYPES.ROW_ADD || 
                    currentOperation.type === OPERATION_TYPES.ROW_DELETE || 
                    currentOperation.type === OPERATION_TYPES.MULTIPLE_ROWS_DELETE) {
                    redoHistory = [];
                    console.log('🧹 Cleared redo stack for structural change');
                }
                
                persistHistoryStacks();
                
                // Keep at least 10 operations, but allow up to 50 for better user experience
                if (operationHistory.length > 50) {
                    // Remove oldest operations while keeping at least 10
                    const toRemove = operationHistory.length - 40; // Keep 40 operations
                    for (let i = 0; i < toRemove; i++) {
                        operationHistory.shift();
                    }
                    console.log(`🧹 Cleaned up ${toRemove} old operations, keeping ${operationHistory.length} operations`);
                }
                
                console.log(`✅ Completed operation: ${currentOperation.type}`, currentOperation);
                
                // Also save to regular history for backward compatibility
                saveStateToHistory();
                
                currentOperation = null;
                updateUndoButtonState();
            }
        }
        
        function cancelOperation() {
            if (currentOperation) {
                console.log(`❌ Cancelled operation: ${currentOperation.type}`);
                currentOperation = null;
            }
        }

        // Persist/restore undo/redo stacks in sessionStorage
        function persistHistoryStacks() {
            try {
                sessionStorage.setItem('operationHistory', JSON.stringify(operationHistory));
                sessionStorage.setItem('redoHistory', JSON.stringify(redoHistory));
            } catch(_) {}
        }
        function restoreHistoryStacks() {
            try {
                const ops = JSON.parse(sessionStorage.getItem('operationHistory') || '[]');
                const red = JSON.parse(sessionStorage.getItem('redoHistory') || '[]');
                if (Array.isArray(ops)) operationHistory = ops; else operationHistory = [];
                if (Array.isArray(red)) redoHistory = red; else redoHistory = [];
            } catch(_) {
                operationHistory = [];
                redoHistory = [];
            }
            updateUndoButtonState();
        }
        
        // Enhanced undo function (with redo support)
        function undo() {
            if (operationHistory.length === 0) {
                log('Aucune opération à annuler.', 'info');
                return;
            }
            
            const lastOperation = operationHistory.pop();
            console.log(`🔄 Undoing operation: ${lastOperation.type}`, lastOperation);
            
            try {
                isPerformingUndoRedo = true;
                // Clear any pending operations before undoing
                if (currentOperation) {
                    console.log('⚠️ Clearing pending operation before undo');
                    currentOperation = null;
                }
                clearOperationTimeout();
                
                // Restore table state
                if (lastOperation.tableState) {
                    loadTableData(lastOperation.tableState.rows);
                }
                
                // Special handling for cell edits - restore specific cell values
                if (lastOperation.type === OPERATION_TYPES.CELL_EDIT && lastOperation.data) {
                    const { rowIndex, columnLabel, initialValue } = lastOperation.data;
                    if (rowIndex !== undefined && columnLabel) {
                        const tbody = document.getElementById('table-body');
                        const rows = Array.from(tbody.children);
                        if (rows[rowIndex]) {
                            const cells = Array.from(rows[rowIndex].querySelectorAll('td')).slice(2); // Skip No and Delete columns
                            const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                            const columnIndex = headers.indexOf(columnLabel);
                            if (columnIndex >= 0 && cells[columnIndex]) {
                                cells[columnIndex].textContent = initialValue;
                                console.log(`🔄 Restored cell [${rowIndex}, ${columnLabel}] to: "${initialValue}"`);
                            }
                        }
                    }
                }
                
                // Special handling for bulk edits
                if (lastOperation.type === OPERATION_TYPES.BULK_EDIT) {
                    if (lastOperation.data && lastOperation.data.edits) {
                        // Type 1: Bulk edits avec liste de modifications individuelles
                        console.log(`🔄 Restoring ${lastOperation.data.edits.length} cell edits`);
                        const tbody = document.getElementById('table-body');
                        const rows = Array.from(tbody.children);
                        const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                        
                        lastOperation.data.edits.forEach(edit => {
                            if (edit.rowIndex !== undefined && edit.columnLabel) {
                                if (rows[edit.rowIndex]) {
                                    const cells = Array.from(rows[edit.rowIndex].querySelectorAll('td')).slice(2);
                                    const columnIndex = headers.indexOf(edit.columnLabel);
                                    if (columnIndex >= 0 && cells[columnIndex]) {
                                        cells[columnIndex].textContent = edit.initialValue;
                                        console.log(`🔄 Restored cell [${edit.rowIndex}, ${edit.columnLabel}] to: "${edit.initialValue}"`);
                                    }
                                }
                            }
                        });
                    } else if (lastOperation.tableState) {
                        // Type 2: Bulk edit avec état complet du tableau
                        console.log(`🔄 Restoring table state from bulk edit`);
                        
                        // Sauvegarder l'état actuel pour le redo si ce n'est pas déjà fait
                        if (!lastOperation.finalState) {
                            lastOperation.finalState = collectTableData();
                        }
                        
                        loadTableData(lastOperation.tableState);
                    }
                }
                
                // Restore row colors
                if (lastOperation.rowColors) {
                    rowColorMap = { ...lastOperation.rowColors };
                    persistRowColors();
                    
                    // Apply colors to visible rows
                    Array.from(document.querySelectorAll('#table-body tr')).forEach(tr => {
                        const k = keyForRow(tr);
                        const c = rowColorMap[k];
                        if (c && c !== '') {
                            setRowColor(tr, c);
                        }
                    });
                }
                
                // Don't remove operations from history - just push to redo stack
                // This allows proper undo/redo cycling
                console.log(`📝 Keeping operation history intact for proper undo/redo cycling`);

                // Push undone operation to redo stack
                redoHistory.push(lastOperation);
                
                // Keep redo stack manageable but allow up to 30 operations
                if (redoHistory.length > 30) {
                    const toRemove = redoHistory.length - 20; // Keep 20 operations
                    for (let i = 0; i < toRemove; i++) {
                        redoHistory.shift();
                    }
                    console.log(`🧹 Cleaned up ${toRemove} old redo operations, keeping ${redoHistory.length} operations`);
                }
                
                persistHistoryStacks();
                
                log(`Opération '${lastOperation.type}' annulée avec succès.`, 'success');
                updateUndoButtonState();
                
                // Schedule automatic sync after undo operation with pruning
                // Ensure server deletes rows that are missing locally and suppress realtime/autosave briefly
                const SUPPRESSION_MS = 2000;
                suppressRealtimeUntil = Date.now() + SUPPRESSION_MS;
                suppressAutosaveUntil = Date.now() + SUPPRESSION_MS;
                if (typeof scheduleUndoRedoSync === 'function') {
                    clearUndoRedoSyncTimeout();
                    undoRedoSyncTimeout = setTimeout(() => {
                        if (!isPerformingUndoRedo) {
                            log('🔄 Auto-sync (prune) after undo');
                            syncToMaster(true, true);
                            undoRedoSyncTimeout = null;
                        }
                    }, 500);
                }
                
            } catch (error) {
                console.error('❌ Error during undo:', error);
                log('Erreur lors de l\'annulation.', 'error');
            } finally {
                isPerformingUndoRedo = false;
            }
        }

        // Redo function
        function redo() {
            if (redoHistory.length === 0) {
                log('Aucune opération à rétablir.', 'info');
                return;
            }
            
            const op = redoHistory.pop();
            console.log(`⏩ Redoing operation: ${op.type}`, op);
            try {
                isPerformingUndoRedo = true;
                clearOperationTimeout();
                
                // Re-apply the final state of the operation
                if (op.finalState) {
                    loadTableData(op.finalState.rows);
                }
                
                // Special handling for cell edits - restore final cell values
                if (op.type === OPERATION_TYPES.CELL_EDIT && op.data) {
                    const { rowIndex, columnLabel, currentValue } = op.data;
                    if (rowIndex !== undefined && columnLabel && currentValue) {
                        const tbody = document.getElementById('table-body');
                        const rows = Array.from(tbody.children);
                        if (rows[rowIndex]) {
                            const cells = Array.from(rows[rowIndex].querySelectorAll('td')).slice(2); // Skip No and Delete columns
                            const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                            const columnIndex = headers.indexOf(columnLabel);
                            if (columnIndex >= 0 && cells[columnIndex]) {
                                cells[columnIndex].textContent = currentValue;
                                console.log(`⏩ Restored cell [${rowIndex}, ${columnLabel}] to: "${currentValue}"`);
                            }
                        }
                    }
                }
                
                // Special handling for bulk edits
                if (op.type === OPERATION_TYPES.BULK_EDIT) {
                    if (op.data && op.data.edits) {
                        // Type 1: Bulk edits avec liste de modifications individuelles
                        console.log(`⏩ Restoring ${op.data.edits.length} cell edits`);
                        const tbody = document.getElementById('table-body');
                        const rows = Array.from(tbody.children);
                        const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                        
                        op.data.edits.forEach(edit => {
                            if (edit.rowIndex !== undefined && edit.columnLabel) {
                                if (rows[edit.rowIndex]) {
                                    const cells = Array.from(rows[edit.rowIndex].querySelectorAll('td')).slice(2);
                                    const columnIndex = headers.indexOf(edit.columnLabel);
                                    if (columnIndex >= 0 && cells[columnIndex]) {
                                        cells[columnIndex].textContent = edit.currentValue;
                                        console.log(`⏩ Restored cell [${edit.rowIndex}, ${edit.columnLabel}] to: "${edit.currentValue}"`);
                                    }
                                }
                            }
                        });
                    } else if (op.finalState) {
                        // Type 2: Bulk edit avec état complet du tableau
                        console.log(`⏩ Restoring table state from bulk edit (redo)`);
                        loadTableData(op.finalState);
                    }
                }
                
                if (op.finalRowColors) {
                    rowColorMap = { ...op.finalRowColors };
                    persistRowColors();
                    Array.from(document.querySelectorAll('#table-body tr')).forEach(tr => {
                        const k = keyForRow(tr);
                        const c = rowColorMap[k];
                        if (c && c !== '') setRowColor(tr, c);
                    });
                }
                
                // After redoing, push back to operation history
                operationHistory.push(op);
                persistHistoryStacks();
                updateUndoButtonState();
                log('Rétabli.', 'success');
                
                // Schedule automatic sync after redo operation with pruning and brief suppression
                const SUPPRESSION_MS = 2000;
                suppressRealtimeUntil = Date.now() + SUPPRESSION_MS;
                suppressAutosaveUntil = Date.now() + SUPPRESSION_MS;
                if (typeof scheduleUndoRedoSync === 'function') {
                    clearUndoRedoSyncTimeout();
                    undoRedoSyncTimeout = setTimeout(() => {
                        if (!isPerformingUndoRedo) {
                            log('🔄 Auto-sync (prune) after redo');
                            syncToMaster(true, true);
                            undoRedoSyncTimeout = null;
                        }
                    }, 500);
                }
                
            } catch (e) {
                console.error('❌ Error during redo:', e);
                log('Erreur lors du rétablissement.', 'error');
            } finally {
                isPerformingUndoRedo = false;
            }
        }
        
        // Function to get operation description for display
        function getOperationDescription(operation) {
            switch (operation.type) {
                case OPERATION_TYPES.CELL_EDIT:
                    const cellInfo = operation.data.columnLabel || operation.data.cellLabel || 'cellule';
                    const rowInfo = operation.data.rowIndex !== undefined ? `ligne ${operation.data.rowIndex + 1}` : '';
                    return `Modification: ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''}`;
                case OPERATION_TYPES.ROW_ADD:
                    return 'Ajout de ligne';
                case OPERATION_TYPES.ROW_DELETE:
                    return 'Suppression de ligne';
                case OPERATION_TYPES.MULTIPLE_ROWS_DELETE:
                    return `Suppression de ${operation.data.deletedRows} ligne(s)`;
                case OPERATION_TYPES.ROW_COLOR:
                    const action = operation.data.action === 'color' ? 'Coloriage' : 'Décoloriage';
                    return `${action} de ligne(s)`;
                case OPERATION_TYPES.BULK_EDIT:
                    return 'Modifications en lot';
                default:
                    return 'Opération';
            }
        }
        
        // Debug function to show current undo/redo state
        function debugUndoRedoState() {
            console.log('🔍 Current Undo/Redo State:');
            console.log('📚 Operation History:', operationHistory.length, 'operations');
            operationHistory.forEach((op, idx) => {
                console.log(`  ${idx + 1}. ${op.type} - ${op.timestamp}`);
            });
            console.log('⏩ Redo History:', redoHistory.length, 'operations');
            redoHistory.forEach((op, idx) => {
                console.log(`  ${idx + 1}. ${op.type} - ${op.timestamp}`);
            });
            console.log('🔄 Current Operation:', currentOperation ? currentOperation.type : 'none');
            console.log('🚫 Is Performing Undo/Redo:', isPerformingUndoRedo);
        }
        
        // Expose debug function globally
        window.debugUndoRedoState = debugUndoRedoState;
        
        // Expose undo/redo functions globally so buttons can access them
        window.undo = undo;
        window.redo = redo;
        
        // Function to clear operation timeout
        function clearOperationTimeout() {
            if (operationTimeout) {
                clearTimeout(operationTimeout);
                operationTimeout = null;
            }
        }
        
        // Function to schedule automatic sync after undo/redo operations
        function scheduleUndoRedoSync() {
            // Clear any existing timeout
            if (undoRedoSyncTimeout) {
                clearTimeout(undoRedoSyncTimeout);
            }
            
            // Schedule sync after 500ms of user inactivity
            undoRedoSyncTimeout = setTimeout(() => {
                if (!isPerformingUndoRedo) {
                    log('🔄 Auto-sync after undo/redo operation (500ms inactivity)');
                    syncToMaster(true);
                    undoRedoSyncTimeout = null;
                }
            }, 500);
        }
        
        // Function to group multiple cell edits into a single operation
        function groupCellEdits() {
            if (currentOperation && currentOperation.type === OPERATION_TYPES.CELL_EDIT) {
                // If we have multiple cell edits, group them into a bulk edit
                if (currentOperation.data.editCount > 1) {
                    currentOperation.type = OPERATION_TYPES.BULK_EDIT;
                    currentOperation.data.description = `${currentOperation.data.editCount} modifications de cellules`;
                    console.log(`📝 Grouped ${currentOperation.data.editCount} cell edits into bulk operation`);
                }
            }
        }
        
        // Function to clear undo/redo sync timeout
        function clearUndoRedoSyncTimeout() {
            if (undoRedoSyncTimeout) {
                clearTimeout(undoRedoSyncTimeout);
                undoRedoSyncTimeout = null;
            }
        }
        
        // Handle page unload to complete pending operations
        window.addEventListener('beforeunload', () => {
            if (currentOperation) {
                completeOperation();
            }
            clearOperationTimeout();
            clearUndoRedoSyncTimeout();
        });
        
        // Handle page visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && currentOperation) {
                completeOperation();
            }
            clearUndoRedoSyncTimeout();
        });
        
        // Function to reset operation history (useful for testing)
        function resetOperationHistory() {
            operationHistory = [];
            if (currentOperation) {
                currentOperation = null;
            }
            clearOperationTimeout();
            updateUndoButtonState();
            console.log('🔄 Operation history reset');
        }
        
        // Function to safely start new operations after undo
        function safeStartOperation(type, data = {}) {
            // Clear any pending operations
            if (currentOperation) {
                completeOperation();
            }
            
            // Clean up conflicting operations
            if (type === OPERATION_TYPES.ROW_ADD || 
                type === OPERATION_TYPES.ROW_DELETE || 
                type === OPERATION_TYPES.MULTIPLE_ROWS_DELETE) {
                
                operationHistory = operationHistory.filter(op => 
                    op.type !== OPERATION_TYPES.ROW_ADD && 
                    op.type !== OPERATION_TYPES.ROW_DELETE && 
                    op.type !== OPERATION_TYPES.MULTIPLE_ROWS_DELETE
                );
            }
            
            startOperation(type, data);
        }
        
        // Expose functions globally for debugging
        window.resetOperationHistory = resetOperationHistory;
        window.safeStartOperation = safeStartOperation;
        window.updateRowCount = updateRowCount;
        
        // Fonction pour forcer l'affichage du bouton d'ajout
        window.forceFabAddVisible = function() {
            const fabAdd = document.getElementById('fab-add');
            if (fabAdd) {
                fabAdd.style.display = 'flex';
                fabAdd.style.visibility = 'visible';
                
                if (isViewMode) {
                    // Mode visualisation : bouton visible mais désactivé
                    fabAdd.style.opacity = '0.5';
                    fabAdd.style.pointerEvents = 'none';
                    fabAdd.style.cursor = 'not-allowed';
                    fabAdd.title = 'Mode visualisation actif - Ajout de lignes désactivé';
                } else {
                    // Mode normal : bouton pleinement fonctionnel
                    fabAdd.style.opacity = '1';
                    fabAdd.style.pointerEvents = 'auto';
                    fabAdd.style.cursor = 'pointer';
                    fabAdd.title = 'Ajouter une nouvelle ligne';
                }
                
                console.log('✅ FAB add button forced visible (respecting view mode)');
                return true;
            } else {
                console.error('❌ FAB add button not found');
                return false;
            }
        };
        
        // Utility functions
        function log(message, type = 'info') { 
            console.log(`[${new Date().toLocaleTimeString()}] ${type.toUpperCase()}: ${message}`); 
        }
        
        function showMessage(message, type = 'success') { 
            const box = document.getElementById('message-box'); 
            const txt = document.getElementById('message-text'); 
            
            if (window._msgTimer) clearTimeout(window._msgTimer); 
            
            box.classList.remove('show'); 
            txt.textContent = message; 
            box.className = `message-box ${type}`; 
            
            void box.offsetWidth; // Force reflow
            box.classList.add('show'); 
            box.classList.remove('hidden'); 
            
            window._msgTimer = setTimeout(() => {
                box.classList.remove('show'); 
                setTimeout(() => box.classList.add('hidden'), 500); 
            }, 3000); 
        }
        
        function updateStatus(message, type = 'pending') { 
            const el = document.getElementById('sync-status'); 
            const textEl = el.querySelector('.sync-text');
            const iconEl = el.querySelector('.sync-icon');
            
            // Mettre à jour le texte et l'icône
            if (textEl) textEl.textContent = message;
            if (iconEl) {
                // Choisir l'icône appropriée selon le type
                if (type === 'success') {
                    iconEl.className = 'sync-icon fa-solid fa-check';
                } else if (type === 'error') {
                    iconEl.className = 'sync-icon fa-solid fa-exclamation-triangle';
                } else if (type === 'saving') {
                    iconEl.className = 'sync-icon fa-solid fa-sync-alt fa-spin';
                } else {
                    iconEl.className = 'sync-icon fa-solid fa-clock';
                }
            }
            
            el.className = `px-3 py-1 rounded-full text-xs font-semibold border-2 bg-white shadow-sm transition-all duration-300 ${getSyncStatusClasses(type)}`;
            
            // Mettre à jour le point coloré si il existe (pour petits écrans)
            const dotEl = el.querySelector('.sync-dot');
            if (dotEl) {
                applyDotColor(dotEl, type);
            }
            
            // Adapter l'affichage selon la taille d'écran
            adaptStatusDisplay();
        }
        
        function getSyncStatusClasses(type) { 
            switch(type) { 
                case 'success': 
                    return 'bg-green-100 text-green-800 border-green-400 shadow-green-200/50'; 
                case 'error': 
                    return 'bg-red-100 text-red-800 border-red-400 shadow-red-200/50'; 
                case 'saving': 
                    return 'bg-blue-100 text-blue-800 border-blue-400 shadow-blue-200/50 sync-pending-animation'; 
                default: 
                    return 'bg-yellow-100 text-yellow-800 border-yellow-400 shadow-yellow-200/50 sync-pending-animation'; 
            } 
        }
        
        function adaptStatusDisplay() {
            const el = document.getElementById('sync-status');
            if (!el) return;
            
            const textEl = el.querySelector('.sync-text');
            const iconEl = el.querySelector('.sync-icon');
            
            if (!textEl || !iconEl) return;
            
            // Trouver le titre "Tableau de Staff" par son ID
            const titleEl = document.getElementById('staff-title');
            
            // Sur petits écrans, afficher seulement un point coloré et cacher le titre
            if (window.innerWidth <= 768) {
                textEl.classList.add('hidden');
                iconEl.classList.add('hidden');
                
                // Cacher le titre sur petits écrans
                if (titleEl) {
                    titleEl.classList.add('hidden');
                }
                
                // Créer ou mettre à jour le point coloré
                let dotEl = el.querySelector('.sync-dot');
                if (!dotEl) {
                    dotEl = document.createElement('div');
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full';
                    dotEl.setAttribute('aria-label', 'Statut de synchronisation');
                    dotEl.setAttribute('title', 'Statut de synchronisation');
                    el.appendChild(dotEl);
                }
                
                // S'assurer que le point est visible
                dotEl.classList.remove('hidden');
                
                // Appliquer la couleur selon le type actuel
                const currentType = getCurrentStatusType(el);
                applyDotColor(dotEl, currentType);
                
                el.classList.add('px-1', 'py-0.5'); // Padding minimal
                el.classList.remove('px-2', 'px-3');
            } else {
                // Sur grands écrans, afficher le texte et le titre, cacher le point
                textEl.classList.remove('hidden');
                iconEl.classList.add('hidden');
                
                // Afficher le titre sur grands écrans
                if (titleEl) {
                    titleEl.classList.remove('hidden');
                }
                
                const dotEl = el.querySelector('.sync-dot');
                if (dotEl) {
                    dotEl.classList.add('hidden');
                    // Optionnel: supprimer complètement le point pour économiser la mémoire
                    // dotEl.remove();
                }
                
                el.classList.add('px-2');
                el.classList.remove('px-1', 'px-3');
            }
        }
        
        function getCurrentStatusType(el) {
            if (!el) return 'pending';
            
            // Détecter le type actuel basé sur les classes CSS
            if (el.classList.contains('bg-green-100')) return 'success';
            if (el.classList.contains('bg-red-100')) return 'error';
            if (el.classList.contains('bg-blue-100')) return 'saving';
            return 'pending';
        }
        
        function applyDotColor(dotEl, type) {
            if (!dotEl) return;
            
            // Appliquer la couleur appropriée au point
            switch(type) {
                case 'success':
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-green-500';
                    break;
                case 'error':
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-red-500';
                    break;
                case 'saving':
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-blue-500 animate-pulse';
                    break;
                default:
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-yellow-500';
                    break;
            }
        }
        

        
                function updateUndoButtonState() { 
            const undoButton = document.getElementById('undo-button');
            const redoButton = document.getElementById('redo-button');
            if (undoButton) {
                const hasOperations = operationHistory.length > 0;
                undoButton.disabled = !hasOperations;
                
                // Update button title with operation info (keep icon unchanged)
                if (hasOperations) {
                    const lastOp = operationHistory[operationHistory.length - 1];
                    const description = getOperationDescription(lastOp);
                    undoButton.title = `Annuler: ${description} (${operationHistory.length} opération(s) disponible(s))`;
                } else {
                    undoButton.title = 'Aucune opération à annuler';
                }
            }
            if (redoButton) {
                const hasRedo = redoHistory.length > 0;
                redoButton.disabled = !hasRedo;
                if (hasRedo) {
                    const lastRedo = redoHistory[redoHistory.length - 1];
                    const descRedo = getOperationDescription(lastRedo);
                    redoButton.title = `Rétablir: ${descRedo} (${redoHistory.length} opération(s) disponible(s))`;
                } else {
                    redoButton.title = 'Aucune opération à rétablir';
                }
            }
        }
        
        function getFormattedDate() { 
            const d = new Date(); 
            return `${String(d.getDate()).padStart(2, '0')}/${String(d.getMonth() + 1).padStart(2, '0')}/${String(d.getFullYear()).slice(-2)}`; 
        }
        
        function generateDataHash(data) { 
            return JSON.stringify(data.rows.map(r => ({...r, [supabaseConfig.primaryKeyColumn]: undefined}))).split('').reduce((a, b) => {
                a = ((a << 5) - a) + b.charCodeAt(0);
                return a & a;
            }, 0).toString(16); 
        }

        // Zoom functionality
        function updateZoomDisplay() {
            const btn = document.getElementById('zoom-display');
            if (!btn) return;
            
            const pct = Math.round(zoomFactor * 100);
            btn.textContent = pct + '%';
            btn.title = `Réinitialiser à 100% (actuel : ${pct}%)`;
        }
        
        function applyZoom() {
            try {
                const clamped = Math.max(0.3, Math.min(2, zoomFactor));
                zoomFactor = clamped;
                document.documentElement.style.fontSize = (16 * zoomFactor) + 'px';
                localStorage.setItem('zoomFactor', String(zoomFactor));
                updateZoomDisplay();
            } catch(_) {}
        }
        
        function zoomIn() { 
            zoomFactor += 0.05; 
            applyZoom(); 
        }
        
        function zoomOut() { 
            zoomFactor -= 0.05; 
            applyZoom(); 
        }
        
        function zoomReset() { 
            zoomFactor = 1; 
            applyZoom(); 
        }

        // Row color management
        function persistRowColors() { 
            try { 
                localStorage.setItem('rowColors', JSON.stringify(rowColorMap)); 
            } catch(_) {} 
        }
        
        function setRowColor(tr, color) {
            if (!tr) return;
            
            // S'assurer que tr est bien un élément TR
            if (tr.tagName !== 'TR') {
                console.warn('setRowColor: tr parameter is not a TR element:', tr);
                return;
            }
            
            if (color) { 
                // Colorer toute la ligne
                tr.style.backgroundColor = color; 
                tr.dataset.rowColored = '1'; 
                
                // S'assurer que toutes les cellules de la ligne héritent de la couleur
                Array.from(tr.cells).forEach(cell => {
                    if (cell.style.backgroundColor !== color) {
                        cell.style.backgroundColor = color;
                    }
                });
            } else { 
                // Décolorer toute la ligne
                tr.style.backgroundColor = ''; 
                tr.dataset.rowColored = '0'; 
                
                // S'assurer que toutes les cellules de la ligne sont décolorées
                Array.from(tr.cells).forEach(cell => {
                    cell.style.backgroundColor = '';
                });
            }
        }
        
        function keyForRow(tr) {
            return tr.dataset.key || (Array.from(tr.parentElement.children).indexOf(tr) + 1);
        }

        function toggleRowColor(tr) {
            // S'assurer que tr est bien un élément tr (ligne)
            if (!tr || tr.tagName !== 'TR') {
                console.warn('toggleRowColor: tr parameter is not a TR element:', tr);
                return;
            }
            
            const key = keyForRow(tr);
            
            // Respecter le mode de peinture actuel
            if (paintMode === 'color') {
                // Mode Colorer : toujours colorer
                setRowColor(tr, currentRowColor);
                rowColorMap[key] = currentRowColor;
            } else if (paintMode === 'clear') {
                // Mode Effacer : toujours effacer
                setRowColor(tr, null);
                delete rowColorMap[key];
            } else {
                // Mode Auto : basculer selon l'état actuel
                if (tr.dataset.rowColored === '1') {
                    setRowColor(tr, null);
                    delete rowColorMap[key];
                } else {
                    setRowColor(tr, currentRowColor);
                    rowColorMap[key] = currentRowColor;
                }
            }
            
            persistRowColors();
        }

        // Drag-to-paint functionality
        function applyRowPaint(row) {
            if (!row) return;
            
            // Start operation tracking for row color changes
            if (!currentOperation || currentOperation.type !== OPERATION_TYPES.ROW_COLOR) {
                startOperation(OPERATION_TYPES.ROW_COLOR, {
                    rowKey: keyForRow(row),
                    action: rowPaintAction,
                    color: currentRowColor
                });
            } else {
                addToOperation({
                    rowKey: keyForRow(row),
                    action: rowPaintAction,
                    color: currentRowColor
                });
            }
            
            const key = keyForRow(row);
            if (rowPaintAction === 'color') {
                setRowColor(row, currentRowColor);
                rowColorMap[key] = currentRowColor;
            } else {
                setRowColor(row, null);
                delete rowColorMap[key];
            }
            persistRowColors();
            
            // Complete operation after a short delay to batch multiple color changes
            if (operationTimeout) clearTimeout(operationTimeout);
            operationTimeout = setTimeout(() => {
                completeOperation();
            }, 500); // 500ms delay for color operations
        }
        
        function startRowPaint(row) {
            // Respecter le mode de peinture actuel
            if (paintMode === 'color') {
                rowPaintAction = 'color';
            } else if (paintMode === 'clear') {
                rowPaintAction = 'clear';
            } else {
                // Mode Auto : basculer selon l'état actuel
                rowPaintAction = (row && row.dataset.rowColored === '1') ? 'clear' : 'color';
            }
            
            isRowPaintDragging = true;
            applyRowPaint(row);
        }
        
        function endRowPaint() { 
            isRowPaintDragging = false; 
            
            // Complete any pending color operation
            if (currentOperation && currentOperation.type === OPERATION_TYPES.ROW_COLOR) {
                if (operationTimeout) clearTimeout(operationTimeout);
                completeOperation();
            }
        }

        // Paint mode management
        function getPaintActionForRow(row) {
            if (paintMode === 'auto') {
                // En mode auto : si la ligne est colorée, on la décolore, sinon on la colorie
                const isColored = row && (row.dataset.rowColored === '1' || 
                                        (row.style.backgroundColor && row.style.backgroundColor !== ''));
                return isColored ? 'clear' : 'color';
            }
            return paintMode;
        }
        
        function updatePaintModeButton() {
            const btn = document.getElementById('paint-mode-toggle');
            if (!btn) return;
            
            if (paintMode === 'auto') { 
                btn.innerHTML = '<i class="fa-solid fa-arrows-rotate w-4 h-4"></i>'; 
                btn.title = 'Mode Auto: Cliquez pour colorer/décolorer (P pour changer)'; 
            } else if (paintMode === 'color') { 
                btn.innerHTML = '<i class="fa-solid fa-paintbrush w-4 h-4"></i>'; 
                btn.title = 'Mode Colorer (P pour changer)'; 
            } else { 
                btn.innerHTML = '<i class="fa-solid fa-eraser w-4 h-4"></i>'; 
                btn.title = 'Mode Effacer (P pour changer)'; 
            }
        }
        
        function cyclePaintMode() {
            paintMode = (paintMode === 'auto') ? 'color' : (paintMode === 'color' ? 'clear' : 'auto');
            localStorage.setItem('rowPaintMode', paintMode);
            updatePaintModeButton();
            
            let message = paintMode === 'auto' ? 'Auto' : (paintMode === 'color' ? 'Coloré' : 'Effacer');
            showMessage(message, 'info');
        }

        // Filter functionality
        function applyColoredFilter() {
            try {
                const tbody = document.getElementById('table-body');
                Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                    const colored = tr.dataset.rowColored === '1' || (tr.style.backgroundColor && tr.style.backgroundColor !== '');
                    tr.style.display = (showOnlyColored && !colored) ? 'none' : '';
                });
            } catch(_) {}
        }

        function updateFilterColoredButton() {
            const btn = document.getElementById('filter-colored-toggle');
            if (!btn) return;
            
            if (showOnlyColored) {
                btn.innerHTML = '<i class="fa-solid fa-eye w-4 h-4"></i>';
                btn.title = 'Afficher toutes les lignes';
                btn.setAttribute('aria-pressed', 'true');
            } else {
                btn.innerHTML = '<i class="fa-solid fa-filter w-4 h-4"></i>';
                btn.title = 'Afficher seulement les lignes colorées';
                btn.setAttribute('aria-pressed', 'false');
            }
        }

        function toggleColoredFilter() {
            showOnlyColored = !showOnlyColored;
            applyColoredFilter();
            updateFilterColoredButton();
        }
        
        // Fonction pour basculer le mode visualisation
        function toggleViewMode() {
            isViewMode = !isViewMode;
            
            // Sauvegarder immédiatement l'état dans localStorage
            localStorage.setItem('viewMode', isViewMode.toString());
            
            updateViewModeButton();
            applyViewMode();
        }
        
        // Mettre à jour l'apparence du bouton de mode visualisation
        function updateViewModeButton() {
            const btn = document.getElementById('view-mode-toggle');
            if (!btn) return;
            
            if (isViewMode) {
                btn.className = 'bg-green-200 text-green-800 p-2 rounded-lg hover:bg-green-300 transition-colors flex items-center justify-center w-8 h-8';
                btn.title = 'Désactiver le mode visualisation (lecture seule)';
                btn.innerHTML = '<i class="fa-solid fa-eye-slash w-4 h-4"></i>';
            } else {
                btn.className = 'bg-blue-200 text-blue-800 p-2 rounded-lg hover:bg-blue-300 transition-colors flex items-center justify-center w-8 h-8';
                btn.title = 'Activer le mode visualisation (lecture seule)';
                btn.innerHTML = '<i class="fa-solid fa-eye w-4 h-4"></i>';
            }
        }
        
        // Appliquer le mode visualisation
        function applyViewMode() {
            const editableCells = document.querySelectorAll('.editable-cell');
            const fabAdd = document.getElementById('fab-add');
            const mobileAddButton = document.getElementById('mobile-add-button');
            
            // Désactiver TEMPORAIREMENT TOUTES les sauvegardes si on passe en mode visualisation
            let originalFunctions = {};
            if (isViewMode) {
                // Sauvegarder toutes les fonctions originales
                originalFunctions.markEdited = window.markEdited;
                originalFunctions.saveStateToHistory = window.saveStateToHistory;
                originalFunctions.saveLocalDraft = window.saveLocalDraft;
                
                // Remplacer par des fonctions vides
                window.markEdited = function() { return; };
                window.saveStateToHistory = function() { return; };
                window.saveLocalDraft = function() { return; };
            }
            
            editableCells.forEach(cell => {
                if (isViewMode) {
                    cell.contentEditable = 'false';
                    cell.style.backgroundColor = '#f8f9fa';
                    cell.style.cursor = 'default';
                } else {
                    cell.contentEditable = 'true';
                    cell.style.backgroundColor = '';
                    cell.style.cursor = 'text';
                }
            });
            
            // Activer la protection renforcée sur mobile en mode visualisation
            if (isViewMode && isMobile()) {
                isViewModeProtected = true;
            } else {
                isViewModeProtected = false;
            }
            
            // Le bouton d'ajout FAB doit toujours être visible, mais désactivé en mode visualisation
            if (fabAdd) {
                fabAdd.style.display = 'flex';
                fabAdd.style.visibility = 'visible';
                
                if (isViewMode) {
                    // Mode visualisation : bouton visible mais désactivé
                    fabAdd.style.opacity = '0.5';
                    fabAdd.style.pointerEvents = 'none';
                    fabAdd.style.cursor = 'not-allowed';
                    fabAdd.title = 'Mode visualisation actif - Ajout de lignes désactivé';
                } else {
                    // Mode normal : bouton pleinement fonctionnel
                    fabAdd.style.opacity = '1';
                    fabAdd.style.pointerEvents = 'auto';
                    fabAdd.style.cursor = 'pointer';
                    fabAdd.title = 'Ajouter une nouvelle ligne';
                }
            }
            
            // Sauvegarder l'état dans localStorage
            localStorage.setItem('viewMode', isViewMode);
            
            // Réactiver les sauvegardes après un délai adaptatif selon l'appareil
            if (isViewMode && Object.keys(originalFunctions).length > 0) {
                const restoreDelay = isMobile() ? 6000 : 3000;
                setTimeout(() => {
                    if (originalFunctions.markEdited) {
                        window.markEdited = originalFunctions.markEdited;
                    }
                    if (originalFunctions.saveStateToHistory) {
                        window.saveStateToHistory = originalFunctions.saveStateToHistory;
                    }
                    if (originalFunctions.saveLocalDraft) {
                        window.saveLocalDraft = originalFunctions.saveLocalDraft;
                    }
                }, restoreDelay);
            }
        }
        
        // Appliquer le mode visualisation après restauration des données
        function applyViewModeAfterRestore() {
            if (isViewMode) {
                const editableCells = document.querySelectorAll('.editable-cell');
                editableCells.forEach(cell => {
                    cell.contentEditable = 'false';
                    cell.style.backgroundColor = '#f8f9fa';
                    cell.style.cursor = 'default';
                });
            }
        }
        
        // Détecter automatiquement l'état du bouton œil et agir en conséquence
        function detectAndApplyViewMode() {
            const btn = document.getElementById('view-mode-toggle');
            if (!btn) return;
            
            // Restaurer l'état depuis localStorage
            const savedViewMode = localStorage.getItem('viewMode') === 'true';
            if (savedViewMode !== isViewMode) {
                isViewMode = savedViewMode;
            }
            
            // Mettre à jour l'apparence du bouton selon l'état sauvegardé
            updateViewModeButton();
            
            // Appliquer le mode sauvegardé
            applyViewMode();
        }
        
        // Fonction pour forcer le mode visualisation et empêcher les sauvegardes
        function forceViewMode() {
            if (isViewMode) {
                // Désactiver temporairement les sauvegardes automatiques
                const originalMarkEdited = window.markEdited;
                window.markEdited = function() {
                    // Ne rien faire si on est en mode visualisation
                    return;
                };
                
                // Appliquer le mode visualisation
                applyViewMode();
                
                // Réactiver les sauvegardes après un délai adaptatif selon l'appareil
                const restoreDelay = isMobile() ? 4000 : 2000;
                setTimeout(() => {
                    window.markEdited = originalMarkEdited;
                }, restoreDelay);
            }
        }
        


        // Row color utilities
        function clearAllRowColors() {
            try {
                const tbody = document.getElementById('table-body');
                Array.from(tbody.querySelectorAll('tr')).forEach(tr => setRowColor(tr, null));
                rowColorMap = {};
                persistRowColors();
                showMessage('Couleurs des lignes effacées.', 'info');
            } catch(_) {}
        }

        // Focus management
        let isInitialLoad = true; // Flag to prevent automatic capture on initial load
        
        function captureSimplePos() {
            // Skip capture during initial load to prevent overwriting user's intended position
            if (isInitialLoad) {
                log(`🚫 captureSimplePos SKIPPED - initial load in progress`);
                return;
            }
            
            const active = document.activeElement;
            if (!(active && active.tagName === 'TD' && active.isContentEditable)) return;
            
            const rowEl = active.closest('tr');
            const tbody = document.getElementById('table-body');
            const rowIndex = Array.from(tbody.querySelectorAll('tr')).indexOf(rowEl);
            const cellIndex = Array.from(rowEl.cells).indexOf(active);
            
            // DEBUG: Log detailed information about the cell being captured
            if (active && rowEl) {
                const cellLabel = active.getAttribute('data-label') || 'NO_LABEL';
                const cellText = active.textContent.substring(0, 20) + '...';
                const totalCells = rowEl.cells.length;
                const totalRows = tbody.querySelectorAll('tr').length;
                
                log(`🔍 CAPTURE DEBUG: row=${rowIndex}/${totalRows}, cell=${cellIndex}/${totalCells}, label="${cellLabel}", text="${cellText}"`);
            }
            
            if (rowIndex >= 0 && cellIndex >= 0) {
                lastCellPos = { rowIndex, cellIndex };
                
                // UNIFY: Also update lastFocusInfo to use the same position
                const colLabel = active.getAttribute('data-label') || '';
                const rowKey = rowEl ? rowEl.dataset.key || null : null;
                const caret = getCaretOffsetWithin(active);
                
                lastFocusInfo = { rowKey, rowIndex, colLabel, caret };
                log(`🔄 UNIFIED CAPTURE: Updated both lastCellPos and lastFocusInfo with same rowIndex=${rowIndex}`);
            }
            
            if (lastCellPos) { 
                log(`captureSimplePos -> row=${lastCellPos.rowIndex}, cell=${lastCellPos.cellIndex}`); 
            }
            
            try { 
                localStorage.setItem('lastCellPos', JSON.stringify(lastCellPos)); 
                localStorage.setItem('lastFocusInfo', JSON.stringify(lastFocusInfo)); 
            } catch(_) {}
        }

        // Mobile detection and support
        function isMobile() {
            try { 
                return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent); 
            } catch(_) { 
                return false; 
            }
        }

        function getScrollContainer() {
            return document.getElementById('table-container');
        }

        function ensureCellVisible(cell) {
            try {
                if (!cell) return;
                
                const sc = getScrollContainer();
                if (!sc) { 
                    cell.scrollIntoView({block: 'center', inline: 'nearest'}); 
                    return; 
                }
                
                const vv = window.visualViewport;
                const rect = cell.getBoundingClientRect();
                const viewportHeight = vv ? vv.height : window.innerHeight;
                const bottomSafe = viewportHeight - 64;
                
                if (rect.bottom > bottomSafe || rect.top < 0) {
                    const delta = rect.bottom - bottomSafe;
                    sc.scrollTop += Math.max(delta, -20);
                    try { 
                        cell.scrollIntoView({block: 'center', inline: 'nearest'}); 
                    } catch(_) {}
                }
            } catch(_) {}
        }

        function focusCellWithMobileSupport(cell) {
            try {
                try { 
                    cell.scrollIntoView({ block: 'center', inline: 'nearest' }); 
                } catch(_) {}
                
                setTimeout(() => {
                    try {
                        cell.dispatchEvent(new Event('pointerdown', { bubbles: true }));
                        cell.dispatchEvent(new Event('mousedown', { bubbles: true }));
                        cell.dispatchEvent(new Event('mouseup', { bubbles: true }));
                        cell.click();
                        
                        try { 
                            cell.focus({ preventScroll: true }); 
                        } catch(_) { 
                            try { 
                                cell.focus(); 
                            } catch(__) {} 
                        }
                        
                        setCaretAt(cell, null);
                        
                        try {
                            requestAnimationFrame(() => {
                                setCaretAt(cell, null);
                                requestAnimationFrame(() => { 
                                    setCaretAt(cell, null); 
                                });
                            });
                        } catch(_) {}
                        
                        setTimeout(() => { 
                            setCaretAt(cell, null); 
                        }, 250);
                    } catch(_) {
                        try { 
                            cell.focus(); 
                            setCaretAt(cell, null); 
                        } catch(__) {}
                    }
                }, 350);
                
                ensureCellVisible(cell);
                return true;
            } catch(_) { 
                return false; 
            }
        }

        // Caret management
        function getCaretOffsetWithin(el) {
            try {
                const sel = window.getSelection();
                if (!sel || sel.rangeCount === 0) return null;
                
                const range = sel.getRangeAt(0);
                if (!el.contains(range.startContainer)) return null;
                
                const preRange = range.cloneRange();
                preRange.selectNodeContents(el);
                preRange.setEnd(range.startContainer, range.startOffset);
                
                return preRange.toString().length;
            } catch(_) { 
                return null; 
            }
        }

        function setCaretAt(el, offset) {
            try {
                el.focus();
                const selection = window.getSelection();
                selection.removeAllRanges();
                const range = document.createRange();
                
                let remaining = (typeof offset === 'number' && offset >= 0) ? offset : null;
                const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
                let node = walker.nextNode();
                
                if (remaining === null) {
                    let lastNode = null;
                    while (node) { 
                        lastNode = node; 
                        node = walker.nextNode(); 
                    }
                    
                    if (lastNode) {
                        range.setStart(lastNode, lastNode.textContent.length);
                        range.collapse(true);
                        selection.addRange(range);
                    }
                    return;
                }
                
                while (node) {
                    const len = node.textContent.length;
                    if (remaining <= len) {
                        range.setStart(node, remaining);
                        range.collapse(true);
                        selection.addRange(range);
                        return;
                    }
                    remaining -= len;
                    node = walker.nextNode();
                }
                
                const endNode = el.lastChild;
                if (endNode && endNode.nodeType === Node.TEXT_NODE) {
                    range.setStart(endNode, endNode.textContent.length);
                } else {
                    range.selectNodeContents(el);
                    range.collapse(false);
                }
                selection.addRange(range);
            } catch(_) {}
        }

        function captureFocusInfo() {
            // Skip capture during initial load to prevent overwriting user's intended position
            if (isInitialLoad) {
                log(`🚫 captureFocusInfo SKIPPED - initial load in progress`);
                return;
            }
            
            const active = document.activeElement;
            if (!(active && active.tagName === 'TD' && active.isContentEditable)) return;
            
            const row = active.closest('tr');
            const tbody = document.getElementById('table-body');
            const rowIndex = Array.from(tbody.querySelectorAll('tr')).indexOf(row);
            const colLabel = active.getAttribute('data-label') || '';
            const rowKey = row ? row.dataset.key || null : null;
            const caret = getCaretOffsetWithin(active);
            
            lastFocusInfo = { rowKey, rowIndex, colLabel, caret };
            
            try { 
                localStorage.setItem('lastFocusInfo', JSON.stringify(lastFocusInfo)); 
            } catch(_) {}
        }

        function focusCellFromInfo(info) {
            if (!info) return false;
            
            log(`🔍 focusCellFromInfo: Looking for rowKey="${info.rowKey}", rowIndex=${info.rowIndex}, colLabel="${info.colLabel}"`);
            
            const tbody = document.getElementById('table-body');
            let targetRow = null;
            
            if (info.rowKey) {
                targetRow = Array.from(tbody.querySelectorAll('tr')).find(tr => tr.dataset.key === String(info.rowKey));
                log(`🔍 focusCellFromInfo: Found row by key: ${!!targetRow}`);
            }
            
            if (!targetRow) {
                const rows = tbody.querySelectorAll('tr');
                targetRow = rows[info.rowIndex] || null;
                log(`🔍 focusCellFromInfo: Found row by index: ${!!targetRow}`);
            }
            
            if (!targetRow) {
                log(`❌ focusCellFromInfo: No target row found`);
                return false;
            }
            
            const cells = Array.from(targetRow.querySelectorAll('td'));
            log(`🔍 focusCellFromInfo: Row has ${cells.length} cells, looking for label "${info.colLabel}"`);
            
            // Use absolute cell index like focusCellByPos, not sliced cells
            const cell = cells.find(td => (td.getAttribute('data-label') || '') === info.colLabel) || null;
            
            if (!cell) {
                log(`❌ focusCellFromInfo: No cell found with label "${info.colLabel}"`);
                // Debug: show all available labels
                const availableLabels = cells.map((td, i) => `${i}:"${td.getAttribute('data-label') || 'NO_LABEL'}"`).join(', ');
                log(`🔍 Available labels: ${availableLabels}`);
                return false;
            }
            
            log(`✅ focusCellFromInfo: Found cell at index ${cells.indexOf(cell)} with label "${info.colLabel}"`);
            
            if (isMobile()) {
                return focusCellWithMobileSupport(cell);
            }
            
            try { 
                cell.scrollIntoView({ block: 'center', inline: 'nearest' }); 
            } catch(_) {}
            
            let placed = false;
            try { 
                setCaretAt(cell, null); 
                placed = true; 
            } catch(_) {}
            
            if (!placed) { 
                setTimeout(() => { 
                    try { 
                        setCaretAt(cell, null); 
                    } catch(_) {} 
                }, 50); 
            }
            
            try {
                requestAnimationFrame(() => {
                    setCaretAt(cell, null);
                    requestAnimationFrame(() => { 
                        setCaretAt(cell, null); 
                    });
                });
            } catch(_) {}
            
            if (document.activeElement !== cell) { 
                try { 
                    cell.focus(); 
                } catch(_) {} 
            }
            
            return true;
        }

        function focusCellByPos(pos) {
            try {
                if (!pos) return false;
                
                const tbody = document.getElementById('table-body');
                const totalRows = tbody.querySelectorAll('tr').length;
                const row = tbody.querySelectorAll('tr')[pos.rowIndex];
                
                if (!row) {
                    log(`❌ RESTORE DEBUG: Row ${pos.rowIndex} not found (total rows: ${totalRows})`);
                    return false;
                }
                
                const totalCells = row.cells.length;
                const cell = row.cells[pos.cellIndex];
                
                if (!cell) {
                    log(`❌ RESTORE DEBUG: Cell ${pos.cellIndex} not found in row ${pos.rowIndex} (total cells: ${totalCells})`);
                    return false;
                }
                
                // DEBUG: Log detailed information about the cell being restored
                const cellLabel = cell.getAttribute('data-label') || 'NO_LABEL';
                const cellText = cell.textContent.substring(0, 20) + '...';
                
                log(`🔍 RESTORE DEBUG: row=${pos.rowIndex}/${totalRows}, cell=${pos.cellIndex}/${totalCells}, label="${cellLabel}", text="${cellText}"`);
                
                if (isMobile()) {
                    return focusCellWithMobileSupport(cell);
                }
                
                setCaretAt(cell, null);
                
                try {
                    cell.dispatchEvent(new MouseEvent('pointerdown', { bubbles: true }));
                    cell.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
                    cell.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
                    cell.click();
                } catch(_) {}
                
                log(`focusCellByPos -> active=${document.activeElement === cell}`);
                
                try {
                    requestAnimationFrame(() => {
                        setCaretAt(cell, null);
                        requestAnimationFrame(() => { 
                            setCaretAt(cell, null); 
                        });
                    });
                } catch(_) {}
                
                return document.activeElement === cell;
            } catch(_) { 
                return false; 
            }
        }

        // Data collection and management
        function collectTableData() { 
            const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent); 
            const rows = []; 
            
            document.querySelectorAll('#data-table tbody tr').forEach((rowEl, index) => { 
                const rowData = {}; 
                
                // Gestion améliorée de la clé primaire compatible smallint
                if (rowEl.dataset.key && rowEl.dataset.key !== '') { 
                    const keyValue = parseInt(rowEl.dataset.key);
                    // S'assurer que la clé est dans la plage smallint (-32,768 à 32,767)
                    if (keyValue >= -32768 && keyValue <= 32767) {
                        rowData[supabaseConfig.primaryKeyColumn] = keyValue;
                    } else {
                        // Si la clé est hors plage, utiliser l'index + 1
                        rowData[supabaseConfig.primaryKeyColumn] = index + 1;
                    }
                } else {
                    // Si pas de clé, utiliser l'index + 1 comme clé temporaire
                    rowData[supabaseConfig.primaryKeyColumn] = index + 1;
                }
                
                const cells = Array.from(rowEl.querySelectorAll('td')).slice(2); 
                cells.forEach((td, i) => { 
                    const label = headers[i]; 
                    const key = label; 
                    rowData[key] = td.textContent === '' ? null : td.textContent; 
                }); 
                
                rows.push(rowData); 
            }); 
            
            return { headers, rows }; 
        }
        
        function saveStateToHistory() { 
            // Debug: voir exactement quand cette fonction est appelée
            console.log('🚨 saveStateToHistory called!', {
                isViewMode,
                isViewModeProtected,
                isMobile: isMobile(),
                timestamp: new Date().toISOString(),
                stack: new Error().stack
            });
            
            // Protection renforcée : ne rien faire si on est en mode visualisation protégé
            if (isViewModeProtected || (isViewMode && isMobile()) || isPerformingUndoRedo) {
                console.log('🔒 saveStateToHistory BLOCKED by protection');
                return;
            }
            
            if (historyDebounceTimeout) clearTimeout(historyDebounceTimeout); 
            
            historyDebounceTimeout = setTimeout(() => { 
                const s = collectTableData(); 
                const last = history[history.length - 1]; 
                
                if (!last || generateDataHash(s) !== generateDataHash(last)) { 
                    history.push(s); 
                    if (history.length > 10) history.shift(); 
                    // Pushing a new state clears redo stack
                    redoHistory = [];
                    // Also record as an operation if none in progress
                    if (!currentOperation) {
                        const op = {
                            type: OPERATION_TYPES.BULK_EDIT,
                            data: {},
                            timestamp: Date.now(),
                            tableState: s,
                            rowColors: { ...rowColorMap },
                            finalState: s,
                            finalRowColors: { ...rowColorMap }
                        };
                        operationHistory.push(op);
                        if (operationHistory.length > 50) operationHistory.shift();
                    }
                    persistHistoryStacks();
                    updateUndoButtonState(); 
                    log('État de l\'historique enregistré.'); 
                } 
            }, 500); 
        }
        
        function saveLocalDraft() { 
            // Protection renforcée : ne rien faire si on est en mode visualisation protégé
            if (isViewModeProtected || (isViewMode && isMobile())) {
                return;
            }
            
            try { 
                localStorage.setItem('staffTableDraft', document.getElementById('data-table').outerHTML); 
            } catch(e) {} 
        }
        
        function restoreLocalDraft() {
            try {
                const draft = localStorage.getItem('staffTableDraft');
                if (draft) {
                    const el = document.getElementById('data-table');
                    if (el) {
                        // Sauvegarder l'état du mode visualisation avant la restauration
                        const wasViewMode = isViewMode;
                        
                        // NUCLEAR OPTION: Désactiver TOUTES les sauvegardes si on est en mode visualisation
                        let originalFunctions = {};
                        if (wasViewMode) {
                            // Sauvegarder toutes les fonctions originales
                            originalFunctions.markEdited = window.markEdited;
                            originalFunctions.saveStateToHistory = window.saveStateToHistory;
                            originalFunctions.saveLocalDraft = window.saveLocalDraft;
                            
                            // Remplacer par des fonctions vides avec debug
                            window.markEdited = function() { 
                                console.log('🔒 markEdited BLOCKED in view mode'); 
                                return; 
                            };
                            window.saveStateToHistory = function() { 
                                console.log('🔒 saveStateToHistory BLOCKED in view mode'); 
                                return; 
                            };
                            window.saveLocalDraft = function() { 
                                console.log('🔒 saveLocalDraft BLOCKED in view mode'); 
                                return; 
                            };
                            
                            // Activer la protection renforcée
                            isViewModeProtected = true;
                            console.log('🛡️ View mode protection ACTIVATED');
                        }
                        
                        el.outerHTML = draft;
                        log('Brouillon local restauré.');
                        
                        // Restaurer le mode visualisation immédiatement après la restauration
                        if (wasViewMode) {
                            isViewMode = true;
                            
                            // Délai adaptatif selon l'appareil (plus long sur mobile)
                            const delay = isMobile() ? 300 : 150;
                            const restoreDelay = isMobile() ? 10000 : 6000;
                            
                            console.log(`⏱️ Applying view mode in ${delay}ms, restoring functions in ${restoreDelay}ms`);
                            
                            // Appliquer le mode visualisation aux nouvelles cellules
                            setTimeout(() => {
                                console.log('🎯 Applying view mode to cells...');
                                const editableCells = document.querySelectorAll('.editable-cell');
                                editableCells.forEach(cell => {
                                    cell.contentEditable = 'false';
                                    cell.style.backgroundColor = '#f8f9fa';
                                    cell.style.cursor = 'default';
                                });
                                
                                // Mettre à jour l'apparence du bouton
                                updateViewModeButton();
                                
                                // Le bouton d'ajout FAB doit toujours être visible, mais désactivé en mode visualisation
                                const fabAdd = document.getElementById('fab-add');
                                if (fabAdd) {
                                    fabAdd.style.display = 'flex';
                                    fabAdd.style.visibility = 'visible';
                                    
                                    if (isViewMode) {
                                        // Mode visualisation : bouton visible mais désactivé
                                        fabAdd.style.opacity = '0.5';
                                        fabAdd.style.pointerEvents = 'none';
                                        fabAdd.style.cursor = 'not-allowed';
                                        fabAdd.title = 'Mode visualisation actif - Ajout de lignes désactivé';
                                    } else {
                                        // Mode normal : bouton pleinement fonctionnel
                                        fabAdd.style.opacity = '1';
                                        fabAdd.style.pointerEvents = 'auto';
                                        fabAdd.style.cursor = 'pointer';
                                        fabAdd.title = 'Ajouter une nouvelle ligne';
                                    }
                                }
                                
                                console.log('✅ View mode applied, functions will be restored in', restoreDelay, 'ms');
                                
                                // Réactiver les sauvegardes après un délai adaptatif
                                setTimeout(() => {
                                    console.log('🔄 Restoring original functions...');
                                    if (originalFunctions.markEdited) {
                                        window.markEdited = originalFunctions.markEdited;
                                    }
                                    if (originalFunctions.saveStateToHistory) {
                                        window.saveStateToHistory = originalFunctions.saveStateToHistory;
                                    }
                                    if (originalFunctions.saveLocalDraft) {
                                        window.saveLocalDraft = originalFunctions.saveLocalDraft;
                                    }
                                    
                                    // Désactiver la protection renforcée
                                    isViewModeProtected = false;
                                    console.log('🛡️ View mode protection DEACTIVATED');
                                }, restoreDelay);
                            }, delay);
                        }
                        
                        rebindRowNumberCells();
                        
                        try {
                            const tbody = document.getElementById('table-body');
                            Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                                const k = keyForRow(tr);
                                const col = rowColorMap[k];
                                if (col) setRowColor(tr, col);
                            });
                        } catch(_) {}
                    }
                }
            } catch(e) {}
        }
        
        function markEdited() {
            isDirty = true; 
            isTyping = true; 
            lastEditAt = Date.now();
            
            if (typingTimer) clearTimeout(typingTimer);
            scheduleAutosaveCountdown();
            typingTimer = setTimeout(() => { isTyping = false; }, 1200);
        }

        // Autosave functionality
        function scheduleAutosaveCountdown() {
            try { 
                if (autosaveTicker) clearInterval(autosaveTicker); 
            } catch(_) {}
            
            lastShownCountdown = null;
            autosaveTicker = setInterval(() => {
                try {
                    if (isSyncing) return;
                    
                    const modal = document.getElementById('confirmation-modal');
                    if (modal && !modal.classList.contains('hidden')) return;
                    
                    if (isTyping) { 
                        lastShownCountdown = null; 
                        return; 
                    }
                    
                    const remaining = AUTOSAVE_DELAY_MS - (Date.now() - lastEditAt);
                    if (remaining > 0) {
                        const secs = Math.ceil(remaining / 1000);
                        if (secs !== lastShownCountdown) {
                            showMessage(`Sauvegarde dans ${secs} s`, 'info');
                            lastShownCountdown = secs;
                        }
                    } else {
                        if (lastShownCountdown !== 0) {
                            showMessage('Sauvegarde imminente…', 'info');
                            lastShownCountdown = 0;
                        }
                    }
                } catch(_) {}
            }, 250);
        }
        
        function startPeriodicSync() {
            if (window._syncTimer) clearInterval(window._syncTimer);
            
            window._syncTimer = setInterval(async () => {
                if (isTyping) return;
                if (Date.now() - lastEditAt < AUTOSAVE_DELAY_MS) return;
                
                const modal = document.getElementById('confirmation-modal');
                if (modal && !modal.classList.contains('hidden')) return;
                if (isSyncing) return;
                if (!isDirty) return;
                
                // BLOCK autosave during undo/redo operations
                if (isPerformingUndoRedo) {
                    log('🚫 Autosave BLOCKED - undo/redo in progress');
                    return;
                }
                
                try {
                    // During autosave suppression window, skip autosave
                    if (Date.now() < suppressAutosaveUntil) {
                        log('🚫 Autosave suppressed due to undo/redo sync window');
                        return;
                    }
                    isSyncing = true;
                    log('Auto-sync (500ms poll, 3s idle) vers Supabase…');
                    await syncToMaster(false);
                } finally {
                    isSyncing = false;
                }
            }, 500);
        }

        // ===== Helpers & constants (DRY) =====
        const BOLD_HEADERS = ['nom_prénom','pec finale','diagnostic_initial'];
        function getHeaders(){
          return Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th=>th.textContent);
        }
        
        // Fonction pour mettre à jour l'affichage du nombre de lignes
        function updateRowCount() {
            const tbody = document.getElementById('table-body');
            const rowCountNumber = document.getElementById('row-count-number');
            
            if (tbody && rowCountNumber) {
                const rowCount = tbody.children.length;
                rowCountNumber.textContent = rowCount;
                console.log(`📊 Row count updated: ${rowCount} rows`);
            }
        }
        function createDeleteCell(row){
          const deleteCell=document.createElement('td');
          deleteCell.className='p-0 text-center';
          deleteCell.setAttribute('data-label','Effacer');
          const sel=document.createElement('input');
          sel.type='checkbox';
          sel.className='m-1 align-middle';
          sel.addEventListener('change',()=>{ row.classList.toggle('selected-row', sel.checked); });
          const deleteButton=document.createElement('button');
          deleteButton.className='text-red-500 hover:text-red-700 font-bold p-2 transition-colors';
          deleteButton.innerHTML='🗑️';
          deleteButton.onclick=(e)=>{
            e.stopPropagation();
            const selected = Array.from(document.querySelectorAll('#table-body tr.selected-row'));
            if (selected.length > 0) {
              // Multiple rows selected: confirm before deleting
              promptKeyConfirm(`Supprimer ${selected.length} ligne(s) ?`, () => deleteRows(selected));
            } else {
              // Single row via trash icon: delete immediately without confirmation
              deleteRows([row]);
            }
          };
          const wrap=document.createElement('div');
          wrap.className='flex items-center justify-center gap-1';
          wrap.appendChild(sel); wrap.appendChild(deleteButton);
          deleteCell.appendChild(wrap);
          return deleteCell;
        }
        function createEditableCell(header, value=''){
          const cell=document.createElement('td');
          const dbKey=header; // names are identical (no mapping)
          cell.textContent=value||'';
          cell.contentEditable=true;
          cell.className='py-2 px-2 md:px-4 editable-cell';
          cell.setAttribute('data-label',header);
          cell.setAttribute('data-dbkey',dbKey);
          
          // Force inline red color for Information complementaire to override any cascade
          if (header === 'Information complementaire' || header === 'information complementaire') {
            cell.style.color = '#dc2626';
          }
          
          // Remove any previous inline font size for numero_tel to keep 1.1rem via CSS
          if (header === 'Numero_tel' || header === 'numero_tel') {
            cell.style.fontSize = '';
          }
          
          // Sélection automatique du contenu lors du double-clic/double-tap
          cell.addEventListener('dblclick', (e) => {
            e.preventDefault();
            // Sélectionner tout le contenu de la cellule
            const range = document.createRange();
            range.selectNodeContents(cell);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
          });
          
          // Gestion du double-tap sur mobile
          let lastTap = 0;
          cell.addEventListener('touchstart', (e) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            if (tapLength < 500 && tapLength > 0) {
              // Double-tap détecté
              e.preventDefault();
              // Sélectionner tout le contenu de la cellule
              const range = document.createRange();
              range.selectNodeContents(cell);
              const selection = window.getSelection();
              selection.removeAllRanges();
              selection.addRange(range);
            }
            lastTap = currentTime;
          });
          
          // Stocker la valeur initiale pour détecter les vraies modifications
          let initialValue = value || '';
          let hasBeenModified = false;
          
          // --- Nom_Prénom auto-formatting logic ---
          if (isNomPrenomLabel(header)) {
            // Ensure initial display is formatted when creating the cell
            if (value) {
              value = formatNomPrenom(value);
              cell.textContent = value;
              initialValue = value;
            }
            
            // Format when the user leaves the cell (seulement si modifié)
            cell.addEventListener('blur', () => {
              const currentValue = cell.textContent;
              const formattedValue = formatNomPrenom(currentValue);
              cell.textContent = formattedValue;
              
              // Sauvegarder seulement si la valeur a vraiment changé
              if (hasBeenModified || formattedValue !== initialValue) {
                saveStateToHistory();
                saveLocalDraft();
                markEdited();
                // Mettre à jour la valeur initiale pour les prochaines comparaisons
                initialValue = formattedValue;
                hasBeenModified = false;
              }
            });
            
            // Gérer le collage (seulement si le contenu change)
            cell.addEventListener('paste', () => {
              setTimeout(() => {
                const pastedValue = cell.textContent;
                const formattedValue = formatNomPrenom(pastedValue);
                cell.textContent = formattedValue;
                
                // Sauvegarder seulement si le contenu collé est différent
                if (formattedValue !== initialValue) {
                  saveStateToHistory();
                  saveLocalDraft();
                  markEdited();
                  initialValue = formattedValue;
                  hasBeenModified = false;
                }
              }, 0);
            });
          } else {
            // Pour les autres colonnes, gérer blur et paste de manière similaire
            cell.addEventListener('blur', () => {
              const currentValue = cell.textContent;
              // Sauvegarder seulement si la valeur a vraiment changé
              if (hasBeenModified || currentValue !== initialValue) {
                saveStateToHistory();
                saveLocalDraft();
                markEdited();
                initialValue = currentValue;
                hasBeenModified = false;
              }
            });
            
            cell.addEventListener('paste', () => {
              setTimeout(() => {
                const pastedValue = cell.textContent;
                // Sauvegarder seulement si le contenu collé est différent
                if (pastedValue !== initialValue) {
                  saveStateToHistory();
                  saveLocalDraft();
                  markEdited();
                  initialValue = pastedValue;
                  hasBeenModified = false;
                }
              }, 0);
            });
          }
          
          if(BOLD_HEADERS.includes(header.toLowerCase())){
            cell.style.fontWeight='bold';
            cell.style.color='#000';
          }
          cell.setAttribute('tabindex','0');
          
          // Sauvegarder seulement lors de vraies modifications (input)
          cell.oninput=()=>{
            hasBeenModified = true;
            
            // Reset undo/redo sync timeout when user starts editing
            clearUndoRedoSyncTimeout();
            
            // Start or continue operation tracking for cell edits
            if (!currentOperation || currentOperation.type !== OPERATION_TYPES.CELL_EDIT) {
                startOperation(OPERATION_TYPES.CELL_EDIT, {
                    cellLabel: header,
                    initialValue: initialValue,
                    rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                    columnLabel: header,
                    editCount: 1,
                    edits: [{
                        columnLabel: header,
                        rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                        initialValue: initialValue,
                        currentValue: cell.textContent
                    }]
                });
            } else {
                // Increment edit count and add to edits array
                currentOperation.data.editCount = (currentOperation.data.editCount || 1) + 1;
                currentOperation.data.edits.push({
                    columnLabel: header,
                    rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                    initialValue: initialValue,
                    currentValue: cell.textContent
                });
                
                addToOperation({
                    cellLabel: header,
                    currentValue: cell.textContent,
                    rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                    columnLabel: header
                });
            }
            
            // Debounce operation completion for cell edits
            if (operationTimeout) clearTimeout(operationTimeout);
            operationTimeout = setTimeout(() => {
                completeOperation();
            }, 1000); // 1 second delay for cell edits
            
            saveStateToHistory();
            saveLocalDraft();
            markEdited();
            // keep caret/position updated while typing
            captureFocusInfo();
            captureSimplePos();
          };
          
          cell.addEventListener('keyup', (e) => {
            // update caret after navigation keys
            if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Home','End','PageUp','PageDown'].includes(e.key)) {
              captureFocusInfo();
              captureSimplePos();
            }
          });
          return cell;
        }

        // Ensure DDN column exists visually even if an older HTML version is served (Live Server/mobile cache)
        function ensureDDNHeader(){
          try {
            const theadRow = document.querySelector('#data-table thead tr');
            if (!theadRow) return;
            const labels = Array.from(theadRow.children).map(th=>th.textContent.trim());
            if (labels.includes('DDN')) return; // already there

            // Create the DDN header cell
            const th = document.createElement('th');
            th.setAttribute('scope','col');
            th.className = 'py-2 px-2 md:px-4';
            th.textContent = 'DDN';

            // Insert right after Nom_Prénom if present, else before Diagnostic_initial, else at the end
            let insertIndex = labels.indexOf('Nom_Prénom');
            if (insertIndex !== -1) {
              theadRow.insertBefore(th, theadRow.children[insertIndex + 1]);
            } else {
              const diagIdx = labels.indexOf('Diagnostic_initial');
              if (diagIdx !== -1) theadRow.insertBefore(th, theadRow.children[diagIdx]);
              else theadRow.appendChild(th);
            }

            // For each body row, insert a new editable DDN cell at the same index
            const headersNow = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th=>th.textContent);
            const ddnPos = headersNow.indexOf('DDN');
            if (ddnPos !== -1) {
              document.querySelectorAll('#table-body tr').forEach(tr => {
                const cell = createEditableCell('DDN', '');
                // Insert after the first two fixed cells (No, Effacer) + ddnPos offset
                const insertAt = 2 + ddnPos;
                const ref = tr.cells[insertAt];
                if (ref) tr.insertBefore(cell, ref); else tr.appendChild(cell);
              });
            }

            // Adjust tfoot colspan to match new column count
            const tfootLast = document.querySelector('#data-table tfoot td:last-child');
            const totalCols = document.querySelectorAll('#data-table thead th').length;
            if (tfootLast) {
              // first two tds in tfoot row are No/Effacer holders; last td should span the remainder
              const span = Math.max(0, totalCols - 2);
              tfootLast.setAttribute('colspan', String(span));
            }
          } catch(e) { /* noop */ }
        }

        // Keep tfoot colspan in sync with the current number of columns
        function updateTfootColspan() {
            try {
                const totalCols = document.querySelectorAll('#data-table thead th').length;
                const tfootRow = document.querySelector('#data-table tfoot tr');
                if (!tfootRow) return;
                // First cell spans the first two utility columns (No, Effacer)
                const firstTd = tfootRow.querySelector('td:first-child');
                if (firstTd) firstTd.setAttribute('colspan', '2');
                // Last cell spans the remainder
                const lastTd = tfootRow.querySelector('td:last-child');
                if (lastTd) lastTd.setAttribute('colspan', String(Math.max(0, totalCols - 2)));
            } catch(_) {}
        }
        // Align table headers with server column keys (case-insensitive)
        function reconcileHeadersWithServer() {
          try {
            if (!appState.serverColumns || appState.serverColumns.length === 0) return;
            const server = appState.serverColumns;
            const theadTh = Array.from(document.querySelectorAll('#data-table thead th')).slice(2);
            theadTh.forEach((th) => {
              const label = th.textContent;
              if (server.includes(label)) return; // exact match OK
              const found = server.find(k => k.toLowerCase() === label.toLowerCase());
              if (found) {
                th.textContent = found; // normalize header to the exact server key
              }
            });
          } catch (e) { /* no-op */ }
        }
        // === Excel import helpers ===
        function normalizeKey(k){
          if(!k) return '';
          return String(k).trim().toLowerCase().replace(/[_\-\s]+/g,' ').replace(/\s+/g,' ').normalize('NFD').replace(/[\u0300-\u036f]/g,'');
        }
        // === Name formatting helpers ===
        function _titleCasePart(s) {
          if (!s) return '';
          return s.split(' ').map(word => {
            if (word.length <= 2) return word.toLowerCase();
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
          }).join(' ');
        }
        
        function formatNomPrenom(raw){
          if(raw==null) return '';
          let s = String(raw).trim().replace(/\s+/g, ' ');
          if(!s) return '';
          // If there's a comma, interpret as "LAST, First ..."
          if(s.includes(',')){
            const [last, rest] = s.split(',');
            const nom = last.trim().toUpperCase();
            const prenom = _titleCasePart((rest||'').trim());
            return prenom ? `${nom}\n${prenom}` : nom;
          }
          // Default: first token is last name; remainder is first name(s)
          const parts = s.split(' ');
          const nom = (parts.shift()||'').toUpperCase();
          const prenom = _titleCasePart(parts.join(' ').trim());
          return prenom ? `${nom}\n${prenom}` : nom;
        }
        
        function isNomPrenomLabel(label){
          try {
            const n = normalizeKey(label);
            return n === 'nom prenom' || n.includes('nom prenom');
          } catch(_) {
            return label === 'Nom_Prénom';
          }
        }
        function buildHeaderMap(sheetKeys, tableHeaders){
          const map = {};
          const nSheet = sheetKeys.map(k=>({raw:k, norm:normalizeKey(k)}));
          const nTable = tableHeaders.map(k=>({raw:k, norm:normalizeKey(k)}));

          // Raw alias definitions (human-friendly)
          const aliasesRaw = {
            'date de saisie': ['date', 'date saisie', 'date d\'entree', 'date entree', 'datesaisie', 'date d\'enregistrement'],
            'pec finale': ['pec finale', 'pec finale (definitive)', 'prise en charge finale', 'prise en charge def'],
            'pec initiale': ['pec initiale', 'prise en charge initiale', 'prise en charge init'],
            'nom_prenom': ['nom prenom', 'nom_prénom', 'nom et prenom', 'nom et prénom', 'patient', 'nom complet', 'fullname', 'name'],
            'ddn': ['date de naissance', 'date naissance', 'naissance', 'dob', 'date of birth', 'birth date', 'dn'],
            'diagnostic_initial': ['diagnostic initial', 'diagnostic', 'diag initial', 'diagnostic de depart'],
            'information complementaire': ['infos', 'information complementaire', 'commentaire', 'notes', 'remarques', 'obs', 'observations'],
            'numero_tel': ['tel', 'telephone', 'numero tel', 'numero telephone', 'phone', 'portable', 'gsm', 'mobile']
          };
          // Normalize alias values once for consistent matching
          const aliases = Object.fromEntries(
            Object.entries(aliasesRaw).map(([k, arr]) => [normalizeKey(k), arr.map(v => normalizeKey(v))])
          );

          nTable.forEach(t => {
            // 1) exact normalized match
            let match = nSheet.find(s => s.norm === t.norm);

            // 2) alias match (normalized)
            if(!match){
              const listNorm = aliases[t.norm] || [];
              match = nSheet.find(s => listNorm.includes(s.norm));
            }

            // 3) fuzzy for DDN — accept any column that contains naiss/birth/dob tokens
            if(!match && t.norm === 'ddn'){
              match = nSheet.find(s => /\b(naiss|birth|dob|date naissance|date de naissance)\b/.test(s.norm))
                    || nSheet.find(s => s.norm.includes('naiss') || s.norm.includes('birth') || s.norm.includes('dob'));
            }

            if(match) map[t.raw] = match.raw; // map table header -> sheet column
          });
          return map;
        }
        function coerceCellValue(header, val){
          if(val==null) return '';
          const h = normalizeKey(header);

          // Excel serial number handling for date-like headers
          if((h.includes('date') || h==='ddn') && typeof val === 'number'){
            try {
              const epoch = new Date(Date.UTC(1899,11,30));
              const d = new Date(epoch.getTime() + val*86400000);
              const dd = String(d.getUTCDate()).padStart(2,'0');
              const mm = String(d.getUTCMonth()+1).padStart(2,'0');
              const yy = String(d.getUTCFullYear()).slice(-2);
              return `${dd}/${mm}/${yy}`;
            } catch(_) { /* fallthrough */ }
          }

          // Parse common textual date forms
          if((h.includes('date') || h==='ddn') && typeof val === 'string'){
            const s = val.trim();
            // Normalize separators
            const norm = s.replace(/[.\-]/g,'/').replace(/\s+/g,'');

            // YYYY/MM/DD or YYYY/M/D
            let m = norm.match(/^(\d{4})\/(\d{1,2})\/(\d{1,2})$/);
            if(m){
              const y = parseInt(m[1],10), mo = parseInt(m[2],10), d = parseInt(m[3],10);
              if(mo>=1 && mo<=12 && d>=1 && d<=31){
                return `${String(d).padStart(2,'0')}/${String(mo).padStart(2,'0')}/${String(y).slice(-2)}`;
              }
            }

            // DD/MM/YYYY or D/M/YY etc.
            m = norm.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
            if(m){
              const d = parseInt(m[1],10), mo = parseInt(m[2],10), y = parseInt(m[3],10);
              if(mo>=1 && mo<=12 && d>=1 && d<=31){
                return `${String(d).padStart(2,'0')}/${String(mo).padStart(2,'0')}/${String(y).toString().slice(-2)}`;
              }
            }

            // Fallback: try Date.parse cautiously
            const t = Date.parse(s);
            if(!isNaN(t)){
              const d = new Date(t);
              const dd = String(d.getUTCDate()).padStart(2,'0');
              const mm = String(d.getUTCMonth()+1).padStart(2,'0');
              const yy = String(d.getUTCFullYear()).slice(-2);
              return `${dd}/${mm}/${yy}`;
            }
          }

          return String(val);
        }
        async function importExcelFromFile(file){
          try{
            if(!file){ showMessage('Aucun fichier sélectionné','info'); return; }
            const ext = (file.name.split('.').pop()||'').toLowerCase();
            if(!['xlsx','xls','csv'].includes(ext)){
              showMessage('Format non pris en charge. Utilisez .xlsx, .xls ou .csv','info');
              return;
            }
            updateStatus('Import en cours...','saving');
            const data = await file.arrayBuffer();
            const wb = XLSX.read(data, { type:'array' });
            const sheetName = wb.SheetNames[0];
            const ws = wb.Sheets[sheetName];
            const rows = XLSX.utils.sheet_to_json(ws, { defval:'', raw:false });
            if(!Array.isArray(rows) || rows.length===0){ showMessage('Feuille vide','info'); updateStatus('Synchronisé','success'); return; }

            // Colonnes système à ignorer lors de l'import
            const systemColumns = ['No', 'Effacer', 'Date de saisie'];
            
            // Colonnes de données à importer (excluant les colonnes système)
            const dataColumns = getHeaders().filter(header => !systemColumns.includes(header));
            
            // Filtrer les lignes : seulement celles avec Nom_Prénom rempli
            const validRows = rows.filter(row => {
              const nomPrenom = row['Nom_Prénom'] || row['Nom_Prénom'] || row['Nom Prénom'] || row['NomPrénom'];
              return nomPrenom && nomPrenom.trim() !== '';
            });

            if(validRows.length === 0){
              showMessage('Aucune ligne avec Nom_Prénom rempli trouvée dans le fichier','info');
              updateStatus('Import terminé','success');
              return;
            }

            console.log(`📊 Import Excel : ${rows.length} lignes totales, ${validRows.length} lignes valides`);

            // Construire les données d'import avec gestion intelligente
            const importData = validRows.map((row, index) => {
              const obj = {};
              
              // Générer automatiquement une clé primaire unique compatible smallint
              // Utiliser un index simple pour éviter les dépassements de type
              obj[supabaseConfig.primaryKeyColumn] = index + 1;
              
              // Ajouter automatiquement la date de saisie
              obj['Date de saisie'] = getFormattedDate();
              
              // Importer seulement les colonnes de données (pas les colonnes système)
              dataColumns.forEach(column => {
                const sheetKey = findBestMatch(column, Object.keys(row));
                if (sheetKey && row[sheetKey] !== undefined && row[sheetKey] !== '') {
                  obj[column] = coerceCellValue(column, row[sheetKey]);
                } else {
                  obj[column] = '';
                }
              });
              
              return obj;
            });

            // Charger dans le tableau
            if(loadTableData(importData)){
              saveStateToHistory();
              saveLocalDraft();
              markEdited();
              updateStatus('Importé (non sauvegardé)','success');
              showMessage(`Import réussi: ${importData.length} ligne(s) avec Nom_Prénom. Colonnes système générées automatiquement.`);
            } else {
              updateStatus('Erreur import','error');
              showMessage('Échec du chargement des données importées.','info');
            }
          } catch(err){
            console.error(err);
            updateStatus('Erreur import','error');
            showMessage('Erreur lors de l\'import. Vérifiez le fichier.','info');
          }
        }

        // Fonction pour trouver la meilleure correspondance de colonne
        function findBestMatch(targetColumn, availableColumns) {
          // Correspondance exacte
          if (availableColumns.includes(targetColumn)) {
            return targetColumn;
          }
          
          // Correspondance sans espaces ni caractères spéciaux
          const normalizedTarget = targetColumn.replace(/[\s\-_]/g, '').toLowerCase();
          for (const col of availableColumns) {
            const normalizedCol = col.replace(/[\s\-_]/g, '').toLowerCase();
            if (normalizedCol === normalizedTarget) {
              return col;
            }
          }
          
          // Correspondance partielle
          for (const col of availableColumns) {
            const normalizedCol = col.replace(/[\s\-_]/g, '').toLowerCase();
            if (normalizedCol.includes(normalizedTarget) || normalizedTarget.includes(normalizedCol)) {
              return col;
            }
          }
          
          return null;
        }

        function loadTableData(data) {
            if (!data) { 
                log('Structure invalide', 'error'); 
                return false; 
            }
            
            const tbody = document.getElementById('table-body');
            tbody.innerHTML = '';
            const headers = getHeaders();
            
            data.forEach((rowData, index) => {
                const row = document.createElement('tr');
                row.className = 'bg-white hover:bg-gray-100 transition-colors cursor-pointer';
                
                if (rowData[supabaseConfig.primaryKeyColumn]) {
                    row.dataset.key = rowData[supabaseConfig.primaryKeyColumn];
                }

                // Create row number cell
                const numCell = document.createElement('td');
                numCell.textContent = index + 1;
                numCell.className = 'py-2 px-2 md:px-4 font-bold text-gray-800 whitespace-nowrap cursor-pointer frozen-column frozen-1';
                numCell.setAttribute('data-label', 'No');
                numCell.title = 'Cliquer pour colorer/effacer la ligne';
                
                // Add event listeners for row painting
                            numCell.addEventListener('mousedown', (e) => { 
                if (e.button !== 0) return; 
                startRowPaint(row); 
                e.preventDefault(); 
            });
            
            numCell.addEventListener('mouseenter', () => { 
                if (isRowPaintDragging) applyRowPaint(row); 
            });
            
            numCell.addEventListener('click', (e) => { 
                e.preventDefault();
                // En mode auto, on colorie/décolore directement au clic
                if (paintMode === 'auto') {
                    rowPaintAction = getPaintActionForRow(row);
                    applyRowPaint(row);
                } else if (!isRowPaintDragging) {
                    // En mode manuel, on utilise l'action sélectionnée
                    rowPaintAction = getPaintActionForRow(row);
                    applyRowPaint(row);
                }
            });
                
                numCell.addEventListener('touchstart', (e) => { 
                    startRowPaint(row); 
                    e.preventDefault(); 
                }, { passive: false });
                
                numCell.addEventListener('touchmove', (e) => { 
                    const t = e.touches && e.touches[0]; 
                    if (!t) return; 
                    const el = document.elementFromPoint(t.clientX, t.clientY); 
                    const tr = el ? el.closest('#table-body tr') : null; 
                    if (tr) applyRowPaint(tr); 
                    e.preventDefault(); 
                }, { passive: false });
                
                row.appendChild(numCell);

                // Add delete/selection cell
                row.appendChild(createDeleteCell(row));

                // Add data cells
                headers.forEach(header => {
                    let value = rowData[header] || '';
                    if (isNomPrenomLabel(header)) {
                        value = formatNomPrenom(value);
                    }
                    row.appendChild(createEditableCell(header, value));
                });

                tbody.appendChild(row);
            });
            
            // Re-apply stored row colors after rebuilding the tbody
            try {
                Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                    const k = keyForRow(tr);
                    const col = rowColorMap[k];
                    if (col) setRowColor(tr, col);
                });
            } catch(_) {}
            
            log('Données du tableau chargées.', 'success');
            appState.localData = collectTableData();
            appState.dataHash = generateDataHash(appState.localData);
            document.dispatchEvent(new CustomEvent('table:reloaded'));
            updateTfootColspan();
            log('table:reloaded dispatched');
            
            // Mettre à jour l'affichage du nombre de lignes
            updateRowCount();
            
            return true;
        }

        async function addRow() {
            // Empêcher l'ajout en mode visualisation
            if (isViewMode) {
                showMessage('Impossible d\'ajouter des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                return;
            }
            
            // Start operation tracking for row addition
            startOperation(OPERATION_TYPES.ROW_ADD, {
                newRowKey: Date.now() + Math.random()
            });
            
            const tbody = document.getElementById('table-body');
            const row = document.createElement('tr');
            row.className = 'bg-white hover:bg-gray-100 transition-colors cursor-pointer';
            
            // Générer une clé primaire unique compatible smallint
            const existingKeys = Array.from(tbody.querySelectorAll('tr'))
                .map(tr => parseInt(tr.dataset.key) || 0)
                .filter(key => key > 0);
            
            let newKey = 1;
            if (existingKeys.length > 0) {
                newKey = Math.max(...existingKeys) + 1;
            }
            
            // S'assurer que la clé est dans la plage smallint
            if (newKey > 32767) {
                newKey = 1; // Recommencer à 1 si on dépasse la limite
            }
            
            row.dataset.key = newKey.toString();

            // Create row number cell
            const numCell = document.createElement('td');
            numCell.textContent = tbody.children.length + 1;
            numCell.className = 'py-2 px-2 md:px-4 font-bold text-gray-800 whitespace-nowrap cursor-pointer frozen-column frozen-1';
            numCell.setAttribute('data-label', 'No');
            numCell.title = 'Cliquer pour colorer/effacer la ligne';
            
                            numCell.addEventListener('mousedown', (e) => { 
                    if (e.button !== 0) return; 
                    startRowPaint(row); 
                    e.preventDefault(); 
                });
                
                numCell.addEventListener('mouseenter', () => { 
                    if (isRowPaintDragging) applyRowPaint(row); 
                });
                
                numCell.addEventListener('click', (e) => { 
                    e.preventDefault();
                    // En mode auto, on colorie/décolore directement au clic
                    if (paintMode === 'auto') {
                        rowPaintAction = getPaintActionForRow(row);
                        applyRowPaint(row);
                    } else if (!isRowPaintDragging) {
                        // En mode manuel, on utilise l'action sélectionnée
                        rowPaintAction = getPaintActionForRow(row);
                        applyRowPaint(row);
                    }
                });
            
            numCell.addEventListener('touchstart', (e) => { 
                startRowPaint(row); 
                e.preventDefault(); 
            }, { passive: false });
            
            numCell.addEventListener('touchmove', (e) => { 
                const t = e.touches && e.touches[0]; 
                if (!t) return; 
                const el = document.elementFromPoint(t.clientX, t.clientY); 
                const tr = el ? el.closest('#table-body tr') : null; 
                if (tr) applyRowPaint(tr); 
                e.preventDefault(); 
            }, { passive: false });
            
            row.appendChild(numCell);

            // Add delete/selection cell
            row.appendChild(createDeleteCell(row));

            // Add date cell (pre-filled)
            const dateCell = createEditableCell('Date de saisie', getFormattedDate());
            row.appendChild(dateCell);

            // Add remaining headers
            const headers = getHeaders().slice(1);
            headers.forEach(header => { 
                row.appendChild(createEditableCell(header, '')); 
            });

            tbody.appendChild(row);
            
            try { 
                const k = keyForRow(row); 
                const col = rowColorMap[k]; 
                if (col) setRowColor(row, col); 
            } catch(_) {}
            
            // Complete the operation
            completeOperation();
            
            markEdited();
            
            // Mettre à jour l'affichage du nombre de lignes
            updateRowCount();
        }

        async function deleteRows(rows) { 
            if (!rows || rows.length === 0) return;
            
            // Empêcher la suppression dans les snapshots ET en mode visualisation
            if (snapshotMode === 'snapshot') {
                showMessage('Impossible de supprimer des lignes dans un snapshot. Retournez aux données en direct pour modifier le tableau.', 'warning');
                return;
            }
            
            // Empêcher la suppression en mode visualisation
            if (isViewMode) {
                showMessage('Impossible de supprimer des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                return;
            }
            
            // Safety check: ensure we're not in the middle of an undo operation
            if (currentOperation && currentOperation.type.includes('undo')) {
                console.log('⚠️ Delete operation blocked: undo in progress');
                return;
            }
            
            // Start operation tracking for deletion
            const operationType = rows.length === 1 ? OPERATION_TYPES.ROW_DELETE : OPERATION_TYPES.MULTIPLE_ROWS_DELETE;
            startOperation(operationType, {
                deletedRows: rows.length,
                rowKeys: rows.map(r => r.dataset.key).filter(Boolean),
                rowData: rows.map(r => {
                    const rowData = {};
                    const cells = Array.from(r.querySelectorAll('td')).slice(2); // Skip No and Delete columns
                    const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                    cells.forEach((cell, i) => {
                        if (headers[i]) {
                            rowData[headers[i]] = cell.textContent;
                        }
                    });
                    return rowData;
                })
            });
            
            const keys = rows.map(r => r.dataset.key).filter(Boolean); 
            
            try { 
                if (keys.length > 0) { 
                    const { error } = await supabase
                        .from(supabaseConfig.tableName)
                        .delete()
                        .in(supabaseConfig.primaryKeyColumn, keys); 
                    
                    if (error) throw error; 
                    log(`Supprimé ${keys.length} ligne(s) côté serveur.`, 'success'); 
                } 
                
                // Store row numbers before deletion for better undo tracking
                const rowNumbers = rows.map(r => {
                    const noCell = r.querySelector('td:first-child');
                    return noCell ? parseInt(noCell.textContent) : null;
                }).filter(n => !isNaN(n));
                
                addToOperation({ rowNumbers });
                
                // Remove rows from DOM
                rows.forEach(r => r.remove()); 
                
                // Renumber rows
                document.querySelectorAll('#table-body tr').forEach((tr, idx) => { 
                    const noCell = tr.querySelector('td:first-child'); 
                    if (noCell) noCell.textContent = idx + 1; 
                    tr.classList.remove('selected-row'); 
                });
                
                // Rebuild color map after deletions and renumbering
                rowColorMap = {};
                Array.from(document.querySelectorAll('#table-body tr')).forEach(tr => {
                    const k = keyForRow(tr);
                    const c = tr.style.backgroundColor;
                    if (c && c !== '') rowColorMap[k] = c;
                });
                
                persistRowColors();
                
                // Complete the operation
                completeOperation();
                
                saveLocalDraft(); 
                markEdited(); 
                updateStatus('Ligne(s) supprimée(s)', 'success'); 
                
                // Mettre à jour l'affichage du nombre de lignes
                updateRowCount();
                
                // Immediately sync with prune to avoid server reintroducing deleted rows
                await syncToMaster(true, true);
            } catch(err) { 
                // Cancel operation on error
                cancelOperation();
                log('Erreur lors de la suppression: ' + err.message, 'error'); 
                updateStatus('Erreur de suppression', 'error'); 
            } 
        }

        // Data synchronization
        async function fetchInitialData() { 
            log('Chargement des données (full fetch)...'); 
            updateStatus('Connexion...'); 
            
            try { 
                // Restore undo/redo stacks for this session
                restoreHistoryStacks();
                const { data, error } = await supabase
                    .from(supabaseConfig.tableName)
                    .select('*')
                    .order(supabaseConfig.primaryKeyColumn, { ascending: true }); 
                
                if (error) throw error; 
                
                if (Array.isArray(data) && data.length > 0) { 
                    appState.serverColumns = Object.keys(data[0]); 
                }
                
                reconcileHeadersWithServer();
                ensureDDNHeader();
                
                if (loadTableData(data)) { 
                    updateStatus('Synchronisé', 'success'); 
                    saveStateToHistory(); 
                }
            } catch(e) { 
                log('Erreur lors du chargement des données : ' + e.message, 'error'); 
                updateStatus('Erreur de connexion', 'error'); 
            }
        }

        async function syncToMaster(isManualSave = false, pruneMissing = false) {
            try { 
                if (autosaveTicker) clearInterval(autosaveTicker); 
            } catch(_) {}
            
            lastShownCountdown = null;
            
            const modal = document.getElementById('confirmation-modal');
            if (modal && !modal.classList.contains('hidden')) { 
                log('Sync ignorée: modale ouverte.'); 
                return; 
            }
            
            // Remember which cell and caret position were active before saving
            captureFocusInfo();
            captureSimplePos();
            
            if (isManualSave && saveTimeout) { 
                clearTimeout(saveTimeout); 
            }
            
            const current = collectTableData();
            const currentHash = generateDataHash(current);
            
            let rowsForSync = current.rows.map(row => { 
                if (!appState.serverColumns) return row; 
                
                const allowed = new Set([supabaseConfig.primaryKeyColumn, ...appState.serverColumns]); 
                const filtered = {}; 
                
                for (const k in row) { 
                    if (allowed.has(k)) filtered[k] = row[k]; 
                } 
                
                return filtered; 
            });
            
            if (!isManualSave && currentHash === appState.dataHash) { 
                log('Pas de changement détecté.'); 
                isDirty = false; 
                updateStatus('Synchronisé', 'success'); 
                return; 
            }
            
            log('Synchronisation des données vers Supabase...');
            updateStatus('Sauvegarde en cours...', 'saving');
            isDirty = false;
            
            try {
                // Utiliser upsert pour toutes les opérations pour éviter les conflits de clé primaire
                if (rowsForSync.length > 0) {
                    const { error: upsertError } = await supabase
                        .from(supabaseConfig.tableName)
                        .upsert(rowsForSync, { 
                            onConflict: supabaseConfig.primaryKeyColumn,
                            ignoreDuplicates: false
                        });
                    if (upsertError) {
                        console.error('❌ Erreur upsert:', upsertError);
                        throw upsertError;
                    }
                }

                // Optionally prune server rows that are missing locally (for undo/redo or explicit deletions)
                if (pruneMissing) {
                    try {
                        const { data: serverKeysRows, error: fetchKeysErr } = await supabase
                            .from(supabaseConfig.tableName)
                            .select(supabaseConfig.primaryKeyColumn);
                        if (fetchKeysErr) throw fetchKeysErr;
                        const localKeys = new Set(current.rows.map(r => r[supabaseConfig.primaryKeyColumn]).filter(k => k != null));
                        const serverKeys = (serverKeysRows || []).map(r => r[supabaseConfig.primaryKeyColumn]).filter(k => k != null);
                        const keysToDelete = serverKeys.filter(k => !localKeys.has(k));
                        if (keysToDelete.length > 0) {
                            const { error: delErr } = await supabase
                                .from(supabaseConfig.tableName)
                                .delete()
                                .in(supabaseConfig.primaryKeyColumn, keysToDelete);
                            if (delErr) throw delErr;
                            log(`🧹 Serveur nettoyé: ${keysToDelete.length} ligne(s) supprimée(s) absentes localement.`);
                        }
                    } catch (pruneErr) {
                        console.error('❌ Erreur lors du prune des lignes manquantes:', pruneErr);
                    }
                }
                
                updateStatus('Sauvegardé', 'success');
                
                // Enregistrer le timestamp de sauvegarde pour éviter les conflits temps réel
                lastSaveTime = Date.now();
                log(`✅ Sauvegarde réussie à ${new Date(lastSaveTime).toLocaleTimeString()} - Cooldown temps réel activé pour ${REALTIME_COOLDOWN_MS}ms`);
                
                log(`syncToMaster -> Focus restoration (lastCellPos=${JSON.stringify(lastCellPos)}, lastFocusInfo.col=${lastFocusInfo ? lastFocusInfo.colLabel : ''})`);
                
                // Restaurer le focus directement sans recharger les données
                // car les données sont déjà synchronisées avec Supabase
                setTimeout(() => {
                    log('🔍 Restauration directe du focus sans rechargement...');
                    
                    // Try simple row/cell index first
                    const posResult = focusCellByPos(lastCellPos);
                    log(`🔍 focusCellByPos result: ${posResult}`);
                    
                    if (!posResult) {
                        // Fallback to the richer label+caret based restore
                        const infoResult = focusCellFromInfo(lastFocusInfo);
                        log(`🔍 focusCellFromInfo result: ${infoResult}`);
                        
                        if (!infoResult) {
                            log('🔍 Both focus methods failed, trying delayed retry...');
                            setTimeout(() => { 
                                if (!focusCellByPos(lastCellPos) && !focusCellFromInfo(lastFocusInfo)) { 
                                    log('🔍 Delayed retry also failed, trying final attempt...');
                                    setTimeout(() => { 
                                        const finalPos = focusCellByPos(lastCellPos);
                                        const finalInfo = focusCellFromInfo(lastFocusInfo);
                                        log(`🔍 Final attempt - pos: ${finalPos}, info: ${finalInfo}`);
                                    }, 250); 
                                } 
                            }, 50);
                        }
                    }
                }, 100);
            } catch(e) {
                log('Erreur de sauvegarde : ' + e.message, 'error');
                updateStatus('Erreur de sauvegarde', 'error');
            }
        }

        async function pullFromMaster() { 
            log('Récupération des dernières données...'); 
            await fetchInitialData(); 
        }
        
        function handleRealtimeUpdate() {
            log('Mise à jour en temps réel reçue.');
            
            // BLOCK realtime updates during undo/redo operations
            if (isPerformingUndoRedo) {
                log('🚫 Realtime update BLOCKED - undo/redo in progress');
                return;
            }
            
            // Supprimer les événements temps réel durant la fenêtre de suppression
            if (Date.now() < suppressRealtimeUntil) {
                log('🚫 Realtime update suppressed due to undo/redo sync window');
                return;
            }

            // Vérifier le cooldown pour éviter les conflits avec nos propres sauvegardes
            const timeSinceLastSave = Date.now() - lastSaveTime;
            if (timeSinceLastSave < REALTIME_COOLDOWN_MS) {
                log(`⏰ Cooldown actif (${REALTIME_COOLDOWN_MS - timeSinceLastSave}ms restant) - Ignore l'événement temps réel`);
                return;
            }
            
            if (isDirty) { 
                log('Modifs locales en attente, on ignore.'); 
                return; 
            }
            
            log('🔄 Synchronisation temps réel - Capture du focus et rechargement...');
            
            // Try to preserve focus across realtime-driven reload as well
            captureFocusInfo();
            captureSimplePos();
            
            const onReload = () => {
                log('🔄 REALTIME -> table:reloaded caught; attempting focus restore');
                document.removeEventListener('table:reloaded', onReload);
                
                // Use the same consolidated restoration logic
                setTimeout(() => {
                    log(`🔄 REALTIME: Performing cursor restoration`);
                    
                    // Try focusCellFromInfo first (more reliable)
                    let restorationSuccess = false;
                    if (lastFocusInfo && lastFocusInfo.rowIndex >= 0 && lastFocusInfo.colLabel) {
                        restorationSuccess = focusCellFromInfo(lastFocusInfo);
                        log(`🔄 REALTIME: focusCellFromInfo result: ${restorationSuccess}`);
                    }
                    
                    // Fallback to focusCellByPos if focusCellFromInfo fails
                    if (!restorationSuccess && lastCellPos && lastCellPos.rowIndex >= 0 && lastCellPos.cellIndex >= 0) {
                    log(`🔄 REALTIME: Trying focusCellByPos with ${JSON.stringify(lastCellPos)}`);
                        restorationSuccess = focusCellByPos(lastCellPos);
                        log(`🔄 REALTIME: focusCellByPos result: ${restorationSuccess}`);
                    }
                    
                    if (restorationSuccess) {
                        log(`✅ REALTIME: Cursor restoration successful`);
                    } else {
                        log(`⚠️ REALTIME: Cursor restoration failed`);
                    }
                }, 100);
            };
            
            document.addEventListener('table:reloaded', onReload, { once: true });
            fetchInitialData();
        }

        // Realtime subscription setup
        function setupRealtimeSubscription() { 
            if (realtimeSubscription) { 
                try { 
                    supabase.removeChannel(realtimeSubscription);
                } catch(e) {} 
            } 
            
            realtimeSubscription = supabase.channel('table-changes')
                .on('postgres_changes', { event: 'INSERT', schema: 'public', table: supabaseConfig.tableName }, handleRealtimeUpdate)
                .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: supabaseConfig.tableName }, handleRealtimeUpdate)
                .on('postgres_changes', { event: 'DELETE', schema: 'public', table: supabaseConfig.tableName }, handleRealtimeUpdate)
                .subscribe(status => log('Realtime status: ' + status)); 
        }



        // Password authentication
        function checkPassword() { 
            const pwd = document.getElementById('password').value; 
            const err = document.getElementById('error-message'); 
            const passwordInput = document.getElementById('password');
            const togglePassword = document.getElementById('toggle-password');
            
            if (pwd === APP_CONFIG.password) { 
                appState.isLoggedIn = true; 
                sessionStorage.setItem('isLoggedIn', '1'); 
                
                // Masquer le login et afficher le tableau immédiatement
                document.getElementById('login-container').classList.add('hidden'); 
                document.getElementById('table-container').classList.remove('hidden'); 
                
                // S'assurer que le tableau est visible
                const tableContainer = document.getElementById('table-container');
                const table = document.getElementById('data-table');
                
                if (tableContainer) {
                    tableContainer.style.display = 'block';
                    tableContainer.style.visibility = 'visible';
                }
                
                if (table) {
                    table.style.display = 'table';
                    table.style.visibility = 'visible';
                }
                
                // Initialiser complètement l'application après la connexion
                initializeApp();
                
            } else { 
                err.textContent = 'Mot de passe incorrect. Le champ est maintenant visible pour faciliter la correction.';
                
                // Transformer automatiquement le champ en texte visible pour faciliter la correction
                passwordInput.type = 'text';
                togglePassword.checked = true;
                
                // Remettre le focus dans le champ pour permettre la correction immédiate
                passwordInput.focus();
                
                // Sélectionner tout le texte pour faciliter la correction
                passwordInput.select();
                
                // Ajouter une classe CSS pour indiquer visuellement l'erreur
                passwordInput.classList.add('password-error');
                
                // Retirer la classe d'erreur quand l'utilisateur commence à taper
                passwordInput.addEventListener('input', function clearErrorStyle() {
                    passwordInput.classList.remove('password-error');
                    passwordInput.removeEventListener('input', clearErrorStyle);
                }, { once: true });
            } 
        }

        // Export functionality
        function downloadExcel() { 
            const table = document.getElementById('data-table'); 
            const ws = XLSX.utils.table_to_sheet(table); 
            const wb = XLSX.utils.book_new(); 
            XLSX.utils.book_append_sheet(wb, ws, 'Staff Data'); 
            XLSX.writeFile(wb, 'Tableau_Staff.xlsx'); 
            showMessage('Excel téléchargé.'); 
        }
        
        function downloadPDF() { 
            const { jsPDF } = window.jspdf; 
            const doc = new jsPDF('l', 'pt', 'a4'); 
            doc.autoTable({ html: '#data-table' }); 
            doc.save('Tableau_Staff.pdf'); 
            showMessage('PDF téléchargé.'); 
        }
        
        function downloadImage() { 
            const table = document.getElementById('data-table'); 
            html2canvas(table).then(canvas => { 
                const link = document.createElement('a'); 
                link.href = canvas.toDataURL('image/png'); 
                link.download = 'Tableau_Staff.png'; 
                link.click(); 
                showMessage('Image téléchargée.'); 
            }); 
        }

        // Manual save function
        function saveManually() { 
            syncToMaster(true); 
        }

        // Row color binding
        function rebindRowNumberCells() {
            try {
                const rows = document.querySelectorAll('#table-body tr');
                rows.forEach((row) => {
                    const numCell = row.cells && row.cells[0];
                    if (!numCell) return;
                    
                    // Ensure proper classes/title
                    if (!numCell.className.includes('cursor-pointer')) {
                        numCell.className += ' cursor-pointer';
                    }
                    if (!numCell.getAttribute('title')) {
                        numCell.title = 'Cliquer pour colorer/effacer la ligne';
                    }
                    
                    // Replace the cell to drop old listeners
                    const newCell = numCell.cloneNode(true);
                    
                    // Drag start (mouse)
                    newCell.addEventListener('mousedown', (e) => { 
                        if (e.button !== 0) return; 
                        startRowPaint(row); 
                        e.preventDefault(); 
                    });
                    
                    // Drag over other rows (mouse)
                    newCell.addEventListener('mouseenter', () => { 
                        if (isRowPaintDragging) applyRowPaint(row); 
                    });
                    
                    // Simple toggle on click when not dragging
                    newCell.addEventListener('click', (e) => { 
                        e.preventDefault();
                        if (isRowPaintDragging) return;
                        rowPaintAction = getPaintActionForRow(row);
                        applyRowPaint(row);
                    });
                    
                    // Touch support
                    newCell.addEventListener('touchstart', (e) => { 
                        startRowPaint(row); 
                        e.preventDefault(); 
                    }, { passive: false });
                    
                    newCell.addEventListener('touchmove', (e) => {
                        const t = e.touches && e.touches[0]; 
                        if (!t) return; 
                        const el = document.elementFromPoint(t.clientX, t.clientY);
                        const tr = el ? el.closest('#table-body tr') : null; 
                        if (tr) applyRowPaint(tr); 
                        e.preventDefault();
                    }, { passive: false });
                    
                    row.replaceChild(newCell, numCell);
                });
            } catch(_) {}
        }

        // First use hint
        function maybeShowFirstUseHint() {
            try {
                if (localStorage.getItem('rowPaintHintShown') === '1') return;
                showMessage('Astuce: cliquez puis faites glisser sur les numéros de ligne pour colorer/effacer.', 'info');
                localStorage.setItem('rowPaintHintShown', '1');
            } catch(_) {}
        }

        // Event listeners setup
        function setupEventListeners() {
            // Before unload warning
            window.addEventListener('beforeunload', function (e) { 
                if (isDirty) { 
                    e.preventDefault(); 
                    e.returnValue = 'Des modifications non sauvegardées seront perdues si vous quittez.'; 
                } 
            });

            // Password toggle
            document.getElementById('toggle-password').addEventListener('change', function() { 
                const el = document.getElementById('password'); 
                el.type = this.checked ? 'text' : 'password'; 
            });
            
            // Password enter key
            document.getElementById('password').addEventListener('keydown', function (e) { 
                // Stop any global keyboard shortcuts from interfering
                e.stopPropagation();
                
                if (e.key === 'Enter') { 
                    e.preventDefault(); 
                    checkPassword(); 
                } 
                
                return true;
            });
            
            // Additional password field protection
            document.getElementById('password').addEventListener('input', function (e) {
                e.stopPropagation();
                return true;
            });
            
            document.getElementById('password').addEventListener('keypress', function (e) {
                e.stopPropagation();
                return true;
            });
            
            document.getElementById('password').addEventListener('keyup', function (e) {
                e.stopPropagation();
                return true;
            });

            // Table body paste handling
            document.getElementById('table-body').addEventListener('paste', function(e) {
                const active = document.activeElement;
                if (!(active && active.tagName === 'TD' && active.isContentEditable === 'true')) return;
                
                const text = (e.clipboardData || window.clipboardData).getData('text');
                if (!text || (text.indexOf('\t') === -1 && text.indexOf('\n') === -1)) return;
                
                e.preventDefault();
                const rows = text.split(/\r?\n/).filter(r => r.length > 0).map(r => r.split('\t'));
                const startCell = active;
                const startRow = startCell.closest('tr');
                const startIndex = Array.from(startRow.cells).indexOf(startCell);
                let r = startRow;
                
                rows.forEach((cols, ridx) => {
                    if (ridx > 0) {
                        r = r.nextElementSibling;
                        if (!r) {
                            const tbody = document.getElementById('table-body');
                            r = document.createElement('tr');
                            r.className = 'bg-white hover:bg-gray-100 transition-colors cursor-pointer';
                            
                            // Create row number cell
                            const n = document.createElement('td');
                            n.textContent = tbody.children.length + 1;
                            n.className = 'py-2 px-2 md:px-4 font-bold text-gray-800 whitespace-nowrap cursor-pointer';
                            n.setAttribute('data-label', 'No');
                            n.title = 'Cliquer pour colorer/effacer la ligne';
                            
                            n.addEventListener('mousedown', (e) => { 
                                if (e.button !== 0) return; 
                                startRowPaint(r); 
                                e.preventDefault(); 
                            });
                            
                            n.addEventListener('mouseenter', () => { 
                                if (isRowPaintDragging) applyRowPaint(r); 
                            });
                            
                            n.addEventListener('click', (e) => { 
                                e.preventDefault();
                                if (isRowPaintDragging) return;
                                rowPaintAction = getPaintActionForRow(r);
                                applyRowPaint(r);
                            });
                            
                            n.addEventListener('touchstart', (e) => { 
                                startRowPaint(r); 
                                e.preventDefault(); 
                            }, { passive: false });
                            
                            n.addEventListener('touchmove', (e) => { 
                                const t = e.touches && e.touches[0]; 
                                if (!t) return; 
                                const el = document.elementFromPoint(t.clientX, t.clientY);
                                const tr = el ? el.closest('#table-body tr') : null; 
                                if (tr) applyRowPaint(tr); 
                                e.preventDefault();
                            }, { passive: false });
                            
                            r.appendChild(n);
                            
                            // Add delete/selection cell
                            r.appendChild(createDeleteCell(r));
                            
                            // Add data cells using current headers
                            const heads = getHeaders();
                            heads.forEach(h => { 
                                r.appendChild(createEditableCell(h, '')); 
                            });
                            
                            tbody.appendChild(r);
                        }
                    }
                    
                    cols.forEach((val, cidx) => {
                        const cell = r.cells[startIndex + cidx];
                        if (cell && cell.contentEditable === 'true') { 
                            cell.textContent = val; 
                        }
                    });
                    
                    // Normalize Nom_Prénom in the affected row after paste
                    try {
                        const nameCell = r.querySelector('td[data-label="Nom_Prénom"]');
                        if (nameCell) { 
                            nameCell.textContent = formatNomPrenom(nameCell.textContent); 
                        }
                    } catch(_) {}
                });
                
                saveStateToHistory(); 
                saveLocalDraft(); 
                markEdited();
            });

            // Double-click date input
            document.getElementById('table-body').addEventListener('dblclick', function(e) {
                const cell = e.target.closest('td');
                if (!cell) return;
                
                const label = (cell.getAttribute('data-label') || '').toLowerCase();
                if (label.includes('date de saisie') || label.includes('ddn')) {
                    if (!dateInputOverlay) {
                        dateInputOverlay = document.createElement('input');
                        dateInputOverlay.type = 'date';
                        dateInputOverlay.className = 'border rounded px-2 py-1';
                        dateInputOverlay.style.position = 'fixed';
                        dateInputOverlay.style.zIndex = '1000';
                        document.body.appendChild(dateInputOverlay);
                        
                        dateInputOverlay.addEventListener('change', () => {
                            const v = dateInputOverlay.value;
                            if (v) {
                                const [y, m, d] = v.split('-');
                                cell.textContent = `${d}/${m}/${y.slice(-2)}`;
                                saveStateToHistory();
                                saveLocalDraft();
                                markEdited();
                            }
                            dateInputOverlay.style.display = 'none';
                        });
                        
                        dateInputOverlay.addEventListener('blur', () => {
                            dateInputOverlay.style.display = 'none';
                        });
                    }
                    
                    const rect = cell.getBoundingClientRect();
                    dateInputOverlay.style.left = `${rect.left + window.scrollX}px`;
                    dateInputOverlay.style.top = `${rect.top + window.scrollY}px`;
                    dateInputOverlay.style.display = 'block';
                    dateInputOverlay.focus();
                }
            });

            // Select all checkbox
            document.addEventListener('change', function(e) { 
                if (e.target && e.target.id === 'select-all') { 
                    const checked = e.target.checked; 
                    document.querySelectorAll('#table-body tr').forEach(tr => { 
                        const cb = tr.querySelector('td:nth-child(2) input[type="checkbox"]'); 
                        if (cb) { 
                            cb.checked = checked; 
                            tr.classList.toggle('selected-row', checked); 
                        } 
                    }); 
                } 
            });

            // Focus management
            document.addEventListener('focusin', (e) => {
                if (e.target && e.target.tagName === 'TD' && e.target.contentEditable === 'true') {
                    captureSimplePos();
                }
            });

            // Mobile focus support
            document.addEventListener('focusin', (e) => {
                if (!isMobile()) return;
                const cell = (e.target && e.target.tagName === 'TD' && e.target.isContentEditable) ? e.target : null;
                if (cell) {
                    setTimeout(() => ensureCellVisible(cell), 100);
                }
            });

            // Table reloaded event
            try {
                document.addEventListener('table:reloaded', () => { 
                    if (showOnlyColored) applyColoredFilter(); 
                });
            } catch(_) {}

            // Global end-drag listeners
            try { 
                document.addEventListener('mouseup', endRowPaint, true); 
            } catch(_) {}
            
            try { 
                document.addEventListener('touchend', endRowPaint, true); 
            } catch(_) {}
        }

        // Keyboard navigation
        function setupKeyboardNavigation() {
            document.addEventListener('keydown', function(e) {
                const active = document.activeElement;
                if (active && active.tagName === 'TD' && active.contentEditable === 'true') {
                    const modal = document.getElementById('confirmation-modal');
                    if (modal && !modal.classList.contains('hidden')) return;
                    
                    const row = active.parentElement;
                    const idx = Array.from(row.cells).indexOf(active);
                    let next = null;
                    
                    if (e.key === 'ArrowRight' || (e.key === 'Tab' && !e.shiftKey)) {
                        next = row.cells[idx + 1] || (row.nextElementSibling && row.nextElementSibling.cells[2]);
                    } else if (e.key === 'ArrowLeft' || (e.key === 'Tab' && e.shiftKey)) {
                        next = row.cells[idx - 1];
                        if ((!next || idx === 2) && row.previousElementSibling) {
                            next = row.previousElementSibling.cells[row.previousElementSibling.cells.length - 1];
                        }
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        const nx = row.nextElementSibling;
                        if (nx) {
                            next = nx.cells[idx];
                        } else {
                            // Empêcher l'ajout en mode visualisation
                            if (isViewMode) {
                                showMessage('Impossible d\'ajouter des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                                return;
                            }
                            addRow();
                            setTimeout(() => {
                                const nr = document.querySelector('#table-body tr:last-child');
                                if (nr && nr.cells.length > idx) nr.cells[idx].focus();
                            }, 0);
                        }
                    } else if (e.key === 'ArrowDown') {
                        const nx = row.nextElementSibling;
                        if (nx) {
                            next = nx.cells[idx];
                        } else {
                            // Empêcher l'ajout en mode visualisation
                            if (isViewMode) {
                                showMessage('Impossible d\'ajouter des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                                return;
                            }
                            addRow();
                            setTimeout(() => {
                                const nr = document.querySelector('#table-body tr:last-child');
                                if (nr && nr.cells.length > idx) nr.cells[idx].focus();
                            }, 0);
                        }
                    } else if (e.key === 'ArrowUp') {
                        const pv = row.previousElementSibling;
                        if (pv) {
                            next = pv.cells[idx];
                        }
                    }
                    
                    if (next) {
                        e.preventDefault();
                        next.focus();
                        if (isMobile()) ensureCellVisible(next);
                    }
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                const active = document.activeElement;
                const inCell = active && active.tagName === 'TD' && active.contentEditable === 'true';
                
                // Check if we're in a form field (input, textarea, select, or contentEditable)
                const inFormField = active && (
                    active.tagName === 'INPUT' || 
                    active.tagName === 'TEXTAREA' || 
                    active.tagName === 'SELECT' || 
                    active.contentEditable === 'true'
                );
                
                // Shortcut: cycle paint mode with P (only when NOT in form fields)
                if (!e.ctrlKey && !e.metaKey && !e.altKey && (e.key === 'p' || e.key === 'P') && !inFormField) {
                    e.preventDefault();
                    cyclePaintMode();
                    return;
                }
                
                // Ctrl+D: Duplicate row
                if ((e.ctrlKey || e.metaKey) && (e.key === 'd' || e.key === 'D') && inCell) {
                    e.preventDefault();
                    
                    // Empêcher la duplication en mode visualisation
                    if (isViewMode) {
                        showMessage('Impossible de dupliquer des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                        return;
                    }
                    
                    const row = active.closest('tr');
                    if (row) {
                        const clone = row.cloneNode(true);
                        delete clone.dataset.key;
                        
                        // Clear any background color on the clone
                        clone.style.backgroundColor = '';
                        
                        // Fix the No cell text and rebind click handler
                        if (clone.cells[0]) {
                            clone.cells[0].textContent = document.querySelectorAll('#table-body tr').length + 1;
                        }
                        
                        // Rebind the line-number toggle and input handlers
                        const numCell = clone.cells[0];
                        if (numCell) {
                            const newNum = numCell.cloneNode(true);
                            if (!newNum.className.includes('cursor-pointer')) {
                                newNum.className += ' cursor-pointer';
                            }
                            newNum.title = 'Cliquer pour colorer/effacer la ligne';
                            newNum.addEventListener('click', () => toggleRowColor(clone));
                            clone.replaceChild(newNum, numCell);
                        }
                        
                        Array.from(clone.cells).forEach((c, i) => {
                            if (i <= 1) return;
                            c.addEventListener('input', () => { 
                                saveStateToHistory(); 
                                saveLocalDraft(); 
                                markEdited(); 
                            });
                        });
                        
                        row.after(clone);
                        
                        // Update color map persistently
                        persistRowColors();
                        saveStateToHistory(); 
                        saveLocalDraft(); 
                        markEdited();
                    }
                }
                
                // Ctrl+Backspace/Delete: Delete row(s)
                if ((e.ctrlKey || e.metaKey) && (e.key === 'Backspace' || e.key === 'Delete') && inCell) {
                    e.preventDefault();
                    const selected = Array.from(document.querySelectorAll('#table-body tr.selected-row'));
                    if (selected.length > 0) {
                        promptKeyConfirm(`Appuyez sur Entrée pour supprimer ${selected.length} ligne(s), Échap pour annuler.`, () => deleteRows(selected));
                    } else {
                        const row = active.closest('tr');
                        if (row) {
                            promptKeyConfirm('Appuyez sur Entrée pour supprimer cette ligne, Échap pour annuler.', () => deleteRows([row]));
                        }
                    }
                }
            });
        }

        // Confirmation prompt
        function promptKeyConfirm(message, onConfirm) {
            // Show ephemeral banner
            showMessage(message, 'info');

            // Create (or reuse) a hidden input to trigger the mobile keyboard
            let keyCapture = document.getElementById('key-capture');
            if (!keyCapture) {
                keyCapture = document.createElement('input');
                keyCapture.type = 'text';
                keyCapture.id = 'key-capture';
                keyCapture.autocapitalize = 'off';
                keyCapture.autocomplete = 'off';
                keyCapture.spellcheck = false;
                keyCapture.style.position = 'fixed';
                keyCapture.style.opacity = '0';
                keyCapture.style.width = '1px';
                keyCapture.style.height = '1px';
                keyCapture.style.left = '-10000px';
                keyCapture.style.top = '0';
                keyCapture.style.pointerEvents = 'none';
                document.body.appendChild(keyCapture);
            }
            
            // Focus to bring up the soft keyboard on mobile
            keyCapture.value = '';
            keyCapture.focus({ preventScroll: true });
            try { 
                keyCapture.setSelectionRange(0, 0); 
            } catch(_) {}
            
            // Some mobile browsers need a second tick to reliably open the keyboard
            setTimeout(() => { 
                if (document.activeElement !== keyCapture) {
                    keyCapture.focus({ preventScroll: true }); 
                }
            }, 0);

            function handleKey(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    cleanup();
                    onConfirm();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cleanup();
                    showMessage('Suppression annulée.', 'info');
                }
            }

            function cleanup() {
                document.removeEventListener('keydown', handleKey, true);
                // Blur and hide the hidden input after finishing
                const cap = document.getElementById('key-capture');
                if (cap) { 
                    try { 
                        cap.blur(); 
                    } catch(_) {} 
                }
            }

            document.addEventListener('keydown', handleKey, true);
        }

        // ===== SNAPSHOT SYSTEM FUNCTIONS =====
        
        // Create a demo snapshot with unique date logic
        async function createDemoSnapshot(useCurrentData = false) {
            try {
                console.log('➕ Creating demo snapshot...');
                
                // Check current state
                const { data: existing, error: checkError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (checkError) {
                    console.error('❌ Error checking existing snapshots:', checkError);
                    return;
                }
                
                console.log(`📊 Existing snapshots: ${existing?.length || 0}`);
                
                // Generate a truly unique date
                let dateString;
                let attempts = 0;
                const maxAttempts = 50; // Increased to handle more date variations
                
                do {
                    attempts++;
                    if (attempts === 1) {
                        // First attempt: today's date
                        const today = new Date();
                        dateString = today.toISOString().split('T')[0];
                    } else if (attempts <= 10) {
                        // Next 10 attempts: dates with small offset (yesterday, day before, etc.)
                        const offsetDate = new Date();
                        offsetDate.setDate(offsetDate.getDate() - attempts + 1);
                        dateString = offsetDate.toISOString().split('T')[0];
                    } else if (attempts <= 20) {
                        // Next 10 attempts: dates with larger offset (1 week ago, 2 weeks ago, etc.)
                        const offsetDate = new Date();
                        offsetDate.setDate(offsetDate.getDate() - (attempts * 7));
                        dateString = offsetDate.toISOString().split('T')[0];
                    } else if (attempts <= 30) {
                        // Next 10 attempts: dates with month offset
                        const offsetDate = new Date();
                        offsetDate.setMonth(offsetDate.getMonth() - (attempts - 20));
                        dateString = offsetDate.toISOString().split('T')[0];
                    } else {
                        // Final attempts: use random dates from previous years
                        const randomYear = 2020 + Math.floor(Math.random() * 5); // 2020-2024
                        const randomMonth = 1 + Math.floor(Math.random() * 12);
                        const randomDay = 1 + Math.floor(Math.random() * 28);
                        dateString = `${randomYear}-${String(randomMonth).padStart(2, '0')}-${String(randomDay).padStart(2, '0')}`;
                    }
                    
                    console.log(`📅 Attempt ${attempts}: date ${dateString}`);
                    
                    // Check if this date already exists
                    const { data: existingDate, error: dateCheckError } = await supabase
                        .from('table_snapshots_index')
                        .select('snapshot_date')
                        .eq('snapshot_date', dateString)
                        .limit(1);
                    
                    if (dateCheckError) {
                        console.error('❌ Error checking date:', dateCheckError);
                        break;
                    }
                    
                    if (!existingDate || existingDate.length === 0) {
                        console.log(`✅ Unique date found: ${dateString}`);
                        break;
                    }
                    
                    console.log(`⚠️ Date ${dateString} already exists, trying next...`);
                    
                } while (attempts < maxAttempts);
                
                if (attempts >= maxAttempts) {
                    console.error('❌ Unable to find unique date after 50 attempts');
                    console.log('🔄 Suggesting database cleanup...');
                    
                    // Show message to user
                    if (typeof showMessage === 'function') {
                        showMessage('Impossible de trouver une date unique. Utilisez le bouton "Nettoyer" pour vider la base.', 'warning');
                    }
                    
                    return;
                }
                
                // Create the JSON content for the snapshot
                let snapshotData;
                let actualRowCount = 3;
                
                if (useCurrentData && window.tableData && window.tableData.length > 0) {
                    // Use current table data
                    actualRowCount = window.tableData.length;
                    snapshotData = {
                        snapshot_metadata: {
                            created_at: new Date().toISOString(),
                            row_count: actualRowCount,
                            version: "1.0",
                            description: "Snapshot des données actuelles du tableau"
                        },
                        data: window.tableData
                    };
                    console.log(`📊 Using current table data: ${actualRowCount} rows`);
                } else {
                    // Use demo data
                    snapshotData = {
                        snapshot_metadata: {
                            created_at: new Date().toISOString(),
                            row_count: 3,
                            version: "1.0",
                            description: "Demo snapshot for testing"
                        },
                        data: [
                            {
                                id: 1,
                                nom: "Dupont",
                                prenom: "Jean",
                                status: "En service",
                                specialite: "Cardiologie",
                                date_embauche: "2020-03-15",
                                salaire: 4500,
                                notes: "Excellent médecin, très apprécié des patients"
                            },
                            {
                                id: 2,
                                nom: "Martin",
                                prenom: "Marie",
                                status: "En service",
                                specialite: "Pédiatrie",
                                date_embauche: "2019-07-22",
                                salaire: 4200,
                                notes: "Spécialiste en maladies infantiles"
                            },
                            {
                                id: 3,
                                nom: "Bernard",
                                prenom: "Pierre",
                                status: "Congé",
                                specialite: "Chirurgie",
                                date_embauche: "2018-11-10",
                                salaire: 5200,
                                notes: "Chirurgien expérimenté"
                            }
                        ]
                    };
                    console.log(`📊 Using demo data: 3 rows`);
                }

                let fileName = `staff_table_${dateString}_10-00-00.json`;
                const jsonBlob = new Blob([JSON.stringify(snapshotData, null, 2)], { type: 'application/json' });

                // Check if file already exists in storage before uploading
                console.log(`🔍 Checking if file exists in storage: ${fileName}`);
                const { data: existingFiles, error: listError } = await supabaseStorage.storage
                    .from('table-snapshots')
                    .list('', { limit: 100 });
                
                if (listError) {
                    console.warn('⚠️ Could not list storage files:', listError);
                } else {
                    const fileExists = existingFiles?.some(file => file.name === fileName);
                    if (fileExists) {
                        console.warn(`⚠️ File already exists in storage: ${fileName}`);
                        console.log('🔄 Trying to remove existing file first...');
                        
                        // Try to remove the existing file
                        const { error: removeError } = await supabaseStorage.storage
                            .from('table-snapshots')
                            .remove([fileName]);
                        
                        if (removeError) {
                            console.error('❌ Error removing existing file:', removeError);
                            // If we can't remove it, try with a different filename
                            const timestamp = Date.now();
                            const newFileName = `staff_table_${dateString}_${timestamp}.json`;
                            console.log(`🔄 Using alternative filename: ${newFileName}`);
                            fileName = newFileName;
                        } else {
                            console.log('✅ Existing file removed successfully');
                        }
                    }
                }

                // Upload the JSON file to storage using service role key
                console.log(`📤 Uploading file: ${fileName}`);
                const { data: uploadData, error: uploadError } = await supabaseStorage.storage
                    .from('table-snapshots')
                    .upload(fileName, jsonBlob);

                if (uploadError) {
                    console.error('❌ Error uploading file to storage:', uploadError);
                    throw new Error(`Failed to upload file: ${uploadError.message}`);
                }

                console.log('✅ File uploaded successfully:', uploadData);

                // Now create the database record
                const { error } = await supabase
                    .from('table_snapshots_index')
                    .insert({
                        snapshot_date: dateString,
                        object_path: fileName,
                        row_count: actualRowCount,
                        file_size_bytes: jsonBlob.size,
                        metadata: JSON.stringify({
                            table: 'staffTable',
                            version: '1.0.0',
                            description: 'Demo snapshot for testing'
                        })
                    });
                
                if (error) {
                    console.error('❌ Error creating snapshot:', error);
                    
                    // If it's still a key error, try with a timestamp
                    if (error.code === '23505') {
                        console.log('🔄 Trying with unique timestamp...');
                        const timestamp = Date.now();
                        const uniqueDate = new Date(timestamp);
                        const uniqueDateString = uniqueDate.toISOString().split('T')[0];
                        
                        const { error: retryError } = await supabase
                            .from('table_snapshots_index')
                            .insert({
                                snapshot_date: uniqueDateString,
                                object_path: `staff_table_${uniqueDateString}_${timestamp}.json`,
                                row_count: 3,
                                file_size_bytes: 1500,
                                metadata: JSON.stringify({
                                    table: 'staffTable',
                                    version: '1.0.0',
                                    description: 'Demo snapshot for testing'
                                })
                            });
                        
                        if (retryError) {
                            console.error('❌ Retry error:', retryError);
                        } else {
                            console.log(`✅ Snapshot created with unique date: ${uniqueDateString}`);
                            await loadAvailableSnapshots();
                            // Update the calendar display
                            populateSnapshotCalendar();
                        }
                    }
                } else {
                    console.log(`✅ Demo snapshot created successfully! Date: ${dateString}`);
                    // Reload snapshots after creation
                    await loadAvailableSnapshots();
                    // Update the calendar display
                    populateSnapshotCalendar();
                }
                
            } catch (err) {
                console.error('❌ Exception error:', err);
            }
        }
        
        // Load available snapshots from the database
        async function loadAvailableSnapshots() {
            try {
                console.log('🔄 Loading available snapshots...');
                
                // First, test the database connection
                const { data: testData, error: testError } = await supabase
                    .from('table_snapshots_index')
                    .select('*')
                    .limit(1);
                
                if (testError) {
                    console.error('❌ Database connection error:', testError);
                    // Try to create a demo snapshot if database is empty
                    if (testError.code === 'PGRST116') { // No rows returned
                        console.log('📊 Database is empty, creating demo snapshot...');
                        await createDemoSnapshot();
                        return;
                    }
                    return;
                }
                
                console.log('✅ Database connection successful, test data:', testData);
                
                const { data, error } = await supabase
                    .from('table_snapshots_index')
                    .select('snapshot_date, created_at, row_count, object_path')
                    .order('snapshot_date', { ascending: false });
                
                if (error) {
                    console.error('❌ Error loading snapshots:', error);
                    return;
                }
                
                availableSnapshots = data || [];
                // Update global variable
                window.availableSnapshots = availableSnapshots;
                
                console.log(`📸 Loaded ${availableSnapshots.length} available snapshots:`, availableSnapshots);
                
                // If no snapshots exist, create a demo one
                if (availableSnapshots.length === 0) {
                    console.log('📊 No snapshots found, creating demo snapshot...');
                    await createDemoSnapshot();
                } else {
                updateHistoryNavigation();
                    // Update the calendar display
                    populateSnapshotCalendar();
                }
                
            } catch (error) {
                console.error('❌ Error in loadAvailableSnapshots:', error);
            }
        }
        
        // Update history navigation buttons state
        function updateHistoryNavigation() {
            const backBtn = document.getElementById('history-back');
            const nextBtn = document.getElementById('history-next');
            
            // Always update button states
            
            if (snapshotMode === 'live') {
                // Enable back/next if snapshots exist
                if (backBtn) backBtn.disabled = availableSnapshots.length === 0;
                if (nextBtn) nextBtn.disabled = availableSnapshots.length === 0;
            } else {
                // Update back/next button states
                if (backBtn) backBtn.disabled = currentSnapshotIndex <= 0;
                if (nextBtn) nextBtn.disabled = currentSnapshotIndex >= availableSnapshots.length - 1;
            }
            
            // Update calendar button text if calendar is open
            const calendarBtnText = document.getElementById('calendar-btn-text');
            if (calendarBtnText) {
                calendarBtnText.textContent = `Calendrier (${availableSnapshots.length})`;
            }
            
            // Update current snapshot date display
            const currentSnapshotDateText = document.getElementById('current-snapshot-date-text');
            if (currentSnapshotDateText) {
                if (snapshotMode === 'live') {
                    currentSnapshotDateText.textContent = 'Données en direct';
                } else if (currentSnapshotDate) {
                    // Format the date nicely
                    const date = new Date(currentSnapshotDate);
                    const formattedDate = date.toLocaleDateString('fr-FR', {
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric'
                    });
                    currentSnapshotDateText.textContent = `Snapshot du ${formattedDate}`;
                }
            }
        }
        
        // Check and fix inconsistencies between database and storage
        async function checkAndFixInconsistencies() {
            try {
                console.log('🔍 Checking for inconsistencies between database and storage...');
                
                // Get database snapshots
                const { data: dbSnapshots, error: dbError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (dbError) {
                    console.error('❌ Error checking database:', dbError);
                    return;
                }
                
                // Get storage files using service role key
                const { data: storageFiles, error: storageError } = await supabaseStorage.storage
                    .from('table-snapshots')
                    .list('', { limit: 100 });
                
                if (storageError) {
                    console.error('❌ Error checking storage:', storageError);
                    return;
                }
                
                console.log(`📊 Database: ${dbSnapshots?.length || 0} snapshots`);
                console.log(`📁 Storage: ${storageFiles?.length || 0} files`);
                
                // Check for orphaned database records (no corresponding file)
                const orphanedRecords = [];
                for (const snapshot of dbSnapshots || []) {
                    const fileExists = storageFiles?.some(file => file.name === snapshot.object_path);
                    if (!fileExists) {
                        orphanedRecords.push(snapshot);
                        console.warn(`⚠️ Orphaned record: ${snapshot.snapshot_date} -> ${snapshot.object_path}`);
                    }
                }
                
                // Check for orphaned storage files (no corresponding database record)
                const orphanedFiles = [];
                for (const file of storageFiles || []) {
                    if (file.name.includes('staff_table_')) {
                        const recordExists = dbSnapshots?.some(s => s.object_path === file.name);
                        if (!recordExists) {
                            orphanedFiles.push(file);
                            console.warn(`⚠️ Orphaned file: ${file.name}`);
                        }
                    }
                }
                
                if (orphanedRecords.length > 0 || orphanedFiles.length > 0) {
                    console.log(`🔧 Found ${orphanedRecords.length} orphaned records and ${orphanedFiles.length} orphaned files`);
                    showMessage(`Incohérences détectées. Utilisez le bouton "Nettoyer" pour corriger.`, 'warning');
                } else {
                    console.log('✅ No inconsistencies found');
                    showMessage('Aucune incohérence détectée', 'success');
                }
                
            } catch (err) {
                console.error('❌ Error checking inconsistencies:', err);
            }
        }
        
                // Clean database and create fresh snapshot
        async function cleanDatabaseAndCreateSnapshot() {
            try {
                console.log('🧹 Cleaning database and creating fresh snapshot...');
                
                // Check current state
                const { data: current, error: checkError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (checkError) {
                    console.error('❌ Error checking current state:', checkError);
                    return;
                }
                
                console.log(`📊 Current state: ${current?.length || 0} snapshots`);
                
                if (current && current.length > 0) {
                    // Delete all existing snapshots
                    const { error: deleteError } = await supabase
                        .from('table_snapshots_index')
                        .delete()
                        .neq('id', '00000000-0000-0000-0000-000000000000');
                    
                    if (deleteError) {
                        console.error('❌ Error deleting snapshots:', deleteError);
                        return;
                    }
                    
                    console.log('✅ All snapshots deleted');
                }
                
                // Create new snapshot with unique date
                await createDemoSnapshot();
                
                // Reload snapshots after cleanup
                await loadAvailableSnapshots();
                
                // Update the calendar display
                populateSnapshotCalendar();
                
                showMessage('Base de données nettoyée et nouveau snapshot créé', 'success');
                
            } catch (err) {
                console.error('❌ Error cleaning database:', err);
                showMessage('Erreur lors du nettoyage de la base', 'error');
            }
        }
        
        // Enter snapshot mode for a specific date
        async function enterSnapshotMode(date) {
            if (snapshotMode === 'snapshot' && currentSnapshotDate === date) {
                return; // Already in this snapshot
            }
            
            try {
                console.log(`🔄 Entering snapshot mode for date: ${date}`);
                
                // Find snapshot info
                const snapshotInfo = availableSnapshots.find(s => s.snapshot_date === date);
                if (!snapshotInfo) {
                    showMessage(`Aucun snapshot trouvé pour le ${formatDateForDisplay(date)}`, 'error');
                    return;
                }
                
                // Check if the file exists in storage first
                console.log(`🔍 Checking if file exists: ${snapshotInfo.object_path}`);
                
                const { data: fileList, error: listError } = await supabaseStorage.storage
                    .from('table-snapshots')
                    .list('', { limit: 100 });
                
                if (listError) {
                    console.warn('⚠️ Could not list storage files:', listError);
                } else {
                    const fileExists = fileList?.some(file => file.name === snapshotInfo.object_path);
                    if (!fileExists) {
                        console.warn(`⚠️ File not found in storage: ${snapshotInfo.object_path}`);
                        console.log('📁 Available files:', fileList?.map(f => f.name));
                        
                        // Try to find a similar file or suggest cleanup
                        const similarFiles = fileList?.filter(f => f.name.includes('staff_table_'));
                        if (similarFiles && similarFiles.length > 0) {
                            console.log('📋 Similar files found:', similarFiles.map(f => f.name));
                            showMessage(`Fichier snapshot introuvable. Utilisez le bouton "Nettoyer" pour corriger.`, 'warning');
                            return;
                        }
                    }
                }
                
                // Get snapshot data from storage using service role key
                const { data: snapshotData, error } = await supabaseStorage.storage
                    .from('table-snapshots')
                    .download(snapshotInfo.object_path);
                
                if (error) {
                    throw new Error(`Failed to download snapshot: ${error.message}`);
                }
                
                // Parse snapshot data
                const snapshot = JSON.parse(await snapshotData.text());
                
                // Update state
                snapshotMode = 'snapshot';
                currentSnapshotDate = date;
                currentSnapshotIndex = availableSnapshots.findIndex(s => s.snapshot_date === date);
                
                // Disable realtime updates
                if (realtimeSubscription) {
                    supabase.removeChannel(realtimeSubscription);
                    realtimeSubscription = null;
                }
                
                // Load snapshot data into table
                loadTableData(snapshot.data);
                
                // Update UI
                updateHistoryNavigation();
                updateSnapshotBanner();
                updateHistoryDateButton();
                
                // Disable editing
                disableTableEditing();
                
                showMessage(`Snapshot chargé du ${formatDateForDisplay(date)} (${snapshot.data.length} lignes)`, 'success');
                
            } catch (error) {
                console.error('❌ Error entering snapshot mode:', error);
                showMessage(`Erreur lors du chargement du snapshot: ${error.message}`, 'error');
            }
        }
        
        // Return to today's live view
        async function returnToToday() {
            if (snapshotMode === 'live') {
                return; // Already in live mode
            }
            
            try {
                console.log('🔄 Returning to today (live mode)');
                
                // Update state
                snapshotMode = 'live';
                currentSnapshotDate = null;
                currentSnapshotIndex = -1;
                
                // Re-enable realtime updates
                setupRealtimeSubscription();
                
                // Refresh data from Supabase (no cache)
                await fetchInitialData();
                
                // Update UI
                updateHistoryNavigation();
                updateSnapshotBanner();
                updateHistoryDateButton();
                
                // Re-enable editing
                enableTableEditing();
                
                showMessage('Retour au mode en direct avec données actuelles', 'success');
                
            } catch (error) {
                console.error('❌ Error returning to today:', error);
                showMessage(`Erreur lors du retour au mode en direct: ${error.message}`, 'error');
            }
        }
        
        // Navigate to previous snapshot
        function goToPreviousSnapshot() {
            if (currentSnapshotIndex > 0) {
                const prevSnapshot = availableSnapshots[currentSnapshotIndex - 1];
                enterSnapshotMode(prevSnapshot.snapshot_date);
            }
        }
        
        // Navigate to next snapshot
        function goToNextSnapshot() {
            if (currentSnapshotIndex < availableSnapshots.length - 1) {
                const nextSnapshot = availableSnapshots[currentSnapshotIndex + 1];
                enterSnapshotMode(nextSnapshot.snapshot_date);
            }
        }
        
        // Open date picker for snapshot selection
        function openDatePicker() {
            if (availableSnapshots.length === 0) {
                showMessage('Aucun snapshot disponible', 'info');
                return;
            }
            
            // Create a simple date picker
            const dates = availableSnapshots.map(s => s.snapshot_date);
            const currentDate = snapshotMode === 'snapshot' ? currentSnapshotDate : null;
            
            // Find current index
            let currentIndex = currentDate ? dates.indexOf(currentDate) : -1;
            if (currentIndex === -1) currentIndex = 0;
            
            // Show next available date
            const nextIndex = (currentIndex + 1) % dates.length;
            const nextDate = dates[nextIndex];
            
            enterSnapshotMode(nextDate);
        }
        
        // Toggle snapshot calendar dropdown
        function toggleSnapshotCalendar() {
            const dropdown = document.getElementById('snapshot-calendar-dropdown');
            const isVisible = !dropdown.classList.contains('hidden');
            
            if (isVisible) {
                dropdown.classList.add('hidden');
            } else {
                // Populate and show calendar
                populateSnapshotCalendar();
                dropdown.classList.remove('hidden');
            }
        }
        
        // Populate snapshot calendar with available dates
        function populateSnapshotCalendar() {
            const datesList = document.getElementById('snapshot-dates-list');
            const calendarBtnText = document.getElementById('calendar-btn-text');
            
            if (!datesList) return;
            
            // Clear existing content
            datesList.innerHTML = '';
            
            if (availableSnapshots.length === 0) {
                datesList.innerHTML = `
                    <div class="p-3 text-center text-gray-500 text-sm">
                        <i class="fa-solid fa-calendar-xmark w-5 h-5 mx-auto mb-2"></i>
                        Aucun snapshot disponible
                    </div>
                `;
                calendarBtnText.textContent = 'Calendrier (0)';
                return;
            }
            
            // Update button text with count
            calendarBtnText.textContent = `Calendrier (${availableSnapshots.length})`;
            
            // Group snapshots by month/year for better organization
            const groupedSnapshots = {};
            availableSnapshots.forEach(snapshot => {
                const date = new Date(snapshot.snapshot_date);
                const monthYear = date.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long' });
                
                if (!groupedSnapshots[monthYear]) {
                    groupedSnapshots[monthYear] = [];
                }
                groupedSnapshots[monthYear].push(snapshot);
            });
            
            // Create calendar entries
            Object.entries(groupedSnapshots).forEach(([monthYear, snapshots]) => {
                // Month header
                const monthHeader = document.createElement('div');
                monthHeader.className = 'px-2 py-1 bg-gray-100 text-xs font-semibold text-gray-700 rounded mb-2';
                monthHeader.textContent = monthYear;
                datesList.appendChild(monthHeader);
                
                // Dates in this month
                snapshots.forEach(snapshot => {
                    const dateItem = document.createElement('div');
                    dateItem.className = 'px-3 py-2 hover:bg-blue-50 cursor-pointer rounded text-sm transition-colors';
                    
                    const isCurrent = snapshotMode === 'snapshot' && currentSnapshotDate === snapshot.snapshot_date;
                    if (isCurrent) {
                        dateItem.className += ' bg-blue-100 border-l-4 border-blue-500';
                    }
                    
                    const date = new Date(snapshot.snapshot_date);
                    const formattedDate = date.toLocaleDateString('fr-FR', {
                        weekday: 'short',
                        day: 'numeric',
                        month: 'short'
                    });
                    
                    dateItem.innerHTML = `
                        <div class="flex items-center justify-between">
                            <span class="${isCurrent ? 'font-semibold text-blue-700' : 'text-gray-700'}">${formattedDate}</span>
                            <span class="text-xs text-gray-500">${snapshot.row_count} lignes</span>
                        </div>
                    `;
                    
                    dateItem.onclick = () => {
                        enterSnapshotMode(snapshot.snapshot_date);
                        toggleSnapshotCalendar(); // Close dropdown
                    };
                    
                    datesList.appendChild(dateItem);
                });
            });
        }
        
        // Update snapshot banner
        function updateSnapshotBanner() {
            const banner = document.getElementById('snapshot-banner');
            const bannerText = document.getElementById('snapshot-banner-text');
            
            // Only show banner when actively viewing history (snapshot mode)
            if (snapshotMode === 'snapshot' && currentSnapshotDate) {
                banner.classList.remove('hidden');
                banner.classList.add('flex');
                bannerText.textContent = `Snapshot du ${formatDateForDisplay(currentSnapshotDate)}`;
            } else {
                // Always hidden in live mode or when no snapshot is selected
                banner.classList.add('hidden');
                banner.classList.remove('flex');
            }
        }
        
        // Update history date button
        function updateHistoryDateButton() {
            const dateText = document.getElementById('current-date-text');
            
            if (snapshotMode === 'snapshot' && currentSnapshotDate) {
                dateText.textContent = formatDateForDisplay(currentSnapshotDate);
            } else {
                dateText.textContent = 'Données en direct';
            }
        }
        
        // Disable table editing
        function disableTableEditing() {
            const cells = document.querySelectorAll('#table-body td.editable-cell');
            cells.forEach(cell => {
                cell.contentEditable = false;
                cell.classList.add('snapshot-readonly');
            });
            
            // Disable all function buttons in snapshot mode
            const functionButtons = document.querySelectorAll('#button-bar button');
            functionButtons.forEach(btn => {
                btn.disabled = true;
            });
            
            // Disable FAB add button
            const fabAdd = document.getElementById('fab-add');
            if (fabAdd) fabAdd.style.pointerEvents = 'none';
        }
        
        // Enable table editing
        function enableTableEditing() {
            const cells = document.querySelectorAll('#table-body td.editable-cell');
            cells.forEach(cell => {
                if (!isViewMode) { // Only enable if not in view mode
                    cell.contentEditable = true;
                }
                cell.classList.remove('snapshot-readonly');
            });
            
            // Re-enable function buttons
            const functionButtons = document.querySelectorAll('#button-bar button');
            functionButtons.forEach(btn => {
                btn.disabled = false;
            });
            
            // Re-enable FAB add button
            const fabAdd = document.getElementById('fab-add');
            if (fabAdd) fabAdd.style.pointerEvents = 'auto';
        }
        
        // Format date for display
        function formatDateForDisplay(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('fr-FR', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        }
        

        

        
        // Fonction pour actualiser le tableau avec les données les plus récentes
        function refreshTableData() {
            console.log('🔄 Actualisation du tableau...');
            
            // Si on est en mode snapshot, retourner aux données en direct
            if (snapshotMode === 'snapshot') {
                console.log('📸 Retour aux données en direct depuis le mode snapshot');
                returnToToday();
            }
            
            // Recharger les données depuis Supabase
            console.log('🔄 Rechargement des données depuis Supabase...');
            loadTableData().then(() => {
                console.log('✅ Données actualisées avec succès');
                showMessage('Tableau actualisé avec les données les plus récentes', 'success');
            }).catch(error => {
                console.error('❌ Erreur lors de l\'actualisation:', error);
                showMessage('Erreur lors de l\'actualisation du tableau', 'error');
            });
        }
        
        // Simple and robust history bar toggle function
        function toggleHistoryBarSimple() {
            console.log('🔄 toggleHistoryBarSimple called');
            
            // Debug: Vérifier que le DOM est chargé
            if (document.readyState !== 'complete') {
                console.warn('⚠️ DOM not fully loaded, waiting...');
                setTimeout(toggleHistoryBarSimple, 100);
                return;
            }
            
            const historyBarContainer = document.getElementById('history-bar-container');
            const toggleBtn = document.getElementById('history-toggle-btn');
            
            console.log('🔍 Elements found:', {
                historyBarContainer: !!historyBarContainer,
                toggleBtn: !!toggleBtn
            });
            
            if (!historyBarContainer || !toggleBtn) {
                console.error('❌ Required elements not found');
                console.error('❌ historyBarContainer:', historyBarContainer);
                console.error('❌ toggleBtn:', toggleBtn);
                return;
            }
            
            // Check current state
            const isCurrentlyVisible = !historyBarContainer.classList.contains('hidden') && historyBarContainer.style.display !== 'none';
            console.log('🔍 Current state:', isCurrentlyVisible ? 'visible' : 'hidden');
            
            if (isCurrentlyVisible) {
                // Hide history bar container
                historyBarContainer.classList.add('hidden');
                historyBarContainer.style.display = 'none';
                
                // Update button icon only
                const toggleIcon = toggleBtn.querySelector('i');
                if (toggleIcon) {
                    toggleIcon.className = 'fa-solid fa-minus w-2 h-2 flex items-center justify-center text-center leading-none';
                }
                
                console.log('✅ History bar container hidden');
            } else {
                // Show history bar container
                historyBarContainer.classList.remove('hidden');
                historyBarContainer.style.display = 'block';
                
                // Update button icon only
                const toggleIcon = toggleBtn.querySelector('i');
                if (toggleIcon) {
                    toggleIcon.className = 'fa-solid fa-plus w-2 h-2 flex items-center justify-center text-center leading-none';
                }
                
                console.log('✅ History bar container shown');
            }
        }
        
        // ===== END SNAPSHOT SYSTEM FUNCTIONS =====



        // Initialize application
        function initializeApp() {
            // Set up event listeners
            setupEventListeners();
            setupKeyboardNavigation();
            
            // Initialize zoom
            if (isMobile() && !localStorage.getItem('zoomFactor')) { 
                zoomFactor = 0.6; 
                localStorage.setItem('zoomFactor', '0.6'); 
            } 
            applyZoom();
            
            // Initialize color picker
            const picker = document.getElementById('row-color-picker');
            if (picker) {
                try { 
                    picker.value = currentRowColor; 
                } catch(_) {}
                
                picker.addEventListener('input', (e) => {
                    currentRowColor = e.target.value || '#FFF59D';
                    try { 
                        localStorage.setItem('rowColor', currentRowColor); 
                    } catch(_) {}
                });
            }
            
                        // Initialize UI state
            updatePaintModeButton();
            maybeShowFirstUseHint();
            updateFilterColoredButton();
            
            // Détecter automatiquement l'état du bouton œil et agir en conséquence
            detectAndApplyViewMode();
            
            // Adapter l'affichage du statut selon la taille d'écran
            adaptStatusDisplay();
            window.addEventListener('resize', adaptStatusDisplay);
            
            // Configurer le clic sur les noms de patients pour les images
            setupPatientImageClick();
            
            // Initialiser l'état de la barre d'historique : cachée par défaut
            const historyBarContainer = document.getElementById('history-bar-container');
            const toggleIcon = document.getElementById('history-toggle-icon');
            if (historyBarContainer && toggleIcon) {
                // S'assurer que la barre est cachée
                historyBarContainer.classList.add('hidden');
                historyBarContainer.style.display = 'none';
                
                // S'assurer que l'icône est en mode "plus" (fermé)
                toggleIcon.className = 'fa-solid fa-plus w-2 h-2 flex items-center justify-center text-center leading-none';
                
                console.log('✅ History bar initialized as hidden by default');
            }
            
            // Initialiser l'affichage du nombre de lignes
            updateRowCount();
            
            // Check if already logged in
            const already = sessionStorage.getItem('isLoggedIn') === '1';
            if (already) {
                document.getElementById('login-container').classList.add('hidden');
                document.getElementById('table-container').classList.remove('hidden');
                
                // Détecter l'état du mode visualisation MAIS ne pas l'appliquer encore
                const savedViewMode = localStorage.getItem('viewMode') === 'true';
                if (savedViewMode !== isViewMode) {
                    isViewMode = savedViewMode;
                }
                
                restoreLocalDraft(); 
                ensureDDNHeader();
                
                // Consolidated cursor restoration function
                const performCursorRestoration = () => {
                    log(`🔄 CURSOR RESTORATION: lastFocusInfo=${JSON.stringify(lastFocusInfo)}, lastCellPos=${JSON.stringify(lastCellPos)}`);
                    
                    // Try focusCellFromInfo first (more reliable)
                    let restorationSuccess = false;
                    if (lastFocusInfo && lastFocusInfo.rowIndex >= 0 && lastFocusInfo.colLabel) {
                        restorationSuccess = focusCellFromInfo(lastFocusInfo);
                        log(`🔄 focusCellFromInfo result: ${restorationSuccess}`);
                    }
                    
                    // Fallback to focusCellByPos if focusCellFromInfo fails
                    if (!restorationSuccess && lastCellPos && lastCellPos.rowIndex >= 0 && lastCellPos.cellIndex >= 0) {
                            log(`🔄 Trying focusCellByPos with ${JSON.stringify(lastCellPos)}`);
                        restorationSuccess = focusCellByPos(lastCellPos);
                        log(`🔄 focusCellByPos result: ${restorationSuccess}`);
                    }
                    
                    if (restorationSuccess) {
                        log(`✅ Cursor restoration successful`);
                        } else {
                        log(`⚠️ Cursor restoration failed - no valid position information`);
                    }
                };
                
                const restoreAfterReload = () => {
                    document.removeEventListener('table:reloaded', restoreAfterReload);
                    
                    // Wait for table to be fully rendered and image icons updated
                    // Use a longer delay to ensure all table updates are complete
                    setTimeout(() => {
                        performCursorRestoration();
                        
                        // Additional mobile retry if needed
                        if (isMobile()) {
                            setTimeout(() => { 
                                performCursorRestoration();
                            }, 350);
                        }
                    }, 200); // Increased delay to ensure table and image icons are fully ready
                };
                
                document.addEventListener('table:reloaded', restoreAfterReload, { once: true });
                fetchInitialData(); 
                setupRealtimeSubscription(); 
                startPeriodicSync(); 
                scheduleAutosaveCountdown();
                
                // Initialize snapshot system
                loadAvailableSnapshots();
                
                // Ensure snapshot banner is hidden by default
                updateSnapshotBanner();
                
                // Update calendar display after loading snapshots
                setTimeout(() => {
                    populateSnapshotCalendar();
                }, 500);
                
                // Verify toggle button functionality
                setTimeout(() => {
                    console.log('🔍 Verifying toggle button functionality...');
                    const toggleBtn = document.getElementById('history-toggle-btn');
                    const historyBarContainer = document.getElementById('history-bar-container');
                    console.log('✅ Toggle button found:', !!toggleBtn);
                    console.log('✅ History bar container found:', !!historyBarContainer);
                    
                    if (toggleBtn && historyBarContainer) {
                        console.log('✅ Toggle functionality ready');
                        console.log('✅ Container initial state:', historyBarContainer.classList.contains('hidden') ? 'hidden' : 'visible');
                    } else {
                        console.warn('⚠️ Toggle elements not ready yet');
                    }
                }, 1000);
                
                // Force UI update to ensure everything is visible
                setTimeout(() => {
                    console.log('🎯 Force UI update after initialization...');
                    document.getElementById('table-container').style.display = 'block';
                    document.getElementById('table-container').classList.remove('hidden');
                    
                    // Ensure table is visible
                    const table = document.getElementById('data-table');
                    if (table) {
                        table.style.display = 'table';
                        table.style.visibility = 'visible';
                    }
                    
                    // Force a reflow to ensure proper rendering
                    table?.offsetHeight;
                }, 100);
                

                
                // Appliquer le mode visualisation APRÈS la restauration des données
                setTimeout(() => {
                    console.log('🎯 Applying view mode after data restoration...');
                    // Mettre à jour l'apparence du bouton
                    updateViewModeButton();
                    // Appliquer le mode
                    applyViewMode();
                }, 150);
                
                // Adapter l'affichage après le chargement des données
                setTimeout(adaptStatusDisplay, 100);
                
                // Mettre à jour les indicateurs d'images
                setTimeout(updateImageIndicators, 200);
                
                // Charger les images depuis Supabase
                setTimeout(loadImagesFromSupabase, 300);
                
                // Mettre à jour les icônes de la colonne Images après le chargement
                setTimeout(updateAllImageColumnIcons, 500);
                
                // Afficher le statut de synchronisation des images
                setTimeout(showImageSyncStatus, 600);
                
                // Enable focus capture after initialization is complete
                setTimeout(() => {
                    isInitialLoad = false;
                    log(`✅ Initial load complete - focus capture now enabled`);
                    
                    // Ensure cursor restoration happens after all updates are complete
                    if (lastFocusInfo || lastCellPos) {
                        log(`🔄 Delayed cursor restoration after initialization complete`);
                        setTimeout(() => {
                            performCursorRestoration();
                        }, 100);
                    }
                }, 1000);
                
                // Add click outside handler for calendar dropdown
                document.addEventListener('click', (e) => {
                    const calendarBtn = document.getElementById('snapshot-calendar-btn');
                    const calendarDropdown = document.getElementById('snapshot-calendar-dropdown');
                    
                    if (calendarDropdown && !calendarDropdown.classList.contains('hidden')) {
                        if (!calendarBtn?.contains(e.target) && !calendarDropdown?.contains(e.target)) {
                            calendarDropdown.classList.add('hidden');
                        }
                    }
                });
            } else {
                document.getElementById('login-container').classList.remove('hidden');
            }
            

        }
        

        

        

        

        

        
        function displayPatientImages(patientName) {
            const gallery = document.getElementById('image-gallery');
            const images = patientImages[patientName] || [];
            
            gallery.innerHTML = '';
            
            if (images.length === 0) {
                gallery.innerHTML = '<p class="text-gray-500 text-center col-span-full">Aucune image pour ce patient</p>';
                return;
            }
            
            images.forEach((image, index) => {
                const imageDiv = document.createElement('div');
                imageDiv.className = 'relative group';
                
                imageDiv.innerHTML = `
                    <img src="${image.data}" alt="${image.name}" class="w-full h-24 object-cover rounded-lg cursor-pointer hover:opacity-80 transition-opacity" 
                         onclick="viewImage('${patientName}', ${index})"
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
                    <div class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs cursor-pointer hover:bg-red-600 opacity-0 group-hover:opacity-100 transition-opacity"
                         onclick="deleteImage('${patientName}', ${index})">×</div>
                    <p class="text-xs text-gray-600 mt-1 truncate">${image.name}</p>
                    <div class="hidden text-xs text-gray-400 text-center mt-2">Image corrompue</div>
                `;
                
                gallery.appendChild(imageDiv);
            });
        }
        
        function viewImage(patientName, imageIndex) {
            const images = patientImages[patientName] || [];
            if (images.length === 0) return;
            
            currentPatientImages = images;
            currentImageIndex = imageIndex;
            
            const modal = document.getElementById('image-viewer-modal');
            const currentImage = document.getElementById('current-image');
            const counter = document.getElementById('image-counter');
            
            currentImage.src = images[imageIndex].data;
            currentImage.onerror = () => {
                showMessage('Erreur lors du chargement de l\'image', 'error');
                currentImage.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzY2NzM4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vbiB0cm91dsOpZTwvdGV4dD48L3N2Zz4=';
            };
            counter.textContent = `${imageIndex + 1} / ${images.length}`;
            
            modal.classList.remove('hidden');
        }
        
        function closeImageViewer() {
            document.getElementById('image-viewer-modal').classList.add('hidden');
        }
        
        function nextImage() {
            if (currentPatientImages.length === 0) return;
            currentImageIndex = (currentImageIndex + 1) % currentPatientImages.length;
            updateImageViewer();
        }
        
        function previousImage() {
            if (currentPatientImages.length === 0) return;
            currentImageIndex = currentImageIndex === 0 ? currentPatientImages.length - 1 : currentImageIndex - 1;
            updateImageViewer();
        }
        
        function updateImageViewer() {
            const currentImage = document.getElementById('current-image');
            const counter = document.getElementById('image-counter');
            
            currentImage.src = currentPatientImages[currentImageIndex].data;
            currentImage.onerror = () => {
                showMessage('Erreur lors du chargement de l\'image', 'error');
                currentImage.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzY2NzM4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vbiB0cm91dsOpZTwvdGV4dD48L3N2Zz4=';
            };
            counter.textContent = `${currentImageIndex + 1} / ${currentPatientImages.length}`;
        }
        
        async function deleteImage(patientName, imageIndex) {
            try {
                // Vérifier que l'image existe
                if (!patientImages[patientName] || !patientImages[patientName][imageIndex]) {
                    showMessage('Image non trouvée', 'error');
                    return;
                }

                // Demander confirmation
                if (!confirm(`Voulez-vous vraiment supprimer cette image ?`)) {
                    return;
                }

                const imageToDelete = patientImages[patientName][imageIndex];
                
                // Supprimer de Supabase si l'image a un ID
                if (imageToDelete.id) {
                    try {
                        const { error } = await supabase
                            .from('gallery_images')
                            .delete()
                            .eq('id', imageToDelete.id);
                        
                        if (error) {
                            console.error('Erreur lors de la suppression depuis Supabase:', error);
                            showMessage('Erreur lors de la suppression depuis le serveur', 'error');
                            return;
                        }
                    } catch (supabaseError) {
                        console.error('Erreur de connexion Supabase:', supabaseError);
                        showMessage('Erreur de connexion au serveur', 'error');
                        return;
                    }
                }

                // Supprimer du stockage local
                patientImages[patientName].splice(imageIndex, 1);
                
                // Si c'était la dernière image du patient, supprimer l'entrée du patient
                if (patientImages[patientName].length === 0) {
                    delete patientImages[patientName];
                }
                
                // Sauvegarder les changements
                savePatientImages();
                
                // Mettre à jour l'affichage
                displayPatientImages(patientName);
                updateAllImageColumnIcons(true); // Éviter les sauvegardes automatiques
                
                // Réinitialiser les indicateurs de modification pour éviter l'autosave
                isDirty = false;
                lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // Désactiver l'autosave
                
                // Fermer le visualiseur si c'était la dernière image
                if (!patientImages[patientName] || patientImages[patientName].length === 0) {
                    closeImageViewer();
                }
                
                showMessage('Image supprimée avec succès', 'success');
                
            } catch (error) {
                console.error('Erreur lors de la suppression de l\'image:', error);
                showMessage('Erreur lors de la suppression de l\'image', 'error');
            }
                }

        // Fonction pour supprimer toutes les images d'un patient
        async function deleteAllImagesForPatient(patientName) {
            try {
                if (!patientImages[patientName] || patientImages[patientName].length === 0) {
                    showMessage('Aucune image à supprimer pour ce patient', 'info');
                    return;
                }

                const imageCount = patientImages[patientName].length;
                
                // Supprimer toutes les images de Supabase
                for (const image of patientImages[patientName]) {
                    if (image.id) {
                        try {
                            const { error } = await supabase
                                .from('gallery_images')
                                .delete()
                                .eq('id', image.id);
                            
                            if (error) {
                                console.error('Erreur lors de la suppression de l\'image depuis Supabase:', error);
                            }
                        } catch (supabaseError) {
                            console.error('Erreur de connexion Supabase:', supabaseError);
                        }
                    }
                }

                // Supprimer du stockage local
                delete patientImages[patientName];
                savePatientImages();
                
                // Mettre à jour l'affichage
                updateAllImageColumnIcons(true); // Éviter les sauvegardes automatiques
                
                // Réinitialiser les indicateurs de modification pour éviter l'autosave
                isDirty = false;
                lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // Désactiver l'autosave
                
                // Fermer le visualiseur si il était ouvert pour ce patient
                if (currentPatientImages && currentPatientImages.length > 0) {
                    const firstImage = currentPatientImages[0];
                    if (firstImage.patientName === patientName) {
                        closeImageViewer();
                    }
                }
                
                showMessage(`${imageCount} image(s) supprimée(s) pour ${patientName}`, 'success');
                
            } catch (error) {
                console.error('Erreur lors de la suppression de toutes les images:', error);
                showMessage('Erreur lors de la suppression des images', 'error');
            }
        }

        async function syncImageToSupabase(imageData) {
            try {
                // Créer une entrée dans la table des images
                const { error } = await supabase
                    .from('gallery_images')
                    .upsert({
                        id: imageData.id,
                        patient_name: imageData.patientName,
                        image_name: imageData.name,
                        image_data: imageData.data,
                        image_type: imageData.type,
                        image_size: imageData.size,
                        upload_date: imageData.uploadDate,
                        last_sync: new Date().toISOString()
                    });
                
                if (error) {
                    console.error('Erreur Supabase:', error);
                    // Stocker pour synchronisation ultérieure
                    storeImageForLaterSync(imageData);
                }
            } catch (error) {
                console.error('Erreur de synchronisation:', error);
                // Stocker pour synchronisation ultérieure
                storeImageForLaterSync(imageData);
            }
        }
        
        function storeImageForLaterSync(imageData) {
            let pendingImages = JSON.parse(localStorage.getItem('pendingImageSync') || '[]');
            pendingImages.push(imageData);
            localStorage.setItem('pendingImageSync', JSON.stringify(pendingImages));
        }
        
        async function syncPendingImages() {
            try {
                let pendingImages = JSON.parse(localStorage.getItem('pendingImageSync') || '[]');
                if (pendingImages.length === 0) return;
                
                for (const imageData of pendingImages) {
                    await syncImageToSupabase(imageData);
                }
                
                // Vider la liste des images en attente
                localStorage.removeItem('pendingImageSync');
                
                // Mettre à jour les icônes de la colonne Images
                updateAllImageColumnIcons(true); // Éviter les sauvegardes automatiques
                
                // Réinitialiser les indicateurs de modification pour éviter l'autosave
                isDirty = false;
                lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // Désactiver l'autosave
                
                showMessage('Images synchronisées avec le serveur', 'success');
            } catch (error) {
                console.error('Erreur lors de la synchronisation des images en attente:', error);
            }
        }
        
        function savePatientImages() {
            try {
                localStorage.setItem('patientImages', JSON.stringify(patientImages));
            } catch (e) {
                console.error('Erreur lors de la sauvegarde des images:', e);
            }
        }
        
        // Fonction pour afficher les images au clic sur le nom du patient
        function setupPatientImageClick() {
            const tbody = document.getElementById('table-body');
            if (!tbody) return;
            
            tbody.addEventListener('click', function(e) {
                const nameCell = e.target.closest('td:nth-child(6)'); // Colonne Nom_Prénom
                if (nameCell && nameCell.textContent.trim()) {
                    const patientName = nameCell.textContent.trim();
                    const images = patientImages[patientName] || [];
                    
                    if (images.length > 0) {
                        // Ouvrir directement le visualiseur d'images
                        currentPatientImages = images;
                        currentImageIndex = 0;
                        viewImage(patientName, 0);
                    } else {
                        // Aucune image pour ce patient - afficher un message
                        showMessage('Aucune image pour ce patient. Utilisez le bouton ➕ dans la colonne Images pour ajouter des images.', 'info');
                    }
                }
            });
        }
        
        // Fonction pour afficher le statut de synchronisation des images
        function showImageSyncStatus() {
            const pendingImages = JSON.parse(localStorage.getItem('pendingImageSync') || '[]');
            if (pendingImages.length > 0) {
                showMessage(`${pendingImages.length} image(s) en attente de synchronisation`, 'warning');
            }
        }
        
        // Fonction pour mettre à jour les indicateurs d'images (maintenant uniquement dans la colonne Images)
        function updateImageIndicators() {
            // Cette fonction est maintenant remplacée par updateAllImageColumnIcons
            // qui met à jour uniquement les icônes dans la colonne Images
            updateAllImageColumnIcons();
        }
        
        // Fonction pour charger les images depuis Supabase
        async function loadImagesFromSupabase() {
            // Skip if cursor restoration is in progress to avoid conflicts
            if (isRestoringFocus) {
                log('🔄 loadImagesFromSupabase skipped - cursor restoration in progress');
                return;
            }
            
            try {
                const { data, error } = await supabase
                    .from('gallery_images')
                    .select('*')
                    .order('upload_date', { ascending: false });
                
                if (error) {
                    console.error('Erreur lors du chargement des images:', error);
                    return;
                }
                
                if (data && data.length > 0) {
                    // Réorganiser les images par patient
                    const newPatientImages = {};
                    data.forEach(image => {
                        if (!newPatientImages[image.patient_name]) {
                            newPatientImages[image.patient_name] = [];
                        }
                        newPatientImages[image.patient_name].push({
                            id: image.id,
                            name: image.image_name,
                            data: image.image_data,
                            type: image.image_type,
                            size: image.image_size,
                            uploadDate: image.upload_date,
                            patientName: image.patient_name
                        });
                    });
                    
                    // Mettre à jour les images locales
                    patientImages = { ...patientImages, ...newPatientImages };
                    savePatientImages();
                    
                    // Synchroniser les images en attente
                    await syncPendingImages();
                    
                    // Mettre à jour les icônes de la colonne Images
                    updateAllImageColumnIcons(true); // Éviter les sauvegardes automatiques
                    
                    // Réinitialiser les indicateurs de modification pour éviter l'autosave
                    isDirty = false;
                    lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // Désactiver l'autosave
                    
                    showMessage(`${data.length} image(s) chargée(s) depuis le serveur`, 'success');
                }
            } catch (error) {
                console.error('Erreur lors du chargement des images:', error);
            }
        }

        // Fonction pour mettre à jour toutes les icônes de la colonne Images
        function updateAllImageColumnIcons(skipAutoSave = false) {
            const tbody = document.getElementById('table-body');
            if (!tbody) return;
            
            // Skip if cursor restoration is in progress to avoid conflicts
            if (isRestoringFocus) {
                log('🔄 updateAllImageColumnIcons skipped - cursor restoration in progress');
                return;
            }
            
            Array.from(tbody.querySelectorAll('tr')).forEach(row => {
                const imageCell = row.querySelector('[data-label="Images"]');
                if (imageCell) {
                    const mainButton = imageCell.querySelector('button:first-child');
                    const trashButton = imageCell.querySelector('button:last-child');
                    const container = imageCell.querySelector('div');
                    
                    if (mainButton && trashButton && container) {
                        const nameCell = row.querySelector('[data-label="Nom_Prénom"]');
                        if (nameCell) {
                            const patientName = nameCell.textContent.trim();
                            

                            
                            // Vérifier si l'état actuel correspond à l'état souhaité pour éviter les modifications inutiles
                            const hasImages = patientName && patientImages[patientName] && patientImages[patientName].length > 0;
                            const currentHasImages = mainButton.innerHTML === '📷';
                            
                            // Ne mettre à jour que si l'état a changé
                            if (hasImages !== currentHasImages) {
                                if (hasImages) {
                                    // Il y a des photos - afficher le bouton caméra et la poubelle
                                    mainButton.innerHTML = '📷';
                                    mainButton.title = `${patientImages[patientName].length} image(s) - Cliquez pour voir`;
                                    mainButton.onclick = (e) => {
                                        e.stopPropagation();
                                        viewImage(patientName, 0);
                                    };
                                    mainButton.className = 'p-1 rounded-full hover:bg-gray-200 transition-colors text-blue-500';
                                    
                                    // Afficher la poubelle
                                    trashButton.style.opacity = '1';
                                    trashButton.onclick = (e) => {
                                        e.stopPropagation();
                                        if (confirm(`Voulez-vous vraiment supprimer toutes les images de ${patientName} ?`)) {
                                            deleteAllImagesForPatient(patientName);
                                        }
                                    };
                                    
                                    // Ajouter un bouton + pour ajouter plus d'images (seulement s'il n'existe pas déjà)
                                    let addMoreButton = container.querySelector('.add-more-button');
                                    if (!addMoreButton) {
                                        addMoreButton = document.createElement('button');
                                        addMoreButton.innerHTML = '➕';
                                        addMoreButton.className = 'add-more-button p-1 rounded-full hover:bg-green-200 transition-colors text-green-600 ml-1';
                                        addMoreButton.title = 'Ajouter plus d\'images pour ce patient';
                                        addMoreButton.onclick = (e) => {
                                            e.stopPropagation();
                                            const fileInput = imageCell.querySelector('input[type="file"]');
                                            if (fileInput) fileInput.click();
                                        };
                                        container.appendChild(addMoreButton);
                                    }
                                    
                                } else {
                                // Pas de photos - afficher le bouton ajouter et cacher la poubelle
                                mainButton.innerHTML = '➕';
                                mainButton.title = 'Ajouter des images pour ce patient';
                                mainButton.onclick = (e) => {
                                    e.stopPropagation();
                                    const fileInput = imageCell.querySelector('input[type="file"]');
                                    if (fileInput) fileInput.click();
                                };
                                mainButton.className = 'p-1 rounded-full hover:bg-green-200 transition-colors text-green-600';
                                
                                    // Cacher la poubelle
                                    trashButton.style.opacity = '0';
                                    trashButton.onclick = null;
                                    
                                    // Supprimer le bouton + s'il existe
                                    const addMoreButton = container.querySelector('.add-more-button');
                                    if (addMoreButton) {
                                        addMoreButton.remove();
                                    }
                                }
                            } else if (hasImages) {
                                // Mettre à jour seulement le titre si le nombre d'images a changé
                                const currentTitle = mainButton.title;
                                const newTitle = `${patientImages[patientName].length} image(s) - Cliquez pour voir`;
                                if (currentTitle !== newTitle) {
                                    mainButton.title = newTitle;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Make functions globally available
        window.checkPassword = checkPassword;
        window.syncToMaster = syncToMaster;
        window.addRow = addRow;
        window.saveManually = saveManually;
        window.undo = undo;
        window.downloadExcel = downloadExcel;
        window.downloadPDF = downloadPDF;
        window.downloadImage = downloadImage;
        window.importExcelFromFile = importExcelFromFile;
        window.zoomIn = zoomIn;
        window.zoomOut = zoomOut;
        window.zoomReset = zoomReset;
        window.clearAllRowColors = clearAllRowColors;
        window.cyclePaintMode = cyclePaintMode;
        window.toggleColoredFilter = toggleColoredFilter;
        window.toggleViewMode = toggleViewMode;
        
        // Expose history bar toggle functions
        window.toggleHistoryBarSimple = toggleHistoryBarSimple;

        window.viewImage = viewImage;
        
        // Expose snapshot system functions
        window.loadAvailableSnapshots = loadAvailableSnapshots;
        window.enterSnapshotMode = enterSnapshotMode;
        window.returnToToday = returnToToday; // Use the existing function instead
        window.goToPreviousSnapshot = goToPreviousSnapshot;
        window.goToNextSnapshot = goToNextSnapshot;
        window.refreshTableData = refreshTableData;
        window.toggleSnapshotCalendar = toggleSnapshotCalendar;
        window.populateSnapshotCalendar = populateSnapshotCalendar;
        window.openDatePicker = openDatePicker;
        window.formatDateForDisplay = formatDateForDisplay;
        window.disableTableEditing = disableTableEditing;
        window.enableTableEditing = enableTableEditing;
        window.updateHistoryNavigation = updateHistoryNavigation;
        window.updateSnapshotBanner = updateSnapshotBanner;
        window.updateHistoryDateButton = updateHistoryDateButton;
        window.fetchInitialData = fetchInitialData;
        window.loadTableData = loadTableData;
        window.showMessage = showMessage;
        window.closeImageViewer = closeImageViewer;
        window.nextImage = nextImage;
        window.previousImage = previousImage;
        window.deleteImage = deleteImage;
        window.deleteAllImagesForPatient = deleteAllImagesForPatient;
        window.syncPendingImages = syncPendingImages;
        window.loadImagesFromSupabase = loadImagesFromSupabase;
        window.updateAllImageColumnIcons = updateAllImageColumnIcons;

        // Fonction pour ouvrir la galerie simple
        function openSimpleGallery() {
            window.open('simple-gallery.html', '_blank', 'width=1200,height=800,scrollbars=yes,resizable=yes');
        }
        
        // Exposer la fonction globalement
        window.openSimpleGallery = openSimpleGallery;
        window.setupMobileViewport = setupMobileViewport;
        window.setupExtendedKeyboardShortcuts = setupExtendedKeyboardShortcuts;
        window.initializeApp = initializeApp;
        window.adaptStatusDisplay = adaptStatusDisplay;
        window.getCurrentStatusType = getCurrentStatusType;
        window.applyDotColor = applyDotColor;

        // Raccourcis clavier étendus

        
        function setupMobileViewport() {
            // Gérer la hauteur dynamique du viewport sur mobile
            function updateViewportHeight() {
                if (window.innerWidth <= 768) {
                    const vh = window.innerHeight * 0.01;
                    document.documentElement.style.setProperty('--vh', `${vh}px`);
                    
                    // Ajuster la hauteur du conteneur principal
                    const tableContainer = document.getElementById('table-container');
                    if (tableContainer) {
                        tableContainer.style.height = `${window.innerHeight}px`;
                        tableContainer.style.minHeight = `${window.innerHeight}px`;
                    }
                    
                    // Ajuster la position du bouton FAB pour éviter la barre de navigation
                    const fabButton = document.getElementById('fab-add');
                    if (fabButton) {
                        const bottomOffset = Math.max(16, window.innerHeight - window.visualViewport.height + 16);
                        fabButton.style.bottom = `${bottomOffset}px`;
                        
                        // Sur mobile, positionner le bouton plus discrètement
                        if (window.innerWidth <= 768) {
                            fabButton.style.right = '12px';
                            fabButton.style.bottom = `${Math.max(12, bottomOffset - 4)}px`;
                        }
                    }
                }
            }
            
            // Mettre à jour lors du redimensionnement
            window.addEventListener('resize', updateViewportHeight);
            window.addEventListener('orientationchange', updateViewportHeight);
            
            // Mettre à jour lors du changement de la barre de navigation mobile
            if ('visualViewport' in window) {
                window.visualViewport.addEventListener('resize', updateViewportHeight);
            }
            
            // Mise à jour initiale
            updateViewportHeight();
            
            // Mettre à jour périodiquement pour s'assurer de la synchronisation
            setInterval(updateViewportHeight, 1000);
        }
        
        function setupExtendedKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Seulement appliquer les raccourcis quand pas dans les champs de formulaire
                const active = document.activeElement;
                const inFormField = active && (
                    active.tagName === 'INPUT' || 
                    active.tagName === 'TEXTAREA' || 
                    active.tagName === 'SELECT' || 
                    active.contentEditable === 'true'
                );

                // Ignorer les raccourcis si dans les champs de formulaire
                if (inFormField) return;

                // G: Ouvrir galerie
                if (!e.ctrlKey && !e.metaKey && !e.altKey && (e.key === 'g' || e.key === 'G')) {
                    e.preventDefault();
                    openSimpleGallery();
                    return;
                }

                // N: Ajouter nouvelle ligne
                if (!e.ctrlKey && !e.metaKey && !e.altKey && (e.key === 'n' || e.key === 'N')) {
                    e.preventDefault();
                    if (typeof addRow === 'function') {
                        addRow();
                    }
                    return;
                }

                // Supprimer: Supprimer lignes sélectionnées
                if (e.key === 'Delete') {
                    e.preventDefault();
                    
                    // Empêcher la suppression dans les snapshots
                    if (snapshotMode === 'snapshot') {
                        showMessage('Impossible de supprimer des lignes dans un snapshot. Retournez aux données en direct pour modifier le tableau.', 'warning');
                        return;
                    }
                    
                    // Récupérer les lignes sélectionnées
                    const selectedRows = Array.from(document.querySelectorAll('#table-body tr.selected-row'));
                    if (selectedRows.length > 0) {
                        promptKeyConfirm(`Supprimer ${selectedRows.length} ligne(s) ?`, () => deleteRows(selectedRows));
                    } else {
                        // Si aucune ligne sélectionnée, essayer de supprimer la ligne active
                        const activeRow = document.querySelector('#table-body tr:focus') || document.querySelector('#table-body tr.selected-row');
                        if (activeRow) {
                            promptKeyConfirm('Appuyez sur Entrée pour supprimer cette ligne, Échap pour annuler.', () => deleteRows([activeRow]));
                        }
                    }
                    return;
                }

                // Échap: Fermer modales
                if (e.key === 'Escape') {
                    const confirmationModal = document.getElementById('confirmation-modal');
                    if (confirmationModal && !confirmationModal.classList.contains('hidden')) {
                        confirmationModal.classList.add('hidden');
                        return;
                    }
                }
            });
        }

        // Initialiser les raccourcis clavier étendus
        document.addEventListener('DOMContentLoaded', function() {
            setupExtendedKeyboardShortcuts();
            
            // Adapter l'affichage du statut selon la taille d'écran initiale
            setTimeout(() => {
                adaptStatusDisplay();
            }, 100);
            
            // Setup mobile viewport management
            setupMobileViewport();
        });

        // Initialize when DOM is ready
        window.addEventListener('load', initializeApp);
    </script>
</body>
</html>