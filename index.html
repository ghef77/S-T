<!DOCTYPE html>
<html lang='fr'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>S-T synchronisé - Supabase</title>
    
    <!-- Preload critical resources -->
    <link rel="preload" href="https://cdn.tailwindcss.com" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm" as="script">
    
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    

    
    <style>
        /* CSS Variables for consistent theming */
        :root {
            --primary-color: #15803d;
            --primary-hover: #16a34a;
            --primary-light: #86efac;
            --secondary-color: #3b82f6;
            --secondary-hover: #2563eb;
            --danger-color: #dc2626;
            --danger-hover: #b91c1c;
            --success-color: #16a34a;
            --warning-color: #eab308;
            --border-color: #e5e7eb;
            --border-focus: #3b82f6;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --bg-primary: #ffffff;
            --bg-secondary: #f9fafb;
            --bg-hover: #f3f4f6;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1);
            --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Base styles */
        body { 
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; 
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        /* Table styles */
        #data-table { 
            border-collapse: collapse; 
            border-spacing: 0; 
            margin-bottom: 50px; 
            width: 100%; 
            background-color: var(--bg-primary);
            box-shadow: var(--shadow-md);
            border-radius: 0.5rem;
        }
        
        #data-table th, #data-table td { 
            border: 1px solid var(--border-color); 
            transition: var(--transition);
        }
        
        #data-table thead { 
            position: sticky !important; 
            top: 0 !important; 
            z-index: 100 !important; 
            background-color: var(--primary-color) !important;
            color: white !important;
            font-weight: 600 !important;
            text-transform: uppercase !important;
            letter-spacing: 0.05em !important;
            /* ✅ GARANTIR que les en-têtes restent toujours visibles */
            will-change: transform !important;
            transform: translateZ(0) !important;
            /* ✅ Ombre pour séparer visuellement les en-têtes */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15) !important;
            /* ✅ Bordure inférieure pour délimiter clairement */
            border-bottom: 3px solid var(--primary-hover) !important;
        }
        
        #data-table thead th {
            padding: 1rem;
            font-size: 0.875rem;
        }
        
        #data-table tbody tr {
            transition: var(--transition);
        }
        
        #data-table tbody tr:hover {
            background-color: var(--bg-hover);
            transform: scale(1.005);
            box-shadow: var(--shadow-sm);
        }
        
        #data-table tfoot {
            position: static;
            background: transparent;
            border-top: 0;
            box-shadow: none;
        }
        /* Floating + button to free vertical space */
        #fab-add {
          position: fixed;
          right: 16px;
          bottom: calc(env(safe-area-inset-bottom, 0px) + 16px);
          z-index: 50;
          width: 56px;
          height: 56px;
          border-radius: 9999px;
          display: flex;
          align-items: center;
          justify-content: center;
          box-shadow: var(--shadow-lg);
        }
        #fab-add:active { transform: scale(0.97); }
        
        /* FAB button styling - no responsive modifications */
        


        /* Hide the old add-row button area to remove the white bar */
        #data-table tfoot td { padding: 0 !important; height: 0 !important; }
        #data-table tfoot button { display: none !important; }

        /* Snapshot System Styles */
        .snapshot-readonly {
            background-color: #fef3c7 !important;
            color: #92400e !important;
            cursor: not-allowed !important;
        }
        
        .snapshot-readonly:hover {
            background-color: #fde68a !important;
        }
        
        #history-bar {
            display: flex;
            transition: all 0.3s ease;
        }
        
        #history-bar button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #snapshot-banner {
            animation: slideInDown 0.3s ease-out;
            max-width: fit-content;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* History bar design - no responsive modifications */
        
        /* Utility classes */
        .hidden {
            display: none !important;
        }
        
        /* Animation classes */
        .sync-pending-animation { 
            animation: pulse 1.5s infinite; 
        }
        
        @keyframes pulse { 
            0% { opacity: 1; } 
            50% { opacity: 0.5; } 
            100% { opacity: 1; } 
        }
        
        /* Sync status dot styles */
        .sync-dot {
            transition: all 0.3s ease;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8);
            flex-shrink: 0;
            display: inline-block;
            border: 1px solid rgba(0, 0, 0, 0.1);
            cursor: help;
        }
        
        .sync-dot.animate-pulse {
            animation: dot-pulse 2s infinite;
        }
        
        @keyframes dot-pulse {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
            }
            50% { 
                opacity: 0.7; 
                transform: scale(1.1);
            }
        }
        
        /* Sync status styling - no responsive modifications */
        

        
        /* Optimisation de l'espace */
        #table-container {
            max-width: 100%;
        }
        
        #button-bar {
            max-width: 100%;
            justify-content: flex-start;
            overflow-x: auto;
            gap: 0.3rem; /* ensure spacing between buttons */
            padding: 0 !important; /* Remove padding between buttons and container */
        }
        
        #button-bar button {
            margin: 0;
            flex-shrink: 0;
            transform: scale(1.2); /* enlarge by ~20% */
            transform-origin: center;
        }

        /* keep slight press effect while preserving 1.2 scale */
        #button-bar button:active {
            transform: scale(1.176);
        }
        
        /* Table container styling - no responsive modifications */
        
        /* Message box styles */
        .message-box {
            position: fixed;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            line-height: 1rem;
            padding: 4px 8px;
            margin-top: 4px;
            border-radius: 0.5rem;
            box-shadow: var(--shadow-lg);
            z-index: 40;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            max-width: 90vw;
            word-wrap: break-word;
        }
        
        .message-box.show { 
            opacity: 1; 
            transform: translateX(-50%) translateY(0); 
        }
        
        .message-box.success { 
            background-color: #d1fae5; 
            color: #065f46; 
        }
        
        .message-box.info { 
            background-color: #dbeafe; 
            color: #1e40af; 
        }
        
        .message-box.error { 
            background-color: #fee2e2; 
            color: #991b1b; 
        }
        
        /* Button bar positioning */
        #button-bar { 
            position: absolute; 
            top: 8px; 
            right: 8px; 
            z-index: 20; 
        }
        
        /* Forcer le positionnement sur tous les écrans non-mobiles */
        @media (min-width: 641px) {
            #button-bar {
                position: absolute !important;
                top: 8px !important;
                right: 8px !important;
                z-index: 20 !important;
                margin: 0 !important;
                margin-bottom: 0 !important;
                padding: 0 !important; /* Remove padding between buttons and container */
            }
        }

        /* Mobile-specific button bar positioning */
        @media (max-width: 640px) {
            #button-bar {
                position: relative !important;
                top: auto !important;
                right: auto !important;
                left: 0 !important;
                z-index: 20 !important;
                margin: 0.5rem 0 !important;
                padding: 0.5rem !important;
                width: 100% !important;
                justify-content: center !important;
                flex-wrap: wrap !important;
                gap: 0.5rem !important;
                background-color: rgba(249, 250, 251, 0.95) !important;
                border: 1px solid #e5e7eb !important;
                border-radius: 0.5rem !important;
                display: flex !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
            
            #button-bar button {
                transform: scale(1.4) !important; /* Larger buttons on mobile */
                min-width: 44px !important; /* Touch-friendly size */
                min-height: 44px !important;
                display: flex !important;
                visibility: visible !important;
                opacity: 1 !important;
            }
        }

        /* Additional mobile button visibility fixes */
        @media (max-width: 768px) {
            #button-bar {
                display: flex !important;
                visibility: visible !important;
                opacity: 1 !important;
                position: relative !important;
                top: auto !important;
                right: auto !important;
                left: 0 !important;
                width: 100% !important;
                margin: 0.5rem 0 !important;
                padding: 0.5rem !important;
                background-color: rgba(249, 250, 251, 0.95) !important;
                border: 1px solid #e5e7eb !important;
                border-radius: 0.5rem !important;
            }
        }

        /* Button bar positioning for medium screens - no responsive modifications */

        /* Button bar positioning - no responsive modifications */
        
        /* Sticky first column */
        #data-table td:first-child {
            position: sticky;
            left: 0;
            z-index: 2;
            background-color: white !important;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }

        #data-table th:first-child {
            position: sticky !important;
            left: 0 !important;
            top: 0 !important;
            z-index: 101 !important;
            background-color: var(--primary-color) !important;
            /* ✅ GARANTIR que la première colonne reste visible */
            will-change: transform !important;
            transform: translateZ(0) !important;
            /* ✅ Ombre pour séparer visuellement */
            box-shadow: 2px 0 5px rgba(0,0,0,0.1) !important;
        }
        
        /* Frozen column classes for JavaScript */
        .frozen-column.frozen-1 {
            position: sticky !important;
            left: 0 !important;
            z-index: 2 !important;
            background-color: white !important;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }
        
        .frozen-column-header.frozen-1 {
            position: sticky !important;
            left: 0 !important;
            top: 0 !important;
            z-index: 101 !important;
            background-color: var(--primary-color) !important;
            /* ✅ GARANTIR que les colonnes gelées restent visibles */
            will-change: transform !important;
            transform: translateZ(0) !important;
            /* ✅ Ombre pour séparer visuellement */
            box-shadow: 2px 0 5px rgba(0,0,0,0.1) !important;
        }
        
        /* ✅ GARANTIR que les en-têtes restent TOUJOURS visibles */
        #data-table thead,
        #data-table thead th,
        .frozen-column-header {
            /* ✅ Forcer le comportement sticky même pendant les opérations */
            position: sticky !important;
            top: 0 !important;
            z-index: 100 !important;
            /* ✅ Optimisations pour la performance */
            will-change: transform !important;
            transform: translateZ(0) !important;
            /* ✅ Garantir la visibilité */
            visibility: visible !important;
            opacity: 1 !important;
            /* ✅ Empêcher le débordement */
            overflow: visible !important;
        }
        
        /* ✅ En-têtes de colonnes gelées avec priorité maximale */
        #data-table th:first-child,
        .frozen-column-header.frozen-1 {
            z-index: 101 !important;
            left: 0 !important;
            top: 0 !important;
        }
        
        /* ✅ Styles pour les en-têtes pendant le téléchargement */
        #data-table thead.downloading {
            background-color: var(--primary-color) !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2) !important;
            border-bottom: 3px solid var(--warning-color) !important;
        }
        
        /* Editable cell styles */
        td.editable-cell:empty::after { 
            content: attr(data-label); 
            color: var(--text-secondary); 
            font-weight: normal; 
        }
        
        /* Texte noir foncé pour toutes les cellules éditables du tableau */
        td.editable-cell {
            color: #1a1a1a !important;
        }
        
        /* Styles spécifiques pour les colonnes importantes avec police plus grande */
        td.editable-cell[data-label="Date de saisie"],
        td.editable-cell[data-label="PEC finale"],
        td.editable-cell[data-label="PEC initiale"],
        td.editable-cell[data-label="Diagnostic_initial"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Numero_tel avec police standard (1.1rem) */
        td.editable-cell[data-label="Numero_tel"],
        td.editable-cell[data-label="numero_tel"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police standard */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Nom_Prénom et DDN en gras pour les cellules éditables */
        td.editable-cell[data-label="Nom_Prénom"],
        td.editable-cell[data-label="DDN"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 700 !important; /* Gras (bold) */
        }
        
        /* Information complementaire en rouge pour les cellules éditables */
        td.editable-cell[data-label="Information complementaire"],
        td.editable-cell[data-label="information complementaire"] {
            color: #dc2626 !important; /* Rouge */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Patient name formatting - support line breaks */
        td.editable-cell[data-label="Nom_Prénom"],
        td.editable-cell[data-label="nom prenom"],
        td.editable-cell[data-label="nom_prénom"],
        td.editable-cell[data-label="nom et prenom"],
        td.editable-cell[data-label="nom et prénom"],
        td.editable-cell[data-label="patient"],
        td.editable-cell[data-label="nom complet"],
        td.editable-cell[data-label="fullname"],
        td.editable-cell[data-label="name"] {
            white-space: pre-line;
            line-height: 1.2;
            vertical-align: top;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }
        
        td.editable-cell[data-label="DDN"]:empty::after { 
            content: 'JJ/MM/YYYY'; 
            color: var(--text-secondary); 
            font-weight: normal; 
        }
        
        /* Row selection */
        tr.selected-row { 
            background-color: #FEF3C7; 
        }

        /* Column text colors and font sizes for specific columns */
        #data-table td[data-label="Date de saisie"],
        #data-table td[data-label="PEC finale"],
        #data-table td[data-label="PEC initiale"],
        #data-table td[data-label="Diagnostic_initial"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Numero_tel avec police standard (1.1rem) */
        #data-table td[data-label="Numero_tel"],
        #data-table td[data-label="numero_tel"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police standard */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Nom_Prénom et DDN en gras */
        #data-table td[data-label="Nom_Prénom"],
        #data-table td[data-label="DDN"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 700 !important; /* Gras (bold) */
        }
        
        /* Information complementaire en rouge */
        #data-table td[data-label="Information complementaire"],
        #data-table td[data-label="information complementaire"] {
            color: #dc2626 !important; /* Rouge */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* Légèrement plus gras */
        }

        /* Column selection visuals */
        #data-table thead th.col-selected {
            outline: 3px solid var(--secondary-color);
            position: relative;
        }
        
        #data-table thead th.col-selected::after {
            content: '✓';
            position: absolute; 
            right: 6px; 
            top: 4px;
            font-weight: 700; 
            font-size: 0.8em; 
            color: var(--text-primary);
        }

        /* Safe areas for iOS/Android */
        body {
            padding-top: env(safe-area-inset-top, 0px);
            padding-bottom: env(safe-area-inset-bottom, 0px);
        }
        
        /* Mobile viewport height management */
        .mobile-viewport-height {
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            min-height: 100vh;
            min-height: 100dvh;
        }
        
        /* Viewport styling - no responsive modifications */
            
                    /* History bar styling - no responsive modifications */
        
        /* History controls row styling */
        .flex.justify-between.items-center.mb-3 {
            gap: 1rem;
        }
        
        /* Toggle button container styling */
        .flex.justify-start {
            min-width: fit-content;
        }
        
        /* Minimal toggle button styling */
        #history-toggle-btn {
            transition: all 0.2s ease-in-out;
        }
        
        #history-toggle-btn:hover {
            transform: scale(1.05);
        }
        
        #history-toggle-btn:active {
            transform: scale(0.95);
        }
        
        /* Perfect centering for FontAwesome icons */
        #history-toggle-btn i {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            text-align: center !important;
            line-height: 1 !important;
            width: 100% !important;
            height: 100% !important;
        }
        
        /* History bar container styling */
        #history-bar-container {
            flex: 1;
            min-width: 0;
            display: flex;
            justify-content: flex-end;
        }
        
        /* Reduced width container styling */
        #history-bar-container > div {
            max-width: 50%;
            min-width: fit-content;
        }
        
        /* History controls styling - no responsive modifications */
        

        
        /* Current snapshot date display styling */
        #current-snapshot-date-display {
            white-space: nowrap;
            flex-shrink: 0;
            transition: all 0.2s ease-in-out;
        }
        
        #current-snapshot-date-display:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
        }
        
        /* Date display styling - no responsive modifications */
        
        /* Focus styles for accessibility */
        .editable-cell:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: -2px;
            background-color: var(--bg-secondary);
            box-shadow: inset 0 0 0 1px var(--border-focus);
            color: #1a1a1a !important; /* Texte noir foncé quand on écrit */
        }
        
        /* Styles de focus spécifiques pour les colonnes importantes */
        .editable-cell[data-label="Date de saisie"]:focus,
        .editable-cell[data-label="PEC finale"]:focus,
        .editable-cell[data-label="PEC initiale"]:focus,
        .editable-cell[data-label="Diagnostic_initial"]:focus {
            color: #1a1a1a !important; /* Noir foncé maintenu en focus */
            font-size: 1.1rem !important; /* Police plus grande maintenue */
            font-weight: 500 !important; /* Gras maintenu */
        }
        
        /* Numero_tel avec police standard (1.1rem) même en focus */
        .editable-cell[data-label="Numero_tel"]:focus,
        .editable-cell[data-label="numero_tel"]:focus {
            color: #1a1a1a !important; /* Noir foncé maintenu en focus */
            font-size: 1.1rem !important; /* Police standard maintenue */
            font-weight: 500 !important; /* Gras maintenu */
        }
        
        /* Nom_Prénom et DDN en gras même en focus */
        .editable-cell[data-label="Nom_Prénom"]:focus,
        .editable-cell[data-label="DDN"]:focus {
            color: #1a1a1a !important; /* Noir foncé maintenu en focus */
            font-size: 1.1rem !important; /* Police plus grande maintenue */
            font-weight: 700 !important; /* Gras (bold) maintenu */
        }
        
        /* Information complementaire en rouge même en focus */
        .editable-cell[data-label="Information complementaire"]:focus {
            color: #dc2626 !important; /* Rouge maintenu en focus */
            font-size: 1.1rem !important; /* Police plus grande maintenue */
            font-weight: 500 !important; /* Gras maintenu */
        }
        
        /* Texte noir foncé pour toutes les cellules éditables (sauf Information complementaire) */
        .editable-cell:not([data-label="Information complementaire"]) {
            color: #1a1a1a !important;
        }
        
        /* S'assurer que le texte reste noir foncé même après avoir écrit (sauf Information complementaire) */
        .editable-cell:not(:empty):not([data-label="Information complementaire"]) {
            color: #1a1a1a !important;
        }
        
        /* Loading states */
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        
        /* Modern form input styles */
        input[type="text"], 
        input[type="password"], 
        input[type="email"], 
        input[type="number"],
        input[type="date"],
        select {
            padding: 0.75rem 1rem;
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-size: 1rem;
            transition: var(--transition);
            background-color: var(--bg-primary);
        }
        
        input[type="text"]:focus,
        input[type="password"]:focus,
        input[type="email"]:focus,
        input[type="number"]:focus,
        input[type="date"]:focus,
        select:focus {
            outline: none;
            border-color: var(--border-focus);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Style pour le champ mot de passe en erreur */
        .password-error {
            border-color: var(--danger-color) !important;
            background-color: rgba(220, 38, 38, 0.05) !important;
            box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.1) !important;
        }
        
        .password-error::placeholder {
            color: var(--danger-color);
        }
        
        /* Enhanced button styles */
        button {
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        /* Button hover effects */
        button:hover::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        button:hover::before {
            width: 300px;
            height: 300px;
        }
        
        /* Enhanced message box */
        .message-box {
            backdrop-filter: blur(10px);
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Login container enhancements */
        #login-container {
            animation: fadeInUp 0.6s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Table container animations */
        #table-container {
            animation: fadeIn 0.5s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Table styling - no responsive modifications */
        
        /* Smart Calendar Styles */
        .month-nav-btn {
            transition: all 0.2s ease-in-out;
            border-width: 2px;
        }
        
        .month-nav-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .month-nav-btn.active {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            border-color: #1d4ed8;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .month-content {
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .week-header {
            background: linear-gradient(90deg, #f8fafc, #e2e8f0);
            border-left: 3px solid #3b82f6;
        }
        
        .snapshot-item {
            transition: all 0.2s ease-in-out;
        }
        
        .snapshot-item:hover {
            transform: translateX(4px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .snapshot-item.current {
            background: linear-gradient(135deg, #dbeafe, #bfdbfe);
            border-left-color: #3b82f6;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);
        }
        
        /* Sticky month navigation */
        .sticky-month-nav {
            position: sticky;
            top: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #e5e7eb;
            z-index: 20;
        }
        
        /* Month header gradient */
        .month-header-gradient {
            background: linear-gradient(135deg, #dbeafe 0%, #e0e7ff 100%);
            border-left: 4px solid #3b82f6;
        }
        
        /* Week section styling */
        .week-section {
            margin-left: 1rem;
            border-left: 2px solid #e5e7eb;
            padding-left: 1rem;
        }
        
        /* Calendar styling - no responsive modifications */
    </style>
</head>
<body class="bg-gray-100 flex flex-col h-screen overflow-hidden text-sm md:text-base lg:text-lg">

    <div id="message-box" class="message-box hidden"><p id="message-text" class="font-bold"></p></div>

    <!-- Login container -->
    <div id='login-container' class="bg-white p-8 md:p-10 lg:p-12 rounded-xl shadow-lg w-full max-w-md mx-auto my-auto flex flex-col items-center space-y-4 md:space-y-6 transition-all duration-300 ease-in-out hidden">
        <h2 class="text-2xl md:text-3xl lg:text-4xl font-bold text-gray-800">Accéder au tableau</h2>
        <input type='password' id='password' placeholder='Mot de passe (Appuyez sur Entrée)' class="w-full p-3 md:p-4 lg:p-5 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 transition-colors">
        <div class="flex items-center space-x-2 w-full">
            <input type='checkbox' id='toggle-password' class="w-4 h-4 md:w-5 md:h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500">
            <label for="toggle-password" class="text-sm md:text-base font-medium text-gray-700">Afficher le mot de passe</label>
        </div>
        <button onclick='checkPassword()' class="w-full bg-green-500 text-white font-bold p-3 md:p-4 lg:p-5 rounded-lg shadow-md hover:bg-green-600 transition-colors">Valider</button>
        
        <!-- Indicateur des raccourcis clavier -->
        <div class="text-center text-xs text-gray-500 mt-2">
            <p>💡 <strong>Raccourcis :</strong> Entrée (Valider) • G (Galerie) • N (Nouvelle ligne)</p>
        </div>
        
        <p id='error-message' class="text-red-500 font-medium text-sm md:text-base"></p>
    </div>

    <!-- Bouton d'ajout - visible sur tous les écrans (en dehors du conteneur de tableau) -->
        <button id="fab-add"
                class="bg-green-500 text-white font-bold hover:bg-green-600 transition-colors"
                onclick="addRow()" title="Ajouter une nouvelle ligne" aria-label="Ajouter">
          <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
            <path d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"/>
          </svg>
        </button>
        
    <!-- Table container -->
    <div id='table-container' class="bg-white relative p-2 md:p-4 lg:p-6 pt-4 md:pt-4 lg:pt-6 rounded-xl w-full flex-grow overflow-y-auto hidden transition-all duration-300 ease-in-out flex flex-col m-2 shadow-xl">
        <div class="flex flex-col md:flex-row items-start md:items-center justify-between mb-2 p-2 bg-gradient-to-r from-gray-50 to-gray-100 rounded-lg border border-gray-200">
            <div class="flex-grow">
                <div class="flex flex-wrap items-center gap-2 mb-1">
                    <h2 id="staff-title" class="text-lg md:text-xl font-bold text-gray-800 tracking-tight">S-T</h2>
                
                <!-- Box affichant le nombre de lignes - à côté du titre -->
                <div id="row-count-display" class="hidden sm:flex items-center justify-center px-2 py-1 bg-gray-100 border border-gray-300 rounded-lg text-gray-700 text-lg md:text-xl font-medium min-w-12 ml-2">
                    <span>N=</span>
                    <span id="row-count-number" class="ml-1 font-bold">0</span>
                </div>
                    <span id="sync-status" class="hidden sm:inline-flex sync-pending-animation px-2 py-1 rounded-full text-xs font-semibold border-2 bg-white shadow-sm">
                        <span class="sync-text">Initialisation...</span>
                        <i class="sync-icon fa-solid fa-check hidden"></i>
                    </span>
                </div>

            </div>
        </div>

        <div id="error-display" class="my-2 text-red-600 font-bold hidden p-2 bg-red-50 rounded-lg border-l-4 border-red-400 text-sm md:text-base"></div>



        <!-- History Controls Row - Toggle button and history buttons on same level -->
        <div class="flex justify-between items-center mb-3">
            <!-- Toggle button container -->
            <div class="w-4 h-4">
                <button id="history-toggle-btn" onclick="toggleHistoryBarSimple()" title="Fermer/Ouvrir la barre d'historique" aria-label="Toggle historique" class="bg-gray-400 text-white p-0 rounded hover:bg-gray-500 transition-colors w-4 h-4 flex items-center justify-center">
                    <i id="history-toggle-icon" class="fa-solid fa-plus w-2 h-2 flex items-center justify-center text-center leading-none"></i>
                </button>
            </div>

            <!-- History Bar Container - This is what gets toggled -->
            <div id="history-bar-container" class="flex justify-end">
                <!-- Single line container for all snapshot controls -->
                <div class="flex items-center gap-2 p-3 bg-blue-50 rounded-lg border border-blue-200 w-full relative z-20">
                    <!-- Navigation buttons - Responsive visibility -->

                    
                    <!-- Desktop navigation buttons -->

                    
                    <!-- Action buttons - Fixed styling for all screen sizes -->
                    <div class="flex items-center gap-2 justify-center">
                        <button onclick="refreshTableData()" title="Actualiser le tableau avec les données les plus récentes" aria-label="Actualiser" class="bg-green-600 text-white px-2 py-1 rounded text-xs hover:bg-green-700 transition-colors font-medium flex items-center justify-center">
                            <i class="fa-solid fa-arrows-rotate w-3 h-3"></i>
                        </button>
                        
                        <!-- Bouton Snapshot Manuel -->
                        <button onclick="createManualSnapshot()" title="Créer un snapshot manuel de la table actuelle" aria-label="Snapshot Manuel" class="bg-purple-600 text-white px-2 py-1 rounded text-xs hover:bg-purple-700 transition-colors font-medium flex items-center justify-center">
                            <i class="fa-solid fa-camera w-3 h-3"></i>
                        </button>
                        
                        <!-- Calendar dropdown for snapshot dates -->
                        <div class="relative z-20">
                            <button id="snapshot-calendar-btn" onclick="toggleSnapshotCalendar()" title="Choisir une date de snapshot" aria-label="Calendrier des snapshots" class="bg-indigo-600 text-white px-2 py-1 rounded text-xs hover:bg-indigo-700 transition-colors font-medium flex items-center justify-center">
                                <i class="fa-solid fa-calendar-days w-3 h-3"></i>
                                <span id="calendar-btn-text" class="ml-1">Calendrier</span>
                            </button>
                            
                            <!-- Enhanced mobile-friendly calendar dropdown -->
                            <div id="snapshot-calendar-dropdown" class="hidden absolute top-full left-0 mt-2 bg-white border border-gray-300 rounded-lg shadow-lg z-50 min-w-64 max-h-96 overflow-y-auto">
                                <div class="p-3 border-b border-gray-200">
                                    <h3 class="text-sm font-semibold text-gray-700 mb-2">📅 Snapshots disponibles</h3>
                                    <div class="text-xs text-gray-500">Cliquez sur une date pour charger le snapshot</div>
                                </div>
                                <div id="snapshot-dates-list" class="p-2">
                                    <!-- Dates will be populated here -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Current Snapshot Date Display - Fixed styling for all screen sizes -->
                    <div id="current-snapshot-date-display" class="flex items-center gap-1 px-2 py-1 bg-gray-100 border border-gray-300 rounded-md text-gray-700 text-xs font-medium justify-center">
                        <i class="fa-solid fa-calendar-day w-3 h-3 text-blue-600"></i>
                        <span id="current-snapshot-date-text" class="text-center">Données en direct</span>
                    </div>
                </div>
            </div>
        </div>



        <div id="button-bar" class="flex flex-nowrap items-center gap-1 mb-3 p-1 bg-gray-50 rounded-lg border border-gray-200 overflow-x-auto">
            <button onclick='saveManually()' title="Sauvegarder (Cmd+Z/Ctrl+Z ou Cmd+S/Ctrl+S)" aria-label="Sauvegarder" class='bg-yellow-400 text-gray-800 p-1.5 rounded-lg hover:bg-yellow-500 transition-colors flex items-center justify-center w-7 h-7'>
                <i class="fa-solid fa-save w-3.5 h-3.5"></i>
            </button>
            <button id="undo-button" onclick="undo()" disabled title="Annuler (Cmd+Y / Ctrl+Y)" aria-label="Annuler" class="bg-gray-300 text-gray-700 p-1.5 rounded-lg hover:bg-gray-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-rotate-left w-3.5 h-3.5"></i>
            </button>
            <button id="redo-button" onclick="redo()" disabled title="Rétablir (Cmd+Shift+Z / Ctrl+Y)" aria-label="Rétablir" class="bg-gray-300 text-gray-700 p-1.5 rounded-lg hover:bg-gray-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-rotate-right w-3.5 h-3.5"></i>
            </button>
            

            <button onclick="downloadExcel()" title="Exporter en Excel" aria-label="Exporter en Excel" class="bg-green-600 text-white p-1.5 rounded-lg hover:bg-green-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-file-excel w-3.5 h-3.5"></i>
            </button>
            <button onclick="downloadPDF()" title="Exporter en PDF" aria-label="Exporter en PDF" class="bg-red-600 text-white p-1.5 rounded-lg hover:bg-red-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-file-pdf w-3.5 h-3.5"></i>
            </button>
            <button onclick="downloadImage()" title="Exporter en image (PNG)" aria-label="Exporter en image (PNG)" class="bg-purple-600 text-white p-1.5 rounded-lg hover:bg-purple-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-image w-3.5 h-3.5"></i>
            </button>
            <button onclick="document.getElementById('excel-input').click()" title="Importer depuis Excel" aria-label="Importer depuis Excel" class="bg-blue-600 text-white p-1.5 rounded-lg hover:bg-blue-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-upload w-3.5 h-3.5"></i>
            </button>
            <input id="excel-input" type="file" accept=".xlsx,.xls,.csv" class="hidden" onchange="importExcelFromFile(this.files[0])" />
            
            <!-- Bouton Galerie d'images -->
            <button onclick="openSimpleGallery()" title="Galerie d'images (G)" aria-label="Galerie d'images" class="bg-indigo-600 text-white p-1.5 rounded-lg hover:bg-indigo-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-images w-3.5 h-3.5"></i>
            </button>
            <button onclick="zoomOut()" title="Réduire (−)" aria-label="Réduire" class="bg-gray-700 text-white p-1.5 rounded-lg hover:bg-gray-800 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-minus w-3.5 h-3.5"></i>
            </button>
            <button id="zoom-display" onclick="zoomReset()" title="Réinitialiser à 100%" aria-label="Réinitialiser à 100%" class="bg-gray-500 text-white px-2 py-2 rounded-lg hover:bg-gray-600 transition-colors text-xs w-8 h-8">100%</button>
            <button onclick="zoomIn()" title="Agrandir (+)" aria-label="Agrandir" class="bg-gray-700 text-white p-2 rounded-lg hover:bg-gray-800 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-plus w-4 h-4"></i>
            </button>
            <input id="row-color-picker"
                   type="color"
                   title="Choisir la couleur de surlignage des lignes"
                   class="w-8 h-8 p-1 border border-gray-300 rounded-lg cursor-pointer hover:border-gray-400 transition-colors" />
            <button onclick="clearAllRowColors()" title="Effacer toutes les couleurs" aria-label="Effacer toutes les couleurs" class="bg-gray-200 text-gray-800 p-2 rounded-lg hover:bg-gray-300 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-trash-can w-4 h-4"></i>
            </button>
            <button id="filter-colored-toggle"
                    onclick="toggleColoredFilter()"
                    title="Afficher seulement les lignes colorées"
                    aria-label="Filtrer lignes colorées"
                    class="bg-gray-200 text-gray-800 p-2 rounded-lg hover:bg-gray-300 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-filter w-4 h-4"></i>
            </button>
                        <button id="paint-mode-toggle"
                    onclick="cyclePaintMode()"
                    title="Mode de peinture: Auto/Colorer/Effacer (appuyez sur P pour changer)"
                    aria-label="Basculer le mode de peinture"
                    class="bg-gray-200 text-gray-800 p-2 rounded-lg hover:bg-gray-300 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-palette w-4 h-4"></i>
            </button>
            
            <!-- Bouton Mode Visualisation -->
            <button id="view-mode-toggle"
                    onclick="toggleViewMode()"
                    title="Basculer le mode visualisation (lecture seule)"
                    aria-label="Basculer le mode visualisation"
                    class="bg-blue-200 text-blue-800 p-2 rounded-lg hover:bg-blue-300 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-eye w-4 h-4"></i>
            </button>

        </div>

        <div class="overflow-auto w-full relative z-10" style="max-width: 100vw; max-height: 85vh;">
            <table id='data-table' class="w-full text-left text-gray-500 text-xs md:text-sm lg:text-base">
                <thead class="text-xs text-white uppercase bg-green-700 relative z-10">
                    <tr>
                        <th scope="col" class="py-2 px-2 md:px-4 rounded-tl-lg frozen-column-header frozen-1">No</th>
                        <th scope="col" class="py-2 px-1 text-center">Effacer<br><input id="select-all" type="checkbox" class="align-middle"></th>
                        <th scope="col" class="py-2 px-2 md:px-4">Date de saisie</th>
                        <th scope="col" class="py-2 px-2 md:px-4">PEC finale</th>
                        <th scope="col" class="py-2 px-2 md:px-4">PEC initiale</th>
                        <th scope="col" class="py-2 px-2 md:px-4">Nom_Prénom</th>
                        <th scope="col" class="py-2 px-2 md:px-4">DDN</th>
                        <th scope="col" class="py-2 px-2 md:px-4">Diagnostic_initial</th>
                        <th scope="col" class="py-2 px-2 md:px-4">information complementaire</th>
                        <th scope="col" class="py-2 px-2 md:px-4 rounded-tr-lg">Numero_tel</th>
                    </tr>
                </thead>
                <tbody id="table-body"></tbody>
                <tfoot class="bg-white border-t-2 border-gray-300">
                    <tr>
                        <td colspan="2" class="py-2 px-2">
                            <button class="bg-green-500 text-white font-bold p-2 rounded-lg hover:bg-green-600 transition-colors text-lg w-10 h-10 flex items-center justify-center mx-auto" onclick="addRow()" title="Ajouter une nouvelle ligne">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"/>
                                </svg>
                            </button>
                        </td>
                        <td colspan="8" class="bg-white"></td>
                    </tr>
                </tfoot>
            </table>
        </div>
        

        

        <div id="confirmation-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 h-full w-full hidden z-50">
            <div class="relative top-1/4 mx-auto p-5 border w-11/12 max-w-sm shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <h3 class="text-lg md:text-xl leading-6 font-medium text-gray-900" id="modal-message"></h3>
                    <div class="mt-4 flex justify-around">
                        <button id="modal-confirm-btn" class="px-4 py-2 bg-red-600 text-white text-base font-medium rounded-md w-24 shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">Oui</button>
                        <button id="modal-cancel-btn" class="px-4 py-2 bg-gray-300 text-black text-base font-medium rounded-md w-24 shadow-sm hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500">Non</button>
                    </div>
                </div>
            </div>
        </div>


    </div>

    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>

    <!-- App -->
    <script type="module">
        // Configuration - In production, these should be environment variables
        const APP_CONFIG = { 
            password: 'p123', 
            version: '2.5.4-enter-on-login' 
        };
        
        const supabaseConfig = { 
            supabaseUrl: 'https://fiecugxopjxzqfdnaqsu.supabase.co', 
            supabaseAnonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ1MDU2NTcsImV4cCI6MjA3MDA4MTY1N30.xd9Thasg4r8Nrwxx5nFwyGB_ufPIvok4XB-78dilpsw', 
            supabaseServiceKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NDUwNTY1NywiZXhwIjoyMDcwMDgxNjU3fQ.5m7nLHxHxOkxQf8maZis7Y7jynqu2dWqIzEbgWvOTcE',
            tableName: 'staffTable', 
            primaryKeyColumn: 'No' 
        };

        // Initialize Supabase client
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';
        const supabase = createClient(supabaseConfig.supabaseUrl, supabaseConfig.supabaseAnonKey);
        
        // Make Supabase globally available
        window.supabase = supabase;
        window.supabaseConfig = supabaseConfig;
        
        // Global state management
        const appState = { 
            isLoggedIn: false, 
            masterSource: 'supabase', 
            dataHash: null, 
            localData: null, 
            serverColumns: null 
        };
        
        // DOM Element Cache for Performance
        const domCache = {
            table: null,
            tbody: null,
            status: null,
            saveBtn: null,
            refreshBtn: null,
            historyBar: null,
            autosaveIndicator: null,
            
            // Initialize cache
            init() {
                this.table = document.getElementById('data-table');
                this.tbody = document.querySelector('#data-table tbody');
                this.status = document.getElementById('sync-status');
                this.saveBtn = document.getElementById('save-btn');
                this.refreshBtn = document.getElementById('refresh-btn');
                this.historyBar = document.getElementById('history-bar');
                this.autosaveIndicator = document.getElementById('autosave-indicator');
            },
            
            // Get cached element or fallback to query
            get(elementId) {
                return this[elementId] || document.getElementById(elementId);
            }
        };
        
        // Performance Utilities
        const performanceUtils = {
            // Efficient debounce function
            debounce(func, delay, immediate = false) {
                let timeoutId;
                return function debounced(...args) {
                    const callNow = immediate && !timeoutId;
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        timeoutId = null;
                        if (!immediate) func.apply(this, args);
                    }, delay);
                    if (callNow) func.apply(this, args);
                };
            },
            
            // Throttle function for high-frequency events
            throttle(func, delay) {
                let lastCall = 0;
                return function throttled(...args) {
                    const now = Date.now();
                    if (now - lastCall >= delay) {
                        lastCall = now;
                        return func.apply(this, args);
                    }
                };
            },
            
            // RAF-based smooth DOM updates
            scheduleUpdate(callback) {
                if (this._pendingUpdate) return;
                this._pendingUpdate = true;
                requestAnimationFrame(() => {
                    this._pendingUpdate = false;
                    callback();
                });
            }
        };
        
        // Optimized Event Management System
        const eventManager = {
            // Debounced event handlers cache
            debouncedHandlers: new Map(),
            
            // Get or create debounced handler
            getDebounced(key, handler, delay = 300) {
                if (!this.debouncedHandlers.has(key)) {
                    this.debouncedHandlers.set(key, performanceUtils.debounce(handler, delay));
                }
                return this.debouncedHandlers.get(key);
            },
            
            // Setup efficient event delegation for table
            initTableEvents() {
                const tableBody = domCache.tbody || document.querySelector('#data-table tbody');
                if (!tableBody) return;
                
                // Single delegated input handler for all cells (Excel mode - no timer autosave)
                const debouncedInput = this.getDebounced('table-input', (e) => {
                    const cell = e.target.closest('td[contenteditable]');
                    if (cell) {
                        // Excel mode: Only mark as dirty, no timer-based autosave
                        console.log('📝 [EXCEL-SAVE] Input detected in cell:', cell.getAttribute('data-label'), '- save on blur only');
                        isDirty = true;
                        isTyping = true;
                        lastEditAt = Date.now();
                    }
                }, 150);
                
                // Remove any existing listeners and add delegated ones
                tableBody.removeEventListener('input', debouncedInput);
                tableBody.addEventListener('input', debouncedInput, { passive: true });
                
                // Throttled scroll handler
                const throttledScroll = performanceUtils.throttle(() => {
                    // Update any scroll-dependent UI
                }, 100);
                
                window.removeEventListener('scroll', throttledScroll);
                window.addEventListener('scroll', throttledScroll, { passive: true });
            },
            
            // Cleanup unused handlers
            cleanup() {
                this.debouncedHandlers.clear();
            },
            
            // Performance monitoring
            monitor: {
                startTime: Date.now(),
                metrics: {},
                
                mark(name) {
                    this.metrics[name] = Date.now() - this.startTime;
                },
                
                report() {
                    console.log('📊 Performance Metrics:', this.metrics);
                    return this.metrics;
                }
            }
        };
        
        // Make app state, DOM cache, performance utils, and event manager globally available
        window.appState = appState;
        window.domCache = domCache;
        window.performanceUtils = performanceUtils;
        window.eventManager = eventManager;
        
        // Application state variables
        let isDirty = false;
        let saveTimeout = null;
        let history = [];
        let historyDebounceTimeout = null;
        
        // ✅ GLOBAL: Variables pour la capture et restauration du focus
        let capturedFocusState = null;
        let focusRestorationEnabled = true;
        let isRestoringCursor = false; // Flag to prevent save cascades during restoration
        let isExcelSaveInProgress = false; // Flag for Excel-like save operations
        
        // Function to update global reference
        function updateGlobalFocusState(newState) {
            capturedFocusState = newState;
            window.capturedFocusState = newState;
            return newState;
        }
        
        // Excel-like save behavior - save only when moving between cells
        async function saveModifiedCell(cell, oldValue, newValue) {
            if (!cell || oldValue === newValue) return false;
            
            console.log('💾 [EXCEL-SAVE] ========== EXCEL-LIKE SAVE START ==========');
            console.log('💾 [EXCEL-SAVE] Cell modified, saving immediately:', {
                column: cell.getAttribute('data-label'),
                oldValue: oldValue?.substring(0, 50) + (oldValue?.length > 50 ? '...' : ''),
                newValue: newValue?.substring(0, 50) + (newValue?.length > 50 ? '...' : ''),
                timestamp: new Date().toISOString()
            });
            
            // Immediate protection flags - set before any other operations
            isExcelSaveInProgress = true;
            isRestoringCursor = true; // Double protection
            console.log('🔒 [EXCEL-SAVE] IMMEDIATE: Excel save and cursor restoration flags set');
            
            // Show Excel-mode status
            updateStatus('Sauvegarde Excel-like en cours...', 'saving');
            
            // Capture focus state with enhanced protection
            const activeElement = document.activeElement;
            const protectionTimestamp = Date.now();
            
            if (activeElement && activeElement.tagName === 'TD' && activeElement.contentEditable === 'true') {
                updateGlobalFocusState({
                    element: activeElement,
                    position: getCaretOffsetWithin(activeElement),
                    timestamp: protectionTimestamp,
                    rowIndex: Array.from(activeElement.closest('tr').parentNode.querySelectorAll('tr')).indexOf(activeElement.closest('tr')),
                    colLabel: activeElement.getAttribute('data-label') || '',
                    excelSaveProtection: true // Special flag for Excel saves
                });
                console.log('📝 [EXCEL-SAVE] Enhanced focus captured on active cell:', activeElement.getAttribute('data-label'));
            } else {
                // If no active element, try to capture the cell that was just modified
                updateGlobalFocusState({
                    element: cell,
                    position: cell.textContent ? cell.textContent.length : 0, // Place cursor at end
                    timestamp: protectionTimestamp,
                    rowIndex: Array.from(cell.closest('tr').parentNode.querySelectorAll('tr')).indexOf(cell.closest('tr')),
                    colLabel: cell.getAttribute('data-label') || '',
                    excelSaveProtection: true // Special flag for Excel saves
                });
                console.log('📝 [EXCEL-SAVE] Enhanced focus captured on modified cell:', cell.getAttribute('data-label'));
            }
            
            try {
                // Mark local save in progress to prevent realtime conflicts
                window.isLocalSaveInProgress = true;
                console.log('🔒 [EXCEL-SAVE] Local save in progress flag set');
                
                // Save to history and local draft first
                console.log('💾 [EXCEL-SAVE] Saving to local history and draft...');
                saveStateToHistory();
                saveLocalDraft();
                
                // Then sync to database immediately
                console.log('💾 [EXCEL-SAVE] Syncing to database...');
                await syncToMaster(false); // false = not manual save
                
                console.log('✅ [EXCEL-SAVE] Database sync completed successfully');
                updateStatus('Cellule sauvée (Excel-like)', 'success');
                
                // Extend the focus protection window with enhanced timestamp
                if (capturedFocusState) {
                    capturedFocusState.timestamp = Date.now() + 2000; // Extend protection by 2 seconds
                    capturedFocusState.excelSaveProtection = true;
                    console.log('🔒 [EXCEL-SAVE] Extended focus protection window with enhanced timestamp');
                }
                
                return true;
            } catch (error) {
                console.error('❌ [EXCEL-SAVE] Cell save failed:', error);
                updateStatus('Erreur sauvegarde cellule', 'error');
                
                // On error, still try to maintain cursor position
                if (capturedFocusState) {
                    capturedFocusState.timestamp = Date.now() + 1000; // Shorter protection on error
                    console.log('⚠️ [EXCEL-SAVE] Maintained cursor protection despite error');
                }
                
                return false;
            } finally {
                // Clear local save flag immediately
                window.isLocalSaveInProgress = false;
                console.log('🔓 [EXCEL-SAVE] Local save flag cleared');
                
                // Clear cursor restoration flag after a shorter delay
                setTimeout(() => {
                    isRestoringCursor = false;
                    console.log('🔓 [EXCEL-SAVE] Cursor restoration flag cleared');
                }, 1000); // 1 second for cursor flag
                
                // Clear Excel save flag after a longer delay for maximum protection
                setTimeout(() => {
                    isExcelSaveInProgress = false;
                    console.log('🔓 [EXCEL-SAVE] Excel save flag cleared - realtime sync re-enabled');
                }, 4000); // Extended to 4 seconds for better protection
                
                console.log('💾 [EXCEL-SAVE] ========== EXCEL-LIKE SAVE END ==========');
            }
        }
        
        // Persistent undo/redo stacks (per session)
        let operationHistory = []; // already-declared enhanced history (kept for clarity)
        let redoHistory = [];
        let isPerformingUndoRedo = false;
        let suppressRealtimeUntil = 0; // timestamp until which realtime updates are ignored
        let suppressAutosaveUntil = 0;  // timestamp until which autosave is paused
        let undoRedoSyncTimeout = null; // Timeout for automatic sync after undo/redo
        let isTyping = false;
        let lastEditAt = 0;
        let typingTimer = null;
        let isSyncing = false;
        let realtimeSubscription = null;
        let lastSaveTime = 0; // Timestamp de la dernière sauvegarde
        const REALTIME_COOLDOWN_MS = 2000; // 2 secondes de cooldown après sauvegarde
        
        // Enhanced undo system
        // operationHistory is declared above in the persistent stacks section
        let currentOperation = null; // Current operation being built
        let operationTimeout = null; // Timeout for operation completion
        
        // Excel-style operation types for undo/redo tracking
        const OPERATION_TYPES = {
            CELL_EDIT: 'cell_edit',           // Cell content modification
            ROW_INSERT: 'row_insert',         // Row insertion
            ROW_DELETE: 'row_delete',         // Row deletion (single or multiple)
            BULK_EDIT: 'bulk_edit'            // Multiple cell edits
        };
        
        // Only track real data changes (no colors, selections, or UI changes)
        const CONTENT_MODIFICATION_TYPES = [
            OPERATION_TYPES.CELL_EDIT,
            OPERATION_TYPES.ROW_INSERT,
            OPERATION_TYPES.ROW_DELETE,
            OPERATION_TYPES.BULK_EDIT
        ];
        
        // Cell edit grouping configuration
        const CELL_EDIT_GROUPING_DELAY = 1300; // 1.3 seconds to group typing edits
        let cellEditTimeout = null;
        let pendingCellEdit = null;
        
        // Excel-style cell edit tracking with grouping
        function trackCellEdit(cell, oldValue, newValue, columnLabel) {
            // Check if undo/redo is disabled
            if (snapshotMode === 'snapshot' || isViewMode) {
                return;
            }
            
            const row = cell.closest('tr');
            const rowKey = keyForRow(row);
            
            // Create cell edit data with stable addressing
            const cellEditData = {
                rowKey: rowKey,
                columnLabel: columnLabel,
                oldValue: oldValue,
                newValue: newValue,
                timestamp: Date.now()
            };
            
            // Clear existing timeout
            if (cellEditTimeout) {
                clearTimeout(cellEditTimeout);
            }
            
            // If we have a pending edit for the same cell, group them
            if (pendingCellEdit && 
                pendingCellEdit.rowKey === rowKey && 
                pendingCellEdit.columnLabel === columnLabel) {
                
                // Update the pending edit
                pendingCellEdit.newValue = newValue;
                pendingCellEdit.timestamp = Date.now();
                
                // Start operation if not already started
                if (!currentOperation || currentOperation.type !== OPERATION_TYPES.CELL_EDIT) {
                    startOperation(OPERATION_TYPES.CELL_EDIT, {
                        rowKey: rowKey,
                        columnLabel: columnLabel,
                        initialValue: pendingCellEdit.oldValue,
                        currentValue: newValue
                    });
                } else {
                    // Update existing operation
                    currentOperation.data.currentValue = newValue;
                    currentOperation.data.timestamp = Date.now();
                }
                
                // Clean: Removed debug log
            } else {
                // New cell edit - start fresh operation
                pendingCellEdit = cellEditData;
                
                startOperation(OPERATION_TYPES.CELL_EDIT, {
                    rowKey: rowKey,
                    columnLabel: columnLabel,
                    initialValue: oldValue,
                    currentValue: newValue
                });
                
                // Clean: Removed debug log
            }
            
            // Set timeout to complete operation after grouping delay
            cellEditTimeout = setTimeout(() => {
                if (currentOperation && currentOperation.type === OPERATION_TYPES.CELL_EDIT) {
                    // ENHANCED: Set suppression windows before completing operation
                    const SUPPRESSION_MS = 2000;
                    suppressRealtimeUntil = Date.now() + SUPPRESSION_MS;
                    suppressAutosaveUntil = Date.now() + SUPPRESSION_MS;
                    
                    // Clean: Removed debug log
                    
                    completeOperation();
                    pendingCellEdit = null;
                }
            }, CELL_EDIT_GROUPING_DELAY);
        }
        
        // Helper function to get column label for a cell
        function getColumnLabelForCell(cell) {
            const cellIndex = Array.from(cell.parentElement.cells).indexOf(cell);
            if (cellIndex >= 2) { // Skip No and Delete columns
                const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2);
                const headerIndex = cellIndex - 2;
                if (headers[headerIndex]) {
                    return headers[headerIndex].textContent;
                }
            }
            return 'Unknown Column';
        }
        
        // ENHANCED: Utility function to check if undo/redo operations are in progress
        function isUndoRedoInProgress() {
            return isPerformingUndoRedo || 
                   (currentOperation && currentOperation.type) ||
                   Date.now() < suppressAutosaveUntil ||
                   Date.now() < suppressRealtimeUntil;
        }
        
        // ENHANCED: Function to get current undo/redo status for debugging
        function getUndoRedoStatus() {
            return {
                isPerformingUndoRedo,
                hasCurrentOperation: !!(currentOperation && currentOperation.type),
                suppressAutosaveUntil: Date.now() < suppressAutosaveUntil,
                suppressRealtimeUntil: Date.now() < suppressRealtimeUntil,
                timeUntilAutosaveUnlock: Math.max(0, suppressAutosaveUntil - Date.now()),
                timeUntilRealtimeUnlock: Math.max(0, suppressRealtimeUntil - Date.now())
            };
        }
        
                        // Autosave configuration
                const AUTOSAVE_DELAY_MS = 1000; // 1 second after last edit when idle
        let autosaveTicker = null;
        let lastShownCountdown = null;
        let lastFocusInfo = null;
        let lastCellPos = null;
        
        // Zoom functionality
        let zoomFactor = parseFloat(localStorage.getItem('zoomFactor') || '1');

        // Snapshot System State
        let snapshotMode = 'live'; // 'live' or 'snapshot'
        let currentSnapshotDate = null;
        let availableSnapshots = [];
        let currentSnapshotIndex = -1;
        
        // History bar visibility state (saved in localStorage)

        
        // Make snapshot system globally available
        window.snapshotMode = snapshotMode;
        window.currentSnapshotDate = currentSnapshotDate;
        window.availableSnapshots = availableSnapshots;
        window.currentSnapshotIndex = currentSnapshotIndex;

        window.realtimeSubscription = realtimeSubscription;
        
        // Make other important variables globally available
        window.isViewMode = false; // Will be updated in initializeApp
        window.isInitialLoad = true; // Will be set to false after initialization
        window.isRestoringFocus = false; // Flag to prevent edit events during focus restoration
        
        // Function to refresh calendar display
        function refreshSnapshotCalendar() {
            // Clean: Removed debug log
            populateSnapshotCalendar();
            updateHistoryNavigation();
        }
        
        // Function to clean storage and database completely
        async function cleanStorageAndDatabase() {
            try {
                // Clean: Removed debug log
                
                // First, clean the database
                const { error: dbError } = await supabase
                    .from('table_snapshots_index')
                    .delete()
                    .neq('id', '00000000-0000-0000-0000-000000000000');
                
                if (dbError) {
                    console.error('❌ Error cleaning database:', dbError);
                    return;
                }
                
                // Clean: Removed debug log
                
                // Then, clean the storage bucket
                const { data: storageFiles, error: listError } = await supabase.storage
                    .from('table-snapshots')
                    .list('', { limit: 1000 });
                
                if (listError) {
                    console.error('❌ Error listing storage files:', listError);
                    return;
                }
                
                if (storageFiles && storageFiles.length > 0) {
                    const fileNames = storageFiles.map(file => file.name);
                    // Clean: Removed debug log
                    
                    const { error: removeError } = await supabase.storage
                        .from('table-snapshots')
                        .remove(fileNames);
                    
                    if (removeError) {
                        console.error('❌ Error removing storage files:', removeError);
                    } else {
                        // Clean: Removed debug log
                    }
                } else {
                    // Clean: Removed debug log
                }
                
                // Create a fresh snapshot
                await createDemoSnapshot();
                
                showMessage('Storage et base de données complètement nettoyés', 'success');
                
            } catch (err) {
                console.error('❌ Error cleaning storage and database:', err);
                showMessage('Erreur lors du nettoyage complet', 'error');
            }
        }
        
        // Add logging function
        window.log = function(message, level = 'info') {
            console.log(`[${level.toUpperCase()}] ${message}`);
        };

        
        // Row color management
        let currentRowColor = localStorage.getItem('rowColor') || '#FFF59D';
        let rowColorMap = {};
        let isRowPaintDragging = false;
        let rowPaintAction = 'color';
        let paintMode = localStorage.getItem('rowPaintMode') || 'auto';
        let showOnlyColored = false;
        let isViewMode = localStorage.getItem('viewMode') === 'true'; // Mode visualisation (lecture seule) - restauré depuis localStorage
        let isViewModeProtected = false; // Flag pour protection renforcée sur mobile
        
        // Protection globale: wrapper pour toutes les fonctions de sauvegarde
        function protectedSaveStateToHistory() {
            if (isViewMode && isMobile()) {
                console.log('🔒 Global protection: saveStateToHistory BLOCKED');
                return;
            }
            return saveStateToHistory();
        }
        
        // Initialize from localStorage
        try { 
            lastFocusInfo = JSON.parse(localStorage.getItem('lastFocusInfo') || 'null'); 
            
            // Forcer l'affichage du bouton d'ajout au démarrage (en respectant le mode visualisation)
            const fabAdd = document.getElementById('fab-add');
            if (fabAdd) {
                fabAdd.style.display = 'flex';
                fabAdd.style.visibility = 'visible';
                
                if (isViewMode) {
                    // Mode visualisation : bouton visible mais désactivé
                    fabAdd.style.opacity = '0.5';
                    fabAdd.style.pointerEvents = 'none';
                    fabAdd.style.cursor = 'not-allowed';
                    fabAdd.title = 'Mode visualisation actif - Ajout de lignes désactivé';
                } else {
                    // Mode normal : bouton pleinement fonctionnel
                    fabAdd.style.opacity = '1';
                    fabAdd.style.pointerEvents = 'auto';
                    fabAdd.style.cursor = 'pointer';
                    fabAdd.title = 'Ajouter une nouvelle ligne';
                }
                
                // Clean: Removed debug log
            }
        } catch(_) { 
            lastFocusInfo = null; 
        }
        
        try { 
            lastCellPos = JSON.parse(localStorage.getItem('lastCellPos') || 'null'); 
        } catch(_) { 
            lastCellPos = null; 
        }
        
        try { 
            rowColorMap = JSON.parse(localStorage.getItem('rowColors') || '{}'); 
        } catch(_) { 
            rowColorMap = {}; 
        }

        // Excel-style operation tracking - only real data changes
        function startOperation(type, data = {}) {
            // Check if undo/redo is disabled
            if (snapshotMode === 'snapshot' || isViewMode) {
                // Clean: Removed debug log
                return;
            }
            
            // Only track operations that modify table content
            if (!CONTENT_MODIFICATION_TYPES.includes(type)) {
                // Clean: Removed debug log
                return;
            }
            
            // Clear any pending operations first
            if (currentOperation) {
                // Clean: Removed debug log
                completeOperation();
            }
            
            // Clear any operation timeout
            clearOperationTimeout();
            
            // Reset undo/redo sync timeout when starting new operations
            clearUndoRedoSyncTimeout();
            
            // For row operations, check if there are conflicting operations in history
            if (type === OPERATION_TYPES.ROW_INSERT || 
                type === OPERATION_TYPES.ROW_DELETE) {
                
                // Clean up any conflicting row operations in history
                const conflictingOps = operationHistory.filter(op => 
                    op.type === OPERATION_TYPES.ROW_INSERT || 
                    op.type === OPERATION_TYPES.ROW_DELETE
                );
                
                if (conflictingOps.length > 0) {
                    // Clean: Removed debug log
                    operationHistory = operationHistory.filter(op => 
                        op.type !== OPERATION_TYPES.ROW_INSERT && 
                        op.type !== OPERATION_TYPES.ROW_DELETE
                    );
                }
            }
            
            currentOperation = {
                type: type,
                data: data,
                timestamp: Date.now(),
                tableState: collectTableData(),
                rowColors: { ...rowColorMap }
            };
            
                            // Clean: Removed debug log
        }
        
        function addToOperation(data) {
            if (currentOperation && CONTENT_MODIFICATION_TYPES.includes(currentOperation.type)) {
                Object.assign(currentOperation.data, data);
                // Clean: Removed debug log
                
                // Excel-style: Clear redo stack on ANY modification
                redoHistory = [];
                                    // Clean: Removed debug log
            }
            persistHistoryStacks();
        }
        
        function completeOperation() {
            if (currentOperation) {
                // Only complete operations that modify table content
                if (!CONTENT_MODIFICATION_TYPES.includes(currentOperation.type)) {
                    // Clean: Removed debug log
                    currentOperation = null;
                    return;
                }
                
                // Add final table state
                currentOperation.finalState = collectTableData();
                currentOperation.finalRowColors = { ...rowColorMap };
                
                // Add to operation history
                operationHistory.push(currentOperation);
                
                // Excel-style: Clear redo stack on ANY new user modification
                redoHistory = [];
                // Clean: Removed debug log
                
                persistHistoryStacks();
                
                // Keep exactly 10 operations for circular history navigation
                if (operationHistory.length > 10) {
                    const toRemove = operationHistory.length - 10;
                    for (let i = 0; i < toRemove; i++) {
                        operationHistory.shift();
                    }
                    // Clean: Removed debug log
                }
                
                // Clean: Removed debug log
                
                // Also save to regular history for backward compatibility
                saveStateToHistory();
                
                currentOperation = null;
                updateUndoButtonState();
            }
        }
        
        function cancelOperation() {
            if (currentOperation) {
                // Clean: Removed debug log
                currentOperation = null;
            }
        }

        // Persist/restore undo/redo stacks in sessionStorage
        function persistHistoryStacks() {
            try {
                sessionStorage.setItem('operationHistory', JSON.stringify(operationHistory));
                sessionStorage.setItem('redoHistory', JSON.stringify(redoHistory));
            } catch(_) {}
        }
        function restoreHistoryStacks() {
            try {
                const ops = JSON.parse(sessionStorage.getItem('operationHistory') || '[]');
                const red = JSON.parse(sessionStorage.getItem('redoHistory') || '[]');
                if (Array.isArray(ops)) operationHistory = ops; else operationHistory = [];
                if (Array.isArray(red)) redoHistory = red; else redoHistory = [];
            } catch(_) {
                operationHistory = [];
                redoHistory = [];
            }
            updateUndoButtonState();
        }
        
        // Enhanced undo function with circular history of 10 states
        function undo() {
            if (operationHistory.length === 0) {
                log('Aucune opération à annuler.', 'info');
                return;
            }
            
            const lastOperation = operationHistory.pop();
            // Clean: Removed debug log
            
            // ENHANCED: Show detailed message about what is being undone
            const undoMessage = getDetailedOperationDescription(lastOperation, true);
            showMessage(undoMessage, 'info');
            
            try {
                isPerformingUndoRedo = true;
                // Clear any pending operations before undoing
                if (currentOperation) {
                    // Clean: Removed debug log
                    currentOperation = null;
                }
                clearOperationTimeout();
                
                // Restore table state - only if we have valid data
                if (lastOperation.tableState && lastOperation.tableState.rows && Array.isArray(lastOperation.tableState.rows) && lastOperation.tableState.rows.length > 0) {
                    // Clean: Removed debug log
                    loadTableData(lastOperation.tableState.rows);
                } else if (lastOperation.tableState && lastOperation.tableState.rows) {
                    console.warn(`⚠️ Table state has rows but they are invalid:`, lastOperation.tableState.rows);
                    // Don't restore if data is invalid - this prevents table clearing
                }
                
                // Special handling for cell edits - restore specific cell values using stable addressing
                if (lastOperation.type === OPERATION_TYPES.CELL_EDIT && lastOperation.data) {
                    const { rowKey, columnLabel, initialValue } = lastOperation.data;
                    if (rowKey && columnLabel) {
                        const tbody = document.getElementById('table-body');
                        const targetRow = Array.from(tbody.children).find(tr => keyForRow(tr) === rowKey);
                        
                        if (targetRow) {
                            const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                            const columnIndex = headers.indexOf(columnLabel);
                            const cells = Array.from(targetRow.querySelectorAll('td')).slice(2); // Skip No and Delete columns
                            
                            if (columnIndex >= 0 && cells[columnIndex]) {
                                cells[columnIndex].textContent = initialValue;
                                // Clean: Removed debug log
                            }
                        } else {
                            // Clean: Removed debug log
                        }
                    }
                }
                
                // ✅ CORRECTION: Special handling for row deletions - restore rows in place WITHOUT DUPLICATION
                if (lastOperation.type === OPERATION_TYPES.ROW_DELETE && lastOperation.data) {
                    const { deletedRows, rowData, rowNumbers, rowKeys } = lastOperation.data;
                    log(`🔄 Tentative de restauration de ${deletedRows} ligne(s) supprimée(s)`, 'info');
                    
                    if (rowData && rowData.length > 0) {
                        const tbody = document.getElementById('table-body');
                        const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                        
                        rowData.forEach((rowDataItem, index) => {
                            // ✅ VÉRIFICATION ANTI-DUPLICATION: Vérifier si la ligne existe déjà
                            const existingRowKey = rowKeys ? rowKeys[index] : null;
                            if (existingRowKey) {
                                const existingRow = document.querySelector(`tr[data-key="${existingRowKey}"]`);
                                if (existingRow) {
                                    log(`⚠️ LIGNE DÉJÀ PRÉSENTE - ÉVITER LA DUPLICATION: Clé ${existingRowKey}`, 'warning');
                                    return; // Skip this row to prevent duplication
                                }
                            }
                            
                            log(`✅ Restauration de la ligne ${rowNumbers ? rowNumbers[index] : 'N/A'} (clé: ${existingRowKey})`, 'info');
                            
                            const newRow = document.createElement('tr');
                            newRow.className = 'bg-white hover:bg-gray-100 transition-colors cursor-pointer';
                            
                            // Set the data-key attribute to prevent future duplications
                            if (existingRowKey) {
                                newRow.dataset.key = existingRowKey;
                            }
                            
                            // Create row number cell
                            const numCell = document.createElement('td');
                            numCell.textContent = rowNumbers ? rowNumbers[index] : (tbody.children.length + 1);
                            numCell.className = 'py-2 px-2 md:px-4 font-bold text-gray-800 whitespace-nowrap cursor-pointer frozen-column frozen-1';
                            numCell.setAttribute('data-label', 'No');
                            newRow.appendChild(numCell);
                            
                            // Create delete/selection cell
                            newRow.appendChild(createDeleteCell(newRow));
                            
                            // Create data cells
                            headers.forEach(header => {
                                const value = rowDataItem[header] || '';
                                newRow.appendChild(createEditableCell(header, value));
                            });
                            
                            // Insert at original position if possible
                            if (rowNumbers && rowNumbers[index]) {
                                const targetPosition = Math.min(rowNumbers[index] - 1, tbody.children.length);
                                if (targetPosition >= 0) {
                                    tbody.insertBefore(newRow, tbody.children[targetPosition]);
                                } else {
                                    tbody.appendChild(newRow);
                                }
                            } else {
                                tbody.appendChild(newRow);
                            }
                        });
                        
                        // Renumber rows after restoration
                        Array.from(tbody.children).forEach((tr, idx) => {
                            const noCell = tr.querySelector('td:first-child');
                            if (noCell) noCell.textContent = idx + 1;
                        });
                        
                        updateRowCount();
                        log(`✅ ${deletedRows} ligne(s) restaurée(s) sans duplication`, 'success');
                    }
                }
                
                // Special handling for bulk edits
                if (lastOperation.type === OPERATION_TYPES.BULK_EDIT) {
                    if (lastOperation.data && lastOperation.data.edits) {
                        // Type 1: Bulk edits avec liste de modifications individuelles
                        // Clean: Removed debug log
                        const tbody = document.getElementById('table-body');
                        const rows = Array.from(tbody.children);
                        const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                        
                        lastOperation.data.edits.forEach(edit => {
                            if (edit.rowKey && edit.columnLabel) {
                                const targetRow = Array.from(tbody.children).find(tr => keyForRow(tr) === edit.rowKey);
                                if (targetRow) {
                                    const cells = Array.from(targetRow.querySelectorAll('td')).slice(2);
                                    const columnIndex = headers.indexOf(edit.columnLabel);
                                    if (columnIndex >= 0 && cells[columnIndex]) {
                                        cells[columnIndex].textContent = edit.initialValue;
                                        // Clean: Removed debug log
                                    }
                                }
                            }
                        });
                    } else if (lastOperation.tableState) {
                        // Type 2: Bulk edit avec état complet du tableau
                        // Clean: Removed debug log
                        
                        // Sauvegarder l'état actuel pour le redo si ce n'est pas déjà fait
                        if (!lastOperation.finalState) {
                            lastOperation.finalState = collectTableData();
                        }
                        
                        loadTableData(lastOperation.tableState);
                    }
                }
                
                // Restore row colors
                if (lastOperation.rowColors) {
                    rowColorMap = { ...lastOperation.rowColors };
                    persistRowColors();
                    
                    // Apply colors to visible rows
                    Array.from(document.querySelectorAll('#table-body tr')).forEach(tr => {
                        const k = keyForRow(tr);
                        const c = rowColorMap[k];
                        if (c && c !== '') {
                            setRowColor(tr, c);
                        }
                    });
                }
                
                // Don't remove operations from history - just push to redo stack
                // This allows proper undo/redo cycling
                // Clean: Removed debug log

                // Push undone operation to redo stack
                redoHistory.push(lastOperation);
                
                // Keep redo stack limited to 10 operations for circular navigation
                if (redoHistory.length > 10) {
                    const toRemove = redoHistory.length - 10;
                    for (let i = 0; i < toRemove; i++) {
                        redoHistory.shift();
                    }
                    // Clean: Removed debug log
                }
                
                persistHistoryStacks();
                
                log(`Opération '${lastOperation.type}' annulée avec succès.`, 'success');
                updateUndoButtonState();
                
                // ENHANCED: Schedule automatic sync after undo operation with extended suppression
                // Extended suppression windows to prevent conflicts with autosave/realtime
                const SUPPRESSION_MS = 3000; // Increased from 2000ms to 3000ms
                const AUTOSAVE_SUPPRESSION_MS = 4000; // Separate, longer suppression for autosave
                
                suppressRealtimeUntil = Date.now() + SUPPRESSION_MS;
                suppressAutosaveUntil = Date.now() + AUTOSAVE_SUPPRESSION_MS;
                
                // Clean: Removed debug log
                
                if (typeof scheduleUndoRedoSync === 'function') {
                    clearUndoRedoSyncTimeout();
                    undoRedoSyncTimeout = setTimeout(() => {
                        if (!isPerformingUndoRedo) {
                            // Clean: Removed debug log
                            // Force manual save to bypass conflict checks
                            syncToMaster(true, true);
                            undoRedoSyncTimeout = null;
                        }
                    }, 800); // Increased delay from 500ms to 800ms for better conflict prevention
                }
                
            } catch (error) {
                console.error('❌ Error during undo:', error);
                log('Erreur lors de l\'annulation.', 'error');
            } finally {
                isPerformingUndoRedo = false;
            }
        }

        // Redo function with circular history of 10 states
        function redo() {
            if (redoHistory.length === 0) {
                log('Aucune opération à rétablir.', 'info');
                return;
            }
            
            const op = redoHistory.pop();
            // Clean: Removed debug log
            
            // ENHANCED: Show detailed message about what is being redone
            const redoMessage = getDetailedOperationDescription(op, false);
            showMessage(redoMessage, 'info');
            try {
                isPerformingUndoRedo = true;
                clearOperationTimeout();
                
                // Re-apply the final state of the operation - only if we have valid data
                if (op.finalState && op.finalState.rows && Array.isArray(op.finalState.rows) && op.finalState.rows.length > 0) {
                    // Clean: Removed debug log
                    loadTableData(op.finalState.rows);
                } else if (op.finalState && op.finalState.rows) {
                    console.warn(`⚠️ Final state has rows but they are invalid:`, op.finalState.rows);
                    // Don't restore if data is invalid - this prevents table clearing
                }
                
                // Special handling for cell edits - restore final cell values using stable addressing
                if (op.type === OPERATION_TYPES.CELL_EDIT && op.data) {
                    const { rowKey, columnLabel, currentValue } = op.data;
                    if (rowKey && columnLabel && currentValue) {
                        const tbody = document.getElementById('table-body');
                        const targetRow = Array.from(tbody.children).find(tr => keyForRow(tr) === rowKey);
                        
                        if (targetRow) {
                            const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                            const columnIndex = headers.indexOf(columnLabel);
                            const cells = Array.from(targetRow.querySelectorAll('td')).slice(2); // Skip No and Delete columns
                            
                            if (columnIndex >= 0 && cells[columnIndex]) {
                                cells[columnIndex].textContent = currentValue;
                                // Clean: Removed debug log
                            }
                        } else {
                            // Clean: Removed debug log
                        }
                    }
                }
                
                // Special handling for row deletions - re-delete rows
                if (op.type === OPERATION_TYPES.ROW_DELETE && op.data) {
                    const { deletedRows, rowKeys } = op.data;
                    // Clean: Removed debug log
                    
                    if (rowKeys && rowKeys.length > 0) {
                        const tbody = document.getElementById('table-body');
                        const rowsToDelete = Array.from(tbody.children).filter(tr => 
                            rowKeys.includes(keyForRow(tr))
                        );
                        
                        if (rowsToDelete.length > 0) {
                            rowsToDelete.forEach(row => row.remove());
                            
                            // Renumber remaining rows
                            Array.from(tbody.children).forEach((tr, idx) => {
                                const noCell = tr.querySelector('td:first-child');
                                if (noCell) noCell.textContent = idx + 1;
                            });
                            
                            updateRowCount();
                            // Clean: Removed debug log
                        }
                    }
                }
                
                // Special handling for bulk edits
                if (op.type === OPERATION_TYPES.BULK_EDIT) {
                    if (op.data && op.data.edits) {
                        // Type 1: Bulk edits avec liste de modifications individuelles
                        // Clean: Removed debug log
                        const tbody = document.getElementById('table-body');
                        const rows = Array.from(tbody.children);
                        const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                        
                        op.data.edits.forEach(edit => {
                            if (edit.rowKey && edit.columnLabel) {
                                const targetRow = Array.from(tbody.children).find(tr => keyForRow(tr) === edit.rowKey);
                                if (targetRow) {
                                    const cells = Array.from(targetRow.querySelectorAll('td')).slice(2);
                                    const columnIndex = headers.indexOf(edit.columnLabel);
                                    if (columnIndex >= 0 && cells[columnIndex]) {
                                        cells[columnIndex].textContent = edit.currentValue;
                                        // Clean: Removed debug log
                                    }
                                }
                            }
                        });
                    } else if (op.finalState) {
                        // Type 2: Bulk edit avec état complet du tableau
                        // Clean: Removed debug log
                        loadTableData(op.finalState);
                    }
                }
                
                if (op.finalRowColors) {
                    rowColorMap = { ...op.finalRowColors };
                    persistRowColors();
                    Array.from(document.querySelectorAll('#table-body tr')).forEach(tr => {
                        const k = keyForRow(tr);
                        const c = rowColorMap[k];
                        if (c && c !== '') setRowColor(tr, c);
                    });
                }
                
                // After redoing, push back to operation history
                operationHistory.push(op);
                persistHistoryStacks();
                updateUndoButtonState();
                
                log('Opération rétablie.', 'success');
                
                // ENHANCED: Schedule automatic sync after redo operation with extended suppression
                // Extended suppression windows to prevent conflicts with autosave/realtime
                const SUPPRESSION_MS = 3000; // Increased from 2000ms to 3000ms
                const AUTOSAVE_SUPPRESSION_MS = 4000; // Separate, longer suppression for autosave
                
                suppressRealtimeUntil = Date.now() + SUPPRESSION_MS;
                suppressAutosaveUntil = Date.now() + AUTOSAVE_SUPPRESSION_MS;
                
                // Clean: Removed debug log
                
                if (typeof scheduleUndoRedoSync === 'function') {
                    clearUndoRedoSyncTimeout();
                    undoRedoSyncTimeout = setTimeout(() => {
                        if (!isPerformingUndoRedo) {
                            // Clean: Removed debug log
                            // Force manual save to bypass conflict checks
                            syncToMaster(true, true);
                            undoRedoSyncTimeout = null;
                        }
                    }, 800); // Increased delay from 500ms to 800ms for better conflict prevention
                }
                
            } catch (e) {
                console.error('❌ Error during redo:', e);
                log('Erreur lors du rétablissement.', 'error');
            } finally {
                isPerformingUndoRedo = false;
            }
        }
        

        
        // ENHANCED: Function to get detailed operation description for display
        function getOperationDescription(operation) {
            switch (operation.type) {
                case OPERATION_TYPES.CELL_EDIT:
                    const cellInfo = operation.data.columnLabel || 'cellule';
                    const rowInfo = operation.data.rowKey ? `ligne ${operation.data.rowKey}` : '';
                    const oldValue = operation.data.initialValue || '';
                    const newValue = operation.data.currentValue || '';
                    if (oldValue && newValue) {
                        return `Modification: ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''} - "${oldValue}" → "${newValue}"`;
                    }
                    return `Modification: ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''}`;
                case OPERATION_TYPES.ROW_INSERT:
                    return 'Insertion de ligne';
                case OPERATION_TYPES.ROW_DELETE:
                    if (operation.data.deletedRows && operation.data.deletedRows > 1) {
                        return `Suppression de ${operation.data.deletedRows} ligne(s)`;
                    }
                    return 'Suppression de ligne';
                case OPERATION_TYPES.BULK_EDIT:
                    if (operation.data.edits && operation.data.edits.length > 0) {
                        return `Modifications en lot: ${operation.data.edits.length} cellule(s) modifiée(s)`;
                    }
                    return 'Modifications en lot';
                default:
                    return 'Opération';
            }
        }
        
        // ENHANCED: Function to get detailed operation description for undo/redo messages
        function getDetailedOperationDescription(operation, isUndo = true) {
            switch (operation.type) {
                case OPERATION_TYPES.CELL_EDIT:
                    const cellInfo = operation.data.columnLabel || 'cellule';
                    const rowInfo = operation.data.rowKey ? `ligne ${operation.data.rowKey}` : '';
                    const oldValue = operation.data.initialValue || '';
                    const newValue = operation.data.currentValue || '';
                    
                    if (isUndo) {
                        if (oldValue && newValue) {
                            return `🔄 Annulation: ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''} - "${newValue}" → "${oldValue}"`;
                        }
                        return `🔄 Annulation: modification de ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''}`;
                    } else {
                        if (oldValue && newValue) {
                            return `⏩ Rétablissement: ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''} - "${oldValue}" → "${newValue}"`;
                        }
                        return `⏩ Rétablissement: modification de ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''}`;
                    }
                    
                case OPERATION_TYPES.ROW_INSERT:
                    if (isUndo) {
                        return `🔄 Annulation: suppression de la ligne insérée`;
                    } else {
                        return `⏩ Rétablissement: insertion de ligne`;
                    }
                    
                case OPERATION_TYPES.ROW_DELETE:
                    if (operation.data.deletedRows && operation.data.deletedRows > 1) {
                        if (isUndo) {
                            return `🔄 Annulation: restauration de ${operation.data.deletedRows} ligne(s) supprimée(s)`;
                        } else {
                            return `⏩ Rétablissement: suppression de ${operation.data.deletedRows} ligne(s)`;
                        }
                    } else {
                        if (isUndo) {
                            return `🔄 Annulation: restauration de la ligne supprimée`;
                        } else {
                            return `⏩ Rétablissement: suppression de ligne`;
                        }
                    }
                    
                case OPERATION_TYPES.BULK_EDIT:
                    if (operation.data.edits && operation.data.edits.length > 0) {
                        if (isUndo) {
                            return `🔄 Annulation: restauration de ${operation.data.edits.length} modification(s) de cellule(s)`;
                        } else {
                            return `⏩ Rétablissement: ${operation.data.edits.length} modification(s) de cellule(s)`;
                        }
                    } else {
                        if (isUndo) {
                            return `🔄 Annulation: restauration des modifications en lot`;
                        } else {
                            return `⏩ Rétablissement: modifications en lot`;
                        }
                    }
                    
                default:
                    if (isUndo) {
                        return `🔄 Annulation: ${operation.type}`;
                    } else {
                        return `⏩ Rétablissement: ${operation.type}`;
                    }
            }
        }
        
        // Clean: Removed debug function for production
        
        // Expose undo/redo functions globally so buttons can access them
        window.undo = undo;
        window.redo = redo;
        window.getDetailedOperationDescription = getDetailedOperationDescription;
        
        // Function to clear operation timeout
        function clearOperationTimeout() {
            if (operationTimeout) {
                clearTimeout(operationTimeout);
                operationTimeout = null;
            }
        }
        
        // Function to schedule automatic sync after undo/redo operations
        function scheduleUndoRedoSync() {
            // Clear any existing timeout
            if (undoRedoSyncTimeout) {
                clearTimeout(undoRedoSyncTimeout);
            }
            
            // Schedule sync after 500ms of user inactivity
            undoRedoSyncTimeout = setTimeout(() => {
                if (!isPerformingUndoRedo) {
                    // Clean: Removed debug log
                    syncToMaster(true);
                    undoRedoSyncTimeout = null;
                }
            }, 500);
        }
        
        // Function to group multiple cell edits into a single operation
        function groupCellEdits() {
            if (currentOperation && currentOperation.type === OPERATION_TYPES.CELL_EDIT) {
                // If we have multiple cell edits, group them into a bulk edit
                if (currentOperation.data.editCount > 1) {
                    currentOperation.type = OPERATION_TYPES.BULK_EDIT;
                    currentOperation.data.description = `${currentOperation.data.editCount} modifications de cellules`;
                    // Clean: Removed debug log
                }
            }
        }
        
        // Function to clear undo/redo sync timeout
        function clearUndoRedoSyncTimeout() {
            if (undoRedoSyncTimeout) {
                clearTimeout(undoRedoSyncTimeout);
                undoRedoSyncTimeout = null;
            }
        }
        
        // Handle page unload to complete pending operations
        window.addEventListener('beforeunload', () => {
            if (currentOperation) {
                completeOperation();
            }
            clearOperationTimeout();
            clearUndoRedoSyncTimeout();
            
            // Cleanup all timers to prevent infinite loops
            cleanupAllTimers();
        });
        
        // Handle page visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && currentOperation) {
                completeOperation();
            }
            clearUndoRedoSyncTimeout();
        });
        
        // Function to reset operation history (useful for testing)
        function resetOperationHistory() {
            operationHistory = [];
            if (currentOperation) {
                currentOperation = null;
            }
            clearOperationTimeout();
            updateUndoButtonState();
            // Clean: Removed debug log
        }
        
        // Function to safely start new operations after undo
        function safeStartOperation(type, data = {}) {
            // Clear any pending operations
            if (currentOperation) {
                completeOperation();
            }
            
            // Clean up conflicting operations
            if (type === OPERATION_TYPES.ROW_ADD || 
                type === OPERATION_TYPES.ROW_DELETE || 
                type === OPERATION_TYPES.MULTIPLE_ROWS_DELETE) {
                
                operationHistory = operationHistory.filter(op => 
                    op.type !== OPERATION_TYPES.ROW_ADD && 
                    op.type !== OPERATION_TYPES.ROW_DELETE && 
                    op.type !== OPERATION_TYPES.MULTIPLE_ROWS_DELETE
                );
            }
            
            startOperation(type, data);
        }
        
        // Expose functions globally for debugging
        window.resetOperationHistory = resetOperationHistory;
        window.safeStartOperation = safeStartOperation;
        window.updateRowCount = updateRowCount;
        
        // Fonction pour forcer l'affichage du bouton d'ajout
        window.forceFabAddVisible = function() {
            const fabAdd = document.getElementById('fab-add');
            if (fabAdd) {
                fabAdd.style.display = 'flex';
                fabAdd.style.visibility = 'visible';
                
                if (isViewMode) {
                    // Mode visualisation : bouton visible mais désactivé
                    fabAdd.style.opacity = '0.5';
                    fabAdd.style.pointerEvents = 'none';
                    fabAdd.style.cursor = 'not-allowed';
                    fabAdd.title = 'Mode visualisation actif - Ajout de lignes désactivé';
                } else {
                    // Mode normal : bouton pleinement fonctionnel
                    fabAdd.style.opacity = '1';
                    fabAdd.style.pointerEvents = 'auto';
                    fabAdd.style.cursor = 'pointer';
                    fabAdd.title = 'Ajouter une nouvelle ligne';
                }
                
                // Clean: Removed debug log
                return true;
            } else {
                console.error('❌ FAB add button not found');
                return false;
            }
        };
        
        // Utility functions
        function log(message, type = 'info') { 
            console.log(`[${new Date().toLocaleTimeString()}] ${type.toUpperCase()}: ${message}`); 
        }
        
        function showMessage(message, type = 'success') { 
            const box = document.getElementById('message-box'); 
            const txt = document.getElementById('message-text'); 
            
            if (window._msgTimer) clearTimeout(window._msgTimer); 
            
            box.classList.remove('show'); 
            txt.textContent = message; 
            box.className = `message-box ${type}`; 
            
            void box.offsetWidth; // Force reflow
            box.classList.add('show'); 
            box.classList.remove('hidden'); 
            
            window._msgTimer = setTimeout(() => {
                box.classList.remove('show'); 
                setTimeout(() => box.classList.add('hidden'), 500); 
            }, 3000); 
        }
        
        // Optimized status update with DOM caching
        const updateStatus = (function() {
            let statusEl = null;
            let textEl = null;
            let iconEl = null;
            
            return function(message, type = 'pending') {
                // Cache elements on first use
                if (!statusEl) {
                    statusEl = domCache.status || document.getElementById('sync-status');
                    if (statusEl) {
                        textEl = statusEl.querySelector('.sync-text');
                        iconEl = statusEl.querySelector('.sync-icon');
                    }
                }
                
                if (!statusEl) return;
            
                // Mettre à jour le texte et l'icône
                if (textEl) textEl.textContent = message;
                if (iconEl) {
                    // Choisir l'icône appropriée selon le type
                    if (type === 'success') {
                        iconEl.className = 'sync-icon fa-solid fa-check';
                    } else if (type === 'error') {
                        iconEl.className = 'sync-icon fa-solid fa-exclamation-triangle';
                    } else if (type === 'saving') {
                        iconEl.className = 'sync-icon fa-solid fa-sync-alt fa-spin';
                    } else {
                        iconEl.className = 'sync-icon fa-solid fa-clock';
                    }
                }
                
                statusEl.className = `px-3 py-1 rounded-full text-xs font-semibold border-2 bg-white shadow-sm transition-all duration-300 ${getSyncStatusClasses(type)}`;
                
                // Mettre à jour le point coloré si il existe (pour petits écrans)
                const dotEl = statusEl.querySelector('.sync-dot');
                if (dotEl) {
                applyDotColor(dotEl, type);
            }
            
            // Adapter l'affichage selon la taille d'écran
            adaptStatusDisplay();
            };
        })();
        
        function getSyncStatusClasses(type) { 
            switch(type) { 
                case 'success': 
                    return 'bg-green-100 text-green-800 border-green-400 shadow-green-200/50'; 
                case 'error': 
                    return 'bg-red-100 text-red-800 border-red-400 shadow-red-200/50'; 
                case 'saving': 
                    return 'bg-blue-100 text-blue-800 border-blue-400 shadow-blue-200/50 sync-pending-animation'; 
                default: 
                    return 'bg-yellow-100 text-yellow-800 border-yellow-400 shadow-yellow-200/50 sync-pending-animation'; 
            } 
        }
        
        function adaptStatusDisplay() {
            const el = document.getElementById('sync-status');
            if (!el) return;
            
            const textEl = el.querySelector('.sync-text');
            const iconEl = el.querySelector('.sync-icon');
            
            if (!textEl || !iconEl) return;
            
            // Trouver le titre "Tableau de Staff" par son ID
            const titleEl = document.getElementById('staff-title');
            
            // Sur petits écrans, afficher seulement un point coloré et cacher le titre
            if (window.innerWidth <= 768) {
                textEl.classList.add('hidden');
                iconEl.classList.add('hidden');
                
                // Cacher le titre sur petits écrans
                if (titleEl) {
                    titleEl.classList.add('hidden');
                }
                
                // Créer ou mettre à jour le point coloré
                let dotEl = el.querySelector('.sync-dot');
                if (!dotEl) {
                    dotEl = document.createElement('div');
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full';
                    dotEl.setAttribute('aria-label', 'Statut de synchronisation');
                    dotEl.setAttribute('title', 'Statut de synchronisation');
                    el.appendChild(dotEl);
                }
                
                // S'assurer que le point est visible
                dotEl.classList.remove('hidden');
                
                // Appliquer la couleur selon le type actuel
                const currentType = getCurrentStatusType(el);
                applyDotColor(dotEl, currentType);
                
                el.classList.add('px-1', 'py-0.5'); // Padding minimal
                el.classList.remove('px-2', 'px-3');
            } else {
                // Sur grands écrans, afficher le texte et le titre, cacher le point
                textEl.classList.remove('hidden');
                iconEl.classList.add('hidden');
                
                // Afficher le titre sur grands écrans
                if (titleEl) {
                    titleEl.classList.remove('hidden');
                }
                
                const dotEl = el.querySelector('.sync-dot');
                if (dotEl) {
                    dotEl.classList.add('hidden');
                    // Optionnel: supprimer complètement le point pour économiser la mémoire
                    // dotEl.remove();
                }
                
                el.classList.add('px-2');
                el.classList.remove('px-1', 'px-3');
            }
        }
        
        function getCurrentStatusType(el) {
            if (!el) return 'pending';
            
            // Détecter le type actuel basé sur les classes CSS
            if (el.classList.contains('bg-green-100')) return 'success';
            if (el.classList.contains('bg-red-100')) return 'error';
            if (el.classList.contains('bg-blue-100')) return 'saving';
            return 'pending';
        }
        
        function applyDotColor(dotEl, type) {
            if (!dotEl) return;
            
            // Appliquer la couleur appropriée au point
            switch(type) {
                case 'success':
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-green-500';
                    break;
                case 'error':
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-red-500';
                    break;
                case 'saving':
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-blue-500 animate-pulse';
                    break;
                default:
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-yellow-500';
                    break;
            }
        }
        

        
                function updateUndoButtonState() { 
            const undoButton = document.getElementById('undo-button');
            const redoButton = document.getElementById('redo-button');
            if (undoButton) {
                // Only count content modification operations
                const contentOperations = operationHistory.filter(op => CONTENT_MODIFICATION_TYPES.includes(op.type));
                const hasOperations = contentOperations.length > 0;
                undoButton.disabled = !hasOperations;
                
                // Update button title with operation info (keep icon unchanged)
                if (hasOperations) {
                    const lastOp = contentOperations[contentOperations.length - 1];
                    const description = getOperationDescription(lastOp);
                    undoButton.title = `Annuler: ${description} (${contentOperations.length} modification(s) de contenu disponible(s))`;
                } else {
                    undoButton.title = 'Aucune modification de contenu à annuler';
                }
            }
            if (redoButton) {
                // Only count content modification operations
                const contentRedoOperations = redoHistory.filter(op => CONTENT_MODIFICATION_TYPES.includes(op.type));
                const hasRedo = contentRedoOperations.length > 0;
                redoButton.disabled = !hasRedo;
                if (hasRedo) {
                    const lastRedo = contentRedoOperations[contentRedoOperations.length - 1];
                    const descRedo = getOperationDescription(lastRedo);
                    redoButton.title = `Rétablir: ${descRedo} (${contentRedoOperations.length} modification(s) de contenu disponible(s))`;
                } else {
                    redoButton.title = 'Aucune modification de contenu à rétablir';
                }
            }
        }
        
        function getFormattedDate() { 
            const d = new Date(); 
            return `${String(d.getDate()).padStart(2, '0')}/${String(d.getMonth() + 1).padStart(2, '0')}/${String(d.getFullYear()).slice(-2)}`; 
        }
        
        function generateDataHash(data) { 
            return JSON.stringify(data.rows.map(r => ({...r, [supabaseConfig.primaryKeyColumn]: undefined}))).split('').reduce((a, b) => {
                a = ((a << 5) - a) + b.charCodeAt(0);
                return a & a;
            }, 0).toString(16); 
        }

        // Zoom functionality
        function updateZoomDisplay() {
            const btn = document.getElementById('zoom-display');
            if (!btn) return;
            
            const pct = Math.round(zoomFactor * 100);
            btn.textContent = pct + '%';
            btn.title = `Réinitialiser à 100% (actuel : ${pct}%)`;
        }
        
        function applyZoom() {
            try {
                const clamped = Math.max(0.3, Math.min(2, zoomFactor));
                zoomFactor = clamped;
                document.documentElement.style.fontSize = (16 * zoomFactor) + 'px';
                localStorage.setItem('zoomFactor', String(zoomFactor));
                updateZoomDisplay();
            } catch(_) {}
        }
        
        function zoomIn() { 
            zoomFactor += 0.05; 
            applyZoom(); 
        }
        
        function zoomOut() { 
            zoomFactor -= 0.05; 
            applyZoom(); 
        }
        
        function zoomReset() { 
            zoomFactor = 1; 
            applyZoom(); 
        }

        // Row color management
        function persistRowColors() { 
            try { 
                localStorage.setItem('rowColors', JSON.stringify(rowColorMap)); 
            } catch(_) {} 
        }
        
        function setRowColor(tr, color) {
            if (!tr) return;
            
            // S'assurer que tr est bien un élément TR
            if (tr.tagName !== 'TR') {
                console.warn('setRowColor: tr parameter is not a TR element:', tr);
                return;
            }
            
            if (color) { 
                // Colorer toute la ligne
                tr.style.backgroundColor = color; 
                tr.dataset.rowColored = '1'; 
                
                // S'assurer que toutes les cellules de la ligne héritent de la couleur
                Array.from(tr.cells).forEach(cell => {
                    if (cell.style.backgroundColor !== color) {
                        cell.style.backgroundColor = color;
                    }
                });
            } else { 
                // Décolorer toute la ligne
                tr.style.backgroundColor = ''; 
                tr.dataset.rowColored = '0'; 
                
                // S'assurer que toutes les cellules de la ligne sont décolorées
                Array.from(tr.cells).forEach(cell => {
                    cell.style.backgroundColor = '';
                });
            }
        }
        
        function keyForRow(tr) {
            return tr.dataset.key || (Array.from(tr.parentElement.children).indexOf(tr) + 1);
        }

        function toggleRowColor(tr) {
            // S'assurer que tr est bien un élément tr (ligne)
            if (!tr || tr.tagName !== 'TR') {
                console.warn('toggleRowColor: tr parameter is not a TR element:', tr);
                return;
            }
            
            const key = keyForRow(tr);
            
            // Respecter le mode de peinture actuel
            if (paintMode === 'color') {
                // Mode Colorer : toujours colorer
                setRowColor(tr, currentRowColor);
                rowColorMap[key] = currentRowColor;
            } else if (paintMode === 'clear') {
                // Mode Effacer : toujours effacer
                setRowColor(tr, null);
                delete rowColorMap[key];
            } else {
                // Mode Auto : basculer selon l'état actuel
                if (tr.dataset.rowColored === '1') {
                    setRowColor(tr, null);
                    delete rowColorMap[key];
                } else {
                    setRowColor(tr, currentRowColor);
                    rowColorMap[key] = currentRowColor;
                }
            }
            
            persistRowColors();
        }

        // Drag-to-paint functionality
        function applyRowPaint(row) {
            if (!row) return;
            
            // Row color operations are NOT tracked for undo/redo (content modification only)
            // No need to start, track, or complete these operations
            
            const key = keyForRow(row);
            if (rowPaintAction === 'color') {
                setRowColor(row, currentRowColor);
                rowColorMap[key] = currentRowColor;
            } else {
                setRowColor(row, null);
                delete rowColorMap[key];
            }
            persistRowColors();
            
            // No operation timeout needed for non-tracked operations
        }
        
        function startRowPaint(row) {
            // Respecter le mode de peinture actuel
            if (paintMode === 'color') {
                rowPaintAction = 'color';
            } else if (paintMode === 'clear') {
                rowPaintAction = 'clear';
            } else {
                // Mode Auto : basculer selon l'état actuel
                rowPaintAction = (row && row.dataset.rowColored === '1') ? 'clear' : 'color';
            }
            
            isRowPaintDragging = true;
            applyRowPaint(row);
            
            // Note: Row color operations are NOT tracked for undo/redo (content modification only)
        }
        
        function endRowPaint() { 
            isRowPaintDragging = false; 
            
            // Row color operations are NOT tracked for undo/redo (content modification only)
            // No need to complete or track these operations
        }

        // Paint mode management
        function getPaintActionForRow(row) {
            if (paintMode === 'auto') {
                // En mode auto : si la ligne est colorée, on la décolore, sinon on la colorie
                const isColored = row && (row.dataset.rowColored === '1' || 
                                        (row.style.backgroundColor && row.style.backgroundColor !== ''));
                return isColored ? 'clear' : 'color';
            }
            return paintMode;
        }
        
        function updatePaintModeButton() {
            const btn = document.getElementById('paint-mode-toggle');
            if (!btn) return;
            
            if (paintMode === 'auto') { 
                btn.innerHTML = '<i class="fa-solid fa-arrows-rotate w-4 h-4"></i>'; 
                btn.title = 'Mode Auto: Cliquez pour colorer/décolorer (P pour changer)'; 
            } else if (paintMode === 'color') { 
                btn.innerHTML = '<i class="fa-solid fa-paintbrush w-4 h-4"></i>'; 
                btn.title = 'Mode Colorer (P pour changer)'; 
            } else { 
                btn.innerHTML = '<i class="fa-solid fa-eraser w-4 h-4"></i>'; 
                btn.title = 'Mode Effacer (P pour changer)'; 
            }
        }
        
        function cyclePaintMode() {
            paintMode = (paintMode === 'auto') ? 'color' : (paintMode === 'color' ? 'clear' : 'auto');
            localStorage.setItem('rowPaintMode', paintMode);
            updatePaintModeButton();
            
            let message = paintMode === 'auto' ? 'Auto' : (paintMode === 'color' ? 'Coloré' : 'Effacer');
            showMessage(message, 'info');
        }

        // Filter functionality
        function applyColoredFilter() {
            try {
                const tbody = document.getElementById('table-body');
                Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                    const colored = tr.dataset.rowColored === '1' || (tr.style.backgroundColor && tr.style.backgroundColor !== '');
                    tr.style.display = (showOnlyColored && !colored) ? 'none' : '';
                });
            } catch(_) {}
        }

        function updateFilterColoredButton() {
            const btn = document.getElementById('filter-colored-toggle');
            if (!btn) return;
            
            if (showOnlyColored) {
                btn.innerHTML = '<i class="fa-solid fa-eye w-4 h-4"></i>';
                btn.title = 'Afficher toutes les lignes';
                btn.setAttribute('aria-pressed', 'true');
            } else {
                btn.innerHTML = '<i class="fa-solid fa-filter w-4 h-4"></i>';
                btn.title = 'Afficher seulement les lignes colorées';
                btn.setAttribute('aria-pressed', 'false');
            }
        }

        function toggleColoredFilter() {
            showOnlyColored = !showOnlyColored;
            applyColoredFilter();
            updateFilterColoredButton();
        }
        
        // Fonction pour basculer le mode visualisation
        function toggleViewMode() {
            isViewMode = !isViewMode;
            
            // Sauvegarder immédiatement l'état dans localStorage
            localStorage.setItem('viewMode', isViewMode.toString());
            
            updateViewModeButton();
            applyViewMode();
        }
        
        // Mettre à jour l'apparence du bouton de mode visualisation
        function updateViewModeButton() {
            const btn = document.getElementById('view-mode-toggle');
            if (!btn) return;
            
            if (isViewMode) {
                btn.className = 'bg-green-200 text-green-800 p-2 rounded-lg hover:bg-green-300 transition-colors flex items-center justify-center w-8 h-8';
                btn.title = 'Désactiver le mode visualisation (lecture seule)';
                btn.innerHTML = '<i class="fa-solid fa-eye-slash w-4 h-4"></i>';
            } else {
                btn.className = 'bg-blue-200 text-blue-800 p-2 rounded-lg hover:bg-blue-300 transition-colors flex items-center justify-center w-8 h-8';
                btn.title = 'Activer le mode visualisation (lecture seule)';
                btn.innerHTML = '<i class="fa-solid fa-eye w-4 h-4"></i>';
            }
        }
        
        // Appliquer le mode visualisation
        function applyViewMode() {
            const editableCells = document.querySelectorAll('.editable-cell');
            const fabAdd = document.getElementById('fab-add');
            const mobileAddButton = document.getElementById('mobile-add-button');
            
            // Désactiver TEMPORAIREMENT TOUTES les sauvegardes si on passe en mode visualisation
            let originalFunctions = {};
            if (isViewMode) {
                // Sauvegarder toutes les fonctions originales
                originalFunctions.markEdited = window.markEdited;
                originalFunctions.saveStateToHistory = window.saveStateToHistory;
                originalFunctions.saveLocalDraft = window.saveLocalDraft;
                
                // Remplacer par des fonctions vides
                window.markEdited = function() { return; };
                window.saveStateToHistory = function() { return; };
                window.saveLocalDraft = function() { return; };
            }
            
            editableCells.forEach(cell => {
                if (isViewMode) {
                    cell.contentEditable = 'false';
                    cell.style.backgroundColor = '#f8f9fa';
                    cell.style.cursor = 'default';
                } else {
                    cell.contentEditable = 'true';
                    cell.style.backgroundColor = '';
                    cell.style.cursor = 'text';
                }
            });
            
            // Activer la protection renforcée sur mobile en mode visualisation
            if (isViewMode && isMobile()) {
                isViewModeProtected = true;
            } else {
                isViewModeProtected = false;
            }
            
            // Le bouton d'ajout FAB doit toujours être visible, mais désactivé en mode visualisation
            if (fabAdd) {
                fabAdd.style.display = 'flex';
                fabAdd.style.visibility = 'visible';
                
                if (isViewMode) {
                    // Mode visualisation : bouton visible mais désactivé
                    fabAdd.style.opacity = '0.5';
                    fabAdd.style.pointerEvents = 'none';
                    fabAdd.style.cursor = 'not-allowed';
                    fabAdd.title = 'Mode visualisation actif - Ajout de lignes désactivé';
                } else {
                    // Mode normal : bouton pleinement fonctionnel
                    fabAdd.style.opacity = '1';
                    fabAdd.style.pointerEvents = 'auto';
                    fabAdd.style.cursor = 'pointer';
                    fabAdd.title = 'Ajouter une nouvelle ligne';
                }
            }
            
            // Sauvegarder l'état dans localStorage
            localStorage.setItem('viewMode', isViewMode);
            
            // Réactiver les sauvegardes après un délai adaptatif selon l'appareil
            if (isViewMode && Object.keys(originalFunctions).length > 0) {
                const restoreDelay = isMobile() ? 6000 : 3000;
                setTimeout(() => {
                    if (originalFunctions.markEdited) {
                        window.markEdited = originalFunctions.markEdited;
                    }
                    if (originalFunctions.saveStateToHistory) {
                        window.saveStateToHistory = originalFunctions.saveStateToHistory;
                    }
                    if (originalFunctions.saveLocalDraft) {
                        window.saveLocalDraft = originalFunctions.saveLocalDraft;
                    }
                }, restoreDelay);
            }
        }
        
        // Appliquer le mode visualisation après restauration des données
        function applyViewModeAfterRestore() {
            if (isViewMode) {
                const editableCells = document.querySelectorAll('.editable-cell');
                editableCells.forEach(cell => {
                    cell.contentEditable = 'false';
                    cell.style.backgroundColor = '#f8f9fa';
                    cell.style.cursor = 'default';
                });
            }
        }
        
        // Détecter automatiquement l'état du bouton œil et agir en conséquence
        function detectAndApplyViewMode() {
            const btn = document.getElementById('view-mode-toggle');
            if (!btn) return;
            
            // Restaurer l'état depuis localStorage
            const savedViewMode = localStorage.getItem('viewMode') === 'true';
            if (savedViewMode !== isViewMode) {
                isViewMode = savedViewMode;
            }
            
            // Mettre à jour l'apparence du bouton selon l'état sauvegardé
            updateViewModeButton();
            
            // Appliquer le mode sauvegardé
            applyViewMode();
        }
        
        // Fonction pour forcer le mode visualisation et empêcher les sauvegardes
        function forceViewMode() {
            if (isViewMode) {
                // Désactiver temporairement les sauvegardes automatiques
                const originalMarkEdited = window.markEdited;
                window.markEdited = function() {
                    // Ne rien faire si on est en mode visualisation
                    return;
                };
                
                // Appliquer le mode visualisation
                applyViewMode();
                
                // Réactiver les sauvegardes après un délai adaptatif selon l'appareil
                const restoreDelay = isMobile() ? 4000 : 2000;
                setTimeout(() => {
                    window.markEdited = originalMarkEdited;
                }, restoreDelay);
            }
        }
        


        // Row color utilities
        function clearAllRowColors() {
            try {
                const tbody = document.getElementById('table-body');
                Array.from(tbody.querySelectorAll('tr')).forEach(tr => setRowColor(tr, null));
                rowColorMap = {};
                persistRowColors();
                showMessage('Couleurs des lignes effacées.', 'info');
            } catch(_) {}
        }

        // Focus management
        let isInitialLoad = true; // Flag to prevent automatic capture on initial load
        
        function captureSimplePos() {
            // Skip capture during initial load to prevent overwriting user's intended position
            if (isInitialLoad) {
                log(`🚫 captureSimplePos SKIPPED - initial load in progress`);
                return;
            }
            
            const active = document.activeElement;
            if (!(active && active.tagName === 'TD' && active.isContentEditable)) return;
            
            const rowEl = active.closest('tr');
            const tbody = document.getElementById('table-body');
            const rowIndex = Array.from(tbody.querySelectorAll('tr')).indexOf(rowEl);
            const cellIndex = Array.from(rowEl.cells).indexOf(active);
            
            // DEBUG: Log detailed information about the cell being captured
            if (active && rowEl) {
                const cellLabel = active.getAttribute('data-label') || 'NO_LABEL';
                const cellText = active.textContent.substring(0, 20) + '...';
                const totalCells = rowEl.cells.length;
                const totalRows = tbody.querySelectorAll('tr').length;
                
                log(`🔍 CAPTURE DEBUG: row=${rowIndex}/${totalRows}, cell=${cellIndex}/${totalCells}, label="${cellLabel}", text="${cellText}"`);
            }
            
            if (rowIndex >= 0 && cellIndex >= 0) {
                lastCellPos = { rowIndex, cellIndex };
                
                // UNIFY: Also update lastFocusInfo to use the same position
                const colLabel = active.getAttribute('data-label') || '';
                const rowKey = rowEl ? rowEl.dataset.key || null : null;
                const caret = getCaretOffsetWithin(active);
                
                lastFocusInfo = { rowKey, rowIndex, colLabel, caret };
                log(`🔄 UNIFIED CAPTURE: Updated both lastCellPos and lastFocusInfo with same rowIndex=${rowIndex}`);
            }
            
            if (lastCellPos) { 
                log(`captureSimplePos -> row=${lastCellPos.rowIndex}, cell=${lastCellPos.cellIndex}`); 
            }
            
            try { 
                localStorage.setItem('lastCellPos', JSON.stringify(lastCellPos)); 
                localStorage.setItem('lastFocusInfo', JSON.stringify(lastFocusInfo)); 
            } catch(_) {}
        }

        // Mobile detection and support - Enhanced version
        function isMobile() {
            try { 
                // Détection plus robuste
                const userAgent = navigator.userAgent;
                const mobileRegex = /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
                
                // Vérifier la taille de l'écran
                const isSmallScreen = window.innerWidth <= 768;
                
                // Vérifier les capacités tactiles
                const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                
                // Vérifier l'orientation (mobile a souvent une orientation changeante)
                const hasOrientation = 'onorientationchange' in window;
                
                // Détection basée sur userAgent
                const userAgentMobile = mobileRegex.test(userAgent);
                
                // Détection basée sur les capacités et la taille
                const capabilitiesMobile = isSmallScreen && (hasTouch || hasOrientation);
                
                return userAgentMobile || capabilitiesMobile;
            } catch(_) { 
                return false; 
            }
        }

        function getScrollContainer() {
            return document.getElementById('table-container');
        }

        function ensureCellVisible(cell) {
            try {
                if (!cell) return;
                
                const sc = getScrollContainer();
                if (!sc) { 
                    cell.scrollIntoView({block: 'center', inline: 'nearest'}); 
                    return; 
                }
                
                const vv = window.visualViewport;
                const rect = cell.getBoundingClientRect();
                const viewportHeight = vv ? vv.height : window.innerHeight;
                const bottomSafe = viewportHeight - 64;
                
                if (rect.bottom > bottomSafe || rect.top < 0) {
                    const delta = rect.bottom - bottomSafe;
                    sc.scrollTop += Math.max(delta, -20);
                    try { 
                        cell.scrollIntoView({block: 'center', inline: 'nearest'}); 
                    } catch(_) {}
                }
            } catch(_) {}
        }

        function focusCellWithMobileSupport(cell) {
            try {
                try { 
                    cell.scrollIntoView({ block: 'center', inline: 'nearest' }); 
                } catch(_) {}
                
                setTimeout(() => {
                    try {
                        cell.dispatchEvent(new Event('pointerdown', { bubbles: true }));
                        cell.dispatchEvent(new Event('mousedown', { bubbles: true }));
                        cell.dispatchEvent(new Event('mouseup', { bubbles: true }));
                        cell.click();
                        
                        try { 
                            cell.focus({ preventScroll: true }); 
                        } catch(_) { 
                            try { 
                                cell.focus(); 
                            } catch(__) {} 
                        }
                        
                        setCaretAt(cell, null);
                        
                        try {
                            requestAnimationFrame(() => {
                                setCaretAt(cell, null);
                                requestAnimationFrame(() => { 
                                    setCaretAt(cell, null); 
                                });
                            });
                        } catch(_) {}
                        
                        setTimeout(() => { 
                            setCaretAt(cell, null); 
                        }, 250);
                    } catch(_) {
                        try { 
                            cell.focus(); 
                            setCaretAt(cell, null); 
                        } catch(__) {}
                    }
                }, 350);
                
                ensureCellVisible(cell);
                return true;
            } catch(_) { 
                return false; 
            }
        }

        // Caret management
        function getCaretOffsetWithin(el) {
            try {
                const sel = window.getSelection();
                if (!sel || sel.rangeCount === 0) return null;
                
                const range = sel.getRangeAt(0);
                if (!el.contains(range.startContainer)) return null;
                
                const preRange = range.cloneRange();
                preRange.selectNodeContents(el);
                preRange.setEnd(range.startContainer, range.startOffset);
                
                return preRange.toString().length;
            } catch(_) { 
                return null; 
            }
        }

        function setCaretAt(el, offset) {
            try {
                el.focus();
                const selection = window.getSelection();
                selection.removeAllRanges();
                const range = document.createRange();
                
                let remaining = (typeof offset === 'number' && offset >= 0) ? offset : null;
                const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
                let node = walker.nextNode();
                
                if (remaining === null) {
                    let lastNode = null;
                    while (node) { 
                        lastNode = node; 
                        node = walker.nextNode(); 
                    }
                    
                    if (lastNode) {
                        range.setStart(lastNode, lastNode.textContent.length);
                        range.collapse(true);
                        selection.addRange(range);
                    }
                    return;
                }
                
                while (node) {
                    const len = node.textContent.length;
                    if (remaining <= len) {
                        range.setStart(node, remaining);
                        range.collapse(true);
                        selection.addRange(range);
                        return;
                    }
                    remaining -= len;
                    node = walker.nextNode();
                }
                
                const endNode = el.lastChild;
                if (endNode && endNode.nodeType === Node.TEXT_NODE) {
                    range.setStart(endNode, endNode.textContent.length);
                } else {
                    range.selectNodeContents(el);
                    range.collapse(false);
                }
                selection.addRange(range);
            } catch(_) {}
        }

        function captureFocusInfo() {
            // Skip capture during initial load to prevent overwriting user's intended position
            if (isInitialLoad) {
                log(`🚫 captureFocusInfo SKIPPED - initial load in progress`);
                return;
            }
            
            const active = document.activeElement;
            if (!(active && active.tagName === 'TD' && active.isContentEditable)) return;
            
            const row = active.closest('tr');
            const tbody = document.getElementById('table-body');
            const rowIndex = Array.from(tbody.querySelectorAll('tr')).indexOf(row);
            const colLabel = active.getAttribute('data-label') || '';
            const rowKey = row ? row.dataset.key || null : null;
            const caret = getCaretOffsetWithin(active);
            
            lastFocusInfo = { rowKey, rowIndex, colLabel, caret };
            
            try { 
                localStorage.setItem('lastFocusInfo', JSON.stringify(lastFocusInfo)); 
            } catch(_) {}
        }

        function focusCellFromInfo(info) {
            if (!info) return false;
            
            log(`🔍 focusCellFromInfo: Looking for rowKey="${info.rowKey}", rowIndex=${info.rowIndex}, colLabel="${info.colLabel}"`);
            
            const tbody = document.getElementById('table-body');
            let targetRow = null;
            
            if (info.rowKey) {
                targetRow = Array.from(tbody.querySelectorAll('tr')).find(tr => tr.dataset.key === String(info.rowKey));
                log(`🔍 focusCellFromInfo: Found row by key: ${!!targetRow}`);
            }
            
            if (!targetRow) {
                const rows = tbody.querySelectorAll('tr');
                targetRow = rows[info.rowIndex] || null;
                log(`🔍 focusCellFromInfo: Found row by index: ${!!targetRow}`);
            }
            
            if (!targetRow) {
                log(`❌ focusCellFromInfo: No target row found`);
                return false;
            }
            
            const cells = Array.from(targetRow.querySelectorAll('td'));
            log(`🔍 focusCellFromInfo: Row has ${cells.length} cells, looking for label "${info.colLabel}"`);
            
            // Use absolute cell index like focusCellByPos, not sliced cells
            const cell = cells.find(td => (td.getAttribute('data-label') || '') === info.colLabel) || null;
            
            if (!cell) {
                log(`❌ focusCellFromInfo: No cell found with label "${info.colLabel}"`);
                // Debug: show all available labels
                const availableLabels = cells.map((td, i) => `${i}:"${td.getAttribute('data-label') || 'NO_LABEL'}"`).join(', ');
                log(`🔍 Available labels: ${availableLabels}`);
                return false;
            }
            
            log(`✅ focusCellFromInfo: Found cell at index ${cells.indexOf(cell)} with label "${info.colLabel}"`);
            
            if (isMobile()) {
                return focusCellWithMobileSupport(cell);
            }
            
            try { 
                cell.scrollIntoView({ block: 'center', inline: 'nearest' }); 
            } catch(_) {}
            
            let placed = false;
            try { 
                setCaretAt(cell, null); 
                placed = true; 
            } catch(_) {}
            
            if (!placed) { 
                setTimeout(() => { 
                    try { 
                        setCaretAt(cell, null); 
                    } catch(_) {} 
                }, 50); 
            }
            
            try {
                requestAnimationFrame(() => {
                    setCaretAt(cell, null);
                    requestAnimationFrame(() => { 
                        setCaretAt(cell, null); 
                    });
                });
            } catch(_) {}
            
            if (document.activeElement !== cell) { 
                try { 
                    cell.focus(); 
                } catch(_) {} 
            }
            
            return true;
        }

        function focusCellByPos(pos) {
            try {
                if (!pos) return false;
                
                const tbody = document.getElementById('table-body');
                const totalRows = tbody.querySelectorAll('tr').length;
                const row = tbody.querySelectorAll('tr')[pos.rowIndex];
                
                if (!row) {
                    log(`❌ RESTORE DEBUG: Row ${pos.rowIndex} not found (total rows: ${totalRows})`);
                    return false;
                }
                
                const totalCells = row.cells.length;
                const cell = row.cells[pos.cellIndex];
                
                if (!cell) {
                    log(`❌ RESTORE DEBUG: Cell ${pos.cellIndex} not found in row ${pos.rowIndex} (total cells: ${totalCells})`);
                    return false;
                }
                
                // DEBUG: Log detailed information about the cell being restored
                const cellLabel = cell.getAttribute('data-label') || 'NO_LABEL';
                const cellText = cell.textContent.substring(0, 20) + '...';
                
                log(`🔍 RESTORE DEBUG: row=${pos.rowIndex}/${totalRows}, cell=${pos.cellIndex}/${totalCells}, label="${cellLabel}", text="${cellText}"`);
                
                if (isMobile()) {
                    return focusCellWithMobileSupport(cell);
                }
                
                setCaretAt(cell, null);
                
                try {
                    cell.dispatchEvent(new MouseEvent('pointerdown', { bubbles: true }));
                    cell.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
                    cell.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
                    cell.click();
                } catch(_) {}
                
                log(`focusCellByPos -> active=${document.activeElement === cell}`);
                
                try {
                    requestAnimationFrame(() => {
                        setCaretAt(cell, null);
                        requestAnimationFrame(() => { 
                            setCaretAt(cell, null); 
                        });
                    });
                } catch(_) {}
                
                return document.activeElement === cell;
            } catch(_) { 
                return false; 
            }
        }

        // Data collection and management
        function collectTableData() { 
            const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent); 
            const rows = []; 
            
            document.querySelectorAll('#data-table tbody tr').forEach((rowEl, index) => { 
                const rowData = {}; 
                
                // Gestion améliorée de la clé primaire compatible smallint
                if (rowEl.dataset.key && rowEl.dataset.key !== '') { 
                    const keyValue = parseInt(rowEl.dataset.key);
                    // S'assurer que la clé est dans la plage smallint (-32,768 à 32,767)
                    if (keyValue >= -32768 && keyValue <= 32767) {
                        rowData[supabaseConfig.primaryKeyColumn] = keyValue;
                    } else {
                        // Si la clé est hors plage, utiliser l'index + 1
                        rowData[supabaseConfig.primaryKeyColumn] = index + 1;
                    }
                } else {
                    // Si pas de clé, utiliser l'index + 1 comme clé temporaire
                    rowData[supabaseConfig.primaryKeyColumn] = index + 1;
                }
                
                const cells = Array.from(rowEl.querySelectorAll('td')).slice(2); 
                cells.forEach((td, i) => { 
                    const label = headers[i]; 
                    const key = label; 
                    rowData[key] = td.textContent === '' ? null : td.textContent; 
                }); 
                
                rows.push(rowData); 
            }); 
            
            return { headers, rows }; 
        }
        
        function saveStateToHistory() { 
            // Clean: Removed debug logging
            
            // Protection renforcée : ne rien faire si on est en mode visualisation protégé
            if (isViewModeProtected || (isViewMode && isMobile()) || isPerformingUndoRedo) {
                // Clean: Removed debug log
                return;
            }
            
            if (historyDebounceTimeout) clearTimeout(historyDebounceTimeout); 
            
            historyDebounceTimeout = setTimeout(() => { 
                const s = collectTableData(); 
                const last = history[history.length - 1]; 
                
                if (!last || generateDataHash(s) !== generateDataHash(last)) { 
                    history.push(s); 
                    if (history.length > 10) history.shift(); 
                    // Pushing a new state clears redo stack
                    redoHistory = [];
                    // Also record as an operation if none in progress
                    if (!currentOperation) {
                        const op = {
                            type: OPERATION_TYPES.BULK_EDIT,
                            data: {},
                            timestamp: Date.now(),
                            tableState: s,
                            rowColors: { ...rowColorMap },
                            finalState: s,
                            finalRowColors: { ...rowColorMap }
                        };
                        operationHistory.push(op);
                        if (operationHistory.length > 50) operationHistory.shift();
                    }
                    persistHistoryStacks();
                    updateUndoButtonState(); 
                    log('État de l\'historique enregistré.'); 
                } 
            }, 500); 
        }
        
        function saveLocalDraft() { 
            // Protection renforcée : ne rien faire si on est en mode visualisation protégé
            if (isViewModeProtected || (isViewMode && isMobile())) {
                return;
            }
            
            try { 
                localStorage.setItem('staffTableDraft', document.getElementById('data-table').outerHTML); 
            } catch(e) {} 
        }
        
        function restoreLocalDraft() {
            try {
                const draft = localStorage.getItem('staffTableDraft');
                if (draft) {
                    const el = document.getElementById('data-table');
                    if (el) {
                        // Sauvegarder l'état du mode visualisation avant la restauration
                        const wasViewMode = isViewMode;
                        
                        // NUCLEAR OPTION: Désactiver TOUTES les sauvegardes si on est en mode visualisation
                        let originalFunctions = {};
                        if (wasViewMode) {
                            // Sauvegarder toutes les fonctions originales
                            originalFunctions.markEdited = window.markEdited;
                            originalFunctions.saveStateToHistory = window.saveStateToHistory;
                            originalFunctions.saveLocalDraft = window.saveLocalDraft;
                            
                            // Remplacer par des fonctions vides avec debug
                            window.markEdited = function() { 
                                // Clean: Removed debug log 
                                return; 
                            };
                            window.saveStateToHistory = function() { 
                                // Clean: Removed debug log 
                                return; 
                            };
                            window.saveLocalDraft = function() { 
                                // Clean: Removed debug log 
                                return; 
                            };
                            
                            // Activer la protection renforcée
                            isViewModeProtected = true;
                            // Clean: Removed debug log
                        }
                        
                        el.outerHTML = draft;
                        log('Brouillon local restauré.');
                        
                        // Restaurer le mode visualisation immédiatement après la restauration
                        if (wasViewMode) {
                            isViewMode = true;
                            
                            // Délai adaptatif selon l'appareil (plus long sur mobile)
                            const delay = isMobile() ? 300 : 150;
                            const restoreDelay = isMobile() ? 10000 : 6000;
                            
                            // Clean: Removed debug log
                            
                            // Appliquer le mode visualisation aux nouvelles cellules
                            setTimeout(() => {
                                // Clean: Removed debug log
                                const editableCells = document.querySelectorAll('.editable-cell');
                                editableCells.forEach(cell => {
                                    cell.contentEditable = 'false';
                                    cell.style.backgroundColor = '#f8f9fa';
                                    cell.style.cursor = 'default';
                                });
                                
                                // Mettre à jour l'apparence du bouton
                                updateViewModeButton();
                                
                                // Le bouton d'ajout FAB doit toujours être visible, mais désactivé en mode visualisation
                                const fabAdd = document.getElementById('fab-add');
                                if (fabAdd) {
                                    fabAdd.style.display = 'flex';
                                    fabAdd.style.visibility = 'visible';
                                    
                                    if (isViewMode) {
                                        // Mode visualisation : bouton visible mais désactivé
                                        fabAdd.style.opacity = '0.5';
                                        fabAdd.style.pointerEvents = 'none';
                                        fabAdd.style.cursor = 'not-allowed';
                                        fabAdd.title = 'Mode visualisation actif - Ajout de lignes désactivé';
                                    } else {
                                        // Mode normal : bouton pleinement fonctionnel
                                        fabAdd.style.opacity = '1';
                                        fabAdd.style.pointerEvents = 'auto';
                                        fabAdd.style.cursor = 'pointer';
                                        fabAdd.title = 'Ajouter une nouvelle ligne';
                                    }
                                }
                                
                                // Clean: Removed debug log
                                
                                // Réactiver les sauvegardes après un délai adaptatif
                                setTimeout(() => {
                                    // Clean: Removed debug log
                                    if (originalFunctions.markEdited) {
                                        window.markEdited = originalFunctions.markEdited;
                                    }
                                    if (originalFunctions.saveStateToHistory) {
                                        window.saveStateToHistory = originalFunctions.saveStateToHistory;
                                    }
                                    if (originalFunctions.saveLocalDraft) {
                                        window.saveLocalDraft = originalFunctions.saveLocalDraft;
                                    }
                                    
                                    // Désactiver la protection renforcée
                                    isViewModeProtected = false;
                                    // Clean: Removed debug log
                                }, restoreDelay);
                            }, delay);
                        }
                        
                        rebindRowNumberCells();
                        
                        try {
                            const tbody = document.getElementById('table-body');
                            Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                                const k = keyForRow(tr);
                                const col = rowColorMap[k];
                                if (col) setRowColor(tr, col);
                            });
                        } catch(_) {}
                    }
                }
            } catch(e) {}
        }
        
        // Optimized markEdited with performance-focused throttling
        let lastMarkEditedTime = 0;
        const MARK_EDITED_THROTTLE = 50; // Prevent excessive calls
        
        function markEdited() {
            // Don't mark edited during cursor restoration to prevent save cascades
            if (isRestoringCursor) {
                console.log('⚠️ markEdited BLOCKED - cursor restoration in progress', new Error().stack.split('\n')[2]);
                return;
            }
            
            const now = Date.now();
            
            // Throttle to prevent excessive execution
            if (now - lastMarkEditedTime < MARK_EDITED_THROTTLE) {
                console.log('⚠️ markEdited throttled');
                return;
            }
            lastMarkEditedTime = now;
            
            console.log('⚠️ [EXCEL-SAVE] markEdited called (Excel mode - no timer autosave):', new Error().stack.split('\n')[2]);
            
            isDirty = true;
            isTyping = true;
            lastEditAt = now;
            
            // Clear existing typing timer
            if (typingTimer) clearTimeout(typingTimer);
            
            // ✅ EXCEL MODE: No automatic timer-based autosave
            // Save only happens on cell blur (when moving between cells)
            console.log('📝 [EXCEL-SAVE] Changes marked but autosave disabled - save on cell blur only');
            
            // Set typing state timeout
            typingTimer = setTimeout(() => { isTyping = false; }, 1200);
        }

        // Autosave functionality with enhanced undo/redo conflict prevention
        function scheduleAutosaveCountdown() {
            // Use enhanced version for better conflict prevention
            scheduleAutosaveCountdownEnhanced();
        }
        
        function startPeriodicSync() {
            // Use enhanced version for better conflict prevention
            startPeriodicSyncEnhanced();
        }

        // ===== Helpers & constants (DRY) =====
        const BOLD_HEADERS = ['nom_prénom','pec finale','diagnostic_initial'];
        function getHeaders(){
          return Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th=>th.textContent);
        }
        
        // Fonction pour mettre à jour l'affichage du nombre de lignes
        function updateRowCount() {
            const tbody = document.getElementById('table-body');
            const rowCountNumber = document.getElementById('row-count-number');
            
            if (tbody && rowCountNumber) {
                const rowCount = tbody.children.length;
                rowCountNumber.textContent = rowCount;
                // Clean: Removed debug log
            }
        }
        function createDeleteCell(row){
          const deleteCell=document.createElement('td');
          deleteCell.className='p-0 text-center';
          deleteCell.setAttribute('data-label','Effacer');
          const sel=document.createElement('input');
          sel.type='checkbox';
          sel.className='m-1 align-middle';
          sel.addEventListener('change',()=>{ row.classList.toggle('selected-row', sel.checked); });
          const deleteButton=document.createElement('button');
          deleteButton.className='text-red-500 hover:text-red-700 font-bold p-2 transition-colors';
          deleteButton.innerHTML='🗑️';
          deleteButton.onclick=(e)=>{
            e.stopPropagation();
            const selected = Array.from(document.querySelectorAll('#table-body tr.selected-row'));
            if (selected.length > 0) {
              // Multiple rows selected: confirm before deleting
              promptKeyConfirm(`Supprimer ${selected.length} ligne(s) ?`, () => deleteRows(selected));
            } else {
              // Single row via trash icon: delete immediately without confirmation
              deleteRows([row]);
            }
          };
          const wrap=document.createElement('div');
          wrap.className='flex items-center justify-center gap-1';
          wrap.appendChild(sel); wrap.appendChild(deleteButton);
          deleteCell.appendChild(wrap);
          return deleteCell;
        }
        function createEditableCell(header, value=''){
          const cell=document.createElement('td');
          const dbKey=header; // names are identical (no mapping)
          cell.textContent=value||'';
          cell.contentEditable=true;
          cell.className='py-2 px-2 md:px-4 editable-cell';
          cell.setAttribute('data-label',header);
          cell.setAttribute('data-dbkey',dbKey);
          
          // Force inline red color for Information complementaire to override any cascade
          if (header === 'Information complementaire' || header === 'information complementaire') {
            cell.style.color = '#dc2626';
          }
          
          // Remove any previous inline font size for numero_tel to keep 1.1rem via CSS
          if (header === 'Numero_tel' || header === 'numero_tel') {
            cell.style.fontSize = '';
          }
          
          // Sélection automatique du contenu lors du double-clic/double-tap
          cell.addEventListener('dblclick', (e) => {
            e.preventDefault();
            // Sélectionner tout le contenu de la cellule
            const range = document.createRange();
            range.selectNodeContents(cell);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
          });
          
          // Gestion du double-tap sur mobile
          let lastTap = 0;
          cell.addEventListener('touchstart', (e) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            if (tapLength < 500 && tapLength > 0) {
              // Double-tap détecté
              e.preventDefault();
              // Sélectionner tout le contenu de la cellule
              const range = document.createRange();
              range.selectNodeContents(cell);
              const selection = window.getSelection();
              selection.removeAllRanges();
              selection.addRange(range);
            }
            lastTap = currentTime;
          });
          
          // Stocker la valeur initiale pour détecter les vraies modifications
          let initialValue = value || '';
          let hasBeenModified = false;
          
          // --- Nom_Prénom auto-formatting logic ---
          if (isNomPrenomLabel(header)) {
            // Ensure initial display is formatted when creating the cell
            if (value) {
              value = formatNomPrenom(value);
              cell.textContent = value;
              initialValue = value;
            }
            
            // Format when the user leaves the cell (Excel-like behavior)
            cell.addEventListener('blur', async () => {
              const currentValue = cell.textContent;
              const formattedValue = formatNomPrenom(currentValue);
              cell.textContent = formattedValue;
              
              // Excel-like save: save immediately when moving to another cell
              if (hasBeenModified || formattedValue !== initialValue) {
                console.log('📝 [EXCEL-SAVE] Cell blur detected - saving modified cell');
                await saveModifiedCell(cell, initialValue, formattedValue);
                // Mettre à jour la valeur initiale pour les prochaines comparaisons
                initialValue = formattedValue;
                hasBeenModified = false;
              }
            });
            
            // Gérer le collage (seulement si le contenu change)
            cell.addEventListener('paste', () => {
              setTimeout(() => {
                const pastedValue = cell.textContent;
                const formattedValue = formatNomPrenom(pastedValue);
                cell.textContent = formattedValue;
                
                // Sauvegarder seulement si le contenu collé est différent
                if (formattedValue !== initialValue) {
                  saveStateToHistory();
                  saveLocalDraft();
                  markEdited();
                  initialValue = formattedValue;
                  hasBeenModified = false;
                }
              }, 0);
            });
          } else {
            // Pour les autres colonnes, Excel-like behavior
            cell.addEventListener('blur', async () => {
              const currentValue = cell.textContent;
              // Excel-like save: save immediately when moving to another cell
              if (hasBeenModified || currentValue !== initialValue) {
                console.log('📝 [EXCEL-SAVE] Cell blur detected - saving modified cell');
                await saveModifiedCell(cell, initialValue, currentValue);
                initialValue = currentValue;
                hasBeenModified = false;
              }
            });
            
            cell.addEventListener('paste', () => {
              setTimeout(() => {
                const pastedValue = cell.textContent;
                // Sauvegarder seulement si le contenu collé est différent
                if (pastedValue !== initialValue) {
                  saveStateToHistory();
                  saveLocalDraft();
                  markEdited();
                  initialValue = pastedValue;
                  hasBeenModified = false;
                }
              }, 0);
            });
          }
          
          if(BOLD_HEADERS.includes(header.toLowerCase())){
            cell.style.fontWeight='bold';
            cell.style.color='#000';
          }
          cell.setAttribute('tabindex','0');
          
          // Sauvegarder seulement lors de vraies modifications (input)
          cell.oninput=()=>{
            hasBeenModified = true;
            
            // Reset undo/redo sync timeout when user starts editing
            clearUndoRedoSyncTimeout();
            
            // Start or continue operation tracking for cell edits
            if (!currentOperation || currentOperation.type !== OPERATION_TYPES.CELL_EDIT) {
                startOperation(OPERATION_TYPES.CELL_EDIT, {
                    cellLabel: header,
                    initialValue: initialValue,
                    rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                    columnLabel: header,
                    editCount: 1,
                    edits: [{
                        columnLabel: header,
                        rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                        initialValue: initialValue,
                        currentValue: cell.textContent
                    }]
                });
            } else {
                // Increment edit count and add to edits array
                currentOperation.data.editCount = (currentOperation.data.editCount || 1) + 1;
                currentOperation.data.edits.push({
                    columnLabel: header,
                    rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                    initialValue: initialValue,
                    currentValue: cell.textContent
                });
                
                addToOperation({
                    cellLabel: header,
                    currentValue: cell.textContent,
                    rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                    columnLabel: header
                });
            }
            
            // Debounce operation completion for cell edits
            if (operationTimeout) clearTimeout(operationTimeout);
            operationTimeout = setTimeout(() => {
                completeOperation();
            }, 1000); // 1 second delay for cell edits
            
            // Excel mode: Save history and local draft but no timer-based autosave
            saveStateToHistory();
            saveLocalDraft();
            
            // Mark as dirty but don't trigger timer-based autosave (Excel mode)
            isDirty = true;
            isTyping = true;
            lastEditAt = Date.now();
            console.log('📝 [EXCEL-SAVE] Cell input detected - marked dirty, save on blur only');
            
            // keep caret/position updated while typing
            captureFocusInfo();
            captureSimplePos();
          };
          
          cell.addEventListener('keyup', (e) => {
            // update caret after navigation keys
            if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Home','End','PageUp','PageDown'].includes(e.key)) {
              captureFocusInfo();
              captureSimplePos();
            }
          });
          return cell;
        }

        // Ensure DDN column exists visually even if an older HTML version is served (Live Server/mobile cache)
        function ensureDDNHeader(){
          try {
            const theadRow = document.querySelector('#data-table thead tr');
            if (!theadRow) return;
            const labels = Array.from(theadRow.children).map(th=>th.textContent.trim());
            if (labels.includes('DDN')) return; // already there

            // Create the DDN header cell
            const th = document.createElement('th');
            th.setAttribute('scope','col');
            th.className = 'py-2 px-2 md:px-4';
            th.textContent = 'DDN';

            // Insert right after Nom_Prénom if present, else before Diagnostic_initial, else at the end
            let insertIndex = labels.indexOf('Nom_Prénom');
            if (insertIndex !== -1) {
              theadRow.insertBefore(th, theadRow.children[insertIndex + 1]);
            } else {
              const diagIdx = labels.indexOf('Diagnostic_initial');
              if (diagIdx !== -1) theadRow.insertBefore(th, theadRow.children[diagIdx]);
              else theadRow.appendChild(th);
            }

            // For each body row, insert a new editable DDN cell at the same index
            const headersNow = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th=>th.textContent);
            const ddnPos = headersNow.indexOf('DDN');
            if (ddnPos !== -1) {
              document.querySelectorAll('#table-body tr').forEach(tr => {
                const cell = createEditableCell('DDN', '');
                // Insert after the first two fixed cells (No, Effacer) + ddnPos offset
                const insertAt = 2 + ddnPos;
                const ref = tr.cells[insertAt];
                if (ref) tr.insertBefore(cell, ref); else tr.appendChild(cell);
              });
            }

            // Adjust tfoot colspan to match new column count
            const tfootLast = document.querySelector('#data-table tfoot td:last-child');
            const totalCols = document.querySelectorAll('#data-table thead th').length;
            if (tfootLast) {
              // first two tds in tfoot row are No/Effacer holders; last td should span the remainder
              const span = Math.max(0, totalCols - 2);
              tfootLast.setAttribute('colspan', String(span));
            }
          } catch(e) { /* noop */ }
        }

        // Keep tfoot colspan in sync with the current number of columns
        function updateTfootColspan() {
            try {
                const totalCols = document.querySelectorAll('#data-table thead th').length;
                const tfootRow = document.querySelector('#data-table tfoot tr');
                if (!tfootRow) return;
                // First cell spans the first two utility columns (No, Effacer)
                const firstTd = tfootRow.querySelector('td:first-child');
                if (firstTd) firstTd.setAttribute('colspan', '2');
                // Last cell spans the remainder
                const lastTd = tfootRow.querySelector('td:last-child');
                if (lastTd) lastTd.setAttribute('colspan', String(Math.max(0, totalCols - 2)));
            } catch(_) {}
        }
        // Align table headers with server column keys (case-insensitive)
        function reconcileHeadersWithServer() {
          try {
            if (!appState.serverColumns || appState.serverColumns.length === 0) return;
            const server = appState.serverColumns;
            const theadTh = Array.from(document.querySelectorAll('#data-table thead th')).slice(2);
            theadTh.forEach((th) => {
              const label = th.textContent;
              if (server.includes(label)) return; // exact match OK
              const found = server.find(k => k.toLowerCase() === label.toLowerCase());
              if (found) {
                th.textContent = found; // normalize header to the exact server key
              }
            });
          } catch (e) { /* no-op */ }
        }
        // === Excel import helpers ===
        function normalizeKey(k){
          if(!k) return '';
          return String(k).trim().toLowerCase().replace(/[_\-\s]+/g,' ').replace(/\s+/g,' ').normalize('NFD').replace(/[\u0300-\u036f]/g,'');
        }
        // === Name formatting helpers ===
        function _titleCasePart(s) {
          if (!s) return '';
          return s.split(' ').map(word => {
            if (word.length <= 2) return word.toLowerCase();
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
          }).join(' ');
        }
        
        function formatNomPrenom(raw){
          if(raw==null) return '';
          let s = String(raw).trim().replace(/\s+/g, ' ');
          if(!s) return '';
          // If there's a comma, interpret as "LAST, First ..."
          if(s.includes(',')){
            const [last, rest] = s.split(',');
            const nom = last.trim().toUpperCase();
            const prenom = _titleCasePart((rest||'').trim());
            return prenom ? `${nom}\n${prenom}` : nom;
          }
          // Default: first token is last name; remainder is first name(s)
          const parts = s.split(' ');
          const nom = (parts.shift()||'').toUpperCase();
          const prenom = _titleCasePart(parts.join(' ').trim());
          return prenom ? `${nom}\n${prenom}` : nom;
        }
        
        function isNomPrenomLabel(label){
          try {
            const n = normalizeKey(label);
            return n === 'nom prenom' || n.includes('nom prenom');
          } catch(_) {
            return label === 'Nom_Prénom';
          }
        }
        function buildHeaderMap(sheetKeys, tableHeaders){
          const map = {};
          const nSheet = sheetKeys.map(k=>({raw:k, norm:normalizeKey(k)}));
          const nTable = tableHeaders.map(k=>({raw:k, norm:normalizeKey(k)}));

          // Raw alias definitions (human-friendly)
          const aliasesRaw = {
            'date de saisie': ['date', 'date saisie', 'date d\'entree', 'date entree', 'datesaisie', 'date d\'enregistrement'],
            'pec finale': ['pec finale', 'pec finale (definitive)', 'prise en charge finale', 'prise en charge def'],
            'pec initiale': ['pec initiale', 'prise en charge initiale', 'prise en charge init'],
            'nom_prenom': ['nom prenom', 'nom_prénom', 'nom et prenom', 'nom et prénom', 'patient', 'nom complet', 'fullname', 'name'],
            'ddn': ['date de naissance', 'date naissance', 'naissance', 'dob', 'date of birth', 'birth date', 'dn'],
            'diagnostic_initial': ['diagnostic initial', 'diagnostic', 'diag initial', 'diagnostic de depart'],
            'information complementaire': ['infos', 'information complementaire', 'commentaire', 'notes', 'remarques', 'obs', 'observations'],
            'numero_tel': ['tel', 'telephone', 'numero tel', 'numero telephone', 'phone', 'portable', 'gsm', 'mobile']
          };
          // Normalize alias values once for consistent matching
          const aliases = Object.fromEntries(
            Object.entries(aliasesRaw).map(([k, arr]) => [normalizeKey(k), arr.map(v => normalizeKey(v))])
          );

          nTable.forEach(t => {
            // 1) exact normalized match
            let match = nSheet.find(s => s.norm === t.norm);

            // 2) alias match (normalized)
            if(!match){
              const listNorm = aliases[t.norm] || [];
              match = nSheet.find(s => listNorm.includes(s.norm));
            }

            // 3) fuzzy for DDN — accept any column that contains naiss/birth/dob tokens
            if(!match && t.norm === 'ddn'){
              match = nSheet.find(s => /\b(naiss|birth|dob|date naissance|date de naissance)\b/.test(s.norm))
                    || nSheet.find(s => s.norm.includes('naiss') || s.norm.includes('birth') || s.norm.includes('dob'));
            }

            if(match) map[t.raw] = match.raw; // map table header -> sheet column
          });
          return map;
        }
        function coerceCellValue(header, val){
          if(val==null) return '';
          const h = normalizeKey(header);

          // Excel serial number handling for date-like headers
          if((h.includes('date') || h==='ddn') && typeof val === 'number'){
            try {
              const epoch = new Date(Date.UTC(1899,11,30));
              const d = new Date(epoch.getTime() + val*86400000);
              const dd = String(d.getUTCDate()).padStart(2,'0');
              const mm = String(d.getUTCMonth()+1).padStart(2,'0');
              const yy = String(d.getUTCFullYear()).slice(-2);
              return `${dd}/${mm}/${yy}`;
            } catch(_) { /* fallthrough */ }
          }

          // Parse common textual date forms
          if((h.includes('date') || h==='ddn') && typeof val === 'string'){
            const s = val.trim();
            // Normalize separators
            const norm = s.replace(/[.\-]/g,'/').replace(/\s+/g,'');

            // YYYY/MM/DD or YYYY/M/D
            let m = norm.match(/^(\d{4})\/(\d{1,2})\/(\d{1,2})$/);
            if(m){
              const y = parseInt(m[1],10), mo = parseInt(m[2],10), d = parseInt(m[3],10);
              if(mo>=1 && mo<=12 && d>=1 && d<=31){
                return `${String(d).padStart(2,'0')}/${String(mo).padStart(2,'0')}/${String(y).slice(-2)}`;
              }
            }

            // DD/MM/YYYY or D/M/YY etc.
            m = norm.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
            if(m){
              const d = parseInt(m[1],10), mo = parseInt(m[2],10), y = parseInt(m[3],10);
              if(mo>=1 && mo<=12 && d>=1 && d<=31){
                return `${String(d).padStart(2,'0')}/${String(mo).padStart(2,'0')}/${String(y).toString().slice(-2)}`;
              }
            }

            // Fallback: try Date.parse cautiously
            const t = Date.parse(s);
            if(!isNaN(t)){
              const d = new Date(t);
              const dd = String(d.getUTCDate()).padStart(2,'0');
              const mm = String(d.getUTCMonth()+1).padStart(2,'0');
              const yy = String(d.getUTCFullYear()).slice(-2);
              return `${dd}/${mm}/${yy}`;
            }
          }

          return String(val);
        }
        async function importExcelFromFile(file){
          try{
            if(!file){ showMessage('Aucun fichier sélectionné','info'); return; }
            const ext = (file.name.split('.').pop()||'').toLowerCase();
            if(!['xlsx','xls','csv'].includes(ext)){
              showMessage('Format non pris en charge. Utilisez .xlsx, .xls ou .csv','info');
              return;
            }
            updateStatus('Import en cours...','saving');
            const data = await file.arrayBuffer();
            const wb = XLSX.read(data, { type:'array' });
            const sheetName = wb.SheetNames[0];
            const ws = wb.Sheets[sheetName];
            const rows = XLSX.utils.sheet_to_json(ws, { defval:'', raw:false });
            if(!Array.isArray(rows) || rows.length===0){ showMessage('Feuille vide','info'); updateStatus('Synchronisé','success'); return; }

            // Colonnes système à ignorer lors de l'import
            const systemColumns = ['No', 'Effacer', 'Date de saisie'];
            
            // Colonnes de données à importer (excluant les colonnes système)
            const dataColumns = getHeaders().filter(header => !systemColumns.includes(header));
            
            // Filtrer les lignes : seulement celles avec Nom_Prénom rempli
            const validRows = rows.filter(row => {
              const nomPrenom = row['Nom_Prénom'] || row['Nom_Prénom'] || row['Nom Prénom'] || row['NomPrénom'];
              return nomPrenom && nomPrenom.trim() !== '';
            });

            if(validRows.length === 0){
              showMessage('Aucune ligne avec Nom_Prénom rempli trouvée dans le fichier','info');
              updateStatus('Import terminé','success');
              return;
            }

                            // Clean: Removed debug log

            // Construire les données d'import avec gestion intelligente
            const importData = validRows.map((row, index) => {
              const obj = {};
              
              // Générer automatiquement une clé primaire unique compatible smallint
              // Utiliser un index simple pour éviter les dépassements de type
              obj[supabaseConfig.primaryKeyColumn] = index + 1;
              
              // Ajouter automatiquement la date de saisie
              obj['Date de saisie'] = getFormattedDate();
              
              // Importer seulement les colonnes de données (pas les colonnes système)
              dataColumns.forEach(column => {
                const sheetKey = findBestMatch(column, Object.keys(row));
                if (sheetKey && row[sheetKey] !== undefined && row[sheetKey] !== '') {
                  obj[column] = coerceCellValue(column, row[sheetKey]);
                } else {
                  obj[column] = '';
                }
              });
              
              return obj;
            });

            // Charger dans le tableau
            if(loadTableData(importData)){
              saveStateToHistory();
              saveLocalDraft();
              markEdited();
              updateStatus('Importé (non sauvegardé)','success');
              showMessage(`Import réussi: ${importData.length} ligne(s) avec Nom_Prénom. Colonnes système générées automatiquement.`);
            } else {
              updateStatus('Erreur import','error');
              showMessage('Échec du chargement des données importées.','info');
            }
          } catch(err){
            console.error(err);
            updateStatus('Erreur import','error');
            showMessage('Erreur lors de l\'import. Vérifiez le fichier.','info');
          }
        }

        // Fonction pour trouver la meilleure correspondance de colonne
        function findBestMatch(targetColumn, availableColumns) {
          // Correspondance exacte
          if (availableColumns.includes(targetColumn)) {
            return targetColumn;
          }
          
          // Correspondance sans espaces ni caractères spéciaux
          const normalizedTarget = targetColumn.replace(/[\s\-_]/g, '').toLowerCase();
          for (const col of availableColumns) {
            const normalizedCol = col.replace(/[\s\-_]/g, '').toLowerCase();
            if (normalizedCol === normalizedTarget) {
              return col;
            }
          }
          
          // Correspondance partielle
          for (const col of availableColumns) {
            const normalizedCol = col.replace(/[\s\-_]/g, '').toLowerCase();
            if (normalizedCol.includes(normalizedTarget) || normalizedTarget.includes(normalizedCol)) {
              return col;
            }
          }
          
          return null;
        }

        function loadTableData(data) {
            if (!data) { 
                log('Structure invalide', 'error'); 
                return false; 
            }
            
            // Protection supplémentaire contre l'effacement du tableau
            if (!Array.isArray(data) || data.length === 0) {
                console.warn('⚠️ loadTableData: data is not a valid array or is empty, refusing to clear table');
                log('Données invalides - tableau non modifié', 'warning');
                return false;
            }
            
            const tbody = document.getElementById('table-body');
            tbody.innerHTML = '';
            const headers = getHeaders();
            
            data.forEach((rowData, index) => {
                const row = document.createElement('tr');
                row.className = 'bg-white hover:bg-gray-100 transition-colors cursor-pointer';
                
                if (rowData[supabaseConfig.primaryKeyColumn]) {
                    row.dataset.key = rowData[supabaseConfig.primaryKeyColumn];
                }

                // Create row number cell
                const numCell = document.createElement('td');
                numCell.textContent = index + 1;
                numCell.className = 'py-2 px-2 md:px-4 font-bold text-gray-800 whitespace-nowrap cursor-pointer frozen-column frozen-1';
                numCell.setAttribute('data-label', 'No');
                numCell.title = 'Cliquer pour colorer/effacer la ligne';
                
                // Add event listeners for row painting
                            numCell.addEventListener('mousedown', (e) => { 
                if (e.button !== 0) return; 
                startRowPaint(row); 
                e.preventDefault(); 
            });
            
            numCell.addEventListener('mouseenter', () => { 
                if (isRowPaintDragging) applyRowPaint(row); 
            });
            
            numCell.addEventListener('click', (e) => { 
                e.preventDefault();
                // En mode auto, on colorie/décolore directement au clic
                if (paintMode === 'auto') {
                    rowPaintAction = getPaintActionForRow(row);
                    applyRowPaint(row);
                } else if (!isRowPaintDragging) {
                    // En mode manuel, on utilise l'action sélectionnée
                    rowPaintAction = getPaintActionForRow(row);
                    applyRowPaint(row);
                }
            });
                
                numCell.addEventListener('touchstart', (e) => { 
                    startRowPaint(row); 
                    e.preventDefault(); 
                }, { passive: false });
                
                numCell.addEventListener('touchmove', (e) => { 
                    const t = e.touches && e.touches[0]; 
                    if (!t) return; 
                    const el = document.elementFromPoint(t.clientX, t.clientY); 
                    const tr = el ? el.closest('#table-body tr') : null; 
                    if (tr) applyRowPaint(tr); 
                    e.preventDefault(); 
                }, { passive: false });
                
                row.appendChild(numCell);

                // Add delete/selection cell
                row.appendChild(createDeleteCell(row));

                // Add data cells
                headers.forEach(header => {
                    let value = rowData[header] || '';
                    if (isNomPrenomLabel(header)) {
                        value = formatNomPrenom(value);
                    }
                    row.appendChild(createEditableCell(header, value));
                });

                tbody.appendChild(row);
            });
            
            // Re-apply stored row colors after rebuilding the tbody
            try {
                Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                    const k = keyForRow(tr);
                    const col = rowColorMap[k];
                    if (col) setRowColor(tr, col);
                });
            } catch(_) {}
            
            log('Données du tableau chargées.', 'success');
            appState.localData = collectTableData();
            appState.dataHash = generateDataHash(appState.localData);
            document.dispatchEvent(new CustomEvent('table:reloaded'));
            updateTfootColspan();
            log('table:reloaded dispatched');
            
            // Mettre à jour l'affichage du nombre de lignes
            updateRowCount();
            
            return true;
        }

        async function addRow() {
            // Empêcher l'ajout en mode visualisation
            if (isViewMode) {
                showMessage('Impossible d\'ajouter des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                return;
            }
            
            // Start operation tracking for row addition
            startOperation(OPERATION_TYPES.ROW_INSERT, {
                newRowKey: Date.now() + Math.random()
            });
            
            const tbody = document.getElementById('table-body');
            const row = document.createElement('tr');
            row.className = 'bg-white hover:bg-gray-100 transition-colors cursor-pointer';
            
            // Générer une clé primaire unique compatible smallint
            const existingKeys = Array.from(tbody.querySelectorAll('tr'))
                .map(tr => parseInt(tr.dataset.key) || 0)
                .filter(key => key > 0);
            
            let newKey = 1;
            if (existingKeys.length > 0) {
                newKey = Math.max(...existingKeys) + 1;
            }
            
            // S'assurer que la clé est dans la plage smallint
            if (newKey > 32767) {
                newKey = 1; // Recommencer à 1 si on dépasse la limite
            }
            
            row.dataset.key = newKey.toString();

            // Create row number cell
            const numCell = document.createElement('td');
            numCell.textContent = tbody.children.length + 1;
            numCell.className = 'py-2 px-2 md:px-4 font-bold text-gray-800 whitespace-nowrap cursor-pointer frozen-column frozen-1';
            numCell.setAttribute('data-label', 'No');
            numCell.title = 'Cliquer pour colorer/effacer la ligne';
            
                            numCell.addEventListener('mousedown', (e) => { 
                    if (e.button !== 0) return; 
                    startRowPaint(row); 
                    e.preventDefault(); 
                });
                
                numCell.addEventListener('mouseenter', () => { 
                    if (isRowPaintDragging) applyRowPaint(row); 
                });
                
                numCell.addEventListener('click', (e) => { 
                    e.preventDefault();
                    // En mode auto, on colorie/décolore directement au clic
                    if (paintMode === 'auto') {
                        rowPaintAction = getPaintActionForRow(row);
                        applyRowPaint(row);
                    } else if (!isRowPaintDragging) {
                        // En mode manuel, on utilise l'action sélectionnée
                        rowPaintAction = getPaintActionForRow(row);
                        applyRowPaint(row);
                    }
                });
            
            numCell.addEventListener('touchstart', (e) => { 
                startRowPaint(row); 
                e.preventDefault(); 
            }, { passive: false });
            
            numCell.addEventListener('touchmove', (e) => { 
                const t = e.touches && e.touches[0]; 
                if (!t) return; 
                const el = document.elementFromPoint(t.clientX, t.clientY); 
                const tr = el ? el.closest('#table-body tr') : null; 
                if (tr) applyRowPaint(tr); 
                e.preventDefault(); 
            }, { passive: false });
            
            row.appendChild(numCell);

            // Add delete/selection cell
            row.appendChild(createDeleteCell(row));

            // Add date cell (pre-filled)
            const dateCell = createEditableCell('Date de saisie', getFormattedDate());
            row.appendChild(dateCell);

            // Add remaining headers
            const headers = getHeaders().slice(1);
            headers.forEach(header => { 
                row.appendChild(createEditableCell(header, '')); 
            });

            tbody.appendChild(row);
            
            try { 
                const k = keyForRow(row); 
                const col = rowColorMap[k]; 
                if (col) setRowColor(row, col); 
            } catch(_) {}
            
            // Complete the operation
            completeOperation();
            
            markEdited();
            
            // Mettre à jour l'affichage du nombre de lignes
            updateRowCount();
        }

        async function deleteRows(rows) { 
            if (!rows || rows.length === 0) return;
            
            // Empêcher la suppression dans les snapshots ET en mode visualisation
            if (snapshotMode === 'snapshot') {
                showMessage('Impossible de supprimer des lignes dans un snapshot. Retournez aux données en direct pour modifier le tableau.', 'warning');
                return;
            }
            
            // Empêcher la suppression en mode visualisation
            if (isViewMode) {
                showMessage('Impossible de supprimer des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                return;
            }
            
            // Safety check: ensure we're not in the middle of an undo operation
            if (currentOperation && currentOperation.type.includes('undo')) {
                // Clean: Removed debug log
                return;
            }
            
            // Start operation tracking for deletion (Excel-style: single operation for multiple rows)
            startOperation(OPERATION_TYPES.ROW_DELETE, {
                deletedRows: rows.length,
                rowKeys: rows.map(r => r.dataset.key).filter(Boolean),
                rowData: rows.map(r => {
                    const rowData = {};
                    const cells = Array.from(r.querySelectorAll('td')).slice(2); // Skip No and Delete columns
                    const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                    cells.forEach((cell, i) => {
                        if (headers[i]) {
                            rowData[headers[i]] = rowData[headers[i]] = cell.textContent;
                        }
                    });
                    return rowData;
                }),
                rowNumbers: rows.map(r => {
                    const noCell = r.querySelector('td:first-child');
                    return noCell ? parseInt(noCell.textContent) : null;
                }).filter(n => !isNaN(n))
            });
            
            const keys = rows.map(r => r.dataset.key).filter(Boolean); 
            
            try { 
                if (keys.length > 0) { 
                    const { error } = await supabase
                        .from(supabaseConfig.tableName)
                        .delete()
                        .in(supabaseConfig.primaryKeyColumn, keys); 
                    
                    if (error) throw error; 
                    log(`Supprimé ${keys.length} ligne(s) côté serveur.`, 'success'); 
                } 
                

                
                // Remove rows from DOM
                rows.forEach(r => r.remove()); 
                
                // Renumber rows
                document.querySelectorAll('#table-body tr').forEach((tr, idx) => { 
                    const noCell = tr.querySelector('td:first-child'); 
                    if (noCell) noCell.textContent = idx + 1; 
                    tr.classList.remove('selected-row'); 
                });
                
                // Rebuild color map after deletions and renumbering
                rowColorMap = {};
                Array.from(document.querySelectorAll('#table-body tr')).forEach(tr => {
                    const k = keyForRow(tr);
                    const c = tr.style.backgroundColor;
                    if (c && c !== '') rowColorMap[k] = c;
                });
                
                persistRowColors();
                
                // Complete the operation
                completeOperation();
                
                saveLocalDraft(); 
                markEdited(); 
                updateStatus('Ligne(s) supprimée(s)', 'success'); 
                
                // Mettre à jour l'affichage du nombre de lignes
                updateRowCount();
                
                // Immediately sync with prune to avoid server reintroducing deleted rows
                await syncToMaster(true, true);
            } catch(err) { 
                // Cancel operation on error
                cancelOperation();
                log('Erreur lors de la suppression: ' + err.message, 'error'); 
                updateStatus('Erreur de suppression', 'error'); 
            } 
        }

        // Optimized Data synchronization with caching
        const dataCache = {
            lastFetch: 0,
            cacheDuration: 30000, // 30 seconds
            data: null,
            hash: null,
            
            isStale() {
                return Date.now() - this.lastFetch > this.cacheDuration;
            },
            
            set(data) {
                this.data = data;
                this.lastFetch = Date.now();
                this.hash = JSON.stringify(data).slice(0, 100); // Simple hash
            }
        };

        async function fetchInitialData(forceRefresh = false) { 
            log('Chargement des données (full fetch)...'); 
            updateStatus('Connexion...'); 
            
            // Use cached data if available and not stale
            if (!forceRefresh && dataCache.data && !dataCache.isStale()) {
                log('Utilisation des données mises en cache');
                if (loadTableData(dataCache.data)) {
                    updateStatus('Synchronisé (cache)', 'success');
                }
                return;
            }
            
            try { 
                // Restore undo/redo stacks for this session
                restoreHistoryStacks();
                
                // Optimized query with only necessary columns first
                const { data, error } = await supabase
                    .from(supabaseConfig.tableName)
                    .select('*')
                    .order(supabaseConfig.primaryKeyColumn, { ascending: true })
                    .limit(1000); // Prevent massive queries 
                
                if (error) throw error; 
                
                if (Array.isArray(data) && data.length > 0) { 
                    appState.serverColumns = Object.keys(data[0]); 
                }
                
                // Cache the fetched data
                dataCache.set(data);
                
                reconcileHeadersWithServer();
                ensureDDNHeader();
                
                if (loadTableData(data)) { 
                    updateStatus('Synchronisé', 'success'); 
                    saveStateToHistory(); 
                }
            } catch(e) { 
                log('Erreur lors du chargement des données : ' + e.message, 'error'); 
                updateStatus('Erreur de connexion', 'error'); 
            }
        }

        async function syncToMaster(isManualSave = false, pruneMissing = false) {
            // ENHANCED: Block sync during undo/redo operations (except manual saves)
            if (!isManualSave && isPerformingUndoRedo) {
                log('🚫 Sync BLOCKED - undo/redo in progress (manual save allowed)');
                return;
            }
            
            // ENHANCED: Block sync during undo/redo sync windows (except manual saves)
            if (!isManualSave && Date.now() < suppressAutosaveUntil) {
                log('🚫 Sync BLOCKED - undo/redo sync window active (manual save allowed)');
                return;
            }
            
            try { 
                if (autosaveTicker) clearInterval(autosaveTicker); 
            } catch(_) {}
            
            lastShownCountdown = null;
            
            const modal = document.getElementById('confirmation-modal');
            if (modal && !modal.classList.contains('hidden')) { 
                log('Sync ignorée: modale ouverte.'); 
                return; 
            }
            
            // ✅ CAPTURER LA CELLULE SÉLECTIONNÉE AVANT LA SAUVEGARDE
            const activeElement = document.activeElement;
            
            if (activeElement && activeElement.tagName === 'TD' && activeElement.contentEditable === 'true') {
                updateGlobalFocusState({
                    element: activeElement,
                    position: getCaretOffsetWithin(activeElement),
                    timestamp: Date.now(),
                    rowIndex: Array.from(activeElement.closest('tr').parentNode.querySelectorAll('tr')).indexOf(activeElement.closest('tr')),
                    colLabel: activeElement.getAttribute('data-label') || ''
                });
                
                log(`📝 Cellule sélectionnée capturée avant sauvegarde: ${capturedFocusState.colLabel}, position ${capturedFocusState.position}`, 'info');
            } else {
                log('⚠️ Aucune cellule active trouvée pour capture avant sauvegarde', 'warning');
                updateGlobalFocusState(null); // Clear any stale state
            }
            
            // Remember which cell and caret position were active before saving (legacy)
            captureFocusInfo();
            captureSimplePos();
            
            if (isManualSave && saveTimeout) { 
                clearTimeout(saveTimeout); 
            }
            
            const current = collectTableData();
            const currentHash = generateDataHash(current);
            
            let rowsForSync = current.rows.map(row => { 
                if (!appState.serverColumns) return row; 
                
                const allowed = new Set([supabaseConfig.primaryKeyColumn, ...appState.serverColumns]); 
                const filtered = {}; 
                
                for (const k in row) { 
                    if (allowed.has(k)) filtered[k] = row[k]; 
                } 
                
                return filtered; 
            });
            
            if (!isManualSave && currentHash === appState.dataHash) { 
                log('Pas de changement détecté.'); 
                isDirty = false; 
                updateStatus('Synchronisé', 'success'); 
                return; 
            }
            
            log('Synchronisation des données vers Supabase...');
            updateStatus('Sauvegarde en cours...', 'saving');
            isDirty = false;
            
            try {
                // Utiliser upsert pour toutes les opérations pour éviter les conflits de clé primaire
                if (rowsForSync.length > 0) {
                    const { error: upsertError } = await supabase
                        .from(supabaseConfig.tableName)
                        .upsert(rowsForSync, { 
                            onConflict: supabaseConfig.primaryKeyColumn,
                            ignoreDuplicates: false
                        });
                    if (upsertError) {
                        console.error('❌ Erreur upsert:', upsertError);
                        throw upsertError;
                    }
                }

                // Optionally prune server rows that are missing locally (for undo/redo or explicit deletions)
                if (pruneMissing) {
                    try {
                        const { data: serverKeysRows, error: fetchKeysErr } = await supabase
                            .from(supabaseConfig.tableName)
                            .select(supabaseConfig.primaryKeyColumn);
                        if (fetchKeysErr) throw fetchKeysErr;
                        const localKeys = new Set(current.rows.map(r => r[supabaseConfig.primaryKeyColumn]).filter(k => k != null));
                        const serverKeys = (serverKeysRows || []).map(r => r[supabaseConfig.primaryKeyColumn]).filter(k => k != null);
                        const keysToDelete = serverKeys.filter(k => !localKeys.has(k));
                        if (keysToDelete.length > 0) {
                            const { error: delErr } = await supabase
                                .from(supabaseConfig.tableName)
                                .delete()
                                .in(supabaseConfig.primaryKeyColumn, keysToDelete);
                            if (delErr) throw delErr;
                            log(`🧹 Serveur nettoyé: ${keysToDelete.length} ligne(s) supprimée(s) absentes localement.`);
                        }
                    } catch (pruneErr) {
                        console.error('❌ Erreur lors du prune des lignes manquantes:', pruneErr);
                    }
                }
                
                updateStatus('Sauvegardé', 'success');
                
                // Enregistrer le timestamp de sauvegarde pour éviter les conflits temps réel
                lastSaveTime = Date.now();
                log(`✅ Sauvegarde réussie à ${new Date(lastSaveTime).toLocaleTimeString()} - Cooldown temps réel activé pour ${REALTIME_COOLDOWN_MS}ms`);
                
                // ✅ RESTAURER LA CELLULE SÉLECTIONNÉE APRÈS LA SAUVEGARDE
                if (capturedFocusState && (capturedFocusState.element || (capturedFocusState.rowIndex >= 0 && capturedFocusState.colLabel))) {
                    log(`🔄 Restauration de la cellule sélectionnée après sauvegarde: ${capturedFocusState.colLabel}`, 'info');
                    
                    setTimeout(() => {
                        try {
                            // Set restoration flag to prevent save cascades
                            isRestoringCursor = true;
                            console.log('🔒 Cursor restoration started - blocking save operations');
                            
                            let targetElement = capturedFocusState.element;
                            
                            // If the original element reference is stale, find the element by position
                            if (!targetElement || !document.contains(targetElement)) {
                                log(`⚠️ Element référence obsolète, recherche par position: ligne ${capturedFocusState.rowIndex}, colonne ${capturedFocusState.colLabel}`, 'warning');
                                
                                const tbody = document.querySelector('#data-table tbody');
                                if (tbody) {
                                    const rows = tbody.querySelectorAll('tr');
                                    if (rows[capturedFocusState.rowIndex]) {
                                        const row = rows[capturedFocusState.rowIndex];
                                        targetElement = row.querySelector(`td[data-label="${capturedFocusState.colLabel}"]`);
                                        
                                        if (targetElement) {
                                            log(`✅ Élément trouvé par position: ${capturedFocusState.colLabel}`, 'success');
                                        } else {
                                            log(`❌ Impossible de trouver l'élément par position: ${capturedFocusState.colLabel}`, 'error');
                                        }
                                    }
                                }
                            }
                            
                            if (targetElement && document.contains(targetElement)) {
                                // Restaurer le focus sur la cellule
                                targetElement.focus();
                                log(`✅ Focus restauré sur la cellule: ${capturedFocusState.colLabel}`, 'success');
                                
                                // Restaurer la position du curseur
                                if (capturedFocusState.position !== null && capturedFocusState.position !== undefined) {
                                    try {
                                        setCaretAt(targetElement, capturedFocusState.position);
                                        log(`✅ Curseur restauré à la position ${capturedFocusState.position} dans ${capturedFocusState.colLabel}`, 'success');
                                    } catch (caretError) {
                                        log(`⚠️ Erreur lors de la restauration du curseur: ${caretError.message}`, 'warning');
                                        // Fallback: placer le curseur à la fin
                                        try {
                                            setCaretAt(targetElement, null);
                                            log(`✅ Curseur placé à la fin (fallback) dans ${capturedFocusState.colLabel}`, 'success');
                                        } catch (fallbackError) {
                                            log(`❌ Erreur fallback: ${fallbackError.message}`, 'error');
                                        }
                                    }
                                } else {
                                    log(`⚠️ Position du curseur non disponible dans ${capturedFocusState.colLabel}, placement à la fin`, 'warning');
                                    // Placer le curseur à la fin
                                    try {
                                        setCaretAt(targetElement, null);
                                        log(`✅ Curseur placé à la fin dans ${capturedFocusState.colLabel}`, 'success');
                                    } catch (fallbackError) {
                                        log(`❌ Erreur fallback: ${fallbackError.message}`, 'error');
                                    }
                                }
                                
                                // Faire défiler vers la cellule restaurée (sans effet visuel)
                                targetElement.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                                
                                // Clear captured focus state after successful restoration
                                setTimeout(() => {
                                    updateGlobalFocusState(null);
                                    log('🧹 Captured focus state cleared after successful restoration');
                                }, 1000);
                                
                            } else {
                                log(`❌ Impossible de restaurer la cellule - élément non trouvé: ${capturedFocusState.colLabel}`, 'error');
                            }
                            
                        } catch (error) {
                            log(`❌ Erreur lors de la restauration de la cellule sélectionnée: ${error.message}`, 'error');
                        } finally {
                            // Always clear the restoration flag
                            setTimeout(() => {
                                isRestoringCursor = false;
                                console.log('🔓 Cursor restoration completed - save operations re-enabled');
                            }, 1500); // Give extra time for all restoration operations to complete
                        }
                    }, 100);
                    
                } else {
                    log('⚠️ Aucune cellule sélectionnée à restaurer après sauvegarde', 'warning');
                }
                
                // ✅ NOUVELLE LOGIQUE: Si notre restauration a réussi, ne pas utiliser l'ancienne
                if (capturedFocusState && capturedFocusState.element) {
                    log(`✅ Restauration personnalisée réussie, ancienne restauration ignorée pour éviter les conflits`);
                } else {
                    log(`syncToMaster -> Focus restoration (lastCellPos=${JSON.stringify(lastCellPos)}, lastFocusInfo.col=${lastFocusInfo ? lastFocusInfo.colLabel : ''})`);
                    
                    // Restaurer le focus directement sans recharger les données
                    // car les données sont déjà synchronisées avec Supabase
                    setTimeout(() => {
                        log('🔍 Restauration directe du focus sans rechargement...');
                        
                        // Try simple row/cell index first
                        const posResult = focusCellByPos(lastCellPos);
                        log(`🔍 focusCellByPos result: ${posResult}`);
                        
                        if (!posResult) {
                            // Fallback to the richer label+caret based restore
                            const infoResult = focusCellFromInfo(lastFocusInfo);
                            log(`🔍 focusCellFromInfo result: ${infoResult}`);
                            
                            if (!infoResult) {
                                log('🔍 Both focus methods failed, trying delayed retry...');
                                setTimeout(() => { 
                                    if (!focusCellByPos(lastCellPos) && !focusCellFromInfo(lastFocusInfo)) { 
                                        log('🔍 Delayed retry also failed, trying final attempt...');
                                        setTimeout(() => { 
                                            const finalPos = focusCellByPos(lastCellPos);
                                            const finalInfo = focusCellFromInfo(lastFocusInfo);
                                            log(`🔍 Final attempt - pos: ${finalPos}, info: ${finalInfo}`);
                                        }, 250); 
                                    } 
                                }, 50);
                            }
                        }
                    }, 100);
                }
            } catch(e) {
                log('Erreur de sauvegarde : ' + e.message, 'error');
                updateStatus('Erreur de sauvegarde', 'error');
            }
        }

        async function pullFromMaster() { 
            log('Récupération des dernières données...'); 
            await fetchInitialData(); 
        }
        
        // Handle realtime updates from Supabase
        function handleRealtimeUpdate(payload) {
            console.log('🔄 [REALTIME] ========== REALTIME UPDATE START ==========');
            console.log('🔄 [REALTIME] Update received:', payload);
            console.log('🔄 [REALTIME] Event type:', payload.event);
            console.log('🔄 [REALTIME] Timestamp:', new Date().toISOString());
            console.log('🔄 [REALTIME] Current state - isRestoringCursor:', isRestoringCursor);
            console.log('🔄 [REALTIME] Current state - capturedFocusState:', capturedFocusState?.colLabel || 'none');
            
            // Performance monitoring
            if (typeof eventManager !== 'undefined' && eventManager.monitor) {
                eventManager.monitor.mark('realtime-update-start');
            }
            
            // Avoid update loops
            if (window.isLocalSaveInProgress) {
                console.log('⚠️ [REALTIME] Update BLOCKED - local save in progress');
                return;
            }
            
            // ✅ PRIORITY: Block if cursor restoration is actively happening
            if (isRestoringCursor) {
                console.log('⚠️ [REALTIME] Update BLOCKED - cursor restoration in progress (primary protection)');
                // Retry after cursor restoration is complete
                setTimeout(() => {
                    console.log('🔄 [REALTIME] Retrying update after cursor restoration...');
                    if (typeof fetchInitialData === 'function' && !isRestoringCursor && !isExcelSaveInProgress) {
                        fetchInitialData(true); // Force refresh for retry
                    }
                }, 2000); // Wait for cursor restoration to complete
                return;
            }
            
            // ✅ HIGH PRIORITY: Block if Excel-like save is in progress
            if (isExcelSaveInProgress) {
                console.log('⚠️ [REALTIME] Update BLOCKED - Excel-like save in progress (Excel protection)');
                // Retry after Excel save is complete
                setTimeout(() => {
                    console.log('🔄 [REALTIME] Retrying update after Excel save...');
                    if (typeof fetchInitialData === 'function' && !isRestoringCursor && !isExcelSaveInProgress) {
                        fetchInitialData(true); // Force refresh for retry
                    }
                }, 4000); // Wait for Excel save to complete
                return;
            }

            // Process update based on event type
            switch (payload.event) {
                case 'INSERT':
                    console.log('➕ New row inserted via realtime');
                    break;
                case 'UPDATE':
                    console.log('✏️ Row updated via realtime');
                    break;
                case 'DELETE':
                    console.log('🗑️ Row deleted via realtime');
                    break;
            }

            // ✅ Secondary protection: Extended focus restoration window for Excel-like saves
            if (capturedFocusState && capturedFocusState.element && capturedFocusState.timestamp && (Date.now() - capturedFocusState.timestamp < 5000)) {
                console.log('⚠️ [REALTIME] Update DELAYED - Excel-like save protection window active (5 seconds)');
                // Extended retry delay for Excel-like saves
                setTimeout(() => {
                    console.log('🔄 [REALTIME] Retrying update after Excel-like save window...');
                    if (typeof fetchInitialData === 'function' && !isRestoringCursor) {
                        fetchInitialData(true); // Force refresh for retry
                    }
                }, 5500); // Extended delay for Excel-like save completion
                return;
            }
            
            console.log('✅ [REALTIME] Proceeding with data refresh...');
            
            // Capture current cursor position before realtime refresh (if not already captured)
            const wasAlreadyCaptured = capturedFocusState !== null;
            if (!wasAlreadyCaptured) {
                const activeElement = document.activeElement;
                if (activeElement && activeElement.tagName === 'TD' && activeElement.contentEditable === 'true') {
                    updateGlobalFocusState({
                        element: activeElement,
                        position: getCaretOffsetWithin(activeElement),
                        timestamp: Date.now(),
                        rowIndex: Array.from(activeElement.closest('tr').parentNode.querySelectorAll('tr')).indexOf(activeElement.closest('tr')),
                        colLabel: activeElement.getAttribute('data-label') || ''
                    });
                    console.log('📝 [REALTIME] Cursor captured before realtime refresh:', capturedFocusState.colLabel);
                }
            }
            
            // Refresh data from Supabase after a short delay
            setTimeout(() => {
                if (typeof fetchInitialData === 'function') {
                    console.log('🔄 [REALTIME] Starting data refresh...');
                    fetchInitialData(true).then(() => { // Force refresh for realtime updates
                        console.log('✅ [REALTIME] Data refresh completed successfully');
                        updateStatus('Données synchronisées via temps réel', 'success');
                        
                        // Invalidate cache to ensure fresh data for future requests
                        if (typeof dataCache !== 'undefined') {
                            dataCache.lastFetch = 0; // Force cache invalidation
                        }
                        
                        // Force UI refresh to ensure changes are visible
                        if (typeof renderTable === 'function') {
                            console.log('🔄 [REALTIME] Force rendering table');
                            renderTable();
                        } else {
                            console.warn('⚠️ [REALTIME] renderTable function not available');
                        }
                        
                        // Trigger table update event for other components
                        document.dispatchEvent(new CustomEvent('table:updated', { detail: { source: 'realtime', timestamp: new Date().toISOString() } }));
                        console.log('✅ [REALTIME] Table update event dispatched');
                        
                        // ✅ Enhanced cursor restoration with stronger protection
                        if (capturedFocusState && capturedFocusState.colLabel) {
                            console.log('🔄 [REALTIME] Starting enhanced cursor restoration after realtime refresh...');
                            setTimeout(() => {
                                console.log('🔄 [REALTIME] Setting restoration flags...');
                                isRestoringCursor = true; // Primary flag
                                isExcelSaveInProgress = true; // Secondary protection during restoration
                                
                                try {
                                    let targetElement = capturedFocusState.element;
                                    
                                    // Element might be stale after refresh, find by position with enhanced search
                                    if (!targetElement || !document.contains(targetElement)) {
                                        console.log('🔄 [REALTIME] Element stale, searching by position and label...');
                                        const tbody = document.querySelector('#table-body') || document.querySelector('#data-table tbody');
                                        if (tbody) {
                                            const rows = tbody.querySelectorAll('tr');
                                            console.log(`🔄 [REALTIME] Found ${rows.length} rows, looking for row ${capturedFocusState.rowIndex}`);
                                            if (rows[capturedFocusState.rowIndex]) {
                                                const row = rows[capturedFocusState.rowIndex];
                                                targetElement = row.querySelector(`td[data-label="${capturedFocusState.colLabel}"]`);
                                                console.log('🔄 [REALTIME] Found target element by label:', !!targetElement);
                                            } else {
                                                console.warn('⚠️ [REALTIME] Row index out of bounds:', capturedFocusState.rowIndex, 'of', rows.length);
                                            }
                                        } else {
                                            console.warn('⚠️ [REALTIME] Table body not found');
                                        }
                                    }
                                    
                                    if (targetElement && document.contains(targetElement) && targetElement.contentEditable === 'true') {
                                        console.log('🔄 [REALTIME] Focusing target element and restoring caret...');
                                        targetElement.focus();
                                        
                                        // Restore caret position with validation
                                        if (capturedFocusState.position !== null && capturedFocusState.position !== undefined) {
                                            const textLength = targetElement.textContent.length;
                                            const safePosition = Math.min(capturedFocusState.position, textLength);
                                            setCaretAt(targetElement, safePosition);
                                            console.log(`🔄 [REALTIME] Caret set to position ${safePosition} (original: ${capturedFocusState.position})`);
                                        }
                                        
                                        console.log('✅ [REALTIME] Enhanced cursor restoration completed:', capturedFocusState.colLabel);
                                    } else {
                                        console.warn('⚠️ [REALTIME] Target element not available for restoration');
                                    }
                                } catch (error) {
                                    console.error('❌ [REALTIME] Error during enhanced cursor restoration:', error);
                                } finally {
                                    // Clear restoration flags with staggered timing
                                    setTimeout(() => {
                                        isRestoringCursor = false;
                                        console.log('✅ [REALTIME] Cursor restoration flag cleared');
                                    }, 800); // Clear cursor flag first
                                    
                                    setTimeout(() => {
                                        isExcelSaveInProgress = false;
                                        console.log('✅ [REALTIME] Excel save protection flag cleared');
                                    }, 2000); // Keep Excel protection longer
                                    
                                    setTimeout(() => {
                                        if (!wasAlreadyCaptured) {
                                            updateGlobalFocusState(null);
                                            console.log('✅ [REALTIME] Focus state cleared (was captured during realtime)');
                                        } else {
                                            console.log('🔄 [REALTIME] Focus state preserved (was pre-existing)');
                                        }
                                    }, 3000); // Clear focus state last
                                }
                            }, 300); // Slightly longer delay for DOM stability
                        } else {
                            console.log('🔄 [REALTIME] No focus state to restore');
                        }
                        
                        // Performance monitoring
                        if (typeof eventManager !== 'undefined' && eventManager.monitor) {
                            eventManager.monitor.mark('realtime-update-complete');
                        }
                        
                    }).catch(error => {
                        console.error('❌ [REALTIME] Data refresh failed:', error);
                        updateStatus('Erreur de synchronisation temps réel', 'error');
                        
                        // Performance monitoring
                        if (typeof eventManager !== 'undefined' && eventManager.monitor) {
                            eventManager.monitor.mark('realtime-update-error');
                        }
                    });
                } else {
                    console.error('❌ [REALTIME] fetchInitialData function not available!');
                }
            }, 1000);
        }

        // Setup realtime subscription for live data synchronization
        function setupRealtimeSubscription() {
            try {
                if (realtimeSubscription) {
                    console.log('🔄 Cleaning up existing realtime subscription...');
                    supabase.removeChannel(realtimeSubscription);
                }

                console.log('🔄 Setting up realtime subscription...');
                
                realtimeSubscription = supabase.channel('table-changes')
                    .on('postgres_changes', { 
                        event: 'INSERT', 
                        schema: 'public', 
                        table: 'staffTable' 
                    }, handleRealtimeUpdate)
                    .on('postgres_changes', { 
                        event: 'UPDATE', 
                        schema: 'public', 
                        table: 'staffTable' 
                    }, handleRealtimeUpdate)
                    .on('postgres_changes', { 
                        event: 'DELETE', 
                        schema: 'public', 
                        table: 'staffTable' 
                    }, handleRealtimeUpdate)
                    .subscribe(status => {
                        console.log('📡 Realtime subscription status:', status);
                        if (status === 'SUBSCRIBED') {
                            console.log('✅ Realtime synchronization activated');
                            updateStatus('Synchronisation temps réel activée', 'success');
                        } else if (status === 'CHANNEL_ERROR') {
                            console.log('❌ Realtime synchronization error');
                            updateStatus('Erreur de synchronisation', 'error');
                        }
                    });
                    
                console.log('✅ Realtime subscription configured');
            } catch (error) {
                console.error('❌ Error setting up realtime subscription:', error);
                updateStatus('Erreur de configuration temps réel', 'error');
            }
        }



        // Password authentication
        function checkPassword() { 
            const pwd = document.getElementById('password').value; 
            const err = document.getElementById('error-message'); 
            const passwordInput = document.getElementById('password');
            const togglePassword = document.getElementById('toggle-password');
            
            if (pwd === APP_CONFIG.password) { 
                appState.isLoggedIn = true; 
                sessionStorage.setItem('isLoggedIn', '1'); 
                
                // Masquer le login et afficher le tableau immédiatement
                document.getElementById('login-container').classList.add('hidden'); 
                document.getElementById('table-container').classList.remove('hidden'); 
                
                // S'assurer que le tableau est visible
                const tableContainer = document.getElementById('table-container');
                const table = document.getElementById('data-table');
                
                if (tableContainer) {
                    tableContainer.style.display = 'block';
                    tableContainer.style.visibility = 'visible';
                }
                
                if (table) {
                    table.style.display = 'table';
                    table.style.visibility = 'visible';
                }
                
                // Initialiser complètement l'application après la connexion
                initializeApp();
                
            } else { 
                err.textContent = 'Mot de passe incorrect. Le champ est maintenant visible pour faciliter la correction.';
                
                // Transformer automatiquement le champ en texte visible pour faciliter la correction
                passwordInput.type = 'text';
                togglePassword.checked = true;
                
                // Remettre le focus dans le champ pour permettre la correction immédiate
                passwordInput.focus();
                
                // Sélectionner tout le texte pour faciliter la correction
                passwordInput.select();
                
                // Ajouter une classe CSS pour indiquer visuellement l'erreur
                passwordInput.classList.add('password-error');
                
                // Retirer la classe d'erreur quand l'utilisateur commence à taper
                passwordInput.addEventListener('input', function clearErrorStyle() {
                    passwordInput.classList.remove('password-error');
                    passwordInput.removeEventListener('input', clearErrorStyle);
                }, { once: true });
            } 
        }

        // Export functionality
        function downloadExcel() { 
            const table = document.getElementById('data-table'); 
            const ws = XLSX.utils.table_to_sheet(table); 
            const wb = XLSX.utils.book_new(); 
            XLSX.utils.book_append_sheet(wb, ws, 'Staff Data'); 
            XLSX.writeFile(wb, 'Tableau_Staff.xlsx'); 
            showMessage('Excel téléchargé.'); 
        }
        
        function downloadPDF() { 
            const { jsPDF } = window.jspdf; 
            const doc = new jsPDF('l', 'pt', 'a4'); 
            doc.autoTable({ html: '#data-table' }); 
            doc.save('Tableau_Staff.pdf'); 
            showMessage('PDF téléchargé.'); 
        }
        
        function downloadImage() { 
            const table = document.getElementById('data-table'); 
            html2canvas(table).then(canvas => { 
                const link = document.createElement('a'); 
                link.href = canvas.toDataURL('image/png'); 
                link.download = 'Tableau_Staff.png'; 
                link.click(); 
                showMessage('Image téléchargée.'); 
            }); 
        }

        // Manual save function
        function saveManually() { 
            syncToMaster(true); 
        }

        // Row color binding
        function rebindRowNumberCells() {
            try {
                const rows = document.querySelectorAll('#table-body tr');
                rows.forEach((row) => {
                    const numCell = row.cells && row.cells[0];
                    if (!numCell) return;
                    
                    // Ensure proper classes/title
                    if (!numCell.className.includes('cursor-pointer')) {
                        numCell.className += ' cursor-pointer';
                    }
                    if (!numCell.getAttribute('title')) {
                        numCell.title = 'Cliquer pour colorer/effacer la ligne';
                    }
                    
                    // Replace the cell to drop old listeners
                    const newCell = numCell.cloneNode(true);
                    
                    // Drag start (mouse)
                    newCell.addEventListener('mousedown', (e) => { 
                        if (e.button !== 0) return; 
                        startRowPaint(row); 
                        e.preventDefault(); 
                    });
                    
                    // Drag over other rows (mouse)
                    newCell.addEventListener('mouseenter', () => { 
                        if (isRowPaintDragging) applyRowPaint(row); 
                    });
                    
                    // Simple toggle on click when not dragging
                    newCell.addEventListener('click', (e) => { 
                        e.preventDefault();
                        if (isRowPaintDragging) return;
                        rowPaintAction = getPaintActionForRow(row);
                        applyRowPaint(row);
                    });
                    
                    // Touch support
                    newCell.addEventListener('touchstart', (e) => { 
                        startRowPaint(row); 
                        e.preventDefault(); 
                    }, { passive: false });
                    
                    newCell.addEventListener('touchmove', (e) => {
                        const t = e.touches && e.touches[0]; 
                        if (!t) return; 
                        const el = document.elementFromPoint(t.clientX, t.clientY);
                        const tr = el ? el.closest('#table-body tr') : null; 
                        if (tr) applyRowPaint(tr); 
                        e.preventDefault();
                    }, { passive: false });
                    
                    row.replaceChild(newCell, numCell);
                });
            } catch(_) {}
        }

        // First use hint
        function maybeShowFirstUseHint() {
            try {
                if (localStorage.getItem('rowPaintHintShown') === '1') return;
                showMessage('Astuce: cliquez puis faites glisser sur les numéros de ligne pour colorer/effacer.', 'info');
                localStorage.setItem('rowPaintHintShown', '1');
            } catch(_) {}
        }

        // Event listeners setup
        function setupEventListeners() {
            // Before unload warning
            window.addEventListener('beforeunload', function (e) { 
                if (isDirty) { 
                    e.preventDefault(); 
                    e.returnValue = 'Des modifications non sauvegardées seront perdues si vous quittez.'; 
                } 
            });

            // Password toggle
            document.getElementById('toggle-password').addEventListener('change', function() { 
                const el = document.getElementById('password'); 
                el.type = this.checked ? 'text' : 'password'; 
            });
            
            // Password enter key
            document.getElementById('password').addEventListener('keydown', function (e) { 
                // Stop any global keyboard shortcuts from interfering
                e.stopPropagation();
                
                if (e.key === 'Enter') { 
                    e.preventDefault(); 
                    checkPassword(); 
                } 
                
                return true;
            });
            
            // Global keyboard shortcuts
            document.addEventListener('keydown', function (e) {
                // Manual save shortcut: Cmd+Z (Mac) or Ctrl+Z (Windows/Linux)
                if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
                    e.preventDefault(); // Prevent browser undo dialog
                    
                    // Only trigger if not in password input
                    const passwordInput = document.getElementById('password');
                    if (passwordInput && document.activeElement === passwordInput) {
                        return;
                    }
                    
                    // Only trigger if not in table cells (to avoid interfering with cell editing)
                    if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                        return;
                    }
                    
                    console.log('💾 Raccourci clavier de sauvegarde manuelle activé (Cmd+Z/Ctrl+Z)');
                    saveManually();
                }
                
                // Alternative save shortcut: Cmd+S (Mac) or Ctrl+S (Windows/Linux)
                if ((e.metaKey || e.ctrlKey) && e.key === 's') {
                    e.preventDefault(); // Prevent browser save dialog
                    
                    // Only trigger if not in password input
                    const passwordInput = document.getElementById('password');
                    if (passwordInput && document.activeElement === passwordInput) {
                        return;
                    }
                    
                    // Only trigger if not in table cells (to avoid interfering with cell editing)
                    if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                        return;
                    }
                    
                    console.log('💾 Raccourci clavier de sauvegarde manuelle activé (Cmd+S/Ctrl+S)');
                    saveManually();
                }
                
                // Undo shortcut: Cmd+Y (Mac) or Ctrl+Y (Windows/Linux)
                if ((e.metaKey || e.ctrlKey) && e.key === 'y') {
                    e.preventDefault(); // Prevent browser history dialog
                    
                    // Only trigger if not in password input
                    const passwordInput = document.getElementById('password');
                    if (passwordInput && document.activeElement === passwordInput) {
                        return;
                    }
                    
                    // Only trigger if not in table cells (to avoid interfering with cell editing)
                    if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                        return;
                    }
                    
                    // Check if undo is available
                    if (typeof undo === 'function' && operationHistory && operationHistory.length > 0) {
                        console.log('↩️ Raccourci clavier undo activé (Cmd+Y/Ctrl+Y)');
                        undo();
                    } else {
                        console.log('⚠️ Undo non disponible - aucune action à annuler');
                        showMessage('Aucune action à annuler', 'info');
                    }
                }
            });
            
            // Additional password field protection
            document.getElementById('password').addEventListener('input', function (e) {
                e.stopPropagation();
                return true;
            });
            
            document.getElementById('password').addEventListener('keypress', function (e) {
                e.stopPropagation();
                return true;
            });
            
            document.getElementById('password').addEventListener('keyup', function (e) {
                e.stopPropagation();
                return true;
            });

            // Table body paste handling
            document.getElementById('table-body').addEventListener('paste', function(e) {
                const active = document.activeElement;
                if (!(active && active.tagName === 'TD' && active.isContentEditable === 'true')) return;
                
                const text = (e.clipboardData || window.clipboardData).getData('text');
                if (!text || (text.indexOf('\t') === -1 && text.indexOf('\n') === -1)) return;
                
                e.preventDefault();
                const rows = text.split(/\r?\n/).filter(r => r.length > 0).map(r => r.split('\t'));
                const startCell = active;
                const startRow = startCell.closest('tr');
                const startIndex = Array.from(startRow.cells).indexOf(startCell);
                let r = startRow;
                
                rows.forEach((cols, ridx) => {
                    if (ridx > 0) {
                        r = r.nextElementSibling;
                        if (!r) {
                            const tbody = document.getElementById('table-body');
                            r = document.createElement('tr');
                            r.className = 'bg-white hover:bg-gray-100 transition-colors cursor-pointer';
                            
                            // Create row number cell
                            const n = document.createElement('td');
                            n.textContent = tbody.children.length + 1;
                            n.className = 'py-2 px-2 md:px-4 font-bold text-gray-800 whitespace-nowrap cursor-pointer';
                            n.setAttribute('data-label', 'No');
                            n.title = 'Cliquer pour colorer/effacer la ligne';
                            
                            n.addEventListener('mousedown', (e) => { 
                                if (e.button !== 0) return; 
                                startRowPaint(r); 
                                e.preventDefault(); 
                            });
                            
                            n.addEventListener('mouseenter', () => { 
                                if (isRowPaintDragging) applyRowPaint(r); 
                            });
                            
                            n.addEventListener('click', (e) => { 
                                e.preventDefault();
                                if (isRowPaintDragging) return;
                                rowPaintAction = getPaintActionForRow(r);
                                applyRowPaint(r);
                            });
                            
                            n.addEventListener('touchstart', (e) => { 
                                startRowPaint(r); 
                                e.preventDefault(); 
                            }, { passive: false });
                            
                            n.addEventListener('touchmove', (e) => { 
                                const t = e.touches && e.touches[0]; 
                                if (!t) return; 
                                const el = document.elementFromPoint(t.clientX, t.clientY);
                                const tr = el ? el.closest('#table-body tr') : null; 
                                if (tr) applyRowPaint(tr); 
                                e.preventDefault();
                            }, { passive: false });
                            
                            r.appendChild(n);
                            
                            // Add delete/selection cell
                            r.appendChild(createDeleteCell(r));
                            
                            // Add data cells using current headers
                            const heads = getHeaders();
                            heads.forEach(h => { 
                                r.appendChild(createEditableCell(h, '')); 
                            });
                            
                            tbody.appendChild(r);
                        }
                    }
                    
                    cols.forEach((val, cidx) => {
                        const cell = r.cells[startIndex + cidx];
                        if (cell && cell.contentEditable === 'true') { 
                            cell.textContent = val; 
                        }
                    });
                    
                    // Normalize Nom_Prénom in the affected row after paste
                    try {
                        const nameCell = r.querySelector('td[data-label="Nom_Prénom"]');
                        if (nameCell) { 
                            nameCell.textContent = formatNomPrenom(nameCell.textContent); 
                        }
                    } catch(_) {}
                });
                
                saveStateToHistory(); 
                saveLocalDraft(); 
                markEdited();
            });

            // Double-click date input
            document.getElementById('table-body').addEventListener('dblclick', function(e) {
                const cell = e.target.closest('td');
                if (!cell) return;
                
                const label = (cell.getAttribute('data-label') || '').toLowerCase();
                if (label.includes('date de saisie') || label.includes('ddn')) {
                    if (!dateInputOverlay) {
                        dateInputOverlay = document.createElement('input');
                        dateInputOverlay.type = 'date';
                        dateInputOverlay.className = 'border rounded px-2 py-1';
                        dateInputOverlay.style.position = 'fixed';
                        dateInputOverlay.style.zIndex = '1000';
                        document.body.appendChild(dateInputOverlay);
                        
                        dateInputOverlay.addEventListener('change', () => {
                            const v = dateInputOverlay.value;
                            if (v) {
                                const [y, m, d] = v.split('-');
                                cell.textContent = `${d}/${m}/${y.slice(-2)}`;
                                saveStateToHistory();
                                saveLocalDraft();
                                markEdited();
                            }
                            dateInputOverlay.style.display = 'none';
                        });
                        
                        dateInputOverlay.addEventListener('blur', () => {
                            dateInputOverlay.style.display = 'none';
                        });
                    }
                    
                    const rect = cell.getBoundingClientRect();
                    dateInputOverlay.style.left = `${rect.left + window.scrollX}px`;
                    dateInputOverlay.style.top = `${rect.top + window.scrollY}px`;
                    dateInputOverlay.style.display = 'block';
                    dateInputOverlay.focus();
                }
            });

            // Select all checkbox
            document.addEventListener('change', function(e) { 
                if (e.target && e.target.id === 'select-all') { 
                    const checked = e.target.checked; 
                    document.querySelectorAll('#table-body tr').forEach(tr => { 
                        const cb = tr.querySelector('td:nth-child(2) input[type="checkbox"]'); 
                        if (cb) { 
                            cb.checked = checked; 
                            tr.classList.toggle('selected-row', checked); 
                        } 
                    }); 
                } 
            });

            // Focus management
            document.addEventListener('focusin', (e) => {
                if (e.target && e.target.tagName === 'TD' && e.target.contentEditable === 'true') {
                    captureSimplePos();
                }
            });

            // Mobile focus support
            document.addEventListener('focusin', (e) => {
                if (!isMobile()) return;
                const cell = (e.target && e.target.tagName === 'TD' && e.target.isContentEditable) ? e.target : null;
                if (cell) {
                    setTimeout(() => ensureCellVisible(cell), 100);
                }
            });

            // Table reloaded event
            try {
                document.addEventListener('table:reloaded', () => { 
                    if (showOnlyColored) applyColoredFilter(); 
                });
            } catch(_) {}

            // Global end-drag listeners
            try { 
                document.addEventListener('mouseup', endRowPaint, true); 
            } catch(_) {}
            
            try { 
                document.addEventListener('touchend', endRowPaint, true); 
            } catch(_) {}
            
            // Mobile touch support for history toggle button
            try {
                const toggleBtn = document.getElementById('history-toggle-btn');
                if (toggleBtn) {
                    // Touch events for better mobile compatibility
                    toggleBtn.addEventListener('touchstart', function(e) {
                        e.preventDefault();
                        console.log('📱 Touch start on toggle button');
                    }, { passive: false });
                    
                    toggleBtn.addEventListener('touchend', function(e) {
                        e.preventDefault();
                        console.log('📱 Touch end on toggle button');
                        toggleHistoryBarSimple();
                    }, { passive: false });
                    
                    // Additional mobile event handling
                    if (isMobile()) {
                        toggleBtn.addEventListener('click', function(e) {
                            console.log('📱 Click on toggle button (mobile)');
                            // Ensure proper mobile handling
                            setTimeout(() => {
                                if (window.innerWidth <= 768) {
                                    const historyBarContainer = document.getElementById('history-bar-container');
                                    if (historyBarContainer) {
                                        historyBarContainer.style.width = '100%';
                                        historyBarContainer.style.maxWidth = 'none';
                                    }
                                }
                            }, 50);
                        });
                    }
                }
            } catch(_) {}
        }

        // Keyboard navigation
        function setupKeyboardNavigation() {
            document.addEventListener('keydown', function(e) {
                const active = document.activeElement;
                if (active && active.tagName === 'TD' && active.contentEditable === 'true') {
                    const modal = document.getElementById('confirmation-modal');
                    if (modal && !modal.classList.contains('hidden')) return;
                    
                    // ✅ CORRECTION: Éviter le double traitement des touches de navigation
                    if (e.defaultPrevented) return;
                    
                    const row = active.parentElement;
                    const idx = Array.from(row.cells).indexOf(active);
                    let next = null;
                    
                    if (e.key === 'ArrowRight' || (e.key === 'Tab' && !e.shiftKey)) {
                        next = row.cells[idx + 1] || (row.nextElementSibling && row.nextElementSibling.cells[2]);
                    } else if (e.key === 'ArrowLeft' || (e.key === 'Tab' && e.shiftKey)) {
                        next = row.cells[idx - 1];
                        if ((!next || idx === 2) && row.previousElementSibling) {
                            next = row.previousElementSibling.cells[row.previousElementSibling.cells.length - 1];
                        }
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        const nx = row.nextElementSibling;
                        if (nx) {
                            next = nx.cells[idx];
                        } else {
                            // Empêcher l'ajout en mode visualisation
                            if (isViewMode) {
                                showMessage('Impossible d\'ajouter des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                                return;
                            }
                            addRow();
                            setTimeout(() => {
                                const nr = document.querySelector('#table-body tr:last-child');
                                if (nr && nr.cells.length > idx) nr.cells[idx].focus();
                            }, 0);
                        }
                    } else if (e.key === 'ArrowDown') {
                        const nx = row.nextElementSibling;
                        if (nx) {
                            next = nx.cells[idx];
                        } else {
                            // Empêcher l'ajout en mode visualisation
                            if (isViewMode) {
                                showMessage('Impossible d\'ajouter des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                                return;
                            }
                            addRow();
                            setTimeout(() => {
                                const nr = document.querySelector('#table-body tr:last-child');
                                if (nr && nr.cells.length > idx) nr.cells[idx].focus();
                            }, 0);
                        }
                    } else if (e.key === 'ArrowUp') {
                        const pv = row.previousElementSibling;
                        if (pv) {
                            next = pv.cells[idx];
                        }
                    }
                    
                    if (next) {
                        e.preventDefault();
                        next.focus();
                        if (isMobile()) ensureCellVisible(next);
                    }
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                const active = document.activeElement;
                const inCell = active && active.tagName === 'TD' && active.contentEditable === 'true';
                
                // Check if we're in a form field (input, textarea, select, or contentEditable)
                const inFormField = active && (
                    active.tagName === 'INPUT' || 
                    active.tagName === 'TEXTAREA' || 
                    active.tagName === 'SELECT' || 
                    active.contentEditable === 'true'
                );
                
                // Shortcut: cycle paint mode with P (only when NOT in form fields)
                if (!e.ctrlKey && !e.metaKey && !e.altKey && (e.key === 'p' || e.key === 'P') && !inFormField) {
                    e.preventDefault();
                    cyclePaintMode();
                    return;
                }
                
                // Excel-style Undo/Redo shortcuts
                if ((e.ctrlKey || e.metaKey) && !e.shiftKey && (e.key === 'z' || e.key === 'Z')) {
                    e.preventDefault();
                    if (operationHistory.length > 0) {
                        undo();
                    }
                    return;
                }
                
                // Excel-style Redo shortcuts: Ctrl+Shift+Z or Ctrl+Y
                if ((e.ctrlKey || e.metaKey) && (
                    (e.shiftKey && (e.key === 'z' || e.key === 'Z')) || 
                    (e.key === 'y' || e.key === 'Y')
                )) {
                    e.preventDefault();
                    if (redoHistory.length > 0) {
                        redo();
                    }
                    return;
                }
                
                // Ctrl+D: Duplicate row
                if ((e.ctrlKey || e.metaKey) && (e.key === 'd' || e.key === 'D') && inCell) {
                    e.preventDefault();
                    
                    // Empêcher la duplication en mode visualisation
                    if (isViewMode) {
                        showMessage('Impossible de dupliquer des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                        return;
                    }
                    
                    const row = active.closest('tr');
                    if (row) {
                        const clone = row.cloneNode(true);
                        delete clone.dataset.key;
                        
                        // Clear any background color on the clone
                        clone.style.backgroundColor = '';
                        
                        // Fix the No cell text and rebind click handler
                        if (clone.cells[0]) {
                            clone.cells[0].textContent = document.querySelectorAll('#table-body tr').length + 1;
                        }
                        
                        // Rebind the line-number toggle and input handlers
                        const numCell = clone.cells[0];
                        if (numCell) {
                            const newNum = numCell.cloneNode(true);
                            if (!newNum.className.includes('cursor-pointer')) {
                                newNum.className += ' cursor-pointer';
                            }
                            newNum.title = 'Cliquer pour colorer/effacer la ligne';
                            newNum.addEventListener('click', () => toggleRowColor(clone));
                            clone.replaceChild(newNum, numCell);
                        }
                        
                        Array.from(clone.cells).forEach((c, i) => {
                            if (i <= 1) return;
                            c.addEventListener('input', (e) => { 
                                const oldValue = c.dataset.originalValue || '';
                                const newValue = c.textContent;
                                const columnLabel = getColumnLabelForCell(c);
                                
                                // Track cell edit for undo/redo
                                trackCellEdit(c, oldValue, newValue, columnLabel);
                                
                                // Update original value for next edit
                                c.dataset.originalValue = newValue;
                                
                                saveStateToHistory(); 
                                saveLocalDraft(); 
                                markEdited(); 
                            });
                        });
                        
                        row.after(clone);
                        
                        // Update color map persistently
                        persistRowColors();
                        saveStateToHistory(); 
                        saveLocalDraft(); 
                        markEdited();
                    }
                }
                
                // Ctrl+Backspace/Delete: Delete row(s)
                if ((e.ctrlKey || e.metaKey) && (e.key === 'Backspace' || e.key === 'Delete') && inCell) {
                    e.preventDefault();
                    const selected = Array.from(document.querySelectorAll('#table-body tr.selected-row'));
                    if (selected.length > 0) {
                        promptKeyConfirm(`Appuyez sur Entrée pour supprimer ${selected.length} ligne(s), Échap pour annuler.`, () => deleteRows(selected));
                    } else {
                        const row = active.closest('tr');
                        if (row) {
                            promptKeyConfirm('Appuyez sur Entrée pour supprimer cette ligne, Échap pour annuler.', () => deleteRows([row]));
                        }
                    }
                }
            });
        }

        // Confirmation prompt
        function promptKeyConfirm(message, onConfirm) {
            // Show ephemeral banner
            showMessage(message, 'info');

            // Create (or reuse) a hidden input to trigger the mobile keyboard
            let keyCapture = document.getElementById('key-capture');
            if (!keyCapture) {
                keyCapture = document.createElement('input');
                keyCapture.type = 'text';
                keyCapture.id = 'key-capture';
                keyCapture.autocapitalize = 'off';
                keyCapture.autocomplete = 'off';
                keyCapture.spellcheck = false;
                keyCapture.style.position = 'fixed';
                keyCapture.style.opacity = '0';
                keyCapture.style.width = '1px';
                keyCapture.style.height = '1px';
                keyCapture.style.left = '-10000px';
                keyCapture.style.top = '0';
                keyCapture.style.pointerEvents = 'none';
                document.body.appendChild(keyCapture);
            }
            
            // Focus to bring up the soft keyboard on mobile
            keyCapture.value = '';
            keyCapture.focus({ preventScroll: true });
            try { 
                keyCapture.setSelectionRange(0, 0); 
            } catch(_) {}
            
            // Some mobile browsers need a second tick to reliably open the keyboard
            setTimeout(() => { 
                if (document.activeElement !== keyCapture) {
                    keyCapture.focus({ preventScroll: true }); 
                }
            }, 0);

            function handleKey(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    cleanup();
                    onConfirm();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cleanup();
                    showMessage('Suppression annulée.', 'info');
                }
            }

            function cleanup() {
                document.removeEventListener('keydown', handleKey, true);
                // Blur and hide the hidden input after finishing
                const cap = document.getElementById('key-capture');
                if (cap) { 
                    try { 
                        cap.blur(); 
                    } catch(_) {} 
                }
            }

            document.addEventListener('keydown', handleKey, true);
        }

        // ===== SNAPSHOT SYSTEM FUNCTIONS =====
        
        // Fonction de nettoyage automatique des anciens snapshots
        async function cleanupOldSnapshots(keepCount = 20) {
            try {
                // Récupérer tous les snapshots triés par date (plus récents en premier)
                const { data: snapshots, error: fetchError } = await supabase
                    .from('table_snapshots_index')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (fetchError) {
                    console.error('❌ Error fetching snapshots for cleanup:', fetchError);
                    return;
                }
                
                if (snapshots.length > keepCount) {
                    // Supprimer les snapshots les plus anciens
                    const toDelete = snapshots.slice(keepCount);
                    let deletedCount = 0;
                    
                    for (const snapshot of toDelete) {
                        try {
                            // Supprimer du stockage Supabase
                            const { error: storageError } = await supabase.storage
                                .from('table-snapshots')
                                .remove([snapshot.object_path]);
                            
                            if (storageError) {
                                console.warn(`⚠️ Warning: Could not delete file ${snapshot.object_path}:`, storageError);
                            }
                            
                            // Supprimer de la base de données
                            const { error: dbError } = await supabase
                                .from('table_snapshots_index')
                                .delete()
                                .eq('id', snapshot.id);
                            
                            if (dbError) {
                                console.warn(`⚠️ Warning: Could not delete database record for ${snapshot.snapshot_date}:`, dbError);
                            } else {
                                deletedCount++;
                            }
                            
                        } catch (error) {
                            console.warn(`⚠️ Warning: Error deleting snapshot ${snapshot.snapshot_date}:`, error);
                        }
                    }
                    
                    if (deletedCount > 0) {
                        console.log(`🧹 Cleanup completed: ${deletedCount} old snapshots removed`);
                        if (typeof showMessage === 'function') {
                            showMessage(`🧹 Nettoyage automatique : ${deletedCount} anciens snapshots supprimés`, 'info');
                        }
                    }
                }
                
            } catch (error) {
                console.error('❌ Error in cleanupOldSnapshots:', error);
            }
        }

        // Fonction de vérification de la capacité de stockage
        async function checkStorageCapacity() {
            try {
                const { data: snapshots, error: fetchError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (fetchError) {
                    console.error('❌ Error checking storage capacity:', fetchError);
                    return { count: 0, needsCleanup: false };
                }
                
                const snapshotCount = snapshots.length;
                
                // Calculer la taille totale des snapshots
                let totalSize = 0;
                snapshots.forEach(snapshot => {
                    totalSize += snapshot.file_size_bytes || 0;
                });
                
                // Limite de stockage : 100 MB (100 * 1024 * 1024 bytes)
                const MAX_BUCKET_SIZE = 100 * 1024 * 1024;
                const usagePercentage = (totalSize / MAX_BUCKET_SIZE) * 100;
                
                // Si on dépasse 95% de la capacité, déclencher le nettoyage
                if (usagePercentage >= 95) {
                    // Calculer combien de snapshots garder pour libérer de l'espace
                    const targetSize = MAX_BUCKET_SIZE * 0.7; // Cibler 70% d'utilisation
                    const snapshotsToKeep = calculateOptimalSnapshotCount(snapshots, targetSize);
                    
                    return { 
                        count: snapshotCount, 
                        needsCleanup: true, 
                        target: snapshotsToKeep,
                        currentSize: totalSize,
                        maxSize: MAX_BUCKET_SIZE,
                        usagePercentage: usagePercentage
                    };
                }
                
                return { 
                    count: snapshotCount, 
                    needsCleanup: false,
                    currentSize: totalSize,
                    maxSize: MAX_BUCKET_SIZE,
                    usagePercentage: usagePercentage
                };
                
            } catch (error) {
                console.error('❌ Error checking storage capacity:', error);
                return { count: 0, needsCleanup: false };
            }
        }

        // Fonction pour calculer le nombre optimal de snapshots à garder
        function calculateOptimalSnapshotCount(snapshots, targetSize) {
            // Trier les snapshots par date (plus récents en premier)
            const sortedSnapshots = [...snapshots].sort((a, b) => 
                new Date(b.snapshot_date) - new Date(a.snapshot_date)
            );
            
            let currentSize = 0;
            let snapshotsToKeep = 0;
            
            // Garder les snapshots les plus récents jusqu'à atteindre la taille cible
            for (const snapshot of sortedSnapshots) {
                const snapshotSize = snapshot.file_size_bytes || 0;
                if (currentSize + snapshotSize <= targetSize) {
                    currentSize += snapshotSize;
                    snapshotsToKeep++;
                } else {
                    break;
                }
                }
            
            // Toujours garder au minimum 5 snapshots
            return Math.max(snapshotsToKeep, 5);
        }

        // Fonction de monitoring et d'alertes du stockage
        async function monitorStorageHealth() {
            try {
                const { data: snapshots, error: fetchError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (fetchError) {
                    console.error('❌ Error monitoring storage health:', fetchError);
                    return;
                }
                
                const snapshotCount = snapshots.length;
                
                // Calculer la taille totale des snapshots
                let totalSize = 0;
                snapshots.forEach(snapshot => {
                    totalSize += snapshot.file_size_bytes || 0;
                });
                
                const MAX_BUCKET_SIZE = 100 * 1024 * 1024; // 100 MB
                const usagePercentage = (totalSize / MAX_BUCKET_SIZE) * 100;
                
                // Alertes automatiques selon l'utilisation de l'espace
                if (usagePercentage >= 95) {
                    // 🚨 CRITIQUE : Stockage presque plein
                    if (typeof showMessage === 'function') {
                        showMessage(`🚨 Stockage critique : ${usagePercentage.toFixed(1)}% utilisé (${(totalSize / 1024 / 1024).toFixed(2)} MB). Nettoyage automatique en cours...`, 'error');
                    }
                } else if (usagePercentage >= 85) {
                    // ⚠️ ATTENTION : Stockage élevé
                    if (typeof showMessage === 'function') {
                        showMessage(`⚠️ Stockage élevé : ${usagePercentage.toFixed(1)}% utilisé (${(totalSize / 1024 / 1024).toFixed(2)} MB). Nettoyage préventif recommandé.`, 'warning');
                    }
                } else if (usagePercentage >= 70) {
                    // ℹ️ INFO : Surveillance
                    if (typeof showMessage === 'function') {
                        showMessage(`ℹ️ Stockage modéré : ${usagePercentage.toFixed(1)}% utilisé (${(totalSize / 1024 / 1024).toFixed(2)} MB).`, 'info');
                    }
                }
                
                // Log des informations de stockage
                console.log(`📊 Storage Health: ${snapshotCount} snapshots, ${(totalSize / 1024 / 1024).toFixed(2)} MB used (${usagePercentage.toFixed(1)}% of ${(MAX_BUCKET_SIZE / 1024 / 1024).toFixed(0)} MB)`);
                
            } catch (error) {
                console.error('❌ Error in monitorStorageHealth:', error);
            }
        }

        // Create a demo snapshot with unique date logic and automatic cleanup
        async function createDemoSnapshot(useCurrentData = false) {
            try {
                // VÉRIFICATION ET NETTOYAGE AUTOMATIQUE AVANT CRÉATION
                const capacityInfo = await checkStorageCapacity();
                if (capacityInfo.needsCleanup) {
                    await cleanupOldSnapshots(capacityInfo.target);
                }
                
                // Check current state
                const { data: existing, error: checkError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (checkError) {
                    console.error('❌ Error checking existing snapshots:', checkError);
                    return;
                }
                
                // Clean: Removed debug log
                
                // Generate a truly unique date
                let dateString;
                let attempts = 0;
                const maxAttempts = 50; // Increased to handle more date variations
                
                do {
                    attempts++;
                    if (attempts === 1) {
                        // First attempt: today's date
                        const today = new Date();
                        dateString = today.toISOString().split('T')[0];
                    } else if (attempts <= 10) {
                        // Next 10 attempts: dates with small offset (yesterday, day before, etc.)
                        const offsetDate = new Date();
                        offsetDate.setDate(offsetDate.getDate() - attempts + 1);
                        dateString = offsetDate.toISOString().split('T')[0];
                    } else if (attempts <= 20) {
                        // Next 10 attempts: dates with larger offset (1 week ago, 2 weeks ago, etc.)
                        const offsetDate = new Date();
                        offsetDate.setDate(offsetDate.getDate() - (attempts * 7));
                        dateString = offsetDate.toISOString().split('T')[0];
                    } else if (attempts <= 30) {
                        // Next 10 attempts: dates with month offset
                        const offsetDate = new Date();
                        offsetDate.setMonth(offsetDate.getMonth() - (attempts - 20));
                        dateString = offsetDate.toISOString().split('T')[0];
                    } else {
                        // Final attempts: use random dates from previous years
                        const randomYear = 2020 + Math.floor(Math.random() * 5); // 2020-2024
                        const randomMonth = 1 + Math.floor(Math.random() * 12);
                        const randomDay = 1 + Math.floor(Math.random() * 28);
                        dateString = `${randomYear}-${String(randomMonth).padStart(2, '0')}-${String(randomDay).padStart(2, '0')}`;
                    }
                    
                    // Check if this date already exists
                    const { data: existingDate, error: dateCheckError } = await supabase
                        .from('table_snapshots_index')
                        .select('snapshot_date')
                        .eq('snapshot_date', dateString)
                        .limit(1);
                    
                    if (dateCheckError) {
                        console.error('❌ Error checking date:', dateCheckError);
                        break;
                    }
                    
                    if (!existingDate || existingDate.length === 0) {
                        break;
                    }
                    
                } while (attempts < maxAttempts);
                
                if (attempts >= maxAttempts) {
                    console.error('❌ Unable to find unique date after 50 attempts');
                    
                    // Show message to user
                    if (typeof showMessage === 'function') {
                        showMessage('Impossible de trouver une date unique. Utilisez le bouton "Nettoyer" pour vider la base.', 'warning');
                    }
                    
                    return;
                }
                
                // Create the JSON content for the snapshot
                let snapshotData;
                let actualRowCount = 3;
                
                if (useCurrentData && window.tableData && window.tableData.length > 0) {
                    // Use current table data
                    actualRowCount = window.tableData.length;
                    snapshotData = {
                        snapshot_metadata: {
                            created_at: new Date().toISOString(),
                            row_count: actualRowCount,
                            version: "1.0",
                            description: "Snapshot des données actuelles du tableau"
                        },
                        data: window.tableData
                    };
                    // Clean: Removed debug log
                } else {
                    // Use demo data
                    snapshotData = {
                        snapshot_metadata: {
                            created_at: new Date().toISOString(),
                            row_count: 3,
                            version: "1.0",
                            description: "Demo snapshot for testing"
                        },
                        data: [
                            {
                                id: 1,
                                nom: "Dupont",
                                prenom: "Jean",
                                status: "En service",
                                specialite: "Cardiologie",
                                date_embauche: "2020-03-15",
                                salaire: 4500,
                                notes: "Excellent médecin, très apprécié des patients"
                            },
                            {
                                id: 2,
                                nom: "Martin",
                                prenom: "Marie",
                                status: "En service",
                                specialite: "Pédiatrie",
                                date_embauche: "2019-07-22",
                                salaire: 4200,
                                notes: "Spécialiste en maladies infantiles"
                            },
                            {
                                id: 3,
                                nom: "Bernard",
                                prenom: "Pierre",
                                status: "Congé",
                                specialite: "Chirurgie",
                                date_embauche: "2018-11-10",
                                salaire: 5200,
                                notes: "Chirurgien expérimenté"
                            }
                        ]
                    };
                    // Clean: Removed debug log
                }

                // Generate unique filename with timestamp
                const now = new Date();
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                const seconds = now.getSeconds().toString().padStart(2, '0');
                const timeStamp = `${hours}-${minutes}-${seconds}`;
                let fileName = `staff_table_${dateString}_${timeStamp}.json`;
                const jsonBlob = new Blob([JSON.stringify(snapshotData, null, 2)], { type: 'application/json' });

                // Check if file already exists in storage before uploading
                // Clean: Removed debug log
                const { data: existingFiles, error: listError } = await supabase.storage
                    .from('table-snapshots')
                    .list('', { limit: 100 });
                
                if (listError) {
                    console.warn('⚠️ Could not list storage files:', listError);
                } else {
                    const fileExists = existingFiles?.some(file => file.name === fileName);
                    if (fileExists) {
                        console.warn(`⚠️ File already exists in storage: ${fileName}`);
                        // Clean: Removed debug log
                        
                        // Try to remove the existing file
                        const { error: removeError } = await supabase.storage
                            .from('table-snapshots')
                            .remove([fileName]);
                        
                        if (removeError) {
                            console.error('❌ Error removing existing file:', removeError);
                            // If we can't remove it, try with a different filename
                            const timestamp = Date.now();
                            const newFileName = `staff_table_${dateString}_${timestamp}.json`;
                            // Clean: Removed debug log
                            fileName = newFileName;
                        } else {
                            // Clean: Removed debug log
                        }
                    }
                }

                // Upload the JSON file to storage
                // Clean: Removed debug log
                const { data: uploadData, error: uploadError } = await supabase.storage
                    .from('table-snapshots')
                    .upload(fileName, jsonBlob);

                if (uploadError) {
                    console.error('❌ Error uploading file to storage:', uploadError);
                    throw new Error(`Failed to upload file: ${uploadError.message}`);
                }

                                    // Clean: Removed debug log

                // Now create the database record
                const { error } = await supabase
                    .from('table_snapshots_index')
                    .insert({
                        snapshot_date: dateString,
                        object_path: fileName,
                        row_count: actualRowCount,
                        file_size_bytes: jsonBlob.size,
                        metadata: JSON.stringify({
                            table: 'staffTable',
                            version: '1.0.0',
                            description: 'Demo snapshot for testing'
                        })
                    });
                
                if (error) {
                    console.error('❌ Error creating snapshot:', error);
                    
                    // If it's still a key error, try with a timestamp
                    if (error.code === '23505') {
                        // Clean: Removed debug log
                        const timestamp = Date.now();
                        const uniqueDate = new Date(timestamp);
                        const uniqueDateString = uniqueDate.toISOString().split('T')[0];
                        
                        const { error: retryError } = await supabase
                            .from('table_snapshots_index')
                            .insert({
                                snapshot_date: uniqueDateString,
                                object_path: `staff_table_${uniqueDateString}_${timestamp}_retry.json`,
                                row_count: 3,
                                file_size_bytes: 1500,
                                metadata: JSON.stringify({
                                    table: 'staffTable',
                                    version: '1.0.0',
                                    description: 'Demo snapshot for testing (retry)'
                                })
                            });
                        
                        if (retryError) {
                            console.error('❌ Retry error:', retryError);
                        } else {
                            // Clean: Removed debug log
                            await loadAvailableSnapshots();
                            // Update the calendar display
                            populateSnapshotCalendar();
                        }
                    }
                } else {
                    // Clean: Removed debug log
                    // Reload snapshots after creation
                    await loadAvailableSnapshots();
                    // Update the calendar display
                    populateSnapshotCalendar();
                    
                    // MONITORING : Vérifier la santé du stockage après création
                    await monitorStorageHealth();
                }
                
            } catch (err) {
                console.error('❌ Exception error:', err);
            }
        }
        
        // DEBUG WRAPPER for manual snapshot button
        async function debugManualSnapshot() {
            console.log('🚀 DEBUG: Manual Snapshot Button Clicked!');
            console.log('=' .repeat(60));
            
            // Debug current state
            console.log('📊 DEBUG: Current App State:');
            console.log('   - snapshotMode:', window.snapshotMode || 'undefined');
            console.log('   - currentSnapshotDate:', window.currentSnapshotDate || 'undefined');
            console.log('   - availableSnapshots count:', window.availableSnapshots?.length || 0);
            
            // Debug window.tableData
            console.log('📋 DEBUG: window.tableData status:');
            console.log('   - Exists:', typeof window.tableData !== 'undefined');
            console.log('   - Is Array:', Array.isArray(window.tableData));
            console.log('   - Length:', window.tableData?.length || 0);
            if (window.tableData && window.tableData.length > 0) {
                console.log('   - First row keys:', Object.keys(window.tableData[0] || {}));
                console.log('   - First row sample:', JSON.stringify(window.tableData[0], null, 2));
            }
            
            // Debug DOM table data
            console.log('🏗️ DEBUG: DOM Table Analysis:');
            const table = document.getElementById('data-table');
            if (table) {
                const tbody = table.querySelector('tbody');
                const rows = tbody?.querySelectorAll('tr') || [];
                console.log('   - Table found:', !!table);
                console.log('   - Rows in DOM:', rows.length);
                
                if (rows.length > 0) {
                    const firstRow = rows[0];
                    const cells = firstRow.querySelectorAll('td');
                    console.log('   - Cells in first row:', cells.length);
                    
                    // Sample cell values
                    const cellValues = Array.from(cells).slice(0, 3).map(cell => {
                        const input = cell.querySelector('input, textarea, select');
                        return input ? input.value : cell.textContent.trim();
                    });
                    console.log('   - First 3 cell values:', cellValues);
                }
            } else {
                console.log('   - Table NOT found in DOM!');
            }
            
            // Extract current data from DOM for comparison
            console.log('🔍 DEBUG: Extracting current data from DOM...');
            const domData = extractDOMTableData();
            console.log('   - DOM extraction result:', domData?.length || 0, 'rows');
            if (domData && domData.length > 0) {
                console.log('   - DOM first row:', JSON.stringify(domData[0], null, 2));
            }
            
            // Update window.tableData with current DOM state
            if (domData && domData.length > 0) {
                console.log('🔄 DEBUG: Updating window.tableData with current DOM data...');
                window.tableData = domData;
                console.log('   - window.tableData updated with', domData.length, 'rows');
            }
            
            console.log('🎯 DEBUG: About to call createManualSnapshot()...');
            console.log('=' .repeat(60));
            
            // Call the actual function
            try {
                await createManualSnapshot();
                console.log('✅ DEBUG: createManualSnapshot() completed');
            } catch (error) {
                console.error('❌ DEBUG: createManualSnapshot() failed:', error);
            }
        }
        
        // Helper function to extract data from DOM
        function extractDOMTableData() {
            const table = document.getElementById('data-table');
            if (!table) return null;
            
            const tbody = table.querySelector('tbody');
            if (!tbody) return null;
            
            const headerRow = table.querySelector('thead tr');
            const headers = Array.from(headerRow?.querySelectorAll('th') || []).map(th => 
                th.textContent.trim()
            );
            
            const rows = tbody.querySelectorAll('tr');
            const data = [];
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                const rowData = {};
                
                cells.forEach((cell, index) => {
                    if (headers[index]) {
                        const input = cell.querySelector('input, textarea, select');
                        let value = input ? input.value : cell.textContent.trim();
                        
                        // Convert numbers
                        if (!isNaN(value) && value !== '' && !isNaN(parseFloat(value))) {
                            value = parseFloat(value);
                        }
                        
                        rowData[headers[index]] = value;
                    }
                });
                
                if (Object.keys(rowData).length > 0) {
                    data.push(rowData);
                }
            });
            
            return data;
        }
        
        // Create a manual snapshot with current table data
        async function createManualSnapshot() {
            console.log('🎯 FUNCTION CALLED: createManualSnapshot() STARTED');
            console.log('⏰ Timestamp:', new Date().toISOString());
            try {
                console.log('🚀 Création d\'un snapshot manuel...');
                
                // Créer un client Supabase avec la clé de service pour contourner les politiques RLS
                console.log('🔑 Création du client Supabase avec la clé de service...');
                
                // Utiliser une approche simple et robuste
                let supabaseService;
                try {
                    // Essayer d'importer et créer le client
                    const { createClient: createClientService } = await import('https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm');
                    supabaseService = createClientService(supabaseConfig.supabaseUrl, supabaseConfig.supabaseServiceKey);
                    console.log('✅ Client Supabase créé avec la clé de service');
                } catch (error) {
                    console.error('❌ Erreur lors de la création du client Supabase:', error);
                    throw new Error(`Impossible de créer le client Supabase: ${error.message}`);
                }
                
                // 🔧 FIXED: Capturer les données actuellement éditées dans le navigateur
                console.log('📊 Capture des données actuelles du tableau (état édité)...');
                
                let tableData = null;
                
                // PRIORITÉ 1: Utiliser les données éditées actuellement dans le navigateur
                if (window.tableData && Array.isArray(window.tableData) && window.tableData.length > 0) {
                    tableData = window.tableData;
                    console.log(`✅ Données capturées depuis le navigateur (état édité): ${tableData.length} lignes`);
                    console.log('📝 DEBUG: Premier élément des données éditées:', JSON.stringify(tableData[0], null, 2));
                } else {
                    // FALLBACK: Si pas de données éditées, récupérer depuis la base
                    console.log('⚠️ Aucune donnée éditée trouvée, récupération depuis la base de données...');
                    const { data: dbData, error: fetchError } = await supabaseService
                        .from('staffTable')
                        .select('*')
                        .order('No', { ascending: true });
                    
                    if (fetchError) {
                        throw new Error(`Erreur lors de la récupération des données: ${fetchError.message}`);
                    }
                    
                    tableData = dbData;
                    console.log(`📊 Données récupérées depuis la base: ${tableData?.length || 0} lignes`);
                }
                
                if (!tableData || tableData.length === 0) {
                    showMessage('❌ Aucune donnée trouvée (ni éditée, ni en base)', 'error');
                    return;
                }
                
                console.log(`📊 Données récupérées: ${tableData.length} lignes`);
                
                // Vérifier la capacité de stockage
                const capacityInfo = await checkStorageCapacity();
                if (capacityInfo.needsCleanup) {
                    await cleanupOldSnapshots(capacityInfo.target);
                }
                
                // Générer un nom de fichier unique avec timestamp
                const now = new Date();
                const timestamp = now.getTime();
                const dateString = now.toISOString().split('T')[0];
                const timeString = now.toTimeString().split(' ')[0].replace(/:/g, '-');
                
                // Créer le chemin de stockage : YYYY/MM/DD/MANUAL_HH-MM-SS_staffTable.json
                const year = now.getFullYear();
                const month = (now.getMonth() + 1).toString().padStart(2, '0');
                const day = now.getDate().toString().padStart(2, '0');
                const objectPath = `${year}/${month}/${day}/MANUAL_${timeString}_staffTable.json`;
                
                // Préparer les données du snapshot
                const snapshotData = {
                    data: tableData,
                    metadata: {
                        table: 'staffTable',
                        rowCount: tableData.length,
                        createdAt: now.toISOString(),
                        snapshotDate: dateString,
                        type: 'MANUAL_SNAPSHOT',
                        version: '2.0.0',
                        description: 'Snapshot manuel créé par l\'utilisateur',
                        timestamp: timestamp,
                        userAction: 'manual_creation'
                    }
                };
                
                // Sérialiser en JSON
                const jsonContent = JSON.stringify(snapshotData, null, 2);
                const fileSize = new TextEncoder().encode(jsonContent).length;
                
                console.log(`📊 Création du snapshot manuel: ${tableData.length} lignes, ${(fileSize / 1024).toFixed(2)} KB`);
                console.log(`📁 Object path: ${objectPath}`);
                console.log(`🔑 Using service client: ${!!supabaseService}`);
                
                // Upload vers le stockage avec le client de service
                console.log(`📤 DEBUT UPLOAD vers table-snapshots...`);
                const uploadResult = await supabaseService.storage
                    .from('table-snapshots')
                    .upload(objectPath, jsonContent, {
                        contentType: 'application/json',
                        upsert: true
                    });
                
                console.log(`📤 RESULTAT UPLOAD:`, uploadResult);
                
                if (uploadResult.error) {
                    console.error(`❌ ERREUR UPLOAD:`, uploadResult.error);
                    throw new Error(`Erreur lors de l'upload: ${uploadResult.error.message}`);
                }
                
                console.log(`💾 Snapshot manuel uploadé vers: ${objectPath}`);
                console.log(`✅ Upload data:`, uploadResult.data);
                
                // Créer l'enregistrement dans l'index avec le client de service
                const { error: indexError } = await supabaseService
                    .from('table_snapshots_index')
                    .insert({
                        snapshot_date: dateString,
                        object_path: objectPath,
                        row_count: tableData.length,
                        file_size_bytes: fileSize,
                        metadata: snapshotData.metadata
                    });
                
                if (indexError) {
                    throw new Error(`Erreur lors de la création de l'index: ${indexError.message}`);
                }
                
                console.log(`✅ Snapshot manuel indexé avec succès pour la date: ${dateString}`);
                
                // Log dans le journal de restauration avec le client de service
                try {
                    await supabaseService
                        .from('snapshot_restore_log')
                        .insert({
                            snapshot_date: dateString,
                            restored_at: now.toISOString(),
                            restored_by: 'user_manual',
                            restore_reason: 'Snapshot manuel créé par l\'utilisateur'
                        });
                    console.log('📝 Entrée de log créée dans snapshot_restore_log');
                } catch (logError) {
                    console.warn(`⚠️ Warning: Impossible de créer l'entrée de log: ${logError.message}`);
                }
                
                // Recharger les snapshots disponibles
                await loadAvailableSnapshots();
                
                // Mettre à jour l'interface
                populateSnapshotCalendar();
                updateHistoryNavigation();
                
                // Message de succès
                showMessage(`✅ Snapshot manuel créé avec succès! ${tableData.length} lignes sauvegardées`, 'success');
                
                // Monitoring de la santé du stockage
                await monitorStorageHealth();
                
                // Retourner le résultat pour les tests
                return {
                    success: true,
                    objectPath: objectPath,
                    dateString: dateString,
                    rowCount: tableData.length,
                    fileSize: fileSize
                };
                
            } catch (error) {
                console.error('❌ Erreur lors de la création du snapshot manuel:', error);
                showMessage(`❌ Erreur lors de la création du snapshot: ${error.message}`, 'error');
                
                // Retourner l'erreur pour les tests
                throw error;
            }
        }
        
        // Load available snapshots from the database
        async function loadAvailableSnapshots() {
            try {
                console.log('🔄 loadAvailableSnapshots: Début du chargement...');
                
                // Vérifier que supabase est initialisé
                if (!supabase) {
                    console.error('❌ Client Supabase non initialisé');
                    return;
                }
                
                // First, test the database connection
                console.log('🔄 Test de connexion à la table table_snapshots_index...');
                const { data: testData, error: testError } = await supabase
                    .from('table_snapshots_index')
                    .select('*')
                    .limit(1);
                
                if (testError) {
                    console.error('❌ Database connection error:', testError);
                    
                    // Analyser le type d'erreur
                    if (testError.code === 'PGRST116') { // No rows returned
                        console.log('ℹ️ Table vide - état normal, pas de snapshot automatique');
                        // Don't create demo snapshot automatically
                        return;
                    } else if (testError.code === 'PGRST301') { // Table doesn't exist
                        console.error('❌ Table table_snapshots_index n\'existe pas. Vérifiez la configuration SQL.');
                        showMessage('❌ Table des snapshots manquante. Vérifiez la configuration Supabase.', 'error');
                        return;
                    } else if (testError.code === 'PGRST301' || testError.message.includes('permission')) {
                        console.error('❌ Problème de permissions. Vérifiez les politiques RLS.');
                        showMessage('❌ Problème de permissions. Vérifiez les politiques RLS Supabase.', 'error');
                        return;
                    }
                    
                    showMessage('❌ Erreur de connexion à la base de données: ' + testError.message, 'error');
                    return;
                }
                
                console.log('✅ Connexion à la table réussie, testData:', testData);
                
                console.log('🔄 Chargement de tous les snapshots...');
                const { data, error } = await supabase
                    .from('table_snapshots_index')
                    .select('id, snapshot_date, created_at, row_count, object_path, file_size_bytes')
                    .order('created_at', { ascending: false });
                
                if (error) {
                    console.error('❌ Error loading snapshots:', error);
                    showMessage('❌ Erreur lors du chargement des snapshots: ' + error.message, 'error');
                    return;
                }
                
                console.log('✅ Snapshots chargés depuis la base:', data);
                
                availableSnapshots = data || [];
                // Update global variable
                window.availableSnapshots = availableSnapshots;
                
                console.log(`📊 ${availableSnapshots.length} snapshots disponibles:`, availableSnapshots);
                
                // If no snapshots exist, just show empty state
                if (availableSnapshots.length === 0) {
                    console.log('ℹ️ Aucun snapshot trouvé - état vide normal');
                    // Don't create demo snapshot automatically
                } else {
                    console.log('✅ Snapshots trouvés, mise à jour de l\'interface...');
                    updateHistoryNavigation();
                    // Update the calendar display
                    populateSnapshotCalendar();
                }
                
                // MONITORING : Vérifier la santé du stockage après chargement
                await monitorStorageHealth();
        
            } catch (error) {
                console.error('❌ Error in loadAvailableSnapshots:', error);
                showMessage('❌ Erreur inattendue lors du chargement des snapshots: ' + error.message, 'error');
            }
        }

        // Fonction utilitaire pour forcer le nettoyage manuel
        async function forceStorageCleanup() {
            try {
                if (typeof showMessage === 'function') {
                    showMessage('🧹 Déclenchement du nettoyage manuel du stockage...', 'info');
                }
                
                // Vérifier la capacité actuelle
                const capacityInfo = await checkStorageCapacity();
                
                // Calculer le nombre optimal de snapshots à garder
                const targetSize = capacityInfo.maxSize * 0.6; // Cibler 60% d'utilisation
                const snapshotsToKeep = calculateOptimalSnapshotCount(availableSnapshots, targetSize);
                
                console.log(`🧹 Manual cleanup: targeting ${snapshotsToKeep} snapshots to reach ${(targetSize / 1024 / 1024).toFixed(2)} MB usage`);
                
                // Forcer le nettoyage en gardant le nombre optimal de snapshots
                await cleanupOldSnapshots(snapshotsToKeep);
                
                // Recharger les snapshots disponibles
                await loadAvailableSnapshots();
                
                if (typeof showMessage === 'function') {
                    showMessage(`✅ Nettoyage manuel terminé ! Gardé ${snapshotsToKeep} snapshots les plus récents.`, 'success');
                }
                
            } catch (error) {
                console.error('❌ Error in forceStorageCleanup:', error);
                if (typeof showMessage === 'function') {
                    showMessage('❌ Erreur lors du nettoyage manuel', 'error');
                }
            }
        }
        
        // Enhanced mobile-responsive history navigation update function
        function updateHistoryNavigation() {
            // Update both mobile and desktop buttons
            const backBtn = document.getElementById('history-back');
            const nextBtn = document.getElementById('history-next');
            const backBtnDesktop = document.getElementById('history-back-desktop');
            const nextBtnDesktop = document.getElementById('history-next-desktop');
            
            // Always update button states for both mobile and desktop
            if (snapshotMode === 'live') {
                // Enable back/next if snapshots exist
                if (backBtn) backBtn.disabled = availableSnapshots.length === 0;
                if (nextBtn) nextBtn.disabled = availableSnapshots.length === 0;
                if (backBtnDesktop) backBtnDesktop.disabled = availableSnapshots.length === 0;
                if (nextBtnDesktop) nextBtnDesktop.disabled = availableSnapshots.length === 0;
            } else {
                // Update back/next button states
                if (backBtn) backBtn.disabled = currentSnapshotIndex <= 0;
                if (nextBtn) nextBtn.disabled = currentSnapshotIndex >= availableSnapshots.length - 1;
                if (backBtnDesktop) backBtnDesktop.disabled = currentSnapshotIndex <= 0;
                if (nextBtnDesktop) nextBtnDesktop.disabled = currentSnapshotIndex >= availableSnapshots.length - 1;
            }
            
            // Update calendar button text if calendar is open
            const calendarBtnText = document.getElementById('calendar-btn-text');
            if (calendarBtnText) {
                calendarBtnText.textContent = `Calendrier (${availableSnapshots.length})`;
            }
            
            // Update current snapshot date display for both mobile and desktop
            const currentSnapshotDateText = document.getElementById('current-snapshot-date-text');
            const currentSnapshotDateTextDesktop = document.getElementById('current-snapshot-date-text-desktop');
            
            const updateDateText = (element) => {
                if (element) {
                    if (snapshotMode === 'live') {
                        element.textContent = 'Données en direct';
                    } else if (currentSnapshotDate && currentSnapshotIndex >= 0) {
                        // Get the current snapshot info for better display
                        const currentSnapshot = availableSnapshots[currentSnapshotIndex];
                        if (currentSnapshot) {
                            const date = new Date(currentSnapshot.snapshot_date);
                            const createdTime = new Date(currentSnapshot.created_at);
                            const formattedDate = date.toLocaleDateString('fr-FR', {
                                day: '2-digit',
                                month: '2-digit',
                                year: 'numeric'
                            });
                            const timeString = createdTime.toLocaleTimeString('fr-FR', {
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                            element.textContent = `Snapshot du ${formattedDate} à ${timeString}`;
                        } else {
                            element.textContent = 'Snapshot en cours...';
                        }
                    }
                }
            };
            
            // Update both mobile and desktop date displays
            updateDateText(currentSnapshotDateText);
            updateDateText(currentSnapshotDateTextDesktop);
        }
        
        // Check and fix inconsistencies between database and storage
        async function checkAndFixInconsistencies() {
            try {
                // Clean: Removed debug log
                
                // Get database snapshots
                const { data: dbSnapshots, error: dbError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (dbError) {
                    console.error('❌ Error checking database:', dbError);
                    return;
                }
                
                // Get storage files
                        const { data: storageFiles, error: storageError } = await supabase.storage
            .from('table-snapshots')
            .list('', { limit: 100 });
                
                if (storageError) {
                    console.error('❌ Error checking storage:', storageError);
                    return;
                }
                
                // Clean: Removed debug logs
                
                // Check for orphaned database records (no corresponding file)
                const orphanedRecords = [];
                for (const snapshot of dbSnapshots || []) {
                    // Extract filename from object_path (remove directory part)
                    const fileName = snapshot.object_path.split('/').pop();
                    const fileExists = storageFiles?.some(file => file.name === fileName);
                    if (!fileExists) {
                        orphanedRecords.push(snapshot);
                        console.warn(`⚠️ Orphaned record: ${snapshot.snapshot_date} -> ${snapshot.object_path} (filename: ${fileName})`);
                    }
                }
                
                // Check for orphaned storage files (no corresponding database record)
                const orphanedFiles = [];
                for (const file of storageFiles || []) {
                    if (file.name.includes('staff_table_') || file.name.includes('staffTable_')) {
                        // Check if any database record has this filename in its object_path
                        const recordExists = dbSnapshots?.some(s => s.object_path.endsWith(file.name));
                        if (!recordExists) {
                            orphanedFiles.push(file);
                            console.warn(`⚠️ Orphaned file: ${file.name}`);
                        }
                    }
                }
                
                if (orphanedRecords.length > 0 || orphanedFiles.length > 0) {
                    // Clean: Removed debug log
                    showMessage(`Incohérences détectées. Utilisez le bouton "Nettoyer" pour corriger.`, 'warning');
                } else {
                    // Clean: Removed debug log
                    showMessage('Aucune incohérence détectée', 'success');
                }
                
            } catch (err) {
                console.error('❌ Error checking inconsistencies:', err);
            }
        }
        
                // Clean database and create fresh snapshot
        async function cleanDatabaseAndCreateSnapshot() {
            try {
                // Clean: Removed debug log
                
                // Check current state
                const { data: current, error: checkError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (checkError) {
                    console.error('❌ Error checking current state:', checkError);
                    return;
                }
                
                // Clean: Removed debug log
                
                if (current && current.length > 0) {
                    // Delete all existing snapshots
                    const { error: deleteError } = await supabase
                        .from('table_snapshots_index')
                        .delete()
                        .neq('id', '00000000-0000-0000-0000-000000000000');
                    
                    if (deleteError) {
                        console.error('❌ Error deleting snapshots:', deleteError);
                        return;
                    }
                    
                    // Clean: Removed debug log
                }
                
                // Create new snapshot with unique date
                await createDemoSnapshot();
                
                // Reload snapshots after cleanup
                await loadAvailableSnapshots();
                
                // Update the calendar display
                populateSnapshotCalendar();
                
                showMessage('Base de données nettoyée et nouveau snapshot créé', 'success');
                
            } catch (err) {
                console.error('❌ Error cleaning database:', err);
                showMessage('Erreur lors du nettoyage de la base', 'error');
            }
        }
        
        // Enter snapshot mode for a specific date
        async function enterSnapshotMode(date) {
            if (snapshotMode === 'snapshot' && currentSnapshotDate === date) {
                return; // Already in this snapshot
            }
            
            try {
                // Clean: Removed debug log
                
                // Find snapshot info
                const snapshotInfo = availableSnapshots.find(s => s.snapshot_date === date);
                if (!snapshotInfo) {
                    showMessage(`Aucun snapshot trouvé pour le ${formatDateForDisplay(date)}`, 'error');
                    return;
                }
                
                // Check if the file exists in storage first
                // Clean: Removed debug log
                
                        const { data: fileList, error: listError } = await supabase.storage
            .from('table-snapshots')
            .list('', { limit: 100 });
                
                if (listError) {
                    console.warn('⚠️ Could not list storage files:', listError);
                } else {
                    // Extract filename from object_path for comparison
                    const fileName = snapshotInfo.object_path.split('/').pop() || snapshotInfo.object_path;
                    const fileExists = fileList?.some(file => file.name === fileName);
                    if (!fileExists) {
                        console.warn(`⚠️ File not found in storage: ${fileName} (from path: ${snapshotInfo.object_path})`);
                        // Clean: Removed debug log
                        
                        // Try to find a similar file or suggest cleanup
                        const similarFiles = fileList?.filter(f => f.name.includes('staffTable_'));
                        if (similarFiles && similarFiles.length > 0) {
                            console.log('📋 Similar files found:', similarFiles.map(f => f.name));
                            showMessage('Fichier snapshot introuvable. Utilisez le bouton "Nettoyer" pour corriger.', 'warning');
                            return;
                        }
                    }
                }
                
                // Get snapshot data from storage - Handle both old and new path formats
                let fileName = snapshotInfo.object_path;
                let isHierarchicalPath = false;
                
                // Check if this is a new hierarchical path (YYYY/MM/DD/HH-MM-SS_staffTable.json)
                if (fileName.match(/^\d{4}\/\d{2}\/\d{2}\/\d{2}-\d{2}-\d{2}_staffTable\.json$/)) {
                    isHierarchicalPath = true;
                    console.log('🔄 Nouveau format hiérarchique détecté:', fileName);
                } else if (fileName.includes('/')) {
                    // Old format with slashes, extract filename
                    fileName = fileName.split('/').pop();
                    console.log('🔄 Ancien format détecté, nom extrait:', fileName);
                } else {
                    // Flat format (staffTable_YYYY-MM-DD_HH-MM-SS.json)
                    console.log('🔄 Format plat détecté:', fileName);
                }
                
                console.log('🔍 Debug - Reading snapshot:', {
                    originalPath: snapshotInfo.object_path,
                    finalFileName: fileName,
                    snapshotDate: snapshotInfo.snapshot_date,
                    created_at: snapshotInfo.created_at,
                    snapshotId: snapshotInfo.id
                });
                
                // RADICAL SOLUTION: Force fresh Supabase client + multiple download methods
                let snapshotData;
                
                // STEP 1: Create a completely fresh Supabase client for this download
                const freshSupabase = createClient(
                    'https://fiecugxopjxzqfdnaqsu.supabase.co',
                    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ1MDU2NTcsImV4cCI6MjA3MDA4MTY1N30.xd9Thasg4r8Nrwxx5nFwyGB_ufPIvok4XB-78dilpsw'
                );
                
                console.log('🔄 Created fresh Supabase client for download');
                
                // STEP 2: Try multiple download methods with fresh client
                try {
                    // METHOD 1: Fresh Supabase client download
                    console.log('🔄 METHOD 1: Fresh Supabase client download...');
                    
                    // Always use the full object path for download
                    const downloadPath = snapshotInfo.object_path;
                    console.log('📁 Téléchargement avec chemin:', downloadPath);
                    
                    const result = await freshSupabase.storage
                        .from('table-snapshots')
                        .download(downloadPath);
                    
                    if (result.error) {
                        throw new Error(`Fresh client download failed: ${result.error.message}`);
                    }
                    
                    if (!result.data) {
                        throw new Error(`No data from fresh client for: ${downloadPath}`);
                    }
                    
                    snapshotData = result.data;
                    console.log('✅ METHOD 1 SUCCESS: Fresh Supabase client, Size:', snapshotData.size);
                    
                } catch (method1Err) {
                    console.error('❌ METHOD 1 failed:', method1Err);
                    
                    // METHOD 2: Direct URL fetch with cache busting
                    try {
                        console.log('🔄 METHOD 2: Direct URL with cache busting...');
                        const timestamp = Date.now();
                        const downloadPath = snapshotInfo.object_path;
                        const directUrl = `https://fiecugxopjxzqfdnaqsu.supabase.co/storage/v1/object/public/table-snapshots/${downloadPath}?t=${timestamp}`;
                        
                        const response = await fetch(directUrl, {
                            method: 'GET',
                            headers: {
                                'Cache-Control': 'no-cache, no-store, must-revalidate',
                                'Pragma': 'no-cache',
                                'Expires': '0'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Direct URL failed: HTTP ${response.status}`);
                        }
                        
                        const textData = await response.text();
                        console.log('✅ METHOD 2 SUCCESS: Direct URL, Size:', textData.length);
                        
                        // Create a mock File object
                        snapshotData = new File([textData], fileName, { type: 'application/json' });
                        
                    } catch (method2Err) {
                        console.error('❌ METHOD 2 failed:', method2Err);
                        
                        // METHOD 3: Service role key with fresh client
                        try {
                            console.log('🔄 METHOD 3: Service role with fresh client...');
                            const serviceSupabase = createClient(
                                'https://fiecugxopjxzqfdnaqsu.supabase.co',
                                'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NDUwNTY1NywiZXhwIjoyMDcwMDgxNjU3fQ.5m7nLHxHxOkxQf8maZis7Y7jynqu2dWqIzEbgWvOTcE'
                            );
                            
                            const downloadPath = snapshotInfo.object_path;
                            const serviceResult = await serviceSupabase.storage
                                .from('table-snapshots')
                                .download(downloadPath);
                            
                            if (serviceResult.error) {
                                throw new Error(`Service role download failed: ${serviceResult.error.message}`);
                            }
                            
                            snapshotData = serviceResult.data;
                            console.log('✅ METHOD 3 SUCCESS: Service role, Size:', snapshotData.size);
                            
                        } catch (method3Err) {
                            console.error('❌ All methods failed!');
                            throw new Error(`All download methods failed for ${downloadPath}. Method1: ${method1Err.message}, Method2: ${method2Err.message}, Method3: ${method3Err.message}`);
                        }
                    }
                }
                
                // Parse snapshot data with verification
                const snapshotText = await snapshotData.text();
                console.log('📄 Raw snapshot content preview:', snapshotText.substring(0, 200) + '...');
                
                const snapshot = JSON.parse(snapshotText);
                
                // VERIFICATION: Check if this is the right snapshot
                if (snapshot.data && snapshot.data.length !== snapshotInfo.row_count) {
                    console.warn('⚠️ WARNING: Snapshot row count mismatch!', {
                        expected: snapshotInfo.row_count,
                        actual: snapshot.data.length,
                        fileName: fileName,
                        snapshotId: snapshotInfo.id
                    });
                }
                
                // Update state
                snapshotMode = 'snapshot';
                currentSnapshotDate = date;
                currentSnapshotIndex = availableSnapshots.findIndex(s => s.snapshot_date === date);
                
                // Disable realtime updates
                if (realtimeSubscription) {
                    supabase.removeChannel(realtimeSubscription);
                    realtimeSubscription = null;
                }
                
                // Load snapshot data into table
                loadTableData(snapshot.data);
                
                // Update UI
                updateHistoryNavigation();
                updateSnapshotBanner();
                updateHistoryDateButton();
                
                // Disable editing
                disableTableEditing();
                
                showMessage(`Snapshot chargé du ${formatDateForDisplay(date)} (${snapshot.data.length} lignes)`, 'success');
                
            } catch (error) {
                console.error('❌ Error entering snapshot mode:', error);
                showMessage(`Erreur lors du chargement du snapshot: ${error.message}`, 'error');
            }
        }
        
        // Enter snapshot mode using unique snapshot object (fixes multiple snapshots per day issue)
        async function enterSnapshotModeByUniqueId(snapshotInfo) {
            console.log('🚀 DEBUG: enterSnapshotModeByUniqueId called with:', {
                snapshotInfo,
                currentMode: snapshotMode,
                currentDate: currentSnapshotDate,
                currentIndex: currentSnapshotIndex,
                availableCount: availableSnapshots?.length || 0
            });
            
            if (snapshotMode === 'snapshot' && currentSnapshotDate === snapshotInfo.snapshot_date && 
                currentSnapshotIndex >= 0 && availableSnapshots[currentSnapshotIndex]?.id === snapshotInfo.id) {
                console.log('⚠️ DEBUG: Already in this snapshot, returning early');
                return; // Already in this exact snapshot
            }
            
            try {
                console.log('🔄 enterSnapshotModeByUniqueId: Loading snapshot with ID:', snapshotInfo.id);
                console.log('📊 DEBUG: Full snapshot info:', JSON.stringify(snapshotInfo, null, 2));
                
                // Check if the file exists in storage first
                // For organized paths like "2025/08/24/file.json", extract the folder
                const pathParts = snapshotInfo.object_path.split('/');
                const searchPath = pathParts.length > 1 ? pathParts.slice(0, -1).join('/') : '';
                
                console.log('📁 DEBUG: Searching in folder:', searchPath || 'root');
                
                const { data: fileList, error: listError } = await supabase.storage
                    .from('table-snapshots')
                    .list(searchPath, { limit: 200 });
                
                if (listError) {
                    console.warn('⚠️ Could not list storage files:', listError);
                } else {
                    console.log('📁 DEBUG: Files in storage folder:', fileList?.map(f => f.name) || []);
                    console.log('🔍 DEBUG: Looking for file path:', snapshotInfo.object_path);
                    
                    // Extract filename from object_path since we're searching in the specific folder
                    const fileName = snapshotInfo.object_path.split('/').pop() || snapshotInfo.object_path;
                    console.log('🔍 DEBUG: Looking for filename:', fileName);
                    
                    // Look for the file in the folder
                    const fileMatch = fileList?.find(file => file.name === fileName);
                    console.log('🎯 DEBUG: File found in folder:', !!fileMatch);
                    
                    let actualFilePath = null;
                    let fileExists = false;
                    
                    if (fileMatch) {
                        actualFilePath = snapshotInfo.object_path;
                        fileExists = true;
                        console.log('✅ DEBUG: File found in organized folder structure');
                    } else {
                        // Fallback: try to find by filename pattern matching
                        const fallbackMatch = fileList?.find(file => 
                            file.name.includes(fileName.replace('_staffTable.json', '')) ||
                            fileName.includes(file.name.replace('_staffTable.json', ''))
                        );
                        
                        if (fallbackMatch) {
                            actualFilePath = searchPath ? `${searchPath}/${fallbackMatch.name}` : fallbackMatch.name;
                            fileExists = true;
                            console.log('✅ DEBUG: Fallback filename match found:', fallbackMatch.name);
                        }
                    }
                    
                    if (!fileExists) {
                        console.log('❌ DEBUG: No file found in folder');
                        console.log('🔍 DEBUG: Available files:', fileList?.map(f => f.name) || []);
                        console.log('🔍 DEBUG: Searched for:', fileName);
                        showMessage(`❌ Fichier snapshot introuvable: ${fileName}`, 'error');
                        return;
                    }
                    
                    // File exists, proceed with loading
                    console.log('✅ DEBUG: Using file path:', actualFilePath);
                    // Update the snapshotInfo to use the actual file path
                    snapshotInfo.object_path = actualFilePath;
                }
                
                // Get snapshot data from storage - Handle both old and new path formats
                let fileName = snapshotInfo.object_path;
                let isHierarchicalPath = false;
                
                // Check if this is a new hierarchical path (YYYY/MM/DD/HH-MM-SS_staffTable.json)
                if (fileName.match(/^\d{4}\/\d{2}\/\d{2}\/\d{2}-\d{2}-\d{2}_staffTable\.json$/)) {
                    isHierarchicalPath = true;
                    console.log('🔄 Nouveau format hiérarchique détecté:', fileName);
                } else if (fileName.includes('/')) {
                    // Old format with slashes, extract filename
                    fileName = fileName.split('/').pop();
                    console.log('🔄 Ancien format détecté, nom extrait:', fileName);
                } else {
                    // Flat format (staffTable_YYYY-MM-DD_HH-MM-SS.json)
                    console.log('🔄 Format plat détecté:', fileName);
                }
                
                console.log('🔍 Debug - Reading snapshot:', {
                    snapshotId: snapshotInfo.id,
                    originalPath: snapshotInfo.object_path,
                    finalFileName: fileName,
                    snapshotDate: snapshotInfo.snapshot_date,
                    created_at: snapshotInfo.created_at
                });
                
                // RADICAL SOLUTION: Force fresh Supabase client + multiple download methods
                let snapshotData;
                
                // STEP 1: Create a completely fresh Supabase client for this download
                const freshSupabase = createClient(
                    'https://fiecugxopjxzqfdnaqsu.supabase.co',
                    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ1MDU2NTcsImV4cCI6MjA3MDA4MTY1N30.xd9Thasg4r8Nrwxx5nFwyGB_ufPIvok4XB-78dilpsw'
                );
                
                console.log('🔄 Created fresh Supabase client for download');
                
                // STEP 2: Try multiple download methods with fresh client
                try {
                    // METHOD 1: Fresh Supabase client download
                    console.log('🔄 METHOD 1: Fresh Supabase client download...');
                    
                    // Always use the full object path for download
                    const downloadPath = snapshotInfo.object_path;
                    console.log('📁 Téléchargement avec chemin:', downloadPath);
                    
                    const result = await freshSupabase.storage
                        .from('table-snapshots')
                        .download(downloadPath);
                    
                    if (result.error) {
                        throw new Error(`Fresh client download failed: ${result.error.message}`);
                    }
                    
                    if (!result.data) {
                        throw new Error(`No data from fresh client for: ${downloadPath}`);
                    }
                    
                    snapshotData = result.data;
                    console.log('✅ METHOD 1 SUCCESS: Fresh Supabase client, Size:', snapshotData.size);
                    
                } catch (method1Err) {
                    console.error('❌ METHOD 1 failed:', method1Err);
                    
                    // METHOD 2: Direct URL fetch with cache busting
                    try {
                        console.log('🔄 METHOD 2: Direct URL with cache busting...');
                        const timestamp = Date.now();
                        const downloadPath = snapshotInfo.object_path;
                        const directUrl = `https://fiecugxopjxzqfdnaqsu.supabase.co/storage/v1/object/public/table-snapshots/${downloadPath}?t=${timestamp}`;
                        
                        const response = await fetch(directUrl, {
                            method: 'GET',
                            headers: {
                                'Cache-Control': 'no-cache, no-store, must-revalidate',
                                'Pragma': 'no-cache',
                                'Expires': '0'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Direct URL failed: HTTP ${response.status}`);
                        }
                        
                        const textData = await response.text();
                        console.log('✅ METHOD 2 SUCCESS: Direct URL, Size:', textData.length);
                        
                        // Create a mock File object
                        snapshotData = new File([textData], fileName, { type: 'application/json' });
                        
                    } catch (method2Err) {
                        console.error('❌ METHOD 2 failed:', method2Err);
                        
                        // METHOD 3: Service role key with fresh client
                        try {
                            console.log('🔄 METHOD 3: Service role with fresh client...');
                            const serviceSupabase = createClient(
                                'https://fiecugxopjxzqfdnaqsu.supabase.co',
                                'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NDUwNTY1NywiZXhwIjoyMDcwMDgxNjU3fQ.5m7nLHxHxOkxQf8maZis7Y7jynqu2dWqIzEbgWvOTcE'
                            );
                            
                            const downloadPath = snapshotInfo.object_path;
                            const serviceResult = await serviceSupabase.storage
                                .from('table-snapshots')
                                .download(downloadPath);
                            
                            if (serviceResult.error) {
                                throw new Error(`Service role download failed: ${serviceResult.error.message}`);
                            }
                            
                            snapshotData = serviceResult.data;
                            console.log('✅ METHOD 3 SUCCESS: Service role, Size:', snapshotData.size);
                            
                        } catch (method3Err) {
                            console.error('❌ All methods failed!');
                            throw new Error(`All download methods failed for ${downloadPath}. Method1: ${method1Err.message}, Method2: ${method2Err.message}, Method3: ${method3Err.message}`);
                        }
                    }
                }
                
                // Parse snapshot data with verification
                const snapshotText = await snapshotData.text();
                console.log('📄 Raw snapshot content preview:', snapshotText.substring(0, 200) + '...');
                
                const snapshot = JSON.parse(snapshotText);
                
                // VERIFICATION: Check if this is the right snapshot
                if (snapshot.data && snapshot.data.length !== snapshotInfo.row_count) {
                    console.warn('⚠️ WARNING: Snapshot row count mismatch!', {
                        expected: snapshotInfo.row_count,
                        actual: snapshot.data.length,
                        fileName: fileName,
                        snapshotId: snapshotInfo.id
                    });
                }
                
                // Update state using unique identifier
                snapshotMode = 'snapshot';
                currentSnapshotDate = snapshotInfo.snapshot_date;
                currentSnapshotIndex = availableSnapshots.findIndex(s => s.id === snapshotInfo.id);
                
                // Disable realtime updates
                if (realtimeSubscription) {
                    supabase.removeChannel(realtimeSubscription);
                    realtimeSubscription = null;
                }
                
                // Load snapshot data into table
                loadTableData(snapshot.data);
                
                // Update UI
                updateHistoryNavigation();
                updateSnapshotBanner();
                updateHistoryDateButton();
                
                // Disable editing
                disableTableEditing();
                
                showMessage(`Snapshot chargé du ${formatDateForDisplay(snapshotInfo.snapshot_date)} (${snapshot.data.length} lignes) - ID: ${snapshotInfo.id}`, 'success');
                
            } catch (error) {
                console.error('❌ Error entering snapshot mode by unique ID:', error);
                showMessage(`Erreur lors du chargement du snapshot: ${error.message}`, 'error');
            }
        }
        
        // Return to today's live view
        async function returnToToday() {
            if (snapshotMode === 'live') {
                return; // Already in live mode
            }
            
            try {
                // Clean: Removed debug log
                
                // Update state
                snapshotMode = 'live';
                currentSnapshotDate = null;
                currentSnapshotIndex = -1;
                
                // Re-enable realtime updates
                setupRealtimeSubscription();
                
                // Refresh data from Supabase (no cache)
                await fetchInitialData();
                
                // Update UI
                updateHistoryNavigation();
                updateSnapshotBanner();
                updateHistoryDateButton();
                
                // Re-enable editing
                enableTableEditing();
                
                showMessage('Retour au mode en direct avec données actuelles', 'success');
                
            } catch (error) {
                console.error('❌ Error returning to today:', error);
                showMessage(`Erreur lors du retour au mode en direct: ${error.message}`, 'error');
            }
        }
        
        // Navigate to previous snapshot
        function goToPreviousSnapshot() {
            if (currentSnapshotIndex > 0) {
                const prevSnapshot = availableSnapshots[currentSnapshotIndex - 1];
                enterSnapshotModeByUniqueId(prevSnapshot);
            }
        }
        
        // Navigate to next snapshot
        function goToNextSnapshot() {
            if (currentSnapshotIndex < availableSnapshots.length - 1) {
                const nextSnapshot = availableSnapshots[currentSnapshotIndex + 1];
                enterSnapshotModeByUniqueId(nextSnapshot);
            }
        }
        
        // Open date picker for snapshot selection
        function openDatePicker() {
            if (availableSnapshots.length === 0) {
                showMessage('Aucun snapshot disponible', 'info');
                return;
            }
            
            // Create a simple date picker
            const dates = availableSnapshots.map(s => s.snapshot_date);
            const currentDate = snapshotMode === 'snapshot' ? currentSnapshotDate : null;
            
            // Find current index
            let currentIndex = currentDate ? dates.indexOf(currentDate) : -1;
            if (currentIndex === -1) currentIndex = 0;
            
            // Show next available date
            const nextIndex = (currentIndex + 1) % dates.length;
            const nextDate = dates[nextIndex];
            
            // Find the snapshot object for this date
            const nextSnapshot = availableSnapshots.find(s => s.snapshot_date === nextDate);
            if (nextSnapshot) {
                enterSnapshotModeByUniqueId(nextSnapshot);
            } else {
                showMessage('Snapshot non trouvé pour cette date', 'error');
            }
        }
        
        // Toggle snapshot calendar dropdown
        function toggleSnapshotCalendar() {
            const dropdown = document.getElementById('snapshot-calendar-dropdown');
            const isVisible = !dropdown.classList.contains('hidden');
            
            if (isVisible) {
                dropdown.classList.add('hidden');
            } else {
                // Populate and show calendar
                populateSnapshotCalendar();
                dropdown.classList.remove('hidden');
            }
        }
        
        // Populate snapshot calendar with available dates
        function populateSnapshotCalendar() {
            const datesList = document.getElementById('snapshot-dates-list');
            const calendarBtnText = document.getElementById('calendar-btn-text');
            
            if (!datesList) return;
            
            // Clear existing content
            datesList.innerHTML = '';
            
            if (availableSnapshots.length === 0) {
                datesList.innerHTML = `
                    <div class="p-3 text-center text-gray-500 text-sm">
                        <i class="fa-solid fa-calendar-xmark w-5 h-5 mx-auto mb-2"></i>
                        Aucun snapshot disponible
                    </div>
                `;
                calendarBtnText.textContent = 'Calendrier (0)';
                return;
            }
            
            // Update button text with count
            calendarBtnText.textContent = `Calendrier (${availableSnapshots.length})`;
            
            // Sort snapshots by created_at (most recent first) to ensure proper ordering
            const sortedSnapshots = [...availableSnapshots].sort((a, b) => 
                new Date(b.created_at) - new Date(a.created_at)
            );
            
            // Group snapshots by month/year for better organization
            const groupedSnapshots = {};
            sortedSnapshots.forEach(snapshot => {
                const date = new Date(snapshot.snapshot_date);
                const monthYear = date.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long' });
                
                if (!groupedSnapshots[monthYear]) {
                    groupedSnapshots[monthYear] = [];
                }
                groupedSnapshots[monthYear].push(snapshot);
            });
            
            // Get unique months for navigation
            const months = Object.keys(groupedSnapshots).sort((a, b) => {
                const dateA = new Date(sortedSnapshots.find(s => {
                    const date = new Date(s.snapshot_date);
                    return date.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long' }) === a;
                })?.snapshot_date || 0);
                const dateB = new Date(sortedSnapshots.find(s => {
                    const date = new Date(s.snapshot_date);
                    return date.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long' }) === b;
                })?.snapshot_date || 0);
                return dateB - dateA; // Most recent first
            });
            
            // Create month navigation header
            const monthNavHeader = document.createElement('div');
            monthNavHeader.className = 'sticky top-0 bg-white border-b border-gray-200 p-3 mb-3 z-10 sticky-month-nav';
            monthNavHeader.innerHTML = `
                <div class="flex items-center justify-between mb-2">
                    <h4 class="text-sm font-semibold text-gray-700">📅 Navigation par mois</h4>
                    <span class="text-xs text-gray-500">${availableSnapshots.length} snapshots</span>
                </div>
                <div class="flex items-center gap-2 overflow-x-auto pb-2">
                    ${months.map((month, index) => `
                        <button 
                            onclick="showMonthSnapshots('${month}')" 
                            class="month-nav-btn px-3 py-1.5 text-xs rounded-lg border transition-colors whitespace-nowrap ${
                                index === 0 ? 'bg-blue-100 border-blue-300 text-blue-700 font-medium' : 'bg-gray-50 border-gray-200 text-gray-600 hover:bg-gray-100'
                            }"
                            data-month="${month}"
                        >
                            ${month}
                        </button>
                    `).join('')}
                </div>
            `;
            datesList.appendChild(monthNavHeader);
            
            // Show the most recent month by default
            if (months.length > 0) {
                showMonthSnapshots(months[0]);
            }
        }
        
        // Function to delete a snapshot
        async function deleteSnapshot(snapshotId, snapshotDate, objectPath, isCurrentSnapshot = false) {
            try {
                // Confirmation de suppression
                const confirmMessage = isCurrentSnapshot 
                    ? `⚠️ ATTENTION: Vous êtes actuellement dans ce snapshot!\n\nÊtes-vous sûr de vouloir le supprimer ?\n\nDate: ${snapshotDate}\nID: ${snapshotId}`
                    : `Êtes-vous sûr de vouloir supprimer ce snapshot ?\n\nDate: ${snapshotDate}\nID: ${snapshotId}`;
                
                if (!confirm(confirmMessage)) {
                    return;
                }
                
                console.log(`🗑️ Suppression du snapshot: ${snapshotId} (${snapshotDate})`);
                
                // Si c'est le snapshot actuel, sortir du mode snapshot d'abord
                if (isCurrentSnapshot) {
                    console.log('🔄 Sortie du mode snapshot avant suppression...');
                    await exitSnapshotMode();
                }
                
                // Créer un client Supabase avec la clé de service pour la suppression
                const { createClient: createClientService } = await import('https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm');
                const supabaseService = createClientService(supabaseConfig.supabaseUrl, supabaseConfig.supabaseServiceKey);
                
                // 1. Supprimer le fichier du stockage
                console.log('🗑️ Suppression du fichier du stockage...');
                const { error: storageError } = await supabaseService.storage
                    .from('table-snapshots')
                    .remove([objectPath]);
                
                if (storageError) {
                    console.warn('⚠️ Erreur lors de la suppression du fichier:', storageError);
                    // Continuer même si le fichier n'existe pas
                } else {
                    console.log('✅ Fichier supprimé du stockage');
                }
                
                // 2. Supprimer l'enregistrement de la base de données
                console.log('🗑️ Suppression de l\'enregistrement de la base...');
                const { error: dbError } = await supabaseService
                    .from('table_snapshots_index')
                    .delete()
                    .eq('id', snapshotId);
                
                if (dbError) {
                    throw new Error(`Erreur lors de la suppression de l'enregistrement: ${dbError.message}`);
                }
                
                console.log('✅ Enregistrement supprimé de la base');
                
                // 3. Supprimer l'entrée du log de restauration
                console.log('🗑️ Suppression de l\'entrée du log...');
                const { error: logError } = await supabaseService
                    .from('snapshot_restore_log')
                    .delete()
                    .eq('snapshot_date', snapshotDate);
                
                if (logError) {
                    console.warn('⚠️ Erreur lors de la suppression du log:', logError);
                    // Continuer même si l'entrée n'existe pas
                } else {
                    console.log('✅ Entrée du log supprimée');
                }
                
                // 4. Mettre à jour la liste des snapshots disponibles
                console.log('🔄 Mise à jour de la liste des snapshots...');
                await loadAvailableSnapshots();
                
                // 5. Rafraîchir l'affichage du calendrier
                populateSnapshotCalendar();
                
                // 6. Afficher le message de succès
                showMessage(`✅ Snapshot supprimé avec succès: ${snapshotDate}`, 'success');
                
                console.log('🎉 Snapshot supprimé avec succès!');
                
            } catch (error) {
                console.error('❌ Erreur lors de la suppression du snapshot:', error);
                showMessage(`❌ Erreur lors de la suppression: ${error.message}`, 'error');
            }
        }

        // Function to show snapshots for a specific month
        function showMonthSnapshots(monthYear) {
            const datesList = document.getElementById('snapshot-dates-list');
            if (!datesList) return;
            
            // Update active month button
            const monthButtons = datesList.querySelectorAll('.month-nav-btn');
            monthButtons.forEach(btn => {
                if (btn.dataset.month === monthYear) {
                    btn.className = 'month-nav-btn px-3 py-1.5 text-xs rounded-lg border transition-colors whitespace-nowrap bg-blue-100 border-blue-300 text-blue-700 font-medium';
                } else {
                    btn.className = 'month-nav-btn px-3 py-1.5 text-xs rounded-lg border transition-colors whitespace-nowrap bg-gray-50 border-gray-200 text-gray-600 hover:bg-gray-100';
                }
            });
            
            // Find the month content container or create it
            let monthContent = datesList.querySelector('.month-content');
            if (!monthContent) {
                monthContent = document.createElement('div');
                monthContent.className = 'month-content';
                datesList.appendChild(monthContent);
            }
            
            // Clear previous month content
            monthContent.innerHTML = '';
            
            // Get snapshots for this month
            const monthSnapshots = availableSnapshots.filter(snapshot => {
                const date = new Date(snapshot.snapshot_date);
                const snapshotMonth = date.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long' });
                return snapshotMonth === monthYear;
            });
            
            if (monthSnapshots.length === 0) {
                monthContent.innerHTML = `
                    <div class="p-3 text-center text-gray-500 text-sm">
                        <i class="fa-solid fa-calendar-xmark w-5 h-3 mx-auto mb-2"></i>
                        Aucun snapshot pour ${monthYear}
                    </div>
                `;
                return;
            }
            
            // Sort snapshots by date (most recent first)
            monthSnapshots.sort((a, b) => new Date(b.snapshot_date) - new Date(a.snapshot_date));
            
            // Create month header
            const monthHeader = document.createElement('div');
            monthHeader.className = 'px-3 py-2 month-header-gradient rounded-r-lg mb-3';
            monthHeader.innerHTML = `
                <div class="flex items-center justify-between">
                    <h3 class="text-sm font-semibold text-blue-800">${monthYear}</h3>
                    <span class="text-xs text-blue-600 bg-blue-100 px-2 py-1 rounded-full">${monthSnapshots.length} snapshot${monthSnapshots.length > 1 ? 's' : ''}</span>
                </div>
            `;
            monthContent.appendChild(monthHeader);
            
            // Group snapshots by week for better organization
            const weeklySnapshots = {};
            monthSnapshots.forEach(snapshot => {
                const date = new Date(snapshot.snapshot_date);
                const weekStart = new Date(date);
                weekStart.setDate(date.getDate() - date.getDay()); // Start of week (Sunday)
                const weekKey = weekStart.toISOString().split('T')[0];
                
                if (!weeklySnapshots[weekKey]) {
                    weeklySnapshots[weekKey] = [];
                }
                weeklySnapshots[weekKey].push(snapshot);
            });
            
            // Create weekly sections
            Object.entries(weeklySnapshots).forEach(([weekStart, weekSnapshots]) => {
                // Week header
                const weekHeader = document.createElement('div');
                weekHeader.className = 'px-3 py-1 week-header text-xs font-medium text-gray-600 rounded mb-2';
                const weekDate = new Date(weekStart);
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekDate.getDate() + 6);
                weekHeader.textContent = `Semaine du ${weekDate.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' })} au ${weekEnd.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' })}`;
                monthContent.appendChild(weekHeader);
                
                // Sort snapshots within the week by date
                weekSnapshots.sort((a, b) => new Date(b.snapshot_date) - new Date(a.snapshot_date));
                
                // Create snapshot entries for this week
                weekSnapshots.forEach(snapshot => {
                    const dateItem = document.createElement('div');
                    dateItem.className = 'px-4 py-2 hover:bg-blue-50 cursor-pointer rounded-lg text-sm transition-colors border-l-2 border-transparent hover:border-blue-300 ml-2 snapshot-item';
                    
                    // Use unique identifier combining date and time for current snapshot detection
                    const snapshotUniqueId = `${snapshot.snapshot_date}_${snapshot.created_at}`;
                    const currentUniqueId = snapshotMode === 'snapshot' && currentSnapshotDate ? 
                        `${currentSnapshotDate}_${currentSnapshotDate}` : null;
                    const isCurrent = snapshotUniqueId === currentUniqueId;
                    
                    if (isCurrent) {
                        dateItem.className += ' current';
                    }
                    
                    const date = new Date(snapshot.snapshot_date);
                    const formattedDate = date.toLocaleDateString('fr-FR', {
                        weekday: 'long',
                        day: 'numeric',
                        month: 'short'
                    });
                    
                    // Extract time from created_at for unique identification
                    const createdTime = new Date(snapshot.created_at);
                    const timeString = createdTime.toLocaleTimeString('fr-FR', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    
                    // Add unique identifier to help with debugging
                    const uniqueTimeId = createdTime.getTime();
                    
                    dateItem.innerHTML = `
                        <div class="flex items-center justify-between">
                            <div class="flex flex-col flex-1 cursor-pointer" onclick="enterSnapshotModeByUniqueId(${JSON.stringify(snapshot).replace(/"/g, '&quot;')})">
                                <span class="${isCurrent ? 'font-semibold text-blue-700' : 'text-gray-700'}">${formattedDate}</span>
                                <span class="text-xs text-gray-400">${timeString}</span>
                                <span class="text-xs text-gray-300">ID: ${uniqueTimeId}</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="text-xs text-gray-500">${snapshot.row_count} lignes</span>
                                ${isCurrent ? '<span class="text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded-full">Actuel</span>' : ''}
                                <button onclick="event.stopPropagation(); deleteSnapshot('${snapshot.id}', '${snapshot.snapshot_date}', '${snapshot.object_path}', ${isCurrent})" 
                                        class="text-red-500 hover:text-red-700 p-1.5 rounded hover:bg-red-50 transition-colors ml-2" 
                                        title="Supprimer ce snapshot">
                                    <i class="fas fa-trash text-xs"></i>
                                </button>
                            </div>
                        </div>
                    `;
                    
                    // Remove the old onclick handler since we now handle clicks on the content div
                    // and the delete button has its own handler
                    
                    monthContent.appendChild(dateItem);
                });
            });
        }
        
        // Update snapshot banner
        function updateSnapshotBanner() {
            // Note: snapshot-banner HTML element has been removed from the interface
            // This function is kept for compatibility but does nothing
            const banner = document.getElementById('snapshot-banner');
            if (!banner) {
                // Element doesn't exist anymore, silently return
                return;
            }
            
            const bannerText = document.getElementById('snapshot-banner-text');
            
            // Only show banner when actively viewing history (snapshot mode)
            if (snapshotMode === 'snapshot' && currentSnapshotDate) {
                banner.classList.remove('hidden');
                banner.classList.add('flex');
                if (bannerText) {
                    bannerText.textContent = `Snapshot du ${formatDateForDisplay(currentSnapshotDate)}`;
                }
            } else {
                // Always hidden in live mode or when no snapshot is selected
                banner.classList.add('hidden');
                banner.classList.remove('flex');
            }
        }
        
        // Update history date button
        function updateHistoryDateButton() {
            const dateText = document.getElementById('current-snapshot-date-text');
            
            if (snapshotMode === 'snapshot' && currentSnapshotDate) {
                dateText.textContent = formatDateForDisplay(currentSnapshotDate);
            } else {
                dateText.textContent = 'Données en direct';
            }
        }
        
        // Disable table editing
        function disableTableEditing() {
            console.log('🔒 DEBUG: disableTableEditing called');
            
            // Wait for DOM to be ready
            setTimeout(() => {
                const cells = document.querySelectorAll('#table-body td.editable-cell');
                console.log('🔒 DEBUG: Found', cells.length, 'editable cells to disable');
                
                cells.forEach((cell, index) => {
                    cell.contentEditable = false;
                    cell.classList.add('snapshot-readonly');
                    console.log(`🔒 DEBUG: Cell ${index} disabled and marked readonly`);
                });
                
                // Disable all function buttons in snapshot mode
                const functionButtons = document.querySelectorAll('#button-bar button');
                console.log('🔒 DEBUG: Found', functionButtons.length, 'function buttons to disable');
                
                functionButtons.forEach((btn, index) => {
                    btn.disabled = true;
                    console.log(`🔒 DEBUG: Button ${index} disabled`);
                });
                
                // Disable FAB add button
                const fabAdd = document.getElementById('fab-add');
                if (fabAdd) {
                    fabAdd.style.pointerEvents = 'none';
                    console.log('🔒 DEBUG: FAB add button disabled');
                } else {
                    console.warn('⚠️ DEBUG: FAB add button not found');
                }
                
                console.log('✅ DEBUG: Table editing disabled successfully');
            }, 100); // Small delay to ensure DOM is ready
        }
        
        // Enable table editing
        function enableTableEditing() {
            console.log('🔓 DEBUG: enableTableEditing called');
            
            // Wait for DOM to be ready
            setTimeout(() => {
                const cells = document.querySelectorAll('#table-body td.editable-cell');
                console.log('🔓 DEBUG: Found', cells.length, 'editable cells to enable');
                
                cells.forEach((cell, index) => {
                    if (!isViewMode) { // Only enable if not in view mode
                        cell.contentEditable = true;
                        console.log(`🔓 DEBUG: Cell ${index} enabled for editing`);
                    } else {
                        console.log(`🔓 DEBUG: Cell ${index} kept disabled (view mode)`);
                    }
                    cell.classList.remove('snapshot-readonly');
                    console.log(`🔓 DEBUG: Cell ${index} readonly class removed`);
                });
                
                // Re-enable function buttons
                const functionButtons = document.querySelectorAll('#button-bar button');
                console.log('🔓 DEBUG: Found', functionButtons.length, 'function buttons to enable');
                
                functionButtons.forEach((btn, index) => {
                    btn.disabled = false;
                    console.log(`🔓 DEBUG: Button ${index} enabled`);
                });
                
                // Re-enable FAB add button
                const fabAdd = document.getElementById('fab-add');
                if (fabAdd) {
                    fabAdd.style.pointerEvents = 'auto';
                    console.log('🔓 DEBUG: FAB add button enabled');
                } else {
                    console.warn('⚠️ DEBUG: FAB add button not found');
                }
                
                console.log('✅ DEBUG: Table editing enabled successfully');
            }, 100); // Small delay to ensure DOM is ready
        }
        
        // Format date for display
        function formatDateForDisplay(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('fr-FR', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        }
        

        

        
        // Fonction pour actualiser le tableau avec les données les plus récentes
        function refreshTableData() {
            // Clean: Removed debug log
            
            // Si on est en mode snapshot, retourner aux données en direct
            if (snapshotMode === 'snapshot') {
                // Clean: Removed debug log
                returnToToday();
            }
            
            // Recharger les données depuis Supabase
            fetchInitialData().then(() => {
                showMessage('Tableau actualisé avec les données les plus récentes', 'success');
            }).catch(error => {
                console.error('❌ Erreur lors de l\'actualisation:', error);
                showMessage('Erreur lors de l\'actualisation du tableau', 'error');
            });
        }
        
        // Enhanced mobile-responsive history bar toggle function
        function toggleHistoryBarSimple() {
            // Debug: Vérifier que le DOM est chargé
            if (document.readyState !== 'complete') {
                console.warn('⚠️ DOM not fully loaded, waiting...');
                setTimeout(toggleHistoryBarSimple, 100);
                return;
            }
            
            const historyBarContainer = document.getElementById('history-bar-container');
            const toggleBtn = document.getElementById('history-toggle-btn');
            const toggleIcon = document.getElementById('history-toggle-icon');
            
            if (!historyBarContainer || !toggleBtn || !toggleIcon) {
                console.error('❌ Required elements not found');
                console.error('❌ historyBarContainer:', historyBarContainer);
                console.error('❌ toggleBtn:', toggleBtn);
                console.error('❌ toggleIcon:', toggleIcon);
                return;
            }
            
            // Check current state - more robust detection
            const isCurrentlyVisible = !historyBarContainer.classList.contains('hidden') && 
                                    historyBarContainer.style.display !== 'none' && 
                                    historyBarContainer.offsetHeight > 0;
            
            if (isCurrentlyVisible) {
                // Hide history bar container
                historyBarContainer.classList.add('hidden');
                historyBarContainer.style.display = 'none';
                
                // Update button icon to show it can open
                toggleIcon.className = 'fa-solid fa-plus w-2 h-2 flex items-center justify-center text-center leading-none';
                
                console.log('🔽 History bar hidden');
            } else {
                // Show history bar container
                historyBarContainer.classList.remove('hidden');
                historyBarContainer.style.display = 'flex'; // Use flex instead of block for better mobile layout
                
                // Update button icon to show it can close
                toggleIcon.className = 'fa-solid fa-minus w-2 h-2 flex items-center justify-center text-center leading-none';
                
                console.log('🔼 History bar shown');
            }
            
            // No mobile-specific modifications - consistent display across all screen sizes
        }
        
        // Mobile event listeners removed - consistent behavior across all screen sizes
        
        // Mobile breakpoint and layout optimization functions removed - consistent display across all screen sizes
        
        // Test function for history bar functionality (mobile-specific features removed)
        function testHistoryBar() {
            const historyBarContainer = document.getElementById('history-bar-container');
            const toggleBtn = document.getElementById('history-toggle-btn');
            const toggleIcon = document.getElementById('history-toggle-icon');
            
            console.log('🧪 Testing History Bar...');
            console.log('🔄 Screen size:', window.innerWidth, 'x', window.innerHeight);
            
            if (!historyBarContainer || !toggleBtn || !toggleIcon) {
                console.error('❌ Test failed: Required elements not found');
                return false;
            }
            
            console.log('✅ All elements found');
            console.log('🔍 History bar container:', historyBarContainer);
            console.log('🔍 Toggle button:', toggleBtn);
            console.log('🔍 Toggle icon:', toggleIcon);
            
            // Test initial state
            const initialHidden = historyBarContainer.classList.contains('hidden');
            const initialDisplay = historyBarContainer.style.display;
            const initialHeight = historyBarContainer.offsetHeight;
            
            console.log('📊 Initial state:');
            console.log('  - Hidden class:', initialHidden);
            console.log('  - Display style:', initialDisplay);
            console.log('  - Offset height:', initialHeight);
            
            // Test toggle functionality
            console.log('🔄 Testing toggle functionality...');
            toggleHistoryBarSimple();
            
            setTimeout(() => {
                const afterToggleHidden = historyBarContainer.classList.contains('hidden');
                const afterToggleDisplay = historyBarContainer.style.display;
                const afterToggleHeight = historyBarContainer.offsetHeight;
                
                console.log('📊 After toggle:');
                console.log('  - Hidden class:', afterToggleHidden);
                console.log('  - Display style:', afterToggleDisplay);
                console.log('  - Offset height:', afterToggleHeight);
                
                // Test toggle back
                setTimeout(() => {
                    console.log('🔄 Testing toggle back...');
                    toggleHistoryBarSimple();
                    
                    setTimeout(() => {
                        const finalHidden = historyBarContainer.classList.contains('hidden');
                        const finalDisplay = historyBarContainer.style.display;
                        const finalHeight = historyBarContainer.offsetHeight;
                        
                        console.log('📊 Final state:');
                        console.log('  - Hidden class:', finalHidden);
                        console.log('  - Display style:', finalDisplay);
                        console.log('  - Offset height:', finalHeight);
                        
                        console.log('✅ History Bar test completed');
                    }, 100);
                }, 100);
            }, 100);
            
            return true;
        }

        // ===== END SNAPSHOT SYSTEM FUNCTIONS =====



        // Initialize application
        function initializeApp() {
            // Set up event listeners
            setupEventListeners();
            setupKeyboardNavigation();
            
            // Initialize zoom
            applyZoom();
            
            // Initialize color picker
            const picker = document.getElementById('row-color-picker');
            if (picker) {
                try { 
                    picker.value = currentRowColor; 
                } catch(_) {}
                
                picker.addEventListener('input', (e) => {
                    currentRowColor = e.target.value || '#FFF59D';
                    try { 
                        localStorage.setItem('rowColor', currentRowColor); 
                    } catch(_) {}
                });
            }
            
                        // Initialize UI state
            updatePaintModeButton();
            maybeShowFirstUseHint();
            updateFilterColoredButton();
            
            // Détecter automatiquement l'état du bouton œil et agir en conséquence
            detectAndApplyViewMode();
            
            // Adapter l'affichage du statut selon la taille d'écran
            adaptStatusDisplay();
            window.addEventListener('resize', adaptStatusDisplay);
            
            // Configurer le clic sur les noms de patients pour les images
            setupPatientImageClick();
            
            // Initialiser l'état de la barre d'historique : cachée par défaut
            const historyBarContainer = document.getElementById('history-bar-container');
            const toggleIcon = document.getElementById('history-toggle-icon');
            if (historyBarContainer && toggleIcon) {
                // S'assurer que la barre est cachée
                historyBarContainer.classList.add('hidden');
                historyBarContainer.style.display = 'none';
                
                // S'assurer que l'icône est en mode "plus" (fermé)
                toggleIcon.className = 'fa-solid fa-plus w-2 h-2 flex items-center justify-center text-center leading-none';
                
                // Vérification post-initialisation pour mobile
                setTimeout(() => {
                    if (isMobile()) {
                        const isHidden = historyBarContainer.classList.contains('hidden') && 
                                        historyBarContainer.style.display === 'none';
                        console.log('🔍 Post-init mobile check:', isHidden ? 'Hidden' : 'Visible');
                        
                        // Force mobile-specific layout
                        if (window.innerWidth <= 768) {
                            historyBarContainer.style.width = '100%';
                            historyBarContainer.style.maxWidth = 'none';
                        }
                    }
                }, 100);
            }
            
            // Initialiser l'affichage du nombre de lignes
            updateRowCount();
            
            // Check if already logged in
            const already = sessionStorage.getItem('isLoggedIn') === '1';
            if (already) {
                document.getElementById('login-container').classList.add('hidden');
                document.getElementById('table-container').classList.remove('hidden');
                
                // Détecter l'état du mode visualisation MAIS ne pas l'appliquer encore
                const savedViewMode = localStorage.getItem('viewMode') === 'true';
                if (savedViewMode !== isViewMode) {
                    isViewMode = savedViewMode;
                }
                
                restoreLocalDraft(); 
                ensureDDNHeader();
                
                // Consolidated cursor restoration function
                const performCursorRestoration = () => {
                    log(`🔄 CURSOR RESTORATION: lastFocusInfo=${JSON.stringify(lastFocusInfo)}, lastCellPos=${JSON.stringify(lastCellPos)}`);
                    
                    // Try focusCellFromInfo first (more reliable)
                    let restorationSuccess = false;
                    if (lastFocusInfo && lastFocusInfo.rowIndex >= 0 && lastFocusInfo.colLabel) {
                        restorationSuccess = focusCellFromInfo(lastFocusInfo);
                        log(`🔄 focusCellFromInfo result: ${restorationSuccess}`);
                    }
                    
                    // Fallback to focusCellByPos if focusCellFromInfo fails
                    if (!restorationSuccess && lastCellPos && lastCellPos.rowIndex >= 0 && lastCellPos.cellIndex >= 0) {
                            log(`🔄 Trying focusCellByPos with ${JSON.stringify(lastCellPos)}`);
                        restorationSuccess = focusCellByPos(lastCellPos);
                        log(`🔄 focusCellByPos result: ${restorationSuccess}`);
                    }
                    
                    if (restorationSuccess) {
                        log(`✅ Cursor restoration successful`);
                        } else {
                        log(`⚠️ Cursor restoration failed - no valid position information`);
                    }
                };
                
                const restoreAfterReload = () => {
                    document.removeEventListener('table:reloaded', restoreAfterReload);
                    
                    // Wait for table to be fully rendered and image icons updated
                    // Use a longer delay to ensure all table updates are complete
                    setTimeout(() => {
                        performCursorRestoration();
                        
                        // Additional mobile retry if needed
                        if (isMobile()) {
                            setTimeout(() => { 
                                performCursorRestoration();
                            }, 350);
                        }
                    }, 200); // Increased delay to ensure table and image icons are fully ready
                };
                
                document.addEventListener('table:reloaded', restoreAfterReload, { once: true });
                fetchInitialData(); 
                setupRealtimeSubscription(); 
                startPeriodicSync(); 
                scheduleAutosaveCountdown();
                
                // Initialize snapshot system
                loadAvailableSnapshots();
                
                // Ensure snapshot banner is hidden by default
                updateSnapshotBanner();
                
                // Update calendar display after loading snapshots
                setTimeout(() => {
                    populateSnapshotCalendar();
                }, 500);
                
                // Clean: Removed debug verification for production
                
                // Force UI update to ensure everything is visible
                // Clean: Removed debug UI update for production
                

                
                // Appliquer le mode visualisation APRÈS la restauration des données
                // Clean: Removed debug view mode application for production
                
                // Adapter l'affichage après le chargement des données
                setTimeout(adaptStatusDisplay, 100);
                
                // Mettre à jour les indicateurs d'images
                setTimeout(updateImageIndicators, 200);
                
                // Charger les images depuis Supabase
                setTimeout(loadImagesFromSupabase, 300);
                
                // Mettre à jour les icônes de la colonne Images après le chargement
                setTimeout(updateAllImageColumnIcons, 500);
                
                // Afficher le statut de synchronisation des images
                setTimeout(showImageSyncStatus, 600);
                
                // Enable focus capture after initialization is complete
                setTimeout(() => {
                    isInitialLoad = false;
                    log(`✅ Initial load complete - focus capture now enabled`);
                    
                    // Ensure cursor restoration happens after all updates are complete
                    if (lastFocusInfo || lastCellPos) {
                        // Clean: Removed debug log
                        setTimeout(() => {
                            performCursorRestoration();
                        }, 100);
                    }
                }, 1000);
                
                // Add click outside handler for calendar dropdown
                document.addEventListener('click', (e) => {
                    const calendarBtn = document.getElementById('snapshot-calendar-btn');
                    const calendarDropdown = document.getElementById('snapshot-calendar-dropdown');
                    
                    if (calendarDropdown && !calendarDropdown.classList.contains('hidden')) {
                        if (!calendarBtn?.contains(e.target) && !calendarDropdown?.contains(e.target)) {
                            calendarDropdown.classList.add('hidden');
                        }
                    }
                });
            } else {
                document.getElementById('login-container').classList.remove('hidden');
            }
            

        }
        

        

        

        

        

        
        function displayPatientImages(patientName) {
            const gallery = document.getElementById('image-gallery');
            const images = patientImages[patientName] || [];
            
            gallery.innerHTML = '';
            
            if (images.length === 0) {
                gallery.innerHTML = '<p class="text-gray-500 text-center col-span-full">Aucune image pour ce patient</p>';
                return;
            }
            
            images.forEach((image, index) => {
                const imageDiv = document.createElement('div');
                imageDiv.className = 'relative group';
                
                imageDiv.innerHTML = `
                    <img src="${image.data}" alt="${image.name}" class="w-full h-24 object-cover rounded-lg cursor-pointer hover:opacity-80 transition-opacity" 
                         onclick="viewImage('${patientName}', ${index})"
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
                    <div class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs cursor-pointer hover:bg-red-600 opacity-0 group-hover:opacity-100 transition-opacity"
                         onclick="deleteImage('${patientName}', ${index})">×</div>
                    <p class="text-xs text-gray-600 mt-1 truncate">${image.name}</p>
                    <div class="hidden text-xs text-gray-400 text-center mt-2">Image corrompue</div>
                `;
                
                gallery.appendChild(imageDiv);
            });
        }
        
        function viewImage(patientName, imageIndex) {
            const images = patientImages[patientName] || [];
            if (images.length === 0) return;
            
            currentPatientImages = images;
            currentImageIndex = imageIndex;
            
            const modal = document.getElementById('image-viewer-modal');
            const currentImage = document.getElementById('current-image');
            const counter = document.getElementById('image-counter');
            
            currentImage.src = images[imageIndex].data;
            currentImage.onerror = () => {
                showMessage('Erreur lors du chargement de l\'image', 'error');
                currentImage.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzY2NzM4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vbiB0cm91dsOpZTwvdGV4dD48L3N2Zz4=';
            };
            counter.textContent = `${imageIndex + 1} / ${images.length}`;
            
            modal.classList.remove('hidden');
        }
        
        function closeImageViewer() {
            document.getElementById('image-viewer-modal').classList.add('hidden');
        }
        
        function nextImage() {
            if (currentPatientImages.length === 0) return;
            currentImageIndex = (currentImageIndex + 1) % currentPatientImages.length;
            updateImageViewer();
        }
        
        function previousImage() {
            if (currentPatientImages.length === 0) return;
            currentImageIndex = currentImageIndex === 0 ? currentPatientImages.length - 1 : currentImageIndex - 1;
            updateImageViewer();
        }
        
        function updateImageViewer() {
            const currentImage = document.getElementById('current-image');
            const counter = document.getElementById('image-counter');
            
            currentImage.src = currentPatientImages[currentImageIndex].data;
            currentImage.onerror = () => {
                showMessage('Erreur lors du chargement de l\'image', 'error');
                currentImage.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzY2NzM4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vbiB0cm91dsOpZTwvdGV4dD48L3N2Zz4=';
            };
            counter.textContent = `${currentImageIndex + 1} / ${currentPatientImages.length}`;
        }
        
        async function deleteImage(patientName, imageIndex) {
            try {
                // Vérifier que l'image existe
                if (!patientImages[patientName] || !patientImages[patientName][imageIndex]) {
                    showMessage('Image non trouvée', 'error');
                    return;
                }

                // Demander confirmation
                if (!confirm(`Voulez-vous vraiment supprimer cette image ?`)) {
                    return;
                }

                const imageToDelete = patientImages[patientName][imageIndex];
                
                // Supprimer de Supabase si l'image a un ID
                if (imageToDelete.id) {
                    try {
                        const { error } = await supabase
                            .from('gallery_images')
                            .delete()
                            .eq('id', imageToDelete.id);
                        
                        if (error) {
                            console.error('Erreur lors de la suppression depuis Supabase:', error);
                            showMessage('Erreur lors de la suppression depuis le serveur', 'error');
                            return;
                        }
                    } catch (supabaseError) {
                        console.error('Erreur de connexion Supabase:', supabaseError);
                        showMessage('Erreur de connexion au serveur', 'error');
                        return;
                    }
                }

                // Supprimer du stockage local
                patientImages[patientName].splice(imageIndex, 1);
                
                // Si c'était la dernière image du patient, supprimer l'entrée du patient
                if (patientImages[patientName].length === 0) {
                    delete patientImages[patientName];
                }
                
                // Sauvegarder les changements
                savePatientImages();
                
                // Mettre à jour l'affichage
                displayPatientImages(patientName);
                updateAllImageColumnIcons(true); // Éviter les sauvegardes automatiques
                
                // Réinitialiser les indicateurs de modification pour éviter l'autosave
                isDirty = false;
                lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // Désactiver l'autosave
                
                // Fermer le visualiseur si c'était la dernière image
                if (!patientImages[patientName] || patientImages[patientName].length === 0) {
                    closeImageViewer();
                }
                
                showMessage('Image supprimée avec succès', 'success');
                
            } catch (error) {
                console.error('Erreur lors de la suppression de l\'image:', error);
                showMessage('Erreur lors de la suppression de l\'image', 'error');
            }
                }

        // Fonction pour supprimer toutes les images d'un patient
        async function deleteAllImagesForPatient(patientName) {
            try {
                if (!patientImages[patientName] || patientImages[patientName].length === 0) {
                    showMessage('Aucune image à supprimer pour ce patient', 'info');
                    return;
                }

                const imageCount = patientImages[patientName].length;
                
                // Supprimer toutes les images de Supabase
                for (const image of patientImages[patientName]) {
                    if (image.id) {
                        try {
                            const { error } = await supabase
                                .from('gallery_images')
                                .delete()
                                .eq('id', image.id);
                            
                            if (error) {
                                console.error('Erreur lors de la suppression de l\'image depuis Supabase:', error);
                            }
                        } catch (supabaseError) {
                            console.error('Erreur de connexion Supabase:', supabaseError);
                        }
                    }
                }

                // Supprimer du stockage local
                delete patientImages[patientName];
                savePatientImages();
                
                // Mettre à jour l'affichage
                updateAllImageColumnIcons(true); // Éviter les sauvegardes automatiques
                
                // Réinitialiser les indicateurs de modification pour éviter l'autosave
                isDirty = false;
                lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // Désactiver l'autosave
                
                // Fermer le visualiseur si il était ouvert pour ce patient
                if (currentPatientImages && currentPatientImages.length > 0) {
                    const firstImage = currentPatientImages[0];
                    if (firstImage.patientName === patientName) {
                        closeImageViewer();
                    }
                }
                
                showMessage(`${imageCount} image(s) supprimée(s) pour ${patientName}`, 'success');
                
            } catch (error) {
                console.error('Erreur lors de la suppression de toutes les images:', error);
                showMessage('Erreur lors de la suppression des images', 'error');
            }
        }

        async function syncImageToSupabase(imageData) {
            try {
                // Créer une entrée dans la table des images
                const { error } = await supabase
                    .from('gallery_images')
                    .upsert({
                        id: imageData.id,
                        patient_name: imageData.patientName,
                        image_name: imageData.name,
                        image_data: imageData.data,
                        image_type: imageData.type,
                        image_size: imageData.size,
                        upload_date: imageData.uploadDate,
                        last_sync: new Date().toISOString()
                    });
                
                if (error) {
                    console.error('Erreur Supabase:', error);
                    // Stocker pour synchronisation ultérieure
                    storeImageForLaterSync(imageData);
                }
            } catch (error) {
                console.error('Erreur de synchronisation:', error);
                // Stocker pour synchronisation ultérieure
                storeImageForLaterSync(imageData);
            }
        }
        
        function storeImageForLaterSync(imageData) {
            let pendingImages = JSON.parse(localStorage.getItem('pendingImageSync') || '[]');
            pendingImages.push(imageData);
            localStorage.setItem('pendingImageSync', JSON.stringify(pendingImages));
        }
        
        async function syncPendingImages() {
            try {
                let pendingImages = JSON.parse(localStorage.getItem('pendingImageSync') || '[]');
                if (pendingImages.length === 0) return;
                
                for (const imageData of pendingImages) {
                    await syncImageToSupabase(imageData);
                }
                
                // Vider la liste des images en attente
                localStorage.removeItem('pendingImageSync');
                
                // Mettre à jour les icônes de la colonne Images
                updateAllImageColumnIcons(true); // Éviter les sauvegardes automatiques
                
                // Réinitialiser les indicateurs de modification pour éviter l'autosave
                isDirty = false;
                lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // Désactiver l'autosave
                
                showMessage('Images synchronisées avec le serveur', 'success');
            } catch (error) {
                console.error('Erreur lors de la synchronisation des images en attente:', error);
            }
        }
        
        function savePatientImages() {
            try {
                localStorage.setItem('patientImages', JSON.stringify(patientImages));
            } catch (e) {
                console.error('Erreur lors de la sauvegarde des images:', e);
            }
        }
        
        // Fonction pour afficher les images au clic sur le nom du patient
        function setupPatientImageClick() {
            const tbody = document.getElementById('table-body');
            if (!tbody) return;
            
            tbody.addEventListener('click', function(e) {
                const nameCell = e.target.closest('td:nth-child(6)'); // Colonne Nom_Prénom
                if (nameCell && nameCell.textContent.trim()) {
                    const patientName = nameCell.textContent.trim();
                    const images = patientImages[patientName] || [];
                    
                    if (images.length > 0) {
                        // Ouvrir directement le visualiseur d'images
                        currentPatientImages = images;
                        currentImageIndex = 0;
                        viewImage(patientName, 0);
                    } else {
                        // Aucune image pour ce patient - afficher un message
                        showMessage('Aucune image pour ce patient. Utilisez le bouton ➕ dans la colonne Images pour ajouter des images.', 'info');
                    }
                }
            });
        }
        
        // Fonction pour afficher le statut de synchronisation des images
        function showImageSyncStatus() {
            const pendingImages = JSON.parse(localStorage.getItem('pendingImageSync') || '[]');
            if (pendingImages.length > 0) {
                showMessage(`${pendingImages.length} image(s) en attente de synchronisation`, 'warning');
            }
        }
        
        // Fonction pour mettre à jour les indicateurs d'images (maintenant uniquement dans la colonne Images)
        function updateImageIndicators() {
            // Cette fonction est maintenant remplacée par updateAllImageColumnIcons
            // qui met à jour uniquement les icônes dans la colonne Images
            updateAllImageColumnIcons();
        }
        
        // Fonction pour charger les images depuis Supabase
        async function loadImagesFromSupabase() {
            // Skip if cursor restoration is in progress to avoid conflicts
            if (isRestoringFocus) {
                log('🔄 loadImagesFromSupabase skipped - cursor restoration in progress');
                return;
            }
            
            try {
                const { data, error } = await supabase
                    .from('gallery_images')
                    .select('*')
                    .order('upload_date', { ascending: false });
                
                if (error) {
                    console.error('Erreur lors du chargement des images:', error);
                    return;
                }
                
                if (data && data.length > 0) {
                    // Réorganiser les images par patient
                    const newPatientImages = {};
                    data.forEach(image => {
                        if (!newPatientImages[image.patient_name]) {
                            newPatientImages[image.patient_name] = [];
                        }
                        newPatientImages[image.patient_name].push({
                            id: image.id,
                            name: image.image_name,
                            data: image.image_data,
                            type: image.image_type,
                            size: image.image_size,
                            uploadDate: image.upload_date,
                            patientName: image.patient_name
                        });
                    });
                    
                    // Mettre à jour les images locales
                    patientImages = { ...patientImages, ...newPatientImages };
                    savePatientImages();
                    
                    // Synchroniser les images en attente
                    await syncPendingImages();
                    
                    // Mettre à jour les icônes de la colonne Images
                    updateAllImageColumnIcons(true); // Éviter les sauvegardes automatiques
                    
                    // Réinitialiser les indicateurs de modification pour éviter l'autosave
                    isDirty = false;
                    lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // Désactiver l'autosave
                    
                    showMessage(`${data.length} image(s) chargée(s) depuis le serveur`, 'success');
                }
            } catch (error) {
                console.error('Erreur lors du chargement des images:', error);
            }
        }

        // Fonction pour mettre à jour toutes les icônes de la colonne Images
        function updateAllImageColumnIcons(skipAutoSave = false) {
            const tbody = document.getElementById('table-body');
            if (!tbody) return;
            
            // Skip if cursor restoration is in progress to avoid conflicts
            if (isRestoringFocus) {
                log('🔄 updateAllImageColumnIcons skipped - cursor restoration in progress');
                return;
            }
            
            Array.from(tbody.querySelectorAll('tr')).forEach(row => {
                const imageCell = row.querySelector('[data-label="Images"]');
                if (imageCell) {
                    const mainButton = imageCell.querySelector('button:first-child');
                    const trashButton = imageCell.querySelector('button:last-child');
                    const container = imageCell.querySelector('div');
                    
                    if (mainButton && trashButton && container) {
                        const nameCell = row.querySelector('[data-label="Nom_Prénom"]');
                        if (nameCell) {
                            const patientName = nameCell.textContent.trim();
                            

                            
                            // Vérifier si l'état actuel correspond à l'état souhaité pour éviter les modifications inutiles
                            const hasImages = patientName && patientImages[patientName] && patientImages[patientName].length > 0;
                            const currentHasImages = mainButton.innerHTML === '📷';
                            
                            // Ne mettre à jour que si l'état a changé
                            if (hasImages !== currentHasImages) {
                                if (hasImages) {
                                    // Il y a des photos - afficher le bouton caméra et la poubelle
                                    mainButton.innerHTML = '📷';
                                    mainButton.title = `${patientImages[patientName].length} image(s) - Cliquez pour voir`;
                                    mainButton.onclick = (e) => {
                                        e.stopPropagation();
                                        viewImage(patientName, 0);
                                    };
                                    mainButton.className = 'p-1 rounded-full hover:bg-gray-200 transition-colors text-blue-500';
                                    
                                    // Afficher la poubelle
                                    trashButton.style.opacity = '1';
                                    trashButton.onclick = (e) => {
                                        e.stopPropagation();
                                        if (confirm(`Voulez-vous vraiment supprimer toutes les images de ${patientName} ?`)) {
                                            deleteAllImagesForPatient(patientName);
                                        }
                                    };
                                    
                                    // Ajouter un bouton + pour ajouter plus d'images (seulement s'il n'existe pas déjà)
                                    let addMoreButton = container.querySelector('.add-more-button');
                                    if (!addMoreButton) {
                                        addMoreButton = document.createElement('button');
                                        addMoreButton.innerHTML = '➕';
                                        addMoreButton.className = 'add-more-button p-1 rounded-full hover:bg-green-200 transition-colors text-green-600 ml-1';
                                        addMoreButton.title = 'Ajouter plus d\'images pour ce patient';
                                        addMoreButton.onclick = (e) => {
                                            e.stopPropagation();
                                            const fileInput = imageCell.querySelector('input[type="file"]');
                                            if (fileInput) fileInput.click();
                                        };
                                        container.appendChild(addMoreButton);
                                    }
                                    
                                } else {
                                // Pas de photos - afficher le bouton ajouter et cacher la poubelle
                                mainButton.innerHTML = '➕';
                                mainButton.title = 'Ajouter des images pour ce patient';
                                mainButton.onclick = (e) => {
                                    e.stopPropagation();
                                    const fileInput = imageCell.querySelector('input[type="file"]');
                                    if (fileInput) fileInput.click();
                                };
                                mainButton.className = 'p-1 rounded-full hover:bg-green-200 transition-colors text-green-600';
                                
                                    // Cacher la poubelle
                                    trashButton.style.opacity = '0';
                                    trashButton.onclick = null;
                                    
                                    // Supprimer le bouton + s'il existe
                                    const addMoreButton = container.querySelector('.add-more-button');
                                    if (addMoreButton) {
                                        addMoreButton.remove();
                                    }
                                }
                            } else if (hasImages) {
                                // Mettre à jour seulement le titre si le nombre d'images a changé
                                const currentTitle = mainButton.title;
                                const newTitle = `${patientImages[patientName].length} image(s) - Cliquez pour voir`;
                                if (currentTitle !== newTitle) {
                                    mainButton.title = newTitle;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Make functions globally available
        window.checkPassword = checkPassword;
        window.syncToMaster = syncToMaster;
        window.addRow = addRow;
        window.saveManually = saveManually;
        window.undo = undo;
        window.redo = redo;
        window.trackCellEdit = trackCellEdit;
        window.getColumnLabelForCell = getColumnLabelForCell;
        window.isUndoRedoInProgress = isUndoRedoInProgress;
        window.getUndoRedoStatus = getUndoRedoStatus;
        window.downloadExcel = downloadExcel;
        window.downloadPDF = downloadPDF;
        window.downloadImage = downloadImage;
        window.importExcelFromFile = importExcelFromFile;
        window.zoomIn = zoomIn;
        window.zoomOut = zoomOut;
        window.zoomReset = zoomReset;
        window.clearAllRowColors = clearAllRowColors;
        window.cyclePaintMode = cyclePaintMode;
        window.toggleColoredFilter = toggleColoredFilter;
        window.toggleViewMode = toggleViewMode;
        
        // Expose history bar toggle functions
        window.toggleHistoryBarSimple = toggleHistoryBarSimple;

        window.viewImage = viewImage;
        
        // Expose snapshot system functions
        window.loadAvailableSnapshots = loadAvailableSnapshots;
        window.enterSnapshotMode = enterSnapshotMode;
        window.enterSnapshotModeByUniqueId = enterSnapshotModeByUniqueId;
        window.returnToToday = returnToToday; // Use the existing function instead
        window.goToPreviousSnapshot = goToPreviousSnapshot;
        window.goToNextSnapshot = goToNextSnapshot;
        window.refreshTableData = refreshTableData;
        window.toggleSnapshotCalendar = toggleSnapshotCalendar;
        window.showMonthSnapshots = showMonthSnapshots;
        window.populateSnapshotCalendar = populateSnapshotCalendar;
        window.openDatePicker = openDatePicker;
        window.formatDateForDisplay = formatDateForDisplay;
        window.disableTableEditing = disableTableEditing;
        window.createManualSnapshot = createManualSnapshot;
        
        // Add debug wrapper to window
        window.debugManualSnapshot = async function() {
            try {
                console.log('🚀 DEBUG: Manual Snapshot Button Clicked!');
                console.log('🎯 About to call createManualSnapshot...');
                
                await createManualSnapshot();
                console.log('✅ DEBUG: createManualSnapshot completed');
                
            } catch (error) {
                console.error('❌ DEBUG ERROR:', error);
            }
        };
        
        // Add DOM extraction helper to window
        window.extractDOMTableData = function() {
            const table = document.getElementById('data-table');
            if (!table) return null;
            
            const tbody = table.querySelector('tbody');
            if (!tbody) return null;
            
            const headerRow = table.querySelector('thead tr');
            const headers = Array.from(headerRow?.querySelectorAll('th') || []).map(th => 
                th.textContent.trim()
            );
            
            const rows = tbody.querySelectorAll('tr');
            const data = [];
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                const rowData = {};
                
                cells.forEach((cell, index) => {
                    if (headers[index]) {
                        const input = cell.querySelector('input, textarea, select');
                        let value = input ? input.value : cell.textContent.trim();
                        
                        // Convert numbers
                        if (!isNaN(value) && value !== '' && !isNaN(parseFloat(value))) {
                            value = parseFloat(value);
                        }
                        
                        rowData[headers[index]] = value;
                    }
                });
                
                if (Object.keys(rowData).length > 0) {
                    data.push(rowData);
                }
            });
            
            return data;
        };
        
        // Expose storage management functions globally
        window.cleanupOldSnapshots = cleanupOldSnapshots;
        window.checkStorageCapacity = checkStorageCapacity;
        window.monitorStorageHealth = monitorStorageHealth;
        window.forceStorageCleanup = forceStorageCleanup;
        window.calculateOptimalSnapshotCount = calculateOptimalSnapshotCount;
        window.deleteSnapshot = deleteSnapshot;
        
        // Timer cleanup function to prevent infinite loops
        function cleanupAllTimers() {
            try {
                if (autosaveTicker) {
                    clearInterval(autosaveTicker);
                    autosaveTicker = null;
                }
                if (window._syncTimer) {
                    clearInterval(window._syncTimer);
                    window._syncTimer = null;
                }
                if (window._msgTimer) {
                    clearTimeout(window._msgTimer);
                    window._msgTimer = null;
                }
                if (cellEditTimeout) {
                    clearTimeout(cellEditTimeout);
                    cellEditTimeout = null;
                }
                if (undoRedoSyncTimeout) {
                    clearTimeout(undoRedoSyncTimeout);
                    undoRedoSyncTimeout = null;
                }
                if (historyDebounceTimeout) {
                    clearTimeout(historyDebounceTimeout);
                    historyDebounceTimeout = null;
                }
                if (typingTimer) {
                    clearTimeout(typingTimer);
                    typingTimer = null;
                }
                if (operationTimeout) {
                    clearTimeout(operationTimeout);
                    operationTimeout = null;
                }
                
                console.log('🧹 All timers cleaned up successfully');
            } catch (error) {
                console.error('❌ Error cleaning up timers:', error);
            }
        }
        
        // Enhanced conflict detection and prevention system
        function detectAndPreventConflicts() {
            const conflicts = [];
            
            // Check for autosave conflicts
            if (autosaveTicker && isPerformingUndoRedo) {
                conflicts.push('AUTOSAVE_UNDO_REDO_CONFLICT');
            }
            
            // Check for realtime conflicts
            if (realtimeSubscription && isPerformingUndoRedo) {
                conflicts.push('REALTIME_UNDO_REDO_CONFLICT');
            }
            
            // Check for sync conflicts
            if (window._syncTimer && isPerformingUndoRedo) {
                conflicts.push('SYNC_UNDO_REDO_CONFLICT');
            }
            
            // Check for timer conflicts
            if (autosaveTicker && window._syncTimer) {
                const autosaveInterval = 250; // 250ms from scheduleAutosaveCountdown
                const syncInterval = 500; // 500ms from startPeriodicSync
                
                if (syncInterval % autosaveInterval === 0) {
                    conflicts.push('TIMER_INTERVAL_CONFLICT');
                }
            }
            
            return conflicts;
        }
        
        // Enhanced autosave with conflict prevention
        function scheduleAutosaveCountdownEnhanced() {
            try {
                // Cleanup existing timer
                if (autosaveTicker) {
                    clearInterval(autosaveTicker);
                    autosaveTicker = null;
                }
                
                // Check for conflicts before starting
                const conflicts = detectAndPreventConflicts();
                if (conflicts.length > 0) {
                    console.warn('⚠️ Autosave conflicts detected:', conflicts);
                    return;
                }
                
                lastShownCountdown = null;
                autosaveTicker = setInterval(() => {
                    try {
                        // Enhanced conflict prevention
                        if (isSyncing || isPerformingUndoRedo) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        const modal = document.getElementById('confirmation-modal');
                        if (modal && !modal.classList.contains('hidden')) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        if (isTyping) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        // Check suppression windows
                        if (Date.now() < suppressAutosaveUntil) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        // Check pending operations
                        if (currentOperation && currentOperation.type) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        const remaining = AUTOSAVE_DELAY_MS - (Date.now() - lastEditAt);
                        if (remaining > 0) {
                            const secs = Math.ceil(remaining / 1000);
                            if (secs !== lastShownCountdown) {
                                showMessage(`Sauvegarde dans ${secs} s`, 'info');
                                lastShownCountdown = secs;
                            }
                        } else {
                            if (lastShownCountdown !== 0) {
                                showMessage('Sauvegarde imminente…', 'info');
                                lastShownCountdown = 0;
                            }
                        }
                    } catch (error) {
                        console.error('❌ Error in autosave ticker:', error);
                    }
                }, 250);
                
                console.log('✅ Enhanced autosave scheduled successfully');
            } catch (error) {
                console.error('❌ Error scheduling enhanced autosave:', error);
            }
        }
        
        // Enhanced periodic sync with conflict prevention
        function startPeriodicSyncEnhanced() {
            try {
                // Cleanup existing timer
                if (window._syncTimer) {
                    clearInterval(window._syncTimer);
                    window._syncTimer = null;
                }
                
                // Check for conflicts before starting
                const conflicts = detectAndPreventConflicts();
                if (conflicts.length > 0) {
                    console.warn('⚠️ Sync conflicts detected:', conflicts);
                    return;
                }
                
                window._syncTimer = setInterval(async () => {
                    try {
                        // Enhanced conflict prevention
                        if (isTyping || isPerformingUndoRedo) {
                            return;
                        }
                        
                        if (Date.now() - lastEditAt < AUTOSAVE_DELAY_MS) {
                            return;
                        }
                        
                        const modal = document.getElementById('confirmation-modal');
                        if (modal && !modal.classList.contains('hidden')) {
                            return;
                        }
                        
                        if (isSyncing || !isDirty) {
                            return;
                        }
                        
                        // Check suppression windows
                        if (Date.now() < suppressAutosaveUntil) {
                            return;
                        }
                        
                        // Check pending operations
                        if (currentOperation && currentOperation.type) {
                            return;
                        }
                        
                        isSyncing = true;
                        log('Auto-sync (500ms poll, 3s idle) vers Supabase…');
                        await syncToMaster(false);
                    } catch (error) {
                        console.error('❌ Error in periodic sync:', error);
                    } finally {
                        isSyncing = false;
                    }
                }, 500);
                
                console.log('✅ Enhanced periodic sync started successfully');
            } catch (error) {
                console.error('❌ Error starting enhanced periodic sync:', error);
            }
        }
        
        // Expose timer cleanup function globally
        window.cleanupAllTimers = cleanupAllTimers;
        
        // Expose conflict detection and prevention functions globally
        window.detectAndPreventConflicts = detectAndPreventConflicts;
        window.scheduleAutosaveCountdownEnhanced = scheduleAutosaveCountdownEnhanced;
        window.startPeriodicSyncEnhanced = startPeriodicSyncEnhanced;
        
        // Function to test and report all potential conflicts
        window.testSystemConflicts = function() {
            try {
                console.log('🔍 Testing system for potential conflicts...');
                
                // Test timer conflicts
                const timerConflicts = detectAndPreventConflicts();
                if (timerConflicts.length > 0) {
                    console.warn('⚠️ Timer conflicts detected:', timerConflicts);
                } else {
                    console.log('✅ No timer conflicts detected');
                }
                
                // Test autosave state
                console.log('📊 Autosave state:', {
                    autosaveTicker: !!autosaveTicker,
                    isPerformingUndoRedo,
                    suppressAutosaveUntil: Date.now() < suppressAutosaveUntil,
                    currentOperation: !!currentOperation
                });
                
                // Test sync state
                console.log('📊 Sync state:', {
                    syncTimer: !!window._syncTimer,
                    isSyncing,
                    isDirty,
                    lastEditAt: new Date(lastEditAt).toLocaleTimeString()
                });
                
                // Test realtime state
                console.log('📊 Realtime state:', {
                    realtimeSubscription: !!realtimeSubscription,
                    suppressRealtimeUntil: Date.now() < suppressRealtimeUntil
                });
                
                // Test undo/redo state
                console.log('📊 Undo/Redo state:', {
                    operationHistoryLength: operationHistory.length,
                    redoHistoryLength: redoHistory.length,
                    isPerformingUndoRedo
                });
                
                console.log('✅ System conflict test completed');
                return {
                    timerConflicts,
                    autosaveState: { autosaveTicker: !!autosaveTicker, isPerformingUndoRedo, suppressAutosaveUntil: Date.now() < suppressAutosaveUntil, currentOperation: !!currentOperation },
                    syncState: { syncTimer: !!window._syncTimer, isSyncing, isDirty, lastEditAt: new Date(lastEditAt).toLocaleTimeString() },
                    realtimeState: { realtimeSubscription: !!realtimeSubscription, suppressRealtimeUntil: Date.now() < suppressRealtimeUntil },
                    undoRedoState: { operationHistoryLength: operationHistory.length, redoHistoryLength: redoHistory.length, isPerformingUndoRedo }
                };
                
            } catch (error) {
                console.error('❌ Error testing system conflicts:', error);
                return null;
            }
        };
        
        // Function to test keyboard shortcuts
        window.testKeyboardShortcuts = function() {
            try {
                console.log('⌨️ Testing keyboard shortcuts...');
                
                // Test manual save shortcuts
                console.log('💾 Manual save shortcuts:');
                console.log('   - Cmd+Z (Mac) / Ctrl+Z (Windows/Linux)');
                console.log('   - Cmd+S (Mac) / Ctrl+S (Windows/Linux)');
                console.log('✅ Both shortcuts should trigger saveManually() function');
                
                // Test undo shortcut
                console.log('↩️ Undo shortcut: Cmd+Y (Mac) / Ctrl+Y (Windows/Linux)');
                console.log('✅ Shortcut should trigger undo() function');
                
                // Test other shortcuts
                console.log('⌨️ Other shortcuts:');
                console.log('   - Enter: Add new row');
                console.log('   - Ctrl+D: Delete selected row');
                console.log('   - Arrow keys: Navigate between cells');
                
                console.log('✅ Keyboard shortcuts test completed');
                return {
                    manualSave: ['Cmd+Z (Mac) / Ctrl+Z (Windows/Linux)', 'Cmd+S (Mac) / Ctrl+S (Windows/Linux)'],
                    undo: 'Cmd+Y (Mac) / Ctrl+Y (Windows/Linux)',
                    addRow: 'Enter',
                    deleteRow: 'Ctrl+D',
                    navigation: 'Arrow keys'
                };
                
            } catch (error) {
                console.error('❌ Error testing keyboard shortcuts:', error);
                return null;
            }
        };
        
        // Function to show keyboard shortcuts help
        window.showKeyboardShortcutsHelp = function() {
            try {
                const shortcuts = [
                    { key: 'Cmd+Z / Ctrl+Z', action: 'Sauvegarde manuelle', description: 'Équivalent au clic sur le bouton Sauvegarder' },
                    { key: 'Cmd+S / Ctrl+S', action: 'Sauvegarde manuelle', description: 'Alternative pour la sauvegarde manuelle' },
                    { key: 'Cmd+Y / Ctrl+Y', action: 'Annuler', description: 'Annuler la dernière action (équivalent au bouton Annuler)' },
                    { key: 'Enter', action: 'Nouvelle ligne', description: 'Ajouter une nouvelle ligne au tableau' },
                    { key: 'Ctrl+D', action: 'Supprimer ligne', description: 'Supprimer la ligne sélectionnée' },
                    { key: 'Flèches', action: 'Navigation', description: 'Se déplacer entre les cellules' }
                ];
                
                let helpText = '⌨️ Raccourcis clavier disponibles:\n\n';
                shortcuts.forEach(shortcut => {
                    helpText += `🔸 ${shortcut.key}: ${shortcut.action}\n   ${shortcut.description}\n\n`;
                });
                
                console.log(helpText);
                showMessage('Raccourcis clavier affichés dans la console', 'info');
                
                return shortcuts;
                
            } catch (error) {
                console.error('❌ Error showing keyboard shortcuts help:', error);
                return null;
            }
        };
        
        // Function to test mobile history bar functionality
        window.testMobileHistoryBar = function() {
            try {
                console.log('📱 Testing mobile history bar functionality...');
                
                // Check if we're on mobile
                const isMobileDevice = isMobile();
                console.log('📱 Is mobile device:', isMobileDevice);
                
                // Check required elements
                const toggleBtn = document.getElementById('history-toggle-btn');
                const historyBarContainer = document.getElementById('history-bar-container');
                const toggleIcon = document.getElementById('history-toggle-icon');
                
                console.log('🔍 Elements found:');
                console.log('  - Toggle button:', !!toggleBtn);
                console.log('  - History bar container:', !!historyBarContainer);
                console.log('  - Toggle icon:', !!toggleIcon);
                
                if (toggleBtn && historyBarContainer && toggleIcon) {
                    // Test current state
                    const isVisible = !historyBarContainer.classList.contains('hidden') && 
                                    historyBarContainer.style.display !== 'none' && 
                                    historyBarContainer.offsetHeight > 0;
                    
                    console.log('📊 Current state:', isVisible ? 'Visible' : 'Hidden');
                    console.log('🔍 CSS classes:', historyBarContainer.className);
                    console.log('🔍 Inline styles:', historyBarContainer.style.display);
                    console.log('🔍 Offset height:', historyBarContainer.offsetHeight);
                    
                    // Test toggle functionality
                    console.log('🧪 Testing toggle function...');
                    toggleHistoryBarSimple();
                    
                    // Check new state after toggle
                    setTimeout(() => {
                        const newState = !historyBarContainer.classList.contains('hidden') && 
                                       historyBarContainer.style.display !== 'none' && 
                                       historyBarContainer.offsetHeight > 0;
                        
                        console.log('📊 New state after toggle:', newState ? 'Visible' : 'Hidden');
                        console.log('✅ Toggle test completed');
                    }, 100);
                    
                } else {
                    console.error('❌ Required elements not found for testing');
                }
                
                return {
                    isMobile: isMobileDevice,
                    elementsFound: {
                        toggleBtn: !!toggleBtn,
                        historyBarContainer: !!historyBarContainer,
                        toggleIcon: !!toggleIcon
                    }
                };
                
            } catch (error) {
                console.error('❌ Error testing mobile history bar:', error);
                return null;
            }
        };
        
        // Fonction utilitaire pour afficher les informations détaillées du stockage
        window.showStorageInfo = async function() {
            try {
                const capacityInfo = await checkStorageCapacity();
                const info = `
📊 INFORMATIONS DÉTAILLÉES DU STOCKAGE :

🔢 Nombre de snapshots : ${capacityInfo.count}
💾 Espace utilisé : ${(capacityInfo.currentSize / 1024 / 1024).toFixed(2)} MB
📦 Capacité totale : ${(capacityInfo.maxSize / 1024 / 1024).toFixed(0)} MB
📈 Pourcentage utilisé : ${capacityInfo.usagePercentage.toFixed(1)}%

${capacityInfo.needsCleanup ? 
    `⚠️ NETTOYAGE RECOMMANDÉ : Garder ${capacityInfo.target} snapshots pour libérer de l'espace` : 
    `✅ Stockage en bon état - Aucun nettoyage nécessaire`
}

🧹 Fonctions disponibles :
- window.forceStorageCleanup() : Nettoyage manuel
- window.monitorStorageHealth() : Vérification de santé
- window.checkStorageCapacity() : Vérification de capacité
                `;
                
                console.log(info);
                if (typeof showMessage === 'function') {
                    showMessage('📊 Informations du stockage affichées dans la console', 'info');
                }
                
            } catch (error) {
                console.error('❌ Error showing storage info:', error);
            }
        };
        window.enableTableEditing = enableTableEditing;
        window.updateHistoryNavigation = updateHistoryNavigation;
        window.updateSnapshotBanner = updateSnapshotBanner;
        window.updateHistoryDateButton = updateHistoryDateButton;
        window.fetchInitialData = fetchInitialData;
        window.handleRealtimeUpdate = handleRealtimeUpdate;
        window.markEdited = markEdited;
        window.updateGlobalFocusState = updateGlobalFocusState;
        window.saveModifiedCell = saveModifiedCell; // Excel-like save function
        window.isRestoringCursor = function() { return isRestoringCursor; }; // For debugging
        window.debugCursorRestoration = function() {
            console.log('🔍 Cursor Restoration Debug Info:');
            console.log('  - isRestoringCursor:', isRestoringCursor);
            console.log('  - isExcelSaveInProgress:', isExcelSaveInProgress);
            console.log('  - capturedFocusState:', window.capturedFocusState);
            console.log('  - Current active element:', document.activeElement);
            console.log('  - isDirty:', isDirty);
            console.log('  - isTyping:', isTyping);
            console.log('  - Focus protection window:', window.capturedFocusState?.timestamp ? `${Date.now() - window.capturedFocusState.timestamp}ms ago` : 'none');
            return {
                isRestoringCursor,
                isExcelSaveInProgress,
                capturedFocusState: window.capturedFocusState,
                activeElement: document.activeElement,
                isDirty,
                isTyping,
                focusProtectionAge: window.capturedFocusState?.timestamp ? Date.now() - window.capturedFocusState.timestamp : null
            };
        };
        
        // Debug function to test realtime sync with cursor preservation
        window.testRealtimeWithCursor = function() {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.tagName === 'TD' && activeElement.contentEditable === 'true') {
                console.log('🧪 Testing realtime sync with cursor preservation...');
                
                // Simulate a realtime update by calling the handler directly
                setTimeout(() => {
                    console.log('🔄 Simulating realtime update...');
                    if (typeof window.handleRealtimeUpdate === 'function') {
                        window.handleRealtimeUpdate({
                            event: 'UPDATE',
                            table: 'staffTable',
                            record: { id: 'test' }
                        });
                    }
                }, 1000);
            } else {
                console.log('❌ Please select a cell first and place cursor in it');
            }
        };
        
        // Debug function to test Excel-like autosave behavior
        window.testExcelSave = function() {
            console.log('🧪 Testing Excel-like autosave behavior...');
            console.log('📋 Instructions:');
            console.log('  1. Click on a cell and type some text');
            console.log('  2. Press Tab or click another cell to move away');
            console.log('  3. Save should trigger automatically on blur');
            console.log('  4. While typing, no timer-based saves should occur');
            console.log('');
            console.log('🔍 Current state:');
            console.log('  - isDirty:', isDirty);
            console.log('  - isTyping:', isTyping);
            console.log('  - Active element:', document.activeElement?.getAttribute?.('data-label') || 'none');
            
            // Add temporary event listener to track blur events
            document.addEventListener('blur', function testBlurListener(e) {
                if (e.target && e.target.tagName === 'TD' && e.target.contentEditable === 'true') {
                    console.log('👁️ BLUR detected on cell:', e.target.getAttribute('data-label'));
                    // Remove listener after first test
                    document.removeEventListener('blur', testBlurListener, true);
                }
            }, true);
        };
        
        window.loadTableData = loadTableData;
        
        // Debug function to test cursor restoration
        window.testCursorRestoration = function() {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.tagName === 'TD' && activeElement.contentEditable === 'true') {
                console.log('🧪 Testing cursor restoration...');
                
                // Capture current state
                updateGlobalFocusState({
                    element: activeElement,
                    position: getCaretOffsetWithin(activeElement),
                    timestamp: Date.now(),
                    rowIndex: Array.from(activeElement.closest('tr').parentNode.querySelectorAll('tr')).indexOf(activeElement.closest('tr')),
                    colLabel: activeElement.getAttribute('data-label') || ''
                });
                
                console.log('📝 Captured:', window.capturedFocusState);
                
                // Blur and then restore after 2 seconds
                activeElement.blur();
                setTimeout(() => {
                    console.log('🔄 Restoring cursor...');
                    isRestoringCursor = true; // Set flag during test restoration
                    
                    if (window.capturedFocusState) {
                        const tbody = document.querySelector('#data-table tbody');
                        const rows = tbody.querySelectorAll('tr');
                        if (rows[window.capturedFocusState.rowIndex]) {
                            const row = rows[window.capturedFocusState.rowIndex];
                            const targetElement = row.querySelector(`td[data-label="${window.capturedFocusState.colLabel}"]`);
                            if (targetElement) {
                                targetElement.focus();
                                setCaretAt(targetElement, window.capturedFocusState.position);
                                console.log('✅ Cursor restoration test completed');
                                
                                // Clear flag after test
                                setTimeout(() => {
                                    isRestoringCursor = false;
                                    console.log('🔓 Test restoration flag cleared');
                                }, 1000);
                            }
                        }
                    }
                }, 2000);
            } else {
                console.log('❌ Please select a cell first');
            }
        };
        window.showMessage = showMessage;
        window.closeImageViewer = closeImageViewer;
        window.nextImage = nextImage;
        window.previousImage = previousImage;
        window.deleteImage = deleteImage;
        window.deleteAllImagesForPatient = deleteAllImagesForPatient;
        window.syncPendingImages = syncPendingImages;
        window.loadImagesFromSupabase = loadImagesFromSupabase;
        window.updateAllImageColumnIcons = updateAllImageColumnIcons;

        // Fonction pour ouvrir la galerie simple
        function openSimpleGallery() {
            window.open('simple-gallery.html', '_blank', 'width=1200,height=800,scrollbars=yes,resizable=yes');
        }
        
        // Exposer la fonction globalement
        window.openSimpleGallery = openSimpleGallery;
        window.setupMobileViewport = setupMobileViewport;
        window.setupExtendedKeyboardShortcuts = setupExtendedKeyboardShortcuts;
        window.initializeApp = initializeApp;
        window.adaptStatusDisplay = adaptStatusDisplay;
        window.getCurrentStatusType = getCurrentStatusType;
        window.applyDotColor = applyDotColor;

        // Raccourcis clavier étendus

        
        function setupMobileViewport() {
            // Gérer la hauteur dynamique du viewport sur mobile
            function updateViewportHeight() {
                if (window.innerWidth <= 768) {
                    const vh = window.innerHeight * 0.01;
                    document.documentElement.style.setProperty('--vh', `${vh}px`);
                    
                    // Ajuster la hauteur du conteneur principal
                    const tableContainer = document.getElementById('table-container');
                    if (tableContainer) {
                        tableContainer.style.height = `${window.innerHeight}px`;
                        tableContainer.style.minHeight = `${window.innerHeight}px`;
                    }
                    
                    // Ajuster la position du bouton FAB pour éviter la barre de navigation
                    const fabButton = document.getElementById('fab-add');
                    if (fabButton) {
                        const bottomOffset = Math.max(16, window.innerHeight - window.visualViewport.height + 16);
                        fabButton.style.bottom = `${bottomOffset}px`;
                        
                        // Sur mobile, positionner le bouton plus discrètement
                        if (window.innerWidth <= 768) {
                            fabButton.style.right = '12px';
                            fabButton.style.bottom = `${Math.max(12, bottomOffset - 4)}px`;
                        }
                    }
                }
            }
            
            // Mettre à jour lors du redimensionnement
            window.addEventListener('resize', updateViewportHeight);
            window.addEventListener('orientationchange', updateViewportHeight);
            
            // Mettre à jour lors du changement de la barre de navigation mobile
            if ('visualViewport' in window) {
                window.visualViewport.addEventListener('resize', updateViewportHeight);
            }
            
            // Mise à jour initiale
            updateViewportHeight();
            
            // Mettre à jour périodiquement pour s'assurer de la synchronisation
            setInterval(updateViewportHeight, 1000);
        }
        
        function ensureMobileButtonVisibility() {
            // Ensure button bar is visible on mobile devices
            function checkAndFixButtonVisibility() {
                const buttonBar = document.getElementById('button-bar');
                if (!buttonBar) return;
                
                if (window.innerWidth <= 768) {
                    // Force mobile styling
                    buttonBar.style.display = 'flex';
                    buttonBar.style.visibility = 'visible';
                    buttonBar.style.opacity = '1';
                    buttonBar.style.position = 'relative';
                    buttonBar.style.top = 'auto';
                    buttonBar.style.right = 'auto';
                    buttonBar.style.left = '0';
                    buttonBar.style.width = '100%';
                    buttonBar.style.margin = '0.5rem 0';
                    buttonBar.style.padding = '0.5rem';
                    buttonBar.style.backgroundColor = 'rgba(249, 250, 251, 0.95)';
                    buttonBar.style.border = '1px solid #e5e7eb';
                    buttonBar.style.borderRadius = '0.5rem';
                    buttonBar.style.justifyContent = 'center';
                    buttonBar.style.flexWrap = 'wrap';
                    buttonBar.style.gap = '0.5rem';
                    buttonBar.style.zIndex = '20';
                    
                    // Ensure all buttons are visible
                    const buttons = buttonBar.querySelectorAll('button');
                    buttons.forEach(button => {
                        button.style.display = 'flex';
                        button.style.visibility = 'visible';
                        button.style.opacity = '1';
                        button.style.minWidth = '44px';
                        button.style.minHeight = '44px';
                        button.style.transform = 'scale(1.4)';
                    });
                    
                    console.log('📱 Mobile button visibility enforced');
                }
            }
            
            // Check on load
            checkAndFixButtonVisibility();
            
            // Check on resize
            window.addEventListener('resize', checkAndFixButtonVisibility);
            
            // Check on orientation change
            window.addEventListener('orientationchange', checkAndFixButtonVisibility);
            
            // Check periodically
            setInterval(checkAndFixButtonVisibility, 2000);
        }
        
        function setupExtendedKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Seulement appliquer les raccourcis quand pas dans les champs de formulaire
                const active = document.activeElement;
                const inFormField = active && (
                    active.tagName === 'INPUT' || 
                    active.tagName === 'TEXTAREA' || 
                    active.tagName === 'SELECT' || 
                    active.contentEditable === 'true'
                );

                // Ignorer les raccourcis si dans les champs de formulaire
                if (inFormField) return;

                // G: Ouvrir galerie
                if (!e.ctrlKey && !e.metaKey && !e.altKey && (e.key === 'g' || e.key === 'G')) {
                    e.preventDefault();
                    openSimpleGallery();
                    return;
                }

                // N: Ajouter nouvelle ligne
                if (!e.ctrlKey && !e.metaKey && !e.altKey && (e.key === 'n' || e.key === 'N')) {
                    e.preventDefault();
                    if (typeof addRow === 'function') {
                        addRow();
                    }
                    return;
                }

                // Supprimer: Supprimer lignes sélectionnées
                if (e.key === 'Delete') {
                    e.preventDefault();
                    
                    // Empêcher la suppression dans les snapshots
                    if (snapshotMode === 'snapshot') {
                        showMessage('Impossible de supprimer des lignes dans un snapshot. Retournez aux données en direct pour modifier le tableau.', 'warning');
                        return;
                    }
                    
                    // Récupérer les lignes sélectionnées
                    const selectedRows = Array.from(document.querySelectorAll('#table-body tr.selected-row'));
                    if (selectedRows.length > 0) {
                        promptKeyConfirm(`Supprimer ${selectedRows.length} ligne(s) ?`, () => deleteRows(selectedRows));
                    } else {
                        // Si aucune ligne sélectionnée, essayer de supprimer la ligne active
                        const activeRow = document.querySelector('#table-body tr:focus') || document.querySelector('#table-body tr.selected-row');
                        if (activeRow) {
                            promptKeyConfirm('Appuyez sur Entrée pour supprimer cette ligne, Échap pour annuler.', () => deleteRows([activeRow]));
                        }
                    }
                    return;
                }

                // Échap: Fermer modales
                if (e.key === 'Escape') {
                    const confirmationModal = document.getElementById('confirmation-modal');
                    if (confirmationModal && !confirmationModal.classList.contains('hidden')) {
                        confirmationModal.classList.add('hidden');
                        return;
                    }
                }
            });
        }

        // Initialiser les raccourcis clavier étendus
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize performance optimizations first
            domCache.init();
            eventManager.initTableEvents();
            
            // Performance monitoring
            eventManager.monitor.mark('dom-ready');
            
            // Cleanup on page unload to prevent memory leaks
            window.addEventListener('beforeunload', () => {
                eventManager.cleanup();
                dataCache.data = null; // Clear data cache
                console.log('🧹 Performance optimizations cleaned up');
            });
            
            setupExtendedKeyboardShortcuts();
            
            // Adapter l'affichage du statut selon la taille d'écran initiale
            setTimeout(() => {
                adaptStatusDisplay();
            }, 100);
            
                    // Setup mobile viewport management
        setupMobileViewport();
        
        // Ensure button bar is visible on mobile
        ensureMobileButtonVisibility();
        
        // Debug button bar on mobile
        setTimeout(() => {
            if (window.innerWidth <= 768) {
                const buttonBar = document.getElementById('button-bar');
                if (buttonBar) {
                    console.log('📱 Button bar found:', buttonBar);
                    console.log('📱 Button bar display:', window.getComputedStyle(buttonBar).display);
                    console.log('📱 Button bar visibility:', window.getComputedStyle(buttonBar).visibility);
                    console.log('📱 Button bar position:', window.getComputedStyle(buttonBar).position);
                    console.log('📱 Button bar top:', window.getComputedStyle(buttonBar).top);
                    console.log('📱 Button bar right:', window.getComputedStyle(buttonBar).right);
                    console.log('📱 Button bar width:', window.getComputedStyle(buttonBar).width);
                    console.log('📱 Button bar height:', window.getComputedStyle(buttonBar).height);
                    console.log('📱 Button bar z-index:', window.getComputedStyle(buttonBar).zIndex);
                    
                    const buttons = buttonBar.querySelectorAll('button');
                    console.log('📱 Number of buttons found:', buttons.length);
                    buttons.forEach((btn, index) => {
                        console.log(`📱 Button ${index + 1}:`, btn.textContent || btn.innerHTML, 'Display:', window.getComputedStyle(btn).display);
                    });
                } else {
                    console.log('❌ Button bar not found!');
                }
            }
        }, 1000);
        });

        // Initialize when DOM is ready
        window.addEventListener('load', initializeApp);

        // ========================================
        // SUPPORT TACTILE MOBILE - BOUTON +
        // ========================================
        
        // Gestion des événements tactiles pour mobile - SOLUTION RECOMMANDÉE
        function addTouchSupport() {
            const addButton = document.querySelector('.add-snapshot-btn, .btn-add-snapshot, button[onclick*="createManualSnapshot"], .fa-plus, [class*="add"], [class*="plus"]');
            
            if (addButton) {
                console.log('🔍 Bouton trouvé:', addButton);
                
                // Supprimer les anciens événements pour éviter les doublons
                addButton.removeEventListener('click', handleButtonClick);
                addButton.removeEventListener('touchstart', handleTouchStart);
                addButton.removeEventListener('touchend', handleTouchEnd);
                
                // Gestion des clics (PC)
                addButton.addEventListener('click', handleButtonClick);
                
                // Gestion des événements tactiles (Mobile)
                addButton.addEventListener('touchstart', handleTouchStart);
                addButton.addEventListener('touchend', handleTouchEnd);
                
                console.log('✅ Événements tactiles ajoutés au bouton');
            } else {
                console.log('❌ Bouton non trouvé, recherche alternative...');
                // Recherche alternative
                const alternativeButtons = document.querySelectorAll('button, .btn, [onclick], .fa-plus, [class*="add"]');
                console.log('🔍 Boutons alternatifs trouvés:', alternativeButtons);
                
                alternativeButtons.forEach(btn => {
                    if (btn.textContent.includes('+') || btn.innerHTML.includes('+') || btn.className.includes('add') || btn.className.includes('plus')) {
                        console.log('🎯 Bouton alternatif identifié:', btn);
                        addTouchEventsToButton(btn);
                    }
                });
            }
        }

        // Gestionnaire de clic
        function handleButtonClick(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('✅ Clic détecté sur le bouton');
            openSnapshotBar();
        }

        // Gestionnaire de touch start
        function handleTouchStart(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log(' Touch start détecté');
        }

        // Gestionnaire de touch end
        function handleTouchEnd(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('📱 Touch end détecté');
            
            // Petit délai pour éviter les doubles déclenchements
            setTimeout(() => {
                openSnapshotBar();
            }, 100);
        }

        // Fonction pour ajouter les événements à un bouton
        function addTouchEventsToButton(button) {
            button.addEventListener('click', handleButtonClick);
            button.addEventListener('touchstart', handleTouchStart);
            button.addEventListener('touchend', handleTouchEnd);
            console.log('✅ Événements tactiles ajoutés au bouton alternatif');
        }

        // Fonction pour ouvrir la barre de snapshot (à adapter selon votre code)
        function openSnapshotBar() {
            console.log('🚀 Ouverture de la barre de snapshot...');
            
            // Si vous avez une fonction existante, appelez-la
            if (typeof createManualSnapshot === 'function') {
                console.log('✅ Appel de createManualSnapshot');
                createManualSnapshot();
            } else if (typeof showSnapshotModal === 'function') {
                console.log('✅ Appel de showSnapshotModal');
                showSnapshotModal();
            } else if (typeof toggleSnapshotBar === 'function') {
                console.log('✅ Appel de toggleSnapshotBar');
                toggleSnapshotBar();
            } else {
                console.log('⚠️ Aucune fonction de snapshot trouvée, création d\'une fonction par défaut');
                createDefaultSnapshotBar();
            }
        }

        // Fonction par défaut si aucune fonction n'existe
        function createDefaultSnapshotBar() {
            console.log('🔧 Création d\'une barre de snapshot par défaut...');
            
            // Créer une barre de snapshot simple
            const snapshotBar = document.createElement('div');
            snapshotBar.id = 'defaultSnapshotBar';
            snapshotBar.style.cssText = `
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: white;
                border-top: 2px solid #007bff;
                padding: 20px;
                z-index: 10000;
                box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
                transform: translateY(100%);
                transition: transform 0.3s ease;
            `;
            
            snapshotBar.innerHTML = `
                <h3>Créer un Snapshot</h3>
                <p>Fonctionnalité de snapshot en cours de développement...</p>
                <button onclick="this.parentElement.style.transform='translateY(100%)'" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px;">
                    Fermer
                </button>
            `;
            
            document.body.appendChild(snapshotBar);
            
            // Afficher la barre
            setTimeout(() => {
                snapshotBar.style.transform = 'translateY(0)';
            }, 100);
        }

        // Fonction de débogage pour mobile
        function debugMobileButton() {
            console.log('🔍 === DÉBOGAGE MOBILE ===');
            
            const addButton = document.querySelector('.add-snapshot-btn, .btn-add-snapshot, button[onclick*="createManualSnapshot"], .fa-plus, [class*="add"], [class*="plus"]');
            
            if (addButton) {
                console.log('🔍 Bouton trouvé:', addButton);
                console.log('📱 Bouton visible:', addButton.offsetParent !== null);
                console.log('📏 Dimensions:', addButton.offsetWidth, 'x', addButton.offsetHeight);
                console.log('📍 Position:', addButton.offsetLeft, addButton.offsetTop);
                console.log('🎯 Z-index:', window.getComputedStyle(addButton).zIndex);
                console.log('📱 Classes:', addButton.className);
                console.log(' HTML:', addButton.outerHTML);
            } else {
                console.log('❌ Bouton non trouvé');
                
                // Recherche de tous les boutons
                const allButtons = document.querySelectorAll('button, .btn, [onclick]');
                console.log('🔍 Tous les boutons trouvés:', allButtons.length);
                
                allButtons.forEach((btn, index) => {
                    console.log(` Bouton ${index}:`, {
                        text: btn.textContent,
                        classes: btn.className,
                        onclick: btn.onclick,
                        html: btn.outerHTML
                    });
                });
            }
        }

        // Initialisation au chargement de la page
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 Initialisation du support tactile mobile...');
            
            // Attendre un peu que la page soit complètement chargée
            setTimeout(() => {
                addTouchSupport();
                debugMobileButton();
            }, 500);
            
            // Réessayer après un délai plus long (au cas où)
            setTimeout(() => {
                addTouchSupport();
            }, 2000);
        });

        // Réinitialiser lors des changements de contenu
        if (typeof MutationObserver !== 'undefined') {
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        // Vérifier si de nouveaux boutons ont été ajoutés
                        setTimeout(addTouchSupport, 100);
                    }
                });
            });
            
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        }

        // ========================================
        // FIN DU SUPPORT TACTILE MOBILE
        // ========================================
        
        // ========================================
        // FONCTIONS DE RÉACTIVATION REALTIME
        // ========================================
        
        // Function to manually reactivate realtime sync
        window.reactivateRealtimeSync = function() {
            console.log('🔄 Manually reactivating realtime sync...');
            try {
                // Check current state
                const currentMode = window.snapshotMode || 'unknown';
                const hasRealtimeSub = !!window.realtimeSubscription;
                
                console.log('📊 Current state:', {
                    mode: currentMode,
                    hasRealtimeSub: hasRealtimeSub,
                    currentSnapshotDate: window.currentSnapshotDate
                });
                
                // Force return to live mode if in snapshot mode
                if (currentMode === 'snapshot') {
                    console.log('🔄 Currently in snapshot mode, returning to live mode...');
                    if (typeof window.returnToToday === 'function') {
                        window.returnToToday();
                        return 'Returning to live mode...';
                    } else {
                        console.log('⚠️ returnToToday function not available');
                        // Fallback: manually reset state
                        window.snapshotMode = 'live';
                        window.currentSnapshotDate = null;
                        window.currentSnapshotIndex = -1;
                        console.log('✅ Manually reset to live mode');
                    }
                }
                
                // Reactivate realtime subscription
                console.log('🔄 Setting up realtime subscription...');
                if (typeof window.setupRealtimeSubscription === 'function') {
                    window.setupRealtimeSubscription();
                    console.log('✅ Realtime subscription setup called');
                } else {
                    console.log('⚠️ setupRealtimeSubscription function not available');
                    // Fallback: try to create subscription manually
                    if (window.supabase) {
                        console.log('🔄 Creating manual realtime subscription...');
                        try {
                            window.realtimeSubscription = window.supabase.channel('table-changes')
                                .on('postgres_changes', { 
                                    event: 'INSERT', 
                                    schema: 'public', 
                                    table: 'staffTable' 
                                }, (payload) => {
                                    console.log('🔄 INSERT:', payload);
                                    if (typeof window.fetchInitialData === 'function') {
                                        setTimeout(() => window.fetchInitialData(), 1000);
                                    }
                                })
                                .on('postgres_changes', { 
                                    event: 'UPDATE', 
                                    schema: 'public', 
                                    table: 'staffTable' 
                                }, (payload) => {
                                    console.log('🔄 UPDATE:', payload);
                                    if (typeof window.fetchInitialData === 'function') {
                                        setTimeout(() => window.fetchInitialData(), 1000);
                                    }
                                })
                                .on('postgres_changes', { 
                                    event: 'DELETE', 
                                    schema: 'public', 
                                    table: 'staffTable' 
                                }, (payload) => {
                                    console.log('🔄 DELETE:', payload);
                                    if (typeof window.fetchInitialData === 'function') {
                                        setTimeout(() => window.fetchInitialData(), 1000);
                                    }
                                })
                                .subscribe();
                            console.log('✅ Manual realtime subscription created');
                        } catch (error) {
                            console.error('❌ Error creating manual subscription:', error);
                        }
                    }
                }
                
                console.log('✅ Realtime sync reactivated');
                if (typeof window.showMessage === 'function') {
                    window.showMessage('Synchronisation temps réel réactivée', 'success');
                }
                
                return 'Realtime sync reactivated successfully';
            } catch (error) {
                console.error('❌ Error reactivating realtime sync:', error);
                if (typeof window.showMessage === 'function') {
                    window.showMessage('Erreur lors de la réactivation', 'error');
                }
                return 'Error: ' + error.message;
            }
        };
        
        // Function to check realtime sync status
        window.checkRealtimeStatus = function() {
            console.log('🔍 Checking realtime sync status...');
            
            const status = {
                realtimeSubscription: window.realtimeSubscription,
                snapshotMode: window.snapshotMode || 'unknown',
                currentSnapshotDate: window.currentSnapshotDate,
                hasSupabase: !!window.supabase,
                hasSetupFunction: typeof window.setupRealtimeSubscription === 'function',
                hasReturnFunction: typeof window.returnToToday === 'function'
            };
            
            console.log('📊 Status details:', status);
            
            if (window.realtimeSubscription) {
                console.log('✅ Realtime sync is active');
                if (typeof window.showMessage === 'function') {
                    window.showMessage('Synchronisation temps réel active', 'success');
                }
                return 'ACTIVE';
            } else {
                console.log('❌ Realtime sync is inactive');
                console.log('🔍 Possible reasons:');
                console.log('   - In snapshot mode:', status.snapshotMode === 'snapshot');
                console.log('   - Supabase client:', status.hasSupabase);
                console.log('   - Setup function:', status.hasSetupFunction);
                
                if (typeof window.showMessage === 'function') {
                    window.showMessage('Synchronisation temps réel inactive', 'info');
                }
                return 'INACTIVE';
            }
        };
        
        // ========================================
        // FIN DES FONCTIONS DE RÉACTIVATION
        // ========================================
        
        console.log('✅ Enhanced Excel-like save and realtime sync protection initialized');
        console.log('🛡️ Multi-level protection system active:');
        console.log('   Level 1: Local save blocking');
        console.log('   Level 2: Cursor restoration protection');
        console.log('   Level 3: Excel save process blocking');
        console.log('   Level 4: Excel save protection window (6s)');
        console.log('   Level 5: General focus protection (3s)');
        console.log('   Level 6: Active typing detection');
        console.log('🧪 Debug functions available: debugCursorRestoration(), testExcelSaveWithRealtime(), testRealtimeWithCursor(), testProtectionLevels()');
    </script>
</body>
</html>