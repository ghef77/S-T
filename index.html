<!DOCTYPE html>
<html lang='fr'>
<head>
    <meta charset='UTF-8'>
    <!-- Enhanced viewport for iOS and Android devices -->
    <meta name='viewport' content='width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no, shrink-to-fit=no'>
    
    <!-- Professional healthcare application meta tags -->
    <meta name='description' content='Application sécurisée de gestion du personnel hospitalier - Système de tableau de bord médical'>
    <meta name='keywords' content='hôpital, personnel médical, gestion hospitalière, tableau de bord santé, application médicale'>
    <meta name='author' content='Georges Bassil - Healthcare IT Solutions'>
    <meta name='robots' content='noindex, nofollow'>
    
    <!-- Security and Privacy Headers -->
    <meta http-equiv='X-Content-Type-Options' content='nosniff'>
    <meta http-equiv='X-XSS-Protection' content='1; mode=block'>
    <meta http-equiv='Referrer-Policy' content='strict-origin-when-cross-origin'>
    <meta http-equiv='Permissions-Policy' content='geolocation=(), microphone=(), camera=()'>
    
    <!-- Content Security Policy - Updated to allow required CDN resources -->
    <meta http-equiv='Content-Security-Policy' content="default-src 'self' https:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.tailwindcss.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com; connect-src 'self' https://*.supabase.co wss://*.supabase.co; img-src 'self' data: https:; font-src 'self' https: data:;">
    
    <!-- iOS specific meta tags -->
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-status-bar-style' content='default'>
    <meta name='apple-mobile-web-app-title' content='Gestion Personnel Hospitalier'>
    
    <!-- Android specific meta tags -->
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='theme-color' content='#15803d'>
    <meta name='msapplication-TileColor' content='#15803d'>
    
    <!-- Professional application title -->
    <title>Système de Gestion Personnel Hospitalier - Application Sécurisée</title>
    
    <!-- Favicon and App Icons -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iOCIgZmlsbD0idXJsKCNncmFkaWVudDAiLz4KPHRleHQgeD0iNTAlIiB5PSI1NSUiIGRvbWluYW50LWJhc2VsaW5lPSJjZW50cmFsIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSJ3aGl0ZSIgZm9udC1mYW1pbHk9IkludGVyLCBzYW5zLXNlcmlmIiBmb250LXdlaWdodD0iYm9sZCIgZm9udC1zaXplPSIxMiI+U1Q8L3RleHQ+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9ImdyYWRpZW50MCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMTAwJSI+CjxzdG9wIHN0b3AtY29sb3I9IiMxNmEzNGEiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMTU4MDNkIi8+CjwvbGluZWFyR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+">
    <link rel="apple-touch-icon" sizes="180x180" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTgwIiBoZWlnaHQ9IjE4MCIgdmlld0JveD0iMCAwIDE4MCAxODAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxODAiIGhlaWdodD0iMTgwIiByeD0iNDAiIGZpbGw9InVybCgjZ3JhZGllbnQwKSIvPgo8dGV4dCB4PSI1MCUiIHk9IjU1JSIgZG9taW5hbnQtYmFzZWxpbmU9ImNlbnRyYWwiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGZpbGw9IndoaXRlIiBmb250LWZhbWlseT0iSW50ZXIsIHNhbnMtc2VyaWYiIGZvbnQtd2VpZ2h0PSJib2xkIiBmb250LXNpemU9IjY4Ij5TVDwvdGV4dD4KPGRlZnM+CjxsaW5lYXJHcmFkaWVudCBpZD0iZ3JhZGllbnQwIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIxMDAlIj4KPHN0b3Agc3RvcC1jb2xvcj0iIzE2YTM0YSIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMxNTgwM2QiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4=">
    
    <!-- Preload critical resources -->
    <link rel="preload" href="https://cdn.tailwindcss.com" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm" as="script">
    
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    

    
    <style>
        /* Enhanced CSS Variables with iOS/Android Safe Area Support */
        :root {
            --primary-color: #15803d;
            --primary-hover: #16a34a;
            --primary-light: #86efac;
            --secondary-color: #3b82f6;
            --secondary-hover: #2563eb;
            --danger-color: #dc2626;
            --danger-hover: #b91c1c;
            --success-color: #16a34a;
            --warning-color: #eab308;
            --border-color: #e5e7eb;
            --border-focus: #3b82f6;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --bg-primary: #ffffff;
            --bg-secondary: #f9fafb;
            --bg-hover: #f3f4f6;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1);
            --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            
            /* Performance optimizations */
            --gpu-acceleration: translateZ(0);
            --will-change-transform: transform;
            --will-change-scroll: scroll-position;
            
            /* iOS/Android Safe Area Variables */
            --safe-area-top: env(safe-area-inset-top, 0px);
            --safe-area-right: env(safe-area-inset-right, 0px);
            --safe-area-bottom: env(safe-area-inset-bottom, 0px);
            --safe-area-left: env(safe-area-inset-left, 0px);
            
            /* Dynamic viewport height for mobile browsers */
            --vh: 1vh;
            --dynamic-vh: calc(var(--vh, 1vh) * 100);
        }

        /* Enhanced base styles with iOS/Android viewport adaptation */
        body { 
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif; 
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.6;
            /* Performance optimizations */
            contain: layout style paint;
            will-change: var(--will-change-scroll);
            transform: var(--gpu-acceleration);
            /* iOS/Android viewport adaptation */
            min-height: var(--dynamic-vh);
            padding-top: var(--safe-area-top);
            padding-left: var(--safe-area-left);
            padding-right: var(--safe-area-right);
            padding-bottom: var(--safe-area-bottom);
            /* Prevent horizontal overflow */
            overflow-x: hidden;
            /* Ensure proper mobile rendering */
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }
        
        /* iOS/Android Safe Area Container */
        .safe-area-container {
            min-height: calc(100vh - var(--safe-area-top) - var(--safe-area-bottom));
            padding-top: max(var(--safe-area-top), 0px);
            padding-left: max(var(--safe-area-left), 0px);
            padding-right: max(var(--safe-area-right), 0px);
            padding-bottom: max(var(--safe-area-bottom), 0px);
        }
        
        /* Enhanced viewport handling for mobile devices */
        @supports (padding: max(0px)) {
            body {
                padding-top: max(var(--safe-area-top), 0px);
                padding-left: max(var(--safe-area-left), 0px);
                padding-right: max(var(--safe-area-right), 0px);
                padding-bottom: max(var(--safe-area-bottom), 0px);
            }
        }
        
        /* iOS Device Specific Adaptations */
        @supports (-webkit-touch-callout: none) {
            body {
                /* iOS Safari specific viewport handling */
                padding-top: max(calc(var(--safe-area-top) + 20px), 20px);
                min-height: -webkit-fill-available;
            }
            
            /* iOS status bar height compensation */
            .flex.items-center.gap-2.mb-1,
            #button-bar,
            #table-container {
                margin-top: max(calc(var(--safe-area-top) + 1rem), 1rem);
            }
        }
        
        /* Android Device Specific Adaptations */
        @media screen and (-webkit-min-device-pixel-ratio: 1) {
            body {
                /* Android Chrome specific viewport handling */
                padding-top: max(calc(var(--safe-area-top) + 16px), 16px);
            }
        }
        
        /* Mobile Device Viewport Height Fix */
        @media screen and (max-width: 768px) {
            body {
                min-height: 100vh;
                min-height: -webkit-fill-available;
                min-height: -moz-available;
                min-height: stretch;
            }
            
            /* Ensure top elements are above navigation bars */
            .flex.items-center.gap-2.mb-1,
            #button-bar,
            #table-container {
                position: relative;
                z-index: 10;
                margin-top: max(calc(var(--safe-area-top) + 1.5rem), 1.5rem);
            }
            
            /* Enhanced button bar hiding on mobile when login is visible */
            #login-container:not(.hidden) ~ #table-container #button-bar {
                display: none !important;
                opacity: 0 !important;
                visibility: hidden !important;
                pointer-events: none !important;
                position: absolute !important;
                left: -9999px !important;
                top: -9999px !important;
            }
            
            /* Hide button bar completely on mobile password page */
            #login-container:not(.hidden) ~ * #button-bar {
                display: none !important;
            }
        }
        
        /* Enhanced table styles with iOS/Android safe area support */
        #data-table { 
            border-collapse: collapse; 
            border-spacing: 0; 
            margin-bottom: 50px; 
            width: 100%; 
            background-color: var(--bg-primary);
            box-shadow: var(--shadow-md);
            border-radius: 0.5rem;
            font-size: 0.875rem; /* Consistent font size */
            /* Performance optimizations */
            contain: layout;
            will-change: var(--will-change-scroll);
            transform: var(--gpu-acceleration);
        }
        
        /* Top-level container safe area handling */
        #table-container {
            margin-top: max(calc(var(--safe-area-top) + 1rem), 1rem);
            padding-top: max(var(--safe-area-top), 0px);
        }
        
        /* Status indicators safe area positioning */
        .flex.items-center.gap-2.mb-1 {
            margin-top: max(calc(var(--safe-area-top) + 0.5rem), 0.5rem);
            padding-top: max(var(--safe-area-top), 0px);
        }
        
        /* Function button bar safe area positioning */
        #button-bar {
            margin-top: max(calc(var(--safe-area-top) + 0.5rem), 0.5rem);
            top: max(calc(var(--safe-area-top) + 8px), 8px) !important;
        }
        
        /* Hide button bar when login container is visible */
        #login-container:not(.hidden) ~ #table-container #button-bar,
        #login-container:not(.hidden) + #button-bar {
            display: none !important;
            opacity: 0 !important;
            visibility: hidden !important;
            pointer-events: none !important;
        }
        
        /* Alternative approach: Hide button bar when login is active */
        body:has(#login-container:not(.hidden)) #button-bar {
            display: none !important;
            opacity: 0 !important;
            visibility: hidden !important;
            pointer-events: none !important;
        }
        
        #data-table th, #data-table td { 
            border: 1px solid var(--border-color); 
            transition: var(--transition);
            padding: 0.75rem 0.5rem; /* Consistent padding */
            text-align: left;
            vertical-align: middle;
            /* Optimize cell rendering */
            contain: layout style;
        }
        
        #data-table thead { 
            position: sticky !important; 
            top: 0 !important; 
            z-index: 100 !important; 
            background-color: var(--primary-color) !important;
            color: white !important;
            font-weight: 600 !important;
            text-transform: uppercase !important;
            letter-spacing: 0.05em !important;
            /* Optimized performance */
            will-change: var(--will-change-transform) !important;
            transform: var(--gpu-acceleration) !important;
            contain: layout style paint !important;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15) !important;
            border-bottom: 3px solid var(--primary-hover) !important;
        }
        
        #data-table thead th {
            padding: 0.75rem 0.5rem; /* Match cell padding */
            font-size: 0.875rem; /* Consistent with table font */
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }
        
        #data-table tbody tr {
            transition: var(--transition);
        }
        
        #data-table tbody tr:hover {
            background-color: var(--bg-hover);
            transform: scale(1.005);
            box-shadow: var(--shadow-sm);
        }
        
        #data-table tfoot {
            position: static;
            background: transparent;
            border-top: 0;
            box-shadow: none;
        }
        /* Floating + button to free vertical space */
        #fab-add {
          position: fixed;
          right: 16px;
          bottom: calc(env(safe-area-inset-bottom, 0px) + 16px);
          z-index: 50;
          width: 56px;
          height: 56px;
          border-radius: 9999px;
          display: flex;
          align-items: center;
          justify-content: center;
          box-shadow: var(--shadow-lg);
        }
        #fab-add:active { transform: scale(0.97); }
        
        /* FAB button styling - no responsive modifications */
        


        /* Hide the old add-row button area to remove the white bar */
        #data-table tfoot td { padding: 0 !important; height: 0 !important; }
        #data-table tfoot button { display: none !important; }

        /* Snapshot System Styles */
        .snapshot-readonly {
            background-color: #fef3c7 !important;
            color: #92400e !important;
            cursor: not-allowed !important;
        }
        
        .snapshot-readonly:hover {
            background-color: #fde68a !important;
        }
        
        #history-bar {
            display: flex;
            transition: all 0.3s ease;
        }
        
        #history-bar button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #snapshot-banner {
            animation: slideInDown 0.3s ease-out;
            max-width: fit-content;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* History bar design - no responsive modifications */
        
        /* Utility classes */
        .hidden {
            display: none !important;
        }
        
        /* Screen reader only text */
        .sr-only {
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            padding: 0 !important;
            margin: -1px !important;
            overflow: hidden !important;
            clip: rect(0, 0, 0, 0) !important;
            white-space: nowrap !important;
            border: 0 !important;
        }
        
        /* Animation classes */
        .sync-pending-animation { 
            animation: pulse 1.5s infinite; 
        }
        
        @keyframes pulse { 
            0% { opacity: 1; } 
            50% { opacity: 0.5; } 
            100% { opacity: 1; } 
        }
        
        /* Sync status dot styles */
        .sync-dot {
            transition: all 0.3s ease;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8);
            flex-shrink: 0;
            display: inline-block;
            border: 1px solid rgba(0, 0, 0, 0.1);
            cursor: help;
        }
        
        .sync-dot.animate-pulse {
            animation: dot-pulse 2s infinite;
        }
        
        @keyframes dot-pulse {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
            }
            50% { 
                opacity: 0.7; 
                transform: scale(1.1);
            }
        }
        
        /* Sync status styling - no responsive modifications */
        

        
        
        /* Button bar positioning - Always right-justified with proper wrapping */
        #button-bar { 
            position: absolute; 
            top: 8px; 
            right: 8px; 
            z-index: 20; 
            max-width: 100%;
            justify-content: flex-end !important; /* Force right justification */
            flex-wrap: wrap !important; /* Ensure proper wrapping */
            align-items: center;
            gap: 0.25rem;
            /* Ensure proper wrapping behavior */
            flex-direction: row;
            /* Force right alignment even when wrapping */
            align-content: flex-end;
        }
        
        /* Ensure buttons wrap properly and maintain right alignment */
        #button-bar::after {
            content: '';
            flex: 1;
            min-width: 0;
        }
        
        /* Staff title container width optimization */
        #staff-title {
            width: fit-content;
            max-width: fit-content;
            display: inline-block;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            /* Ensure proper spacing and alignment */
            margin: 0;
            padding: 0;
            line-height: 1.2;
        }
        
        /* Hide title on small/medium screens with proper width control */
        @media (max-width: 1024px) {
            #staff-title {
                display: none;
            }
        }
        
        /* Show title on large screens with optimized width */
        @media (min-width: 1025px) {
            #staff-title {
                display: inline-block;
                width: fit-content;
                max-width: fit-content;
                /* Ensure perfect text sizing */
                box-sizing: border-box;
                /* Prevent any unwanted spacing */
                margin-right: auto;
                margin-left: 0;
                /* Ensure text doesn't wrap */
                word-break: keep-all;
                hyphens: none;
            }
        }
        
        /* Snapshot Controls Size Enhancement - 20% larger on all screen sizes */
        #history-bar-container .flex.items-center.gap-2.justify-center button,
        #snapshot-calendar-btn,
        #current-snapshot-date-display {
            transform: scale(1.2) !important; /* 20% larger */
            transform-origin: center !important;
        }
        
        /* Ensure proper spacing and sizing for snapshot controls */
        #history-bar-container .flex.items-center.gap-2.justify-center button {
            min-width: 44px !important; /* Minimum touch target size */
            min-height: 32px !important;
            font-size: 0.875rem !important; /* Slightly larger text */
            padding: 0.5rem 0.75rem !important; /* Increased padding */
        }
        
        /* Calendar button specific styling */
        #snapshot-calendar-btn {
            min-width: 80px !important; /* Ensure text fits */
            min-height: 32px !important;
            font-size: 0.875rem !important;
            padding: 0.5rem 0.75rem !important;
        }
        
        /* Current snapshot date display styling */
        #current-snapshot-date-display {
            min-width: 120px !important; /* Ensure text fits */
            min-height: 32px !important;
            font-size: 0.875rem !important;
            padding: 0.5rem 0.75rem !important;
            margin-left: 0.5rem !important; /* Add spacing between calendar button and affichage direct */
        }
        
        /* Add padding between function button container and snapshot controls on all screens */
        #history-bar-container {
            margin-top: 1rem !important; /* Add top margin for separation */
            padding-top: 0.75rem !important; /* Add top padding */
        }

        /* Add padding between function button container and snapshot controls on small screens */
        @media (max-width: 1024px) {
            #history-bar-container {
                margin-top: 1.25rem !important; /* Increase top margin for separation */
                padding-top: 1rem !important; /* Increase top padding */
            }
            
            /* Increase spacing between function buttons and snapshot controls */
            #button-bar + div {
                margin-top: 1.5rem !important;
            }
        }
        
        /* Enhanced spacing for very small screens */
        @media (max-width: 640px) {
            #history-bar-container {
                margin-top: 1.5rem !important;
                padding-top: 0.75rem !important;
            }
            
            /* Increase spacing between function buttons and snapshot controls */
            #button-bar + div {
                margin-top: 2rem !important;
            }
        }
        
        /* Icon sizing within snapshot controls - match the 20% size increase */
        #history-bar-container .flex.items-center.gap-2.justify-center button i,
        #snapshot-calendar-btn i,
        #current-snapshot-date-display i {
            font-size: 1.2em !important; /* Scale icons proportionally */
            width: 1.2em !important;
            height: 1.2em !important;
        }
        
        /* Ensure proper icon alignment in buttons */
        #history-bar-container .flex.items-center.gap-2.justify-center button,
        #snapshot-calendar-btn {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            gap: 0.25rem !important; /* Consistent spacing between icon and text */
        }
        
        /* Snapshot controls container enhancement */
        #history-bar-container .flex.items-center.gap-2.p-3.bg-blue-50.rounded-lg.border.border-blue-200 {
            padding: 1rem !important; /* Increase container padding */
            gap: 0.75rem !important; /* Increase gap between elements */
            min-height: 48px !important; /* Ensure minimum height for larger buttons */
        }
        
        /* Responsive container sizing */
        @media (max-width: 1024px) {
            #history-bar-container .flex.items-center.gap-2.p-3.bg-blue-50.rounded-lg.border.border-blue-200 {
                padding: 1.25rem !important; /* Even more padding on small screens */
                gap: 1rem !important; /* Larger gaps on small screens */
            }
        }
        
        /* Calendar dropdown sizing to match larger buttons */
        #snapshot-calendar-dropdown {
            min-width: 280px !important; /* Increase width to accommodate larger text */
            font-size: 1.1em !important; /* Slightly larger text */
        }
        
        #snapshot-calendar-dropdown h3 {
            font-size: 1.1em !important; /* Larger header text */
        }
        
        #snapshot-calendar-dropdown .text-xs {
            font-size: 0.875rem !important; /* Larger description text */
        }
        
        /* Cell selection styling for better visual feedback */
        .editable-cell.selected {
            background-color: #e3f2fd !important;
            border: 2px solid #2196f3 !important;
            box-shadow: 0 0 8px rgba(33, 150, 243, 0.3) !important;
            outline: none !important;
        }
        
        /* Focus state for editable cells */
        .editable-cell:focus {
            background-color: #e3f2fd !important;
            border: 2px solid #2196f3 !important;
            box-shadow: 0 0 8px rgba(33, 150, 243, 0.3) !important;
            outline: none !important;
        }
        
        /* Mobile-specific cell selection */
        @media (max-width: 768px) {
            .editable-cell.selected {
                background-color: #e8f5e8 !important;
                border: 2px solid #4caf50 !important;
                box-shadow: 0 0 12px rgba(76, 175, 80, 0.4) !important;
            }
            
            .editable-cell:focus {
                background-color: #e8f5e8 !important;
                border: 2px solid #4caf50 !important;
                box-shadow: 0 0 12px rgba(76, 175, 80, 0.4) !important;
            }
        }
        
        /* Horizontal scroll for function buttons on small screens */
        @media (max-width: 1024px) {
            #button-bar {
                overflow-x: auto;
                overflow-y: hidden;
                white-space: nowrap;
                flex-wrap: nowrap !important; /* Prevent wrapping on small screens */
                justify-content: flex-start !important; /* Start from left for better scroll experience */
                padding-right: 8px; /* Add padding for scroll bar */
                /* Custom scrollbar styling */
                scrollbar-width: thin;
                scrollbar-color: #9ca3af #f3f4f6;
            }
            
            /* Webkit scrollbar styling for Chrome/Safari */
            #button-bar::-webkit-scrollbar {
                height: 6px;
            }
            
            #button-bar::-webkit-scrollbar-track {
                background: #f3f4f6;
                border-radius: 3px;
            }
            
            #button-bar::-webkit-scrollbar-thumb {
                background: #9ca3af;
                border-radius: 3px;
            }
            
            #button-bar::-webkit-scrollbar-thumb:hover {
                background: #6b7280;
            }
            
            /* Ensure buttons don't shrink on small screens */
            #button-bar button {
                flex-shrink: 0;
                min-width: 36px;
                min-height: 36px;
            }
        }
        
        #button-bar button {
            margin: 0;
            flex-shrink: 0;
            /* Ensure buttons don't shrink and maintain consistent sizing */
            min-width: 36px;
            min-height: 36px;
        }
        
        /* Mobile-safe positioning for the top-right button bar */
        @media (max-width: 640px) {
            #button-bar {
                position: fixed;
                top: calc(env(safe-area-inset-top, 0px) + 8px);
                right: 8px;
                z-index: 50;
                max-width: calc(100vw - 16px); /* Prevent overflow */
                /* Force horizontal scroll on very small screens */
                overflow-x: auto;
                overflow-y: hidden;
                white-space: nowrap;
                flex-wrap: nowrap !important;
                justify-content: flex-start !important;
                padding-right: 8px;
                /* Enhanced scrollbar for mobile */
                scrollbar-width: thin;
                scrollbar-color: #6b7280 #f3f4f6;
            }
            
            /* Mobile-optimized scrollbar */
            #button-bar::-webkit-scrollbar {
                height: 8px; /* Slightly larger for touch */
            }
            
            #button-bar::-webkit-scrollbar-track {
                background: #f3f4f6;
                border-radius: 4px;
            }
            
            #button-bar::-webkit-scrollbar-thumb {
                background: #6b7280;
                border-radius: 4px;
                border: 1px solid #d1d5db;
            }
            
            #button-bar::-webkit-scrollbar-thumb:hover {
                background: #4b5563;
            }
        }
        
        /* Tablet and medium screen optimizations */
        @media (min-width: 641px) and (max-width: 1024px) {
            #button-bar {
                /* Ensure buttons don't get too cramped on medium screens */
                gap: 0.375rem;
                /* Maintain right justification */
                justify-content: flex-end !important;
            }
        }
        
        
        
        /* Color picker and button sizing */
        #row-color-picker {
            flex-shrink: 0 !important;
            min-width: 32px !important;
            min-height: 32px !important;
            width: 32px !important;
            height: 32px !important;
            transform: scale(1.2) !important;
            transform-origin: center !important;
        }

        /* keep slight press effect while preserving 1.2 scale */
        #button-bar button:active {
            transform: scale(1.176);
        }
        
        /* Table container styling - no responsive modifications */
        
        /* Message box styles - Highest z-index to appear above everything */
        .message-box {
            position: fixed;
            top: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            line-height: 1rem;
            padding: 3px 6px;
            margin-top: 2px;
            border-radius: 0.375rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 99999 !important; /* Highest z-index to appear above everything */
            opacity: 0;
            transition: opacity 0.4s ease, transform 0.4s ease;
            max-width: 80vw;
            word-wrap: break-word;
            /* Ensure it's above all other elements */
            pointer-events: none; /* Allow clicks to pass through */
            /* More discrete appearance */
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Message box content should be clickable */
        .message-box p {
            pointer-events: auto;
        }
        
        /* Enhanced message box positioning and mobile optimization */
        @media (max-width: 768px) {
            .message-box {
                top: 0.75rem !important;
                left: 0.75rem !important;
                right: 0.75rem !important;
                transform: none !important;
                max-width: none !important;
                font-size: 0.75rem !important;
                padding: 0.5rem 0.75rem !important;
                border-radius: 0.5rem !important;
                /* Ensure it's above mobile elements */
                z-index: 99999 !important;
                /* More discrete on mobile */
                backdrop-filter: blur(12px);
                border: 1px solid rgba(255, 255, 255, 0.15);
            }
            
            .message-box.show {
                transform: none !important;
            }
        }
        
        /* Ensure message box is above all other elements including modals */
        .message-box {
            /* Force highest stacking context */
            isolation: isolate;
            /* Ensure it's above any other fixed elements */
            position: fixed !important;
            /* Additional safety for z-index */
            z-index: 99999 !important;
            /* Ensure it's above all other elements */
            transform: translateZ(0);
            /* Force hardware acceleration */
            will-change: opacity, transform;
        }
        
        /* Override any other z-index values that might interfere */
        .message-box,
        .message-box * {
            z-index: 99999 !important;
        }
        
        /* Ensure message box appears above confirmation modals and other overlays */
        .message-box {
            /* Above confirmation modal */
            z-index: 99999 !important;
            /* Above snapshot bar */
            z-index: 99999 !important;
            /* Above any other fixed elements */
            z-index: 99999 !important;
        }
        
        /* Subtle hover effect for better visibility when needed */
        .message-box:hover {
            transform: translateX(-50%) translateY(-2px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        /* Ensure smooth transitions */
        .message-box {
            transition: opacity 0.4s ease, transform 0.4s ease, box-shadow 0.2s ease;
        }
        
        .message-box.show { 
            opacity: 1; 
            transform: translateX(-50%) translateY(0); 
        }
        
        /* Subtle entrance animation */
        .message-box {
            transform: translateX(-50%) translateY(-10px);
        }
        
        .message-box.show {
            transform: translateX(-50%) translateY(0);
        }
        
        .message-box.success { 
            background-color: rgba(16, 185, 129, 0.1);
            color: #065f46; 
            border: 1px solid rgba(16, 185, 129, 0.3);
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.15);
        }
        
        .message-box.info { 
            background-color: rgba(59, 130, 246, 0.1);
            color: #1e40af; 
            border: 1px solid rgba(59, 130, 246, 0.3);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
        }
        
        .message-box.error { 
            background-color: rgba(239, 68, 68, 0.1);
            color: #991b1b; 
            border: 1px solid rgba(239, 68, 68, 0.3);
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.15);
        }
        
        .message-box.warning { 
            background-color: rgba(245, 158, 11, 0.1);
            color: #92400e; 
            border: 1px solid rgba(245, 158, 11, 0.3);
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.15);
        }
        
        


        /* Essential mobile optimizations - minimal impact */
        @media (max-width: 768px) {
            html, body {
                margin: 0 !important;
                padding: 0 !important;
                width: 100vw !important;
                overflow-x: hidden !important;
            }
            
            body {
                transform: scale(0.7) !important;
                transform-origin: top left !important;
                width: calc(100vw / 0.7) !important;
                height: calc(100vh / 0.7) !important;
            }
            
            body.user-zoom-override {
                transform: none !important;
                width: 100vw !important;
                height: 100vh !important;
            }
            
            /* Ensure table wrapper takes full width */
            .overflow-auto {
                margin: 0 !important;
                padding: 0 !important;
                width: 100% !important;
                max-width: 100% !important;
            }
            
            /* Title is hidden on small screens - handled by main CSS */
            #staff-title {
                display: none !important;
            }
            
            /* Increase function button size by 30% */
            #button-bar button {
                transform: scale(1.3) !important;
                transform-origin: center !important;
            }
            
            #button-bar button:active {
                transform: scale(1.27) !important;
            }
        }
        
        /* Medium screens (768px to 1024px) - title hidden, buttons scaled */
        @media (min-width: 769px) and (max-width: 1024px) {
            #staff-title {
                display: none !important;
            }
            
            /* Increase function button size by 30% */
            #button-bar button {
                transform: scale(1.3) !important;
                transform-origin: center !important;
            }
            
            #button-bar button:active {
                transform: scale(1.27) !important;
            }
        }
        
        /* Sticky first column */
        #data-table td:first-child {
            position: sticky;
            left: 0;
            z-index: 2;
            background-color: white !important;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }

        #data-table th:first-child {
            position: sticky !important;
            left: 0 !important;
            top: 0 !important;
            z-index: 101 !important;
            background-color: var(--primary-color) !important;
            /* ✅ GARANTIR que la première colonne reste visible */
            will-change: transform !important;
            transform: translateZ(0) !important;
            /* ✅ Ombre pour séparer visuellement */
            box-shadow: 2px 0 5px rgba(0,0,0,0.1) !important;
        }
        
        /* Frozen column classes for JavaScript */
        .frozen-column.frozen-1 {
            position: sticky !important;
            left: 0 !important;
            z-index: 2 !important;
            background-color: white !important;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }
        
        .frozen-column-header.frozen-1 {
            position: sticky !important;
            left: 0 !important;
            top: 0 !important;
            z-index: 101 !important;
            background-color: var(--primary-color) !important;
            /* ✅ GARANTIR que les colonnes gelées restent visibles */
            will-change: transform !important;
            transform: translateZ(0) !important;
            /* ✅ Ombre pour séparer visuellement */
            box-shadow: 2px 0 5px rgba(0,0,0,0.1) !important;
        }
        
        /* Consolidated sticky header styles */
        #data-table thead th,
        .frozen-column-header {
            visibility: visible !important;
            opacity: 1 !important;
            overflow: visible !important;
        }
        
        /* ✅ En-têtes de colonnes gelées avec priorité maximale */
        #data-table th:first-child,
        .frozen-column-header.frozen-1 {
            z-index: 101 !important;
            left: 0 !important;
            top: 0 !important;
        }
        
        /* ✅ Styles pour les en-têtes pendant le téléchargement */
        #data-table thead.downloading {
            background-color: var(--primary-color) !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2) !important;
            border-bottom: 3px solid var(--warning-color) !important;
        }
        
        /* Editable cell styles */
        td.editable-cell:empty::after { 
            content: attr(data-label); 
            color: var(--text-secondary); 
            font-weight: normal; 
        }
        
        /* Texte noir foncé pour toutes les cellules éditables du tableau */
        td.editable-cell {
            color: #1a1a1a !important;
        }
        
        /* Styles spécifiques pour les colonnes importantes avec police plus grande */
        td.editable-cell[data-label="Date de saisie"],
        td.editable-cell[data-label="PEC finale"],
        td.editable-cell[data-label="PEC initiale"],
        td.editable-cell[data-label="Diagnostic_initial"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Numero_tel avec police standard (1.1rem) */
        td.editable-cell[data-label="Numero_tel"],
        td.editable-cell[data-label="numero_tel"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police standard */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Nom_Prénom et DDN en gras pour les cellules éditables */
        td.editable-cell[data-label="Nom_Prénom"],
        td.editable-cell[data-label="DDN"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 700 !important; /* Gras (bold) */
        }
        
        /* Information complementaire en rouge pour les cellules éditables */
        td.editable-cell[data-label="Information complementaire"],
        td.editable-cell[data-label="information complementaire"] {
            color: #dc2626 !important; /* Rouge */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Patient name formatting - support line breaks */
        td.editable-cell[data-label="Nom_Prénom"],
        td.editable-cell[data-label="nom prenom"],
        td.editable-cell[data-label="nom_prénom"],
        td.editable-cell[data-label="nom et prenom"],
        td.editable-cell[data-label="nom et prénom"],
        td.editable-cell[data-label="patient"],
        td.editable-cell[data-label="nom complet"],
        td.editable-cell[data-label="fullname"],
        td.editable-cell[data-label="name"] {
            white-space: pre-line;
            line-height: 1.2;
            vertical-align: top;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }
        
        td.editable-cell[data-label="DDN"]:empty::after { 
            content: 'JJ/MM/YYYY'; 
            color: var(--text-secondary); 
            font-weight: normal; 
        }
        
        /* Row selection */
        tr.selected-row { 
            background-color: #FEF3C7; 
        }

        /* Column text colors and font sizes for specific columns */
        #data-table td[data-label="Date de saisie"],
        #data-table td[data-label="PEC finale"],
        #data-table td[data-label="PEC initiale"],
        #data-table td[data-label="Diagnostic_initial"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Numero_tel avec police standard (1.1rem) */
        #data-table td[data-label="Numero_tel"],
        #data-table td[data-label="numero_tel"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police standard */
            font-weight: 500 !important; /* Légèrement plus gras */
        }
        
        /* Nom_Prénom et DDN en gras */
        #data-table td[data-label="Nom_Prénom"],
        #data-table td[data-label="DDN"] {
            color: #1a1a1a !important; /* Noir foncé */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 700 !important; /* Gras (bold) */
        }
        
        /* Information complementaire en rouge */
        #data-table td[data-label="Information complementaire"],
        #data-table td[data-label="information complementaire"] {
            color: #dc2626 !important; /* Rouge */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* Légèrement plus gras */
        }

        /* Column selection visuals */
        #data-table thead th.col-selected {
            outline: 3px solid var(--secondary-color);
            position: relative;
        }
        
        #data-table thead th.col-selected::after {
            content: '✓';
            position: absolute; 
            right: 6px; 
            top: 4px;
            font-weight: 700; 
            font-size: 0.8em; 
            color: var(--text-primary);
        }

        /* Safe areas for iOS/Android */
        body {
            padding-top: env(safe-area-inset-top, 0px);
            padding-bottom: env(safe-area-inset-bottom, 0px);
        }
        
        /* Mobile viewport height management */
        .mobile-viewport-height {
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            min-height: 100vh;
            min-height: 100dvh;
        }
        
        /* Viewport styling - no responsive modifications */
            
                    /* History bar styling - no responsive modifications */
        
        /* History controls row styling */
        .flex.justify-between.items-center.mb-3 {
            gap: 1rem;
        }
        
        /* Toggle button container styling */
        .flex.justify-start {
            min-width: fit-content;
        }
        
        /* Mobile-optimized toggle button styling */
        #history-toggle-btn {
            transition: all 0.2s ease-in-out;
            border: 2px solid transparent !important;
            outline: none !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }
        
        #history-toggle-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15) !important;
        }
        
        #history-toggle-btn:active {
            transform: scale(0.95);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1) !important;
        }
        
        #history-toggle-btn:focus {
            outline: 2px solid #3b82f6 !important;
            outline-offset: 2px !important;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.1) !important;
        }
        
        /* Mobile-specific toggle button optimizations */
        @media (max-width: 768px) {
            #history-toggle-btn {
                min-width: 44px !important; /* iOS touch guideline */
                min-height: 44px !important;
                width: 44px !important;
                height: 44px !important;
                border-radius: 8px !important;
                background-color: #6b7280 !important; /* Better contrast */
                font-size: 16px !important;
                touch-action: manipulation !important;
                -webkit-tap-highlight-color: transparent !important;
            }
            
            #history-toggle-btn:hover {
                background-color: #4b5563 !important;
            }
            
            #history-toggle-btn:active {
                background-color: #374151 !important;
                transform: scale(0.97) !important;
            }
            
            /* Larger icon on mobile */
            #history-toggle-btn i {
                font-size: 18px !important;
                width: 20px !important;
                height: 20px !important;
            }
        }
        
        /* Medium screen toggle button sizing - match mobile shape */
        @media (min-width: 769px) and (max-width: 1024px) {
            #history-toggle-btn {
                min-width: 44px !important;
                min-height: 44px !important;
                width: 44px !important;
                height: 44px !important;
                border-radius: 8px !important;
                background-color: #6b7280 !important;
                font-size: 16px !important;
                padding: 0 !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
            }
            
            #history-toggle-btn:hover {
                background-color: #4b5563 !important;
                transform: scale(1.05) !important;
            }
            
            #history-toggle-btn:active {
                background-color: #374151 !important;
                transform: scale(0.97) !important;
            }
            
            /* Larger icon on medium screens */
            #history-toggle-btn i {
                font-size: 18px !important;
                width: 20px !important;
                height: 20px !important;
            }
        }
        
        /* Small screen toggle button sizing - match mobile shape */
        @media (max-width: 640px) {
            #history-toggle-btn {
                min-width: 44px !important;
                min-height: 44px !important;
                width: 44px !important;
                height: 44px !important;
                border-radius: 8px !important;
                background-color: #6b7280 !important;
                font-size: 16px !important;
                padding: 0 !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
            }
            
            #history-toggle-btn:hover {
                background-color: #4b5563 !important;
                transform: scale(1.05) !important;
            }
            
            #history-toggle-btn:active {
                background-color: #374151 !important;
                transform: scale(0.97) !important;
            }
            
            /* Larger icon on small screens */
            #history-toggle-btn i {
                font-size: 18px !important;
                width: 20px !important;
                height: 20px !important;
            }
        }
        
        /* Perfect centering for FontAwesome icons */
        #history-toggle-btn i {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            text-align: center !important;
            line-height: 1 !important;
            width: 100% !important;
            height: 100% !important;
            border: none !important;
            outline: none !important;
        }
        
        /* Remove any FontAwesome pseudo-elements that might cause lines */
        #history-toggle-btn i::before,
        #history-toggle-btn i::after {
            border: none !important;
            outline: none !important;
        }
        
        /* History bar container styling */
        #history-bar-container {
            flex: 1;
            min-width: 0;
            display: flex;
            justify-content: flex-end;
            /* Ensure proper visibility on mobile */
            transition: all 0.3s ease-in-out;
            opacity: 1;
            visibility: visible;
            height: auto;
            overflow: visible;
        }
        
        /* Enhanced history bar container for mobile */
        #history-bar-container:not(.hidden) {
            display: flex !important;
            opacity: 1 !important;
            visibility: visible !important;
            height: auto !important;
            overflow: visible !important;
            /* Force visibility on mobile */
            position: relative !important;
            z-index: 5 !important;
        }
        
        /* Hidden state styling */
        #history-bar-container.hidden {
            display: none !important;
            opacity: 0 !important;
            visibility: hidden !important;
            height: 0 !important;
            overflow: hidden !important;
        }
        
        /* Manual snapshot button disabled state */
        #manual-snapshot-btn:disabled {
            opacity: 0.5 !important;
            cursor: not-allowed !important;
            background-color: #9ca3af !important;
            color: #6b7280 !important;
        }
        
        #manual-snapshot-btn:disabled:hover {
            background-color: #9ca3af !important;
            transform: none !important;
        }
        
        /* Reduced width container styling */
        #history-bar-container > div {
            max-width: 50%;
            min-width: fit-content;
        }
        
        /* History controls styling - no responsive modifications */
        

        
        /* Current snapshot date display styling */
        #current-snapshot-date-display {
            white-space: nowrap;
            flex-shrink: 0;
            transition: all 0.2s ease-in-out;
        }
        
        #current-snapshot-date-display:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
        }
        
        /* Date display styling - no responsive modifications */
        
        /* Focus styles for accessibility */
        .editable-cell:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: -2px;
            background-color: var(--bg-secondary);
            box-shadow: inset 0 0 0 1px var(--border-focus);
            color: #1a1a1a !important; /* Texte noir foncé quand on écrit */
        }
        
        /* Styles de focus spécifiques pour les colonnes importantes */
        .editable-cell[data-label="Date de saisie"]:focus,
        .editable-cell[data-label="PEC finale"]:focus,
        .editable-cell[data-label="PEC initiale"]:focus,
        .editable-cell[data-label="Diagnostic_initial"]:focus {
            color: #1a1a1a !important; /* Noir foncé maintenu en focus */
            font-size: 1.1rem !important; /* Police plus grande maintenue */
            font-weight: 500 !important; /* Gras maintenu */
        }
        
        /* Numero_tel avec police standard (1.1rem) même en focus */
        .editable-cell[data-label="Numero_tel"]:focus,
        .editable-cell[data-label="numero_tel"]:focus {
            color: #1a1a1a !important; /* Noir foncé maintenu en focus */
            font-size: 1.1rem !important; /* Police standard maintenue */
            font-weight: 500 !important; /* Gras maintenu */
        }
        
        /* Nom_Prénom et DDN en gras même en focus */
        .editable-cell[data-label="Nom_Prénom"]:focus,
        .editable-cell[data-label="DDN"]:focus {
            color: #1a1a1a !important; /* Noir foncé maintenu en focus */
            font-size: 1.1rem !important; /* Police plus grande maintenue */
            font-weight: 700 !important; /* Gras (bold) maintenu */
        }
        
        /* Information complementaire en rouge même en focus */
        .editable-cell[data-label="Information complementaire"]:focus {
            color: #dc2626 !important; /* Rouge maintenu en focus */
            font-size: 1.1rem !important; /* Police plus grande maintenue */
            font-weight: 500 !important; /* Gras maintenu */
        }
        
        /* Texte noir foncé pour toutes les cellules éditables (sauf Information complementaire) */
        .editable-cell:not([data-label="Information complementaire"]) {
            color: #1a1a1a !important;
        }
        
        /* S'assurer que le texte reste noir foncé même après avoir écrit (sauf Information complementaire) */
        .editable-cell:not(:empty):not([data-label="Information complementaire"]) {
            color: #1a1a1a !important;
        }
        
        /* Loading states */
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        
        /* Modern form input styles */
        input[type="text"], 
        input[type="password"], 
        input[type="email"], 
        input[type="number"],
        input[type="date"],
        select {
            padding: 0.75rem 1rem;
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-size: 1rem;
            transition: var(--transition);
            background-color: var(--bg-primary);
        }
        
        input[type="text"]:focus,
        input[type="password"]:focus,
        input[type="email"]:focus,
        input[type="number"]:focus,
        input[type="date"]:focus,
        select:focus {
            outline: none;
            border-color: var(--border-focus);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Style pour le champ mot de passe en erreur */
        .password-error {
            border-color: var(--danger-color) !important;
            background-color: rgba(220, 38, 38, 0.05) !important;
            box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.1) !important;
        }
        
        .password-error::placeholder {
            color: var(--danger-color);
        }
        
        /* Enhanced button styles */
        button {
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        /* Button hover effects */
        button:hover::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        button:hover::before {
            width: 300px;
            height: 300px;
        }
        
        /* Enhanced message box */
        .message-box {
            backdrop-filter: blur(10px);
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Login container enhancements */
        #login-container {
            animation: fadeInUp 0.6s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Table container animations */
        #table-container {
            animation: fadeIn 0.5s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Table styling - no responsive modifications */
        
        /* Smart Calendar Styles */
        .month-nav-btn {
            transition: all 0.2s ease-in-out;
            border-width: 2px;
        }
        
        .month-nav-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .month-nav-btn.active {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            border-color: #1d4ed8;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .month-content {
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .week-header {
            background: linear-gradient(90deg, #f8fafc, #e2e8f0);
            border-left: 3px solid #3b82f6;
        }
        
        .snapshot-item {
            transition: all 0.2s ease-in-out;
        }
        
        .snapshot-item:hover {
            transform: translateX(4px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .snapshot-item.current {
            background: linear-gradient(135deg, #dbeafe, #bfdbfe);
            border-left-color: #3b82f6;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);
        }
        
        /* Sticky month navigation */
        .sticky-month-nav {
            position: sticky;
            top: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #e5e7eb;
            z-index: 20;
        }
        
        /* Month header gradient */
        .month-header-gradient {
            background: linear-gradient(135deg, #dbeafe 0%, #e0e7ff 100%);
            border-left: 4px solid #3b82f6;
        }
        
        /* Week section styling */
        .week-section {
            margin-left: 1rem;
            border-left: 2px solid #e5e7eb;
            padding-left: 1rem;
        }
        
        /* Calendar styling - no responsive modifications */
    </style>
</head>
<body class="bg-gray-100 flex flex-col h-screen overflow-hidden text-sm md:text-base lg:text-lg">

    <div id="message-box" class="message-box hidden"><p id="message-text" class="font-bold"></p></div>

    <!-- Login container -->
    <div id='login-container' class="fixed inset-0 bg-gray-100 flex items-center justify-center z-50 transition-all duration-300 ease-in-out hidden">
        <div class="bg-white p-8 md:p-10 lg:p-12 rounded-xl shadow-lg w-full max-w-md mx-4 flex flex-col items-center space-y-4 md:space-y-6">
            <h2 class="text-2xl md:text-3xl lg:text-4xl font-bold text-gray-800">Accéder au tableau</h2>
            <input type='password' id='password' placeholder='Mot de passe (Appuyez sur Entrée)' class="w-full p-3 md:p-4 lg:p-5 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 transition-colors">
            <div class="flex items-center space-x-2 w-full">
                <input type='checkbox' id='toggle-password' class="w-4 h-4 md:w-5 md:h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500">
                <label for="toggle-password" class="text-sm md:text-base font-medium text-gray-700">Afficher le mot de passe</label>
            </div>
            <button onclick='checkPassword()' class="w-full bg-green-500 text-white font-bold p-3 md:p-4 lg:p-5 rounded-lg shadow-md hover:bg-green-600 transition-colors">Valider</button>
        
            <!-- Indicateur des raccourcis clavier -->
            <div class="text-center text-xs text-gray-500 mt-2">
                <p>💡 <strong>Raccourcis :</strong> Entrée (Valider) • G (Galerie) • N (Nouvelle ligne)</p>
            </div>
            
            <p id='error-message' class="text-red-500 font-medium text-sm md:text-base"></p>
        </div>
    </div>

    <!-- Bouton d'ajout - visible sur tous les écrans (en dehors du conteneur de tableau) -->
        <button id="fab-add"
                class="bg-green-500 text-white font-bold hover:bg-green-600 transition-colors"
                onclick="addRow()" title="Ajouter une nouvelle ligne" aria-label="Ajouter">
          <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
            <path d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"/>
          </svg>
        </button>
        
    <!-- Table container -->
    <div id='table-container' class="bg-white relative p-2 md:p-4 lg:p-6 pt-2 md:pt-4 lg:pt-6 rounded-xl w-full flex-grow overflow-y-auto transition-all duration-300 ease-in-out flex flex-col shadow-xl">
        
        <!-- Status indicators -->
        <div class="flex items-center gap-2 mb-1">
            <!-- Row count - Hidden on small/medium screens -->
            <div id="row-count-display" class="flex items-center justify-center px-2 py-1 bg-gray-100 border border-gray-300 rounded-lg text-gray-700 text-sm font-medium min-w-12 hidden lg:flex">
                <span>N=</span>
                <span id="row-count-number" class="ml-1 font-bold">0</span>
            </div>
            
            <!-- Icon-only indicator for small/medium screens -->
            <div class="lg:hidden flex items-center justify-center w-8 h-8 bg-green-500 rounded-full">
                <i class="fa-solid fa-check text-white text-sm"></i>
            </div>
            
            <!-- Full sync status - Show only on large screens -->
            <span id="sync-status" class="hidden lg:inline-flex sync-pending-animation px-2 py-1 rounded-full text-xs font-semibold border-2 bg-white shadow-sm">
                <span class="sync-text">Initialisation...</span>
                <i class="sync-icon fa-solid fa-check hidden"></i>
            </span>
        </div>

        <div id="error-display" class="mb-1 text-red-600 font-bold hidden p-2 bg-red-50 rounded-lg border-l-4 border-red-400 text-sm md:text-base"></div>
        
        <!-- Function Button Bar - Positioned absolutely at top-right -->
        <div id="button-bar" class="flex flex-wrap items-center justify-end gap-1 mb-2 p-1 bg-gray-50 rounded-lg border border-gray-200">
            <button onclick='saveManually()' title="Sauvegarder" aria-label="Sauvegarder" class='bg-yellow-400 text-gray-800 p-2 rounded-lg hover:bg-yellow-500 transition-colors flex items-center justify-center w-9 h-9'>
                <i class="fa-solid fa-save w-4.5 h-4.5"></i>
            </button>
            <button id="undo-button" disabled title="Annuler" aria-label="Annuler" class="bg-gray-300 text-gray-700 p-2 rounded-lg hover:bg-gray-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-9 h-9">
                <i class="fa-solid fa-rotate-left w-4.5 h-4.5"></i>
            </button>
            <button id="redo-button" disabled title="Rétablir" aria-label="Rétablir" class="bg-gray-300 text-gray-700 p-2 rounded-lg hover:bg-gray-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-9 h-9">
                <i class="fa-solid fa-rotate-right w-4.5 h-4.5"></i>
            </button>
            <button onclick="downloadExcel()" title="Exporter en Excel" aria-label="Exporter en Excel" class="bg-green-600 text-white p-2 rounded-lg hover:bg-green-700 transition-colors flex items-center justify-center w-9 h-9">
                <i class="fa-solid fa-file-excel w-4.5 h-4.5"></i>
            </button>
            <button onclick="downloadPDF()" title="Exporter en PDF" aria-label="Exporter en PDF" class="bg-red-600 text-white p-2 rounded-lg hover:bg-red-700 transition-colors flex items-center justify-center w-9 h-9">
                <i class="fa-solid fa-file-pdf w-4.5 h-4.5"></i>
            </button>
            <button onclick="downloadImage()" title="Exporter en image (PNG)" aria-label="Exporter en image (PNG)" class="bg-purple-600 text-white p-2 rounded-lg hover:bg-purple-700 transition-colors flex items-center justify-center w-9 h-9">
                <i class="fa-solid fa-image w-4.5 h-4.5"></i>
            </button>
            <button onclick="document.getElementById('excel-input').click()" title="Importer depuis Excel" aria-label="Importer depuis Excel" class="bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 transition-colors flex items-center justify-center w-9 h-9">
                <i class="fa-solid fa-upload w-4.5 h-4.5"></i>
            </button>
            <button onclick="openSimpleGallery()" title="Galerie d'images (G)" aria-label="Galerie d'images" class="bg-indigo-600 text-white p-2 rounded-lg hover:bg-indigo-700 transition-colors flex items-center justify-center w-9 h-9">
                <i class="fa-solid fa-images w-4.5 h-4.5"></i>
            </button>
            <button onclick="zoomOut()" title="Réduire (−)" aria-label="Réduire" class="bg-gray-700 text-white p-2 rounded-lg hover:bg-gray-800 transition-colors flex items-center justify-center w-9 h-9">
                <i class="fa-solid fa-minus w-4.5 h-4.5"></i>
            </button>
            <button id="zoom-display" onclick="zoomReset()" title="Réinitialiser à 100%" aria-label="Réinitialiser à 100%" class="bg-gray-500 text-white px-2.5 py-2.5 rounded-lg hover:bg-gray-600 transition-colors text-sm w-10 h-10">100%</button>
            <button onclick="zoomIn()" title="Agrandir (+)" aria-label="Agrandir" class="bg-gray-700 text-white p-2.5 rounded-lg hover:bg-gray-800 transition-colors flex items-center justify-center w-10 h-10">
                <i class="fa-solid fa-plus w-5 h-5"></i>
            </button>
            <input id="row-color-picker" type="color" title="Choisir la couleur de surlignage des lignes" class="p-1.5 border border-gray-300 rounded-lg cursor-pointer hover:border-gray-400 transition-colors w-10 h-10" />
            <button onclick="clearAllRowColors()" title="Effacer toutes les couleurs" aria-label="Effacer toutes les couleurs" class="bg-gray-200 text-gray-800 p-2.5 rounded-lg hover:bg-gray-300 transition-colors flex items-center justify-center w-10 h-10">
                <i class="fa-solid fa-trash-can w-5 h-5"></i>
            </button>
            <button id="filter-colored-toggle" onclick="toggleColoredFilter()" title="Afficher seulement les lignes colorées" aria-label="Filtrer lignes colorées" class="bg-gray-200 text-gray-800 p-2.5 rounded-lg hover:bg-gray-300 transition-colors flex items-center justify-center w-10 h-10">
                <i class="fa-solid fa-filter w-5 h-5"></i>
            </button>
            <button id="paint-mode-toggle" onclick="cyclePaintMode()" title="Mode de peinture: Auto/Colorer/Effacer (appuyez sur P pour changer)" aria-label="Basculer le mode de peinture" class="bg-gray-200 text-gray-800 p-2.5 rounded-lg hover:bg-gray-300 transition-colors flex items-center justify-center w-10 h-10">
                <i class="fa-solid fa-palette w-5 h-5"></i>
            </button>
            <button id="view-mode-toggle" onclick="toggleViewMode()" title="Basculer le mode visualisation (lecture seule)" aria-label="Basculer le mode visualisation" class="bg-blue-200 text-blue-800 p-2.5 rounded-lg hover:bg-blue-300 transition-colors flex items-center justify-center w-10 h-10">
                <i class="fa-solid fa-eye w-5 h-5"></i>
            </button>
        </div>
        <input id="excel-input" type="file" accept=".xlsx,.xls,.csv" class="hidden" onchange="importExcelFromFile(this.files[0])" />

        <!-- History Controls Row - Toggle button and history buttons on same level -->
        <div class="flex justify-between items-center mb-2">
            <!-- Toggle button container -->
            <div class="flex items-center gap-2">
                <button id="history-toggle-btn" onclick="toggleHistoryBarSimple()" 
                    title="Afficher/Masquer l'historique des snapshots" 
                    aria-label="Bouton pour afficher ou masquer la barre d'historique"
                    aria-expanded="false"
                    aria-controls="history-bar-container"
                    role="button"
                    tabindex="0"
                    class="bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-all duration-200 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                    <i id="history-toggle-icon" class="fa-solid fa-plus" aria-hidden="true"></i>
                    <span class="sr-only">Afficher l'historique</span>
                </button>
            </div>

            <!-- History Bar Container - This is what gets toggled -->
            <div id="history-bar-container" class="flex justify-end md:ml-6 lg:ml-8">
                <!-- Single line container for all snapshot controls -->
                <div class="flex items-center gap-2 p-3 bg-blue-50 rounded-lg border border-blue-200 w-full relative z-20">
                    <!-- Navigation buttons - Responsive visibility -->

                    
                    <!-- Desktop navigation buttons -->

                    
                    <!-- Action buttons - Fixed styling for all screen sizes -->
                    <div class="flex items-center gap-2 justify-center">
                        <button onclick="refreshTableData()" title="Actualiser le tableau avec les données les plus récentes" aria-label="Actualiser" class="bg-green-600 text-white px-2 py-1 rounded text-xs hover:bg-green-700 transition-colors font-medium flex items-center justify-center">
                            <i class="fa-solid fa-arrows-rotate w-3 h-3"></i>
                        </button>
                        
                        <!-- Bouton Snapshot Manuel -->
                        <button id="manual-snapshot-btn" onclick="handleManualSnapshotClick()" title="Créer un snapshot manuel de la table actuelle" aria-label="Snapshot Manuel" class="bg-purple-600 text-white px-2 py-1 rounded text-xs hover:bg-purple-700 transition-colors font-medium flex items-center justify-center">
                            <i class="fa-solid fa-camera w-3 h-3"></i>
                        </button>
                        
                        <!-- Calendar dropdown for snapshot dates -->
                        <div class="relative z-20">
                            <button id="snapshot-calendar-btn" onclick="toggleSnapshotCalendar()" title="Choisir une date de snapshot" aria-label="Calendrier des snapshots" class="bg-indigo-600 text-white px-2 py-1 rounded text-xs hover:bg-indigo-700 transition-colors font-medium flex items-center justify-center">
                                <i class="fa-solid fa-calendar-days w-3 h-3"></i>
                                <span id="calendar-btn-text" class="ml-1">Calendrier</span>
                            </button>
                            
                            <!-- Enhanced mobile-friendly calendar dropdown -->
                            <div id="snapshot-calendar-dropdown" class="hidden absolute top-full left-0 mt-2 bg-white border border-gray-300 rounded-lg shadow-lg z-50 min-w-64 max-h-96 overflow-y-auto">
                                <div class="p-3 border-b border-gray-200">
                                    <h3 class="text-sm font-semibold text-gray-700 mb-2">📅 Snapshots disponibles</h3>
                                    <div class="text-xs text-gray-500">Cliquez sur une date pour charger le snapshot</div>
                                </div>
                                <div id="snapshot-dates-list" class="p-2">
                                    <!-- Dates will be populated here -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Current Snapshot Date Display - Fixed styling for all screen sizes -->
                    <div id="current-snapshot-date-display" class="flex items-center gap-1 px-2 py-1 bg-gray-100 border border-gray-300 rounded-md text-gray-700 text-xs font-medium justify-center">
                        <i class="fa-solid fa-calendar-day w-3 h-3 text-blue-600"></i>
                        <span id="current-snapshot-date-text" class="text-center">Données en direct</span>
                    </div>
                </div>
            </div>
        </div>


        <div class="overflow-auto w-full" style="max-width: 100vw; max-height: 85vh;">
            <table id='data-table' class="w-full text-left text-gray-500 text-xs md:text-sm lg:text-base">
                <thead class="text-xs text-white uppercase bg-green-700 relative z-10">
                    <tr>
                        <th scope="col" class="py-2 px-2 md:px-4 rounded-tl-lg frozen-column-header frozen-1">No</th>
                        <th scope="col" class="py-2 px-1 text-center">Effacer<br><input id="select-all" type="checkbox" class="align-middle"></th>
                        <th scope="col" class="py-2 px-2 md:px-4">Date de saisie</th>
                        <th scope="col" class="py-2 px-2 md:px-4">PEC finale</th>
                        <th scope="col" class="py-2 px-2 md:px-4">PEC initiale</th>
                        <th scope="col" class="py-2 px-2 md:px-4">Nom_Prénom</th>
                        <th scope="col" class="py-2 px-2 md:px-4">DDN</th>
                        <th scope="col" class="py-2 px-2 md:px-4">Diagnostic_initial</th>
                        <th scope="col" class="py-2 px-2 md:px-4">information complementaire</th>
                        <th scope="col" class="py-2 px-2 md:px-4 rounded-tr-lg">Numero_tel</th>
                    </tr>
                </thead>
                <tbody id="table-body"></tbody>
                <tfoot class="bg-white border-t-2 border-gray-300">
                    <tr>
                        <td colspan="2" class="py-2 px-2">
                            <button class="bg-green-500 text-white font-bold p-2 rounded-lg hover:bg-green-600 transition-colors text-lg w-10 h-10 flex items-center justify-center mx-auto" onclick="addRow()" title="Ajouter une nouvelle ligne">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"/>
                                </svg>
                            </button>
                        </td>
                        <td colspan="8" class="bg-white"></td>
                    </tr>
                </tfoot>
            </table>
        </div>
        

        

        <div id="confirmation-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 h-full w-full hidden z-50">
            <div class="relative top-1/4 mx-auto p-5 border w-11/12 max-w-sm shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <h3 class="text-lg md:text-xl leading-6 font-medium text-gray-900" id="modal-message"></h3>
                    <div class="mt-4 flex justify-around">
                        <button id="modal-confirm-btn" class="px-4 py-2 bg-red-600 text-white text-base font-medium rounded-md w-24 shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">Oui</button>
                        <button id="modal-cancel-btn" class="px-4 py-2 bg-gray-300 text-black text-base font-medium rounded-md w-24 shadow-sm hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500">Non</button>
                    </div>
                </div>
            </div>
        </div>


    </div>

    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>

    <!-- Performance Optimizers -->
    <script src="performance-optimizer.js"></script>
    <script src="sync-optimizer.js"></script>
    <script src="hospital-pc-sync-conflict-detector.js"></script>

    <!-- App -->
    <script type="module">
        // Configuration - In production, these should be environment variables
        const APP_CONFIG = { 
            password: 'p123', 
            version: '2.5.4-enter-on-login' 
        };
        
        const supabaseConfig = { 
            supabaseUrl: 'https://fiecugxopjxzqfdnaqsu.supabase.co', 
            supabaseAnonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ1MDU2NTcsImV4cCI6MjA3MDA4MTY1N30.xd9Thasg4r8Nrwxx5nFwyGB_ufPIvok4XB-78dilpsw', 
            // SECURITY FIX: Service key removed from client-side code
            // Use server-side API endpoints for operations requiring elevated privileges
            tableName: 'staffTable', 
            primaryKeyColumn: 'No' 
        };

        // Initialize Supabase client
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';
        const supabase = createClient(supabaseConfig.supabaseUrl, supabaseConfig.supabaseAnonKey);
        
        // Make Supabase globally available
        window.supabase = supabase;
        window.supabaseConfig = supabaseConfig;
        
        // Global state management
        const appState = { 
            isLoggedIn: false, 
            masterSource: 'supabase', 
            dataHash: null, 
            localData: null, 
            serverColumns: null 
        };
        
        // Race Condition Protection System
        const RaceConditionGuard = {
            flags: new Map(),
            
            setFlag(flag, value = true) {
                const oldValue = this.flags.get(flag) || false;
                this.flags.set(flag, value);
                
                if (oldValue !== value) {
                    console.debug(`Race condition flag "${flag}" changed: ${oldValue} -> ${value}`);
                }
                
                return oldValue;
            },
            
            getFlag(flag) {
                return this.flags.get(flag) || false;
            },
            
            isAnyFlagSet(flags) {
                return flags.some(flag => this.getFlag(flag));
            },
            
            clearFlag(flag) {
                const wasSet = this.flags.get(flag) || false;
                this.flags.set(flag, false);
                return wasSet;
            },
            
            clearAllFlags() {
                this.flags.clear();
            },
            
            withFlag(flag, asyncOperation) {
                return async (...args) => {
                    if (this.getFlag(flag)) {
                        console.warn(`Operation blocked: ${flag} is already in progress`);
                        return null;
                    }
                    
                    this.setFlag(flag, true);
                    try {
                        return await asyncOperation(...args);
                    } finally {
                        this.clearFlag(flag);
                    }
                };
            },
            
            getActiveFlags() {
                return Array.from(this.flags.entries()).filter(([key, value]) => value).map(([key]) => key);
            }
        };
        
        // Initialize common race condition flags
        RaceConditionGuard.setFlag('isLocalSaveInProgress', false);
        RaceConditionGuard.setFlag('isExcelSaveInProgress', false);
        RaceConditionGuard.setFlag('isBulkEditInProgress', false);
        RaceConditionGuard.setFlag('isRestoringFromSnapshot', false);
        RaceConditionGuard.setFlag('isInitializingApp', false);
        
        // Legacy compatibility - map old global variables
        Object.defineProperty(window, 'isLocalSaveInProgress', {
            get: () => RaceConditionGuard.getFlag('isLocalSaveInProgress'),
            set: (value) => RaceConditionGuard.setFlag('isLocalSaveInProgress', value)
        });
        
        // Event Listener Management System for Memory Leak Prevention
        const EventListenerManager = {
            listeners: new Map(),
            
            addEventListener(element, eventType, handler, options = {}) {
                if (!element || typeof handler !== 'function') return;
                
                const key = `${element.tagName || 'window'}-${eventType}-${Date.now()}`;
                element.addEventListener(eventType, handler, options);
                
                this.listeners.set(key, {
                    element,
                    eventType,
                    handler,
                    options
                });
                
                return key; // Return key for manual removal if needed
            },
            
            removeEventListener(key) {
                if (!this.listeners.has(key)) return false;
                
                const { element, eventType, handler } = this.listeners.get(key);
                element.removeEventListener(eventType, handler);
                this.listeners.delete(key);
                return true;
            },
            
            cleanup() {
                for (const [key, { element, eventType, handler }] of this.listeners) {
                    try {
                        element.removeEventListener(eventType, handler);
                    } catch (e) {
                        console.warn(`Failed to remove event listener ${key}:`, e);
                    }
                }
                this.listeners.clear();
            },
            
            getActiveListeners() {
                return this.listeners.size;
            }
        };
        
        // Timer Management System
        const TimerManager = {
            timers: new Map(),
            
            setTimeout(callback, delay, id = null) {
                const timerId = id || `timeout-${Date.now()}`;
                const timeoutId = setTimeout(() => {
                    this.timers.delete(timerId);
                    callback();
                }, delay);
                
                this.timers.set(timerId, { type: 'timeout', id: timeoutId });
                return timerId;
            },
            
            setInterval(callback, delay, id = null) {
                const timerId = id || `interval-${Date.now()}`;
                const intervalId = setInterval(callback, delay);
                
                this.timers.set(timerId, { type: 'interval', id: intervalId });
                return timerId;
            },
            
            clearTimer(timerId) {
                if (!this.timers.has(timerId)) return false;
                
                const timer = this.timers.get(timerId);
                if (timer.type === 'timeout') {
                    clearTimeout(timer.id);
                } else if (timer.type === 'interval') {
                    clearInterval(timer.id);
                }
                
                this.timers.delete(timerId);
                return true;
            },
            
            cleanup() {
                for (const [timerId, timer] of this.timers) {
                    if (timer.type === 'timeout') {
                        clearTimeout(timer.id);
                    } else if (timer.type === 'interval') {
                        clearInterval(timer.id);
                    }
                }
                this.timers.clear();
            },
            
            getActiveTimers() {
                return this.timers.size;
            }
        };

        // Safe DOM Access Utilities - moved early to avoid reference errors
        const SafeDOM = {
            getElementById(id, required = false) {
                const element = document.getElementById(id);
                if (!element && required) {
                    console.error(`Required element with ID '${id}' not found`);
                }
                return element;
            },
            
            querySelector(selector, required = false) {
                const element = document.querySelector(selector);
                if (!element && required) {
                    console.error(`Required element with selector '${selector}' not found`);
                }
                return element;
            },
            
            querySelectorAll(selector) {
                return document.querySelectorAll(selector) || [];
            },
            
            safeClick(elementOrId) {
                console.log('SafeDOM.safeClick called with:', elementOrId);
                const element = typeof elementOrId === 'string' ? 
                    this.getElementById(elementOrId) : elementOrId;
                    
                console.log('Element found:', element);
                if (element && typeof element.click === 'function') {
                    console.log('Clicking element');
                    element.click();
                    return true;
                }
                console.log('Element not found or not clickable');
                return false;
            },
            
            safeSetValue(elementOrId, value) {
                const element = typeof elementOrId === 'string' ? 
                    this.getElementById(elementOrId) : elementOrId;
                    
                if (element) {
                    element.value = value;
                    return true;
                }
                return false;
            },
            
            safeAddClass(elementOrId, className) {
                const element = typeof elementOrId === 'string' ? 
                    this.getElementById(elementOrId) : elementOrId;
                    
                if (element && element.classList) {
                    element.classList.add(className);
                    return true;
                }
                return false;
            },
            
            safeRemoveClass(elementOrId, className) {
                const element = typeof elementOrId === 'string' ? 
                    this.getElementById(elementOrId) : elementOrId;
                    
                if (element && element.classList) {
                    element.classList.remove(className);
                    return true;
                }
                return false;
            },
            
            // Safe HTML setting - prevents XSS
            safeSetHTML(elementOrId, htmlContent, allowedTags = ['i', 'span']) {
                const element = typeof elementOrId === 'string' ? 
                    this.getElementById(elementOrId) : elementOrId;
                    
                if (!element) return false;
                
                // For simple icon HTML, use innerHTML directly as it's safe
                if (typeof htmlContent === 'string' && this.isSimpleIconHTML(htmlContent, allowedTags)) {
                    element.innerHTML = htmlContent;
                    return true;
                }
                
                // For other content, use textContent to prevent XSS
                element.textContent = htmlContent;
                return true;
            },
            
            // Check if HTML content is safe (only simple icons)
            isSimpleIconHTML(html, allowedTags = ['i', 'span']) {
                if (!html || typeof html !== 'string') return false;
                
                // Check for dangerous patterns
                const dangerousPatterns = [
                    /<script/i,
                    /javascript:/i,
                    /on\w+\s*=/i,
                    /<iframe/i,
                    /<object/i,
                    /<embed/i
                ];
                
                if (dangerousPatterns.some(pattern => pattern.test(html))) {
                    return false;
                }
                
                // Check if only allowed tags are used
                const tagRegex = /<(\w+)/g;
                let match;
                while ((match = tagRegex.exec(html)) !== null) {
                    if (!allowedTags.includes(match[1].toLowerCase())) {
                        return false;
                    }
                }
                
                return true;
            }
        };

        // DOM Element Cache for Performance
        const domCache = {
            table: null,
            tbody: null,
            status: null,
            saveBtn: null,
            refreshBtn: null,
            historyBar: null,
            autosaveIndicator: null,
            
            // Initialize cache with null safety
            init() {
                this.table = SafeDOM.getElementById('data-table');
                this.tbody = SafeDOM.querySelector('#data-table tbody');
                this.status = document.getElementById('sync-status');
                this.saveBtn = document.getElementById('save-btn');
                this.refreshBtn = document.getElementById('refresh-btn');
                this.historyBar = document.getElementById('history-bar');
                this.autosaveIndicator = document.getElementById('autosave-indicator');
            },
            
            // Get cached element or fallback to query
            get(elementId) {
                return this[elementId] || document.getElementById(elementId);
            }
        };
        
        // Initialize Performance Optimizer
        const performanceOptimizer = new PerformanceOptimizer();
        const performanceUtils = {
            // Enhanced debounce with cancellation support
            debounce: performanceOptimizer.debounce.bind(performanceOptimizer),
            
            // Enhanced throttle with options
            throttle: performanceOptimizer.throttle.bind(performanceOptimizer),
            
            // Batch DOM updates to reduce reflows
            batchDOMUpdates: performanceOptimizer.batchDOMUpdates.bind(performanceOptimizer),
            
            // Queue operations to prevent race conditions
            queueOperation: performanceOptimizer.queueOperation.bind(performanceOptimizer),
            
            // Memory management for history
            manageHistory: performanceOptimizer.manageHistory.bind(performanceOptimizer),
            
            // RAF-based smooth DOM updates
            scheduleUpdate(callback) {
                if (this._pendingUpdate) return;
                this._pendingUpdate = true;
                requestAnimationFrame(() => {
                    this._pendingUpdate = false;
                    callback();
                });
            }
        };
        
        // Cursor Management System
        class CursorManager {
            constructor() {
                this.lastFocusInfo = null;
                this.restoreAttempts = new Map();
                this.preventRestore = false;
            }
            
            captureFocus() {
                const active = document.activeElement;
                if (!(active && active.tagName === 'TD' && active.isContentEditable)) {
                    return null;
                }
                
                // Skip capture if restoration was prevented (e.g., during navigation)
                if (this.preventRestore) {
                    console.log('⚠️ CursorManager: Skipping focus capture - restoration was prevented');
                    return null;
                }
                
                const row = active.closest('tr');
                const tbody = document.getElementById('table-body');
                const rowIndex = Array.from(tbody.querySelectorAll('tr')).indexOf(row);
                const cellIndex = Array.from(row.cells).indexOf(active);
                const colLabel = active.getAttribute('data-label') || '';
                const rowKey = row ? row.dataset.key || null : null;
                
                // Get caret position within the cell
                let caretOffset = 0;
                try {
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        caretOffset = range.startOffset;
                    }
                } catch (_) {}
                
                const focusState = {
                    rowIndex,
                    cellIndex,
                    colLabel,
                    rowKey,
                    caretOffset,
                    timestamp: Date.now()
                };
                
                this.lastFocusInfo = focusState;
                return focusState;
            }
            
            restoreFocus(focusState, maxAttempts = 3) {
                if (!focusState) return false;
                
                // Check if restoration is currently prevented
                if (this.preventRestore) {
                    console.log('🚫 CursorManager: Restore focus skipped - prevention flag is set');
                    return false;
                }
                
                const attemptKey = `${focusState.rowIndex}-${focusState.cellIndex}`;
                const attempts = (this.restoreAttempts.get(attemptKey) || 0) + 1;
                
                if (attempts > maxAttempts) {
                    this.restoreAttempts.delete(attemptKey);
                    console.log(`❌ CursorManager: Max restore attempts reached for ${attemptKey}`);
                    return false;
                }
                
                this.restoreAttempts.set(attemptKey, attempts);
                
                try {
                    const tbody = document.getElementById('table-body');
                    const rows = tbody.querySelectorAll('tr');
                    
                    // Find target cell by row index and cell index
                    if (focusState.rowIndex >= 0 && focusState.rowIndex < rows.length) {
                        const targetRow = rows[focusState.rowIndex];
                        const cells = targetRow.cells;
                        
                        if (focusState.cellIndex >= 0 && focusState.cellIndex < cells.length) {
                            const targetCell = cells[focusState.cellIndex];
                            
                            // Verify this is still the same cell by checking data-label
                            const cellLabel = targetCell.getAttribute('data-label') || '';
                            if (cellLabel === focusState.colLabel) {
                                
                                // Focus the cell
                                targetCell.focus({ preventScroll: true });
                                
                                // Restore caret position if possible
                                if (focusState.caretOffset > 0) {
                                    TimerManager.setTimeout(() => {
                                        try {
                                            const range = document.createRange();
                                            const sel = window.getSelection();
                                            
                                            if (targetCell.firstChild) {
                                                const textNode = targetCell.firstChild;
                                                const maxOffset = textNode.textContent ? textNode.textContent.length : 0;
                                                const offset = Math.min(focusState.caretOffset, maxOffset);
                                                
                                                range.setStart(textNode, offset);
                                                range.setEnd(textNode, offset);
                                                sel.removeAllRanges();
                                                sel.addRange(range);
                                            }
                                        } catch (e) {
                                            console.log('⚠️ CursorManager: Could not restore caret position:', e.message);
                                        }
                                    }, 50);
                                }
                                
                                this.restoreAttempts.delete(attemptKey);
                                console.log(`✅ CursorManager: Successfully restored focus to ${attemptKey}`);
                                return true;
                            }
                        }
                    }
                    
                    console.log(`⚠️ CursorManager: Could not find target cell for ${attemptKey}, attempt ${attempts}`);
                    return false;
                    
                } catch (error) {
                    console.error('❌ CursorManager: Error restoring focus:', error);
                    return false;
                }
            }
            
            // Method to prevent cursor restoration during navigation
            preventNextRestore() {
                this.preventRestore = true;
                console.log('🚫 CursorManager: Cursor restoration prevented for next operation');
                
                // Auto-reset the flag after a short delay to allow normal operation to resume
                TimerManager.setTimeout(() => {
                    this.preventRestore = false;
                    console.log('✅ CursorManager: Cursor restoration re-enabled');
                }, 1000);
            }
        }

        // Initialize Sync Optimizer
        const syncOptimizer = new SyncOptimizer();
        const cursorManager = new CursorManager();

        // Optimized Event Management System
        const eventManager = {
            // Debounced event handlers cache
            debouncedHandlers: new Map(),
            
            // Get or create debounced handler
            getDebounced(key, handler, delay = 300) {
                if (!this.debouncedHandlers.has(key)) {
                    this.debouncedHandlers.set(key, performanceUtils.debounce(handler, delay, false, key));
                }
                return this.debouncedHandlers.get(key);
            },
            
            // Setup efficient event delegation for table
            initTableEvents() {
                const tableBody = domCache.tbody || document.querySelector('#data-table tbody');
                if (!tableBody) return;
                
                // Use optimized event delegation
                performanceOptimizer.delegateEvent(
                    tableBody,
                    'input',
                    'td[contenteditable]',
                    (event) => {
                        const cell = event.target;
                        const label = cell && cell.getAttribute ? cell.getAttribute('data-label') : 'unknown';
                        console.log('📝 [EXCEL-SAVE] Input detected in cell:', label, '- save on blur only');
                        isDirty = true;
                        isTyping = true;
                        lastEditAt = Date.now();
                        updateUserEditTime();
                    },
                    { debounceMs: 150 }
                );
                
                // Optimized scroll handler
                performanceOptimizer.delegateEvent(
                    window,
                    'scroll',
                    'body',
                    () => {
                        // Update any scroll-dependent UI
                    },
                    { throttleMs: 100 }
                );
            },
            
            // Cleanup unused handlers
            cleanup() {
                this.debouncedHandlers.clear();
                performanceOptimizer.dispose();
            },
            
            // Performance monitoring
            monitor: {
                startTime: performance.now(),
                metrics: {},
                
                mark(name) {
                    this.metrics[name] = performance.now() - this.startTime;
                },
                
                report() {
                    console.log('📊 Performance Metrics:', this.metrics);
                    return this.metrics;
                }
            }
        };
        
        // Make app state, DOM cache, performance utils, and event manager globally available
        window.appState = appState;
        window.domCache = domCache;
        window.performanceUtils = performanceUtils;
        window.performanceOptimizer = performanceOptimizer;
        window.eventManager = eventManager;
        window.syncOptimizer = syncOptimizer;
        window.cursorManager = cursorManager;
        
        // Application state variables
        let isDirty = false;
        let saveTimeout = null;
        let history = [];
        let historyDebounceTimeout = null;
        
        // ✅ GLOBAL: Variables pour la capture et restauration du focus
        let capturedFocusState = null;
        let focusRestorationEnabled = true;
        let isRestoringCursor = false; // Flag to prevent save cascades during restoration
        // Removed: now using RaceConditionGuard.getFlag('isExcelSaveInProgress')
        
        // Function to update global reference
        function updateGlobalFocusState(newState) {
            capturedFocusState = newState;
            window.capturedFocusState = newState;
            return newState;
        }
        
        // Excel-like save behavior - save only when moving between cells
        async function saveModifiedCell(cell, oldValue, newValue) {
            if (!cell || oldValue === newValue) return false;
            
            // Performance monitoring
            eventManager.monitor.mark('save-cell-start');
            
            console.log('💾 [EXCEL-SAVE] ========== EXCEL-LIKE SAVE START ==========');
            console.log('💾 [EXCEL-SAVE] Cell modified, saving immediately:', {
                column: cell.getAttribute('data-label'),
                oldValue: oldValue?.substring(0, 50) + (oldValue?.length > 50 ? '...' : ''),
                newValue: newValue?.substring(0, 50) + (newValue?.length > 50 ? '...' : ''),
                timestamp: new Date().toISOString()
            });
            
            // Capture cursor state before save
            const cursorState = cursorManager.captureFocus(cell, { saveType: 'excel', timestamp: Date.now() });
            
            // Show Excel-mode status
            updateStatus('Sauvegarde Excel-like en cours...', 'saving');
            
            // Capture focus state with enhanced protection
            const activeElement = document.activeElement;
            const protectionTimestamp = Date.now();
            
            if (activeElement && activeElement.tagName === 'TD' && activeElement.contentEditable === 'true') {
                updateGlobalFocusState({
                    element: activeElement,
                    position: getCaretOffsetWithin(activeElement),
                    timestamp: protectionTimestamp,
                    rowIndex: Array.from(activeElement.closest('tr').parentNode.querySelectorAll('tr')).indexOf(activeElement.closest('tr')),
                    colLabel: activeElement.getAttribute('data-label') || '',
                    excelSaveProtection: true // Special flag for Excel saves
                });
                console.log('📝 [EXCEL-SAVE] Enhanced focus captured on active cell:', activeElement.getAttribute('data-label'));
            } else {
                // If no active element, try to capture the cell that was just modified
                // Always position cursor at end of text content
                const textContent = cell.textContent || '';
                
                updateGlobalFocusState({
                    element: cell,
                    position: textContent.length, // Place cursor at end
                    timestamp: protectionTimestamp,
                    rowIndex: Array.from(cell.closest('tr').parentNode.querySelectorAll('tr')).indexOf(cell.closest('tr')),
                    colLabel: cell.getAttribute('data-label') || '',
                    excelSaveProtection: true // Special flag for Excel saves
                });
                console.log('📝 [EXCEL-SAVE] Enhanced focus captured on modified cell:', cell.getAttribute('data-label'));
            }
            
            try {
                // Use sync optimizer queue to prevent race conditions
                const saveOperation = async () => {
                    // Mark local save in progress to prevent realtime conflicts
                    window.isLocalSaveInProgress = true;
                    console.log('🔒 [EXCEL-SAVE] Local save in progress flag set');
                    
                    // Save to history and local draft first
                    console.log('💾 [EXCEL-SAVE] Saving to local history and draft...');
                    saveStateToHistory();
                    saveLocalDraft();
                    
                    // Then sync to database
                    console.log('💾 [EXCEL-SAVE] Syncing to database...');
                    await syncToMaster(false); // false = not manual save
                    
                    console.log('✅ [EXCEL-SAVE] Database sync completed successfully');
                    return true;
                };
                
                // Queue the save operation with high priority for Excel saves
                const saveId = await syncOptimizer.queueSave(saveOperation, 'excel', 10);
                
                updateStatus('Cellule sauvée (Excel-like)', 'success');
                eventManager.monitor.mark('save-cell-end');
                
                // Schedule cursor restoration after save
                if (cursorState) {
                    TimerManager.setTimeout(() => {
                        cursorManager.restoreFocus(cursorState, 50);
                    }, 200);
                }
                
                return true;
            } catch (error) {
                console.error('❌ [EXCEL-SAVE] Cell save failed:', error);
                updateStatus('Erreur sauvegarde cellule', 'error');
                eventManager.monitor.mark('save-cell-error');
                
                // Still try to restore cursor on error
                if (cursorState) {
                    cursorManager.restoreFocus(cursorState, 100);
                }
                
                return false;
            } finally {
                // Clear local save flag
                TimerManager.setTimeout(() => {
                    window.isLocalSaveInProgress = false;
                    console.log('🔓 [EXCEL-SAVE] Local save flag cleared');
                }, 500);
                TimerManager.setTimeout(() => {
                    RaceConditionGuard.clearFlag('isExcelSaveInProgress');
                    console.log('🔓 [EXCEL-SAVE] Excel save flag cleared - realtime sync re-enabled');
                }, 4000); // Extended to 4 seconds for better protection
                
                console.log('💾 [EXCEL-SAVE] ========== EXCEL-LIKE SAVE END ==========');
            }
        }
        
        // Persistent undo/redo stacks (per session)
        let operationHistory = []; // already-declared enhanced history (kept for clarity)
        let redoHistory = [];
        let isPerformingUndoRedo = false;
        let suppressRealtimeUntil = 0; // timestamp until which realtime updates are ignored
        let suppressAutosaveUntil = 0;  // timestamp until which autosave is paused
        let undoRedoSyncTimeout = null; // Timeout for automatic sync after undo/redo
        let isTyping = false;
        let lastEditAt = 0;
        let typingTimer = null;
        let isSyncing = false;
        let realtimeSubscription = null;
        let lastSaveTime = 0; // Timestamp de la dernière sauvegarde
        const REALTIME_COOLDOWN_MS = 2000; // 2 secondes de cooldown après sauvegarde
        
        // Enhanced undo system
        // operationHistory is declared above in the persistent stacks section
        let currentOperation = null; // Current operation being built
        let operationTimeout = null; // Timeout for operation completion
        
        // Excel-style operation types for undo/redo tracking
        const OPERATION_TYPES = {
            CELL_EDIT: 'cell_edit',           // Cell content modification
            ROW_INSERT: 'row_insert',         // Row insertion
            ROW_DELETE: 'row_delete',         // Row deletion (single or multiple)
            BULK_EDIT: 'bulk_edit'            // Multiple cell edits
        };
        
        // Only track real data changes (no colors, selections, or UI changes)
        const CONTENT_MODIFICATION_TYPES = [
            OPERATION_TYPES.CELL_EDIT,
            OPERATION_TYPES.ROW_INSERT,
            OPERATION_TYPES.ROW_DELETE,
            OPERATION_TYPES.BULK_EDIT
        ];
        
        // Cell edit grouping configuration
        const CELL_EDIT_GROUPING_DELAY = 1300; // 1.3 seconds to group typing edits
        let cellEditTimeout = null;
        let pendingCellEdit = null;
        
        // Excel-style cell edit tracking with grouping
        function trackCellEdit(cell, oldValue, newValue, columnLabel) {
            // Check if undo/redo is disabled
            if (snapshotMode === 'snapshot' || isViewMode) {
                return;
            }
            
            const row = cell.closest('tr');
            const rowKey = keyForRow(row);
            
            // Create cell edit data with stable addressing
            const cellEditData = {
                rowKey: rowKey,
                columnLabel: columnLabel,
                oldValue: oldValue,
                newValue: newValue,
                timestamp: Date.now()
            };
            
            // Clear existing timeout
            if (cellEditTimeout) {
                clearTimeout(cellEditTimeout);
            }
            
            // If we have a pending edit for the same cell, group them
            if (pendingCellEdit && 
                pendingCellEdit.rowKey === rowKey && 
                pendingCellEdit.columnLabel === columnLabel) {
                
                // Update the pending edit
                pendingCellEdit.newValue = newValue;
                pendingCellEdit.timestamp = Date.now();
                
                // Start operation if not already started
                if (!currentOperation || currentOperation.type !== OPERATION_TYPES.CELL_EDIT) {
                    startOperation(OPERATION_TYPES.CELL_EDIT, {
                        rowKey: rowKey,
                        columnLabel: columnLabel,
                        initialValue: pendingCellEdit.oldValue,
                        currentValue: newValue
                    });
                } else {
                    // Update existing operation
                    currentOperation.data.currentValue = newValue;
                    currentOperation.data.timestamp = Date.now();
                }
                
                // Clean: Removed debug log
            } else {
                // New cell edit - start fresh operation
                pendingCellEdit = cellEditData;
                
                startOperation(OPERATION_TYPES.CELL_EDIT, {
                    rowKey: rowKey,
                    columnLabel: columnLabel,
                    initialValue: oldValue,
                    currentValue: newValue
                });
                
                // Clean: Removed debug log
            }
            
            // Set timeout to complete operation after grouping delay
            cellEditTimeout = setTimeout(() => {
                if (currentOperation && currentOperation.type === OPERATION_TYPES.CELL_EDIT) {
                    // ENHANCED: Set suppression windows before completing operation
                    const SUPPRESSION_MS = 2000;
                    suppressRealtimeUntil = Date.now() + SUPPRESSION_MS;
                    suppressAutosaveUntil = Date.now() + SUPPRESSION_MS;
                    
                    // Clean: Removed debug log
                    
                    completeOperation();
                    pendingCellEdit = null;
                }
            }, CELL_EDIT_GROUPING_DELAY);
        }
        
        // Helper function to get column label for a cell
        function getColumnLabelForCell(cell) {
            const cellIndex = Array.from(cell.parentElement.cells).indexOf(cell);
            if (cellIndex >= 2) { // Skip No and Delete columns
                const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2);
                const headerIndex = cellIndex - 2;
                if (headers[headerIndex]) {
                    return headers[headerIndex].textContent;
                }
            }
            return 'Unknown Column';
        }
        
        // ENHANCED: Utility function to check if undo/redo operations are in progress
        function isUndoRedoInProgress() {
            return isPerformingUndoRedo || 
                   (currentOperation && currentOperation.type) ||
                   Date.now() < suppressAutosaveUntil ||
                   Date.now() < suppressRealtimeUntil;
        }
        
        // ENHANCED: Function to get current undo/redo status for debugging
        function getUndoRedoStatus() {
            return {
                isPerformingUndoRedo,
                hasCurrentOperation: !!(currentOperation && currentOperation.type),
                suppressAutosaveUntil: Date.now() < suppressAutosaveUntil,
                suppressRealtimeUntil: Date.now() < suppressRealtimeUntil,
                timeUntilAutosaveUnlock: Math.max(0, suppressAutosaveUntil - Date.now()),
                timeUntilRealtimeUnlock: Math.max(0, suppressRealtimeUntil - Date.now())
            };
        }
        
        // Utility function to get appropriate message length based on screen size
        function getAdaptiveMessage(shortMessage, longMessage, breakpoint = 1024) {
            return window.innerWidth <= breakpoint ? shortMessage : longMessage;
        }
        
                        // Autosave configuration
                const AUTOSAVE_DELAY_MS = 1000; // 1 second after last edit when idle
        let autosaveTicker = null;
        let lastShownCountdown = null;
        let lastFocusInfo = null;
        let lastCellPos = null;
        
        // Zoom functionality
        let zoomFactor = parseFloat(localStorage.getItem('zoomFactor') || '1');

        // Snapshot System State
        let snapshotMode = 'live'; // 'live' or 'snapshot'
        let currentSnapshotDate = null;
        let availableSnapshots = [];
        let currentSnapshotIndex = -1;
        
        // History bar visibility state (saved in localStorage)

        
        // Make snapshot system globally available
        window.snapshotMode = snapshotMode;
        window.currentSnapshotDate = currentSnapshotDate;
        window.availableSnapshots = availableSnapshots;
        window.currentSnapshotIndex = currentSnapshotIndex;

        window.realtimeSubscription = realtimeSubscription;
        
        // Make other important variables globally available
        window.isViewMode = false; // Will be updated in initializeApp
        window.isInitialLoad = true; // Will be set to false after initialization
        window.isRestoringFocus = false; // Flag to prevent edit events during focus restoration
        
        // Function to refresh calendar display
        function refreshSnapshotCalendar() {
            // Clean: Removed debug log
            populateSnapshotCalendar();
            updateHistoryNavigation();
        }
        
        // Function to clean storage and database completely
        async function cleanStorageAndDatabase() {
            try {
                // Clean: Removed debug log
                
                // First, clean the database
                const { error: dbError } = await supabase
                    .from('table_snapshots_index')
                    .delete()
                    .neq('id', '00000000-0000-0000-0000-000000000000');
                
                if (dbError) {
                    console.error('❌ Error cleaning database:', dbError);
                    return;
                }
                
                // Clean: Removed debug log
                
                // Then, clean the storage bucket
                const { data: storageFiles, error: listError } = await supabase.storage
                    .from('table-snapshots')
                    .list('', { limit: 1000 });
                
                if (listError) {
                    console.error('❌ Error listing storage files:', listError);
                    return;
                }
                
                if (storageFiles && storageFiles.length > 0) {
                    const fileNames = storageFiles.map(file => file.name);
                    // Clean: Removed debug log
                    
                    const { error: removeError } = await supabase.storage
                        .from('table-snapshots')
                        .remove(fileNames);
                    
                    if (removeError) {
                        console.error('❌ Error removing storage files:', removeError);
                    } else {
                        // Clean: Removed debug log
                    }
                } else {
                    // Clean: Removed debug log
                }
                
                // Create a fresh snapshot
                await createDemoSnapshot();
                
                showMessage('Storage et base de données complètement nettoyés', 'success');
                
            } catch (err) {
                console.error('❌ Error cleaning storage and database:', err);
                showMessage('Erreur lors du nettoyage complet', 'error');
            }
        }
        
        // Add logging function
        window.log = function(message, level = 'info') {
            console.log(`[${level.toUpperCase()}] ${message}`);
        };

        
        // Row color management
        let currentRowColor = localStorage.getItem('rowColor') || '#FFF59D';
        let rowColorMap = {};
        let isRowPaintDragging = false;
        let rowPaintAction = 'color';
        let paintMode = localStorage.getItem('rowPaintMode') || 'auto';
        let showOnlyColored = false;
        let isViewMode = localStorage.getItem('viewMode') === 'true';
        let isViewModeProtected = false;
        
        // Performance optimizations
        const MOBILE_DEBOUNCE_DELAY = 300;
        const DESKTOP_DEBOUNCE_DELAY = 150;
        
        // DOM element cache for performance
        const DOM_CACHE = {
            table: null,
            tableContainer: null,
            buttonBar: null,
            syncStatus: null,
            historyToggleBtn: null,
            historyBarContainer: null,
            init() {
                this.table = document.getElementById('data-table');
                this.tableContainer = document.getElementById('table-container');
                this.buttonBar = document.getElementById('button-bar');
                this.syncStatus = document.getElementById('sync-status');
                this.historyToggleBtn = document.getElementById('history-toggle-btn');
                this.historyBarContainer = document.getElementById('history-bar-container');
            },
            get(elementId) {
                if (!this[elementId]) {
                    this[elementId] = document.getElementById(elementId);
                }
                return this[elementId];
            }
        };
        
        // Optimized throttle function
        function throttle(func, delay) {
            let timeoutId;
            let lastExecTime = 0;
            return function (...args) {
                const currentTime = performance.now();
                
                if (currentTime - lastExecTime > delay) {
                    func.apply(this, args);
                    lastExecTime = currentTime;
                } else {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => {
                        func.apply(this, args);
                        lastExecTime = performance.now();
                    }, delay - (currentTime - lastExecTime));
                }
            };
        }
        
        // Batch DOM updates for performance
        const batchManager = {
            pending: new Set(),
            rafId: null,
            
            schedule(fn) {
                this.pending.add(fn);
                if (!this.rafId) {
                    this.rafId = requestAnimationFrame(() => this.flush());
                }
            },
            
            flush() {
                const batch = Array.from(this.pending);
                this.pending.clear();
                this.rafId = null;
                
                // Execute all pending updates in a single frame
                for (const fn of batch) {
                    try {
                        fn();
                    } catch (error) {
                        console.error('Batch update error:', error);
                    }
                }
            }
        };
        
        // Optimized event delegation
        const eventDelegator = {
            handlers: new Map(),
            
            register(element, eventType, selector, handler) {
                const key = `${eventType}-${selector}`;
                if (!this.handlers.has(key)) {
                    this.handlers.set(key, handler);
                    element.addEventListener(eventType, (e) => {
                        if (e.target.matches(selector)) {
                            handler(e);
                        }
                    }, { passive: true });
                }
            }
        };
        
        // Efficient DOM manipulation utilities
        const DOMUtils = {
            // Fragment-based batch updates
            createFragment() {
                return document.createDocumentFragment();
            },
            
            // Efficient class manipulation
            toggleClass(element, className, condition) {
                if (condition !== undefined) {
                    element.classList.toggle(className, condition);
                } else {
                    element.classList.toggle(className);
                }
            },
            
            // Batched style updates
            setStyles(element, styles) {
                const cssText = Object.entries(styles)
                    .map(([prop, value]) => `${prop}: ${value}`)
                    .join('; ');
                element.style.cssText += '; ' + cssText;
            },
            
            // Efficient innerHTML replacement with DocumentFragment
            replaceContent(element, html) {
                const template = document.createElement('template');
                template.innerHTML = html;
                const fragment = template.content.cloneNode(true);
                element.replaceChildren(fragment);
            },
            
            // Optimized element creation with attributes
            createElement(tag, attributes = {}, textContent = '') {
                const element = document.createElement(tag);
                if (textContent) element.textContent = textContent;
                
                for (const [key, value] of Object.entries(attributes)) {
                    if (key === 'className') {
                        element.className = value;
                    } else if (key.startsWith('data-')) {
                        element.setAttribute(key, value);
                    } else {
                        element[key] = value;
                    }
                }
                return element;
            }
        };
        
        // Performance monitoring and cleanup
        const PerformanceMonitor = {
            metrics: new Map(),
            observers: new Set(),
            
            // Start timing a operation
            start(label) {
                this.metrics.set(label, performance.now());
            },
            
            // End timing and log result
            end(label) {
                const startTime = this.metrics.get(label);
                if (startTime) {
                    const duration = performance.now() - startTime;
                    console.log(`⏱️ ${label}: ${duration.toFixed(2)}ms`);
                    this.metrics.delete(label);
                    return duration;
                }
            },
            
            // Monitor memory usage
            checkMemory() {
                if (performance.memory) {
                    const { usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit } = performance.memory;
                    const usage = (usedJSHeapSize / jsHeapSizeLimit * 100).toFixed(2);
                    console.log(`💾 Memory usage: ${usage}% (${(usedJSHeapSize / 1024 / 1024).toFixed(2)}MB)`);
                }
            },
            
            // Setup intersection observer for lazy loading
            setupIntersectionObserver(callback, options = {}) {
                const observer = new IntersectionObserver(callback, {
                    rootMargin: '50px',
                    threshold: 0.1,
                    ...options
                });
                this.observers.add(observer);
                return observer;
            },
            
            // Cleanup all observers
            cleanup() {
                for (const observer of this.observers) {
                    observer.disconnect();
                }
                this.observers.clear();
                this.metrics.clear();
            }
        };
        
        // Memory management utilities
        const MemoryManager = {
            cache: new Map(),
            maxCacheSize: 100,
            
            // Efficient caching with LRU eviction
            set(key, value) {
                if (this.cache.size >= this.maxCacheSize) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }
                this.cache.set(key, value);
            },
            
            get(key) {
                if (this.cache.has(key)) {
                    const value = this.cache.get(key);
                    // Move to end (most recent)
                    this.cache.delete(key);
                    this.cache.set(key, value);
                    return value;
                }
                return null;
            },
            
            clear() {
                this.cache.clear();
            },
            
            // Clean up event listeners
            cleanupEventListeners() {
                // Remove unused event listeners to prevent memory leaks
                const unusedElements = document.querySelectorAll('[data-cleanup]');
                unusedElements.forEach(element => {
                    element.remove();
                });
            }
        };
        
        // Initialize performance monitoring
        EventListenerManager.addEventListener(window, 'load', () => {
            PerformanceMonitor.start('page-load');
            DOM_CACHE.init();
            
            // Complete page load timing
            TimerManager.setTimeout(() => {
                PerformanceMonitor.end('page-load');
            }, 0);
            
            // Check performance periodically with low impact
            TimerManager.setInterval(() => {
                if (Math.random() < 0.1) { // 10% chance
                    requestIdleCallback(() => {
                        PerformanceMonitor.checkMemory();
                    });
                }
            }, 30000, 'performance-monitor'); // Every 30 seconds
            
            // Initialize button bar scroll behavior
            TimerManager.setTimeout(() => {
                if (typeof updateButtonBarScroll === 'function') {
                    updateButtonBarScroll();
                }
            }, 100);
            
            // Initialize mobile keyboard detection
            TimerManager.setTimeout(() => {
                if (typeof setupMobileKeyboardDetection === 'function') {
                    setupMobileKeyboardDetection();
                }
            }, 200);
            
            // Initialize mobile zoom prevention
            TimerManager.setTimeout(() => {
                if (typeof setupMobileZoomPrevention === 'function') {
                    setupMobileZoomPrevention();
                }
            }, 300);
        });
        
        // Cleanup system - prevent memory leaks on page unload
        EventListenerManager.addEventListener(window, 'beforeunload', () => {
            EventListenerManager.cleanup();
            TimerManager.cleanup();
        });
        
        // Also cleanup when the page becomes hidden (mobile apps, tab switching)
        EventListenerManager.addEventListener(document, 'visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                // Optional: pause expensive operations
                console.log('Page hidden - consider pausing operations');
            }
        });
        
        // Add resize listener to adapt messages when screen size changes
        EventListenerManager.addEventListener(window, 'resize', () => {
            // Debounce resize events to avoid excessive updates
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(() => {
                // Update status display when screen size changes
                if (typeof adaptStatusDisplay === 'function') {
                    adaptStatusDisplay();
                }
                // Update button bar scroll behavior
                updateButtonBarScroll();
            }, 250);
        });
        
        // Mobile keyboard detection and cell selection management
        let mobileKeyboardVisible = false;
        let lastViewportHeight = window.innerHeight;
        let keyboardDetectionTimeout = null;
        
        // Function to detect mobile keyboard visibility
        function detectMobileKeyboard() {
            const currentHeight = window.innerHeight;
            const heightDifference = lastViewportHeight - currentHeight;
            
            // Keyboard is likely visible if height decreased significantly
            if (heightDifference > 150) {
                if (!mobileKeyboardVisible) {
                    mobileKeyboardVisible = true;
                    console.log('📱 Mobile keyboard detected as visible');
                }
            } else if (heightDifference < -50) {
                // Keyboard is likely hidden
                if (mobileKeyboardVisible) {
                    mobileKeyboardVisible = false;
                    console.log('📱 Mobile keyboard detected as hidden');
                    
                    // Remove cell selection when keyboard is hidden
                    removeCellSelection();
                }
            }
            
            lastViewportHeight = currentHeight;
        }
        
        // Function to remove cell selection
        function removeCellSelection() {
            const selectedCells = document.querySelectorAll('.editable-cell.selected');
            selectedCells.forEach(cell => {
                cell.classList.remove('selected');
                cell.blur();
            });
            
            // Also remove focus from any focused editable cells
            const focusedCells = document.querySelectorAll('.editable-cell:focus');
            focusedCells.forEach(cell => {
                cell.classList.remove('selected');
                cell.blur();
            });
            
            console.log('🔓 Cell selection removed after keyboard hide');
        }
        
        // Enhanced viewport change detection for mobile
        function setupMobileKeyboardDetection() {
            if (window.innerWidth <= 768) {
                // Use visual viewport API if available (more reliable)
                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', () => {
                        clearTimeout(keyboardDetectionTimeout);
                        keyboardDetectionTimeout = setTimeout(detectMobileKeyboard, 100);
                    });
                } else {
                    // Fallback to window resize events
                    window.addEventListener('resize', () => {
                        clearTimeout(keyboardDetectionTimeout);
                        keyboardDetectionTimeout = setTimeout(detectMobileKeyboard, 100);
                    });
                }
                
                // Additional detection for iOS Safari
                if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
                    // iOS-specific keyboard detection
                    document.addEventListener('focusin', (e) => {
                        if (e.target && e.target.contentEditable === 'true') {
                            mobileKeyboardVisible = true;
                            console.log('📱 iOS: Keyboard likely visible (focusin on editable cell)');
                        }
                    });
                    
                    document.addEventListener('focusout', (e) => {
                        if (e.target && e.target.contentEditable === 'true') {
                            // Small delay to allow for keyboard hide animation
                            TimerManager.setTimeout(() => {
                                if (!document.activeElement || document.activeElement.contentEditable !== 'true') {
                                    mobileKeyboardVisible = false;
                                    console.log('📱 iOS: Keyboard likely hidden (focusout from editable cell)');
                                    removeCellSelection();
                                }
                            }, 300);
                        }
                    });
                }
                
                console.log('📱 Mobile keyboard detection initialized');
            }
        }
        
        // Function to update button bar scroll behavior based on screen size
        function updateButtonBarScroll() {
            const buttonBar = document.getElementById('button-bar');
            if (!buttonBar) return;
            
            if (window.innerWidth <= 1024) {
                // Enable horizontal scroll on small screens
                buttonBar.style.overflowX = 'auto';
                buttonBar.style.flexWrap = 'nowrap';
                buttonBar.style.justifyContent = 'flex-start';
                
                // Add smooth scroll behavior
                buttonBar.style.scrollBehavior = 'smooth';
                
                // Auto-scroll to show active buttons if needed
                TimerManager.setTimeout(() => {
                    const activeButton = buttonBar.querySelector('.bg-blue-500, .bg-green-500, .bg-yellow-500');
                    if (activeButton) {
                        activeButton.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                    }
                }, 100);
                
                // Add touch scroll support for mobile
                addTouchScrollSupport(buttonBar);
            } else {
                // Disable horizontal scroll on large screens
                buttonBar.style.overflowX = 'hidden';
                buttonBar.style.flexWrap = 'wrap';
                buttonBar.style.justifyContent = 'flex-end';
                buttonBar.style.scrollBehavior = 'auto';
                
                // Remove touch scroll support
                removeTouchScrollSupport(buttonBar);
            }
        }
        
        // Add touch-friendly horizontal scrolling support
        function addTouchScrollSupport(element) {
            if (element._touchScrollAdded) return;
            
            let isScrolling = false;
            let startX = 0;
            let startScrollLeft = 0;
            
            const handleTouchStart = (e) => {
                isScrolling = true;
                startX = e.touches[0].pageX;
                startScrollLeft = element.scrollLeft;
                element.style.scrollBehavior = 'auto';
            };
            
            const handleTouchMove = (e) => {
                if (!isScrolling) return;
                
                const x = e.touches[0].pageX;
                const walk = (startX - x) * 1.5; // Scroll speed multiplier
                element.scrollLeft = startScrollLeft + walk;
                
                // Prevent default to avoid page scroll
                e.preventDefault();
            };
            
            const handleTouchEnd = () => {
                isScrolling = false;
                element.style.scrollBehavior = 'smooth';
            };
            
            element.addEventListener('touchstart', handleTouchStart, { passive: false });
            element.addEventListener('touchmove', handleTouchMove, { passive: false });
            element.addEventListener('touchend', handleTouchEnd);
            
            element._touchScrollAdded = true;
            element._touchScrollHandlers = { handleTouchStart, handleTouchMove, handleTouchEnd };
        }
        
        // Remove touch scroll support
        function removeTouchScrollSupport(element) {
            if (!element._touchScrollAdded) return;
            
            const handlers = element._touchScrollHandlers;
            element.removeEventListener('touchstart', handlers.handleTouchStart);
            element.removeEventListener('touchmove', handlers.handleTouchMove);
            element.removeEventListener('touchend', handlers.handleTouchEnd);
            
            element._touchScrollAdded = false;
            delete element._touchScrollHandlers;
        }
        
        // Global function to manually remove cell selection (for testing)
        window.removeCellSelection = removeCellSelection;
        window.detectMobileKeyboard = detectMobileKeyboard;
        window.mobileKeyboardVisible = () => mobileKeyboardVisible;
        
        // Enhanced message management functions
        window.dismissMessage = function() {
            const box = document.getElementById('message-box');
            if (box) {
                box.classList.remove('show');
                setTimeout(() => box.classList.add('hidden'), 500);
                if (window._msgTimer) {
                    clearTimeout(window._msgTimer);
                    window._msgTimer = null;
                }
            }
        };
        
        window.showMessage = showMessage;
        
        // Enhanced mobile experience: prevent zoom on double-tap
        function setupMobileZoomPrevention() {
            if (window.innerWidth <= 768) {
                let lastTouchEnd = 0;
                
                document.addEventListener('touchend', (event) => {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        event.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);
                
                // Prevent zoom on input focus for iOS
                document.addEventListener('gesturestart', (e) => {
                    e.preventDefault();
                });
                
                document.addEventListener('gesturechange', (e) => {
                    e.preventDefault();
                });
                
                document.addEventListener('gestureend', (e) => {
                    e.preventDefault();
                });
            }
        }
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            PerformanceMonitor.cleanup();
            MemoryManager.clear();
        });
        
        // Protection globale: wrapper pour toutes les fonctions de sauvegarde
        function protectedSaveStateToHistory() {
            if (isViewMode && isMobile()) {
                console.log('🔒 Global protection: saveStateToHistory BLOCKED');
                return;
            }
            return saveStateToHistory();
        }
        
        // Initialize from localStorage
        try { 
            lastFocusInfo = JSON.parse(localStorage.getItem('lastFocusInfo') || 'null'); 
            
            // Forcer l'affichage du bouton d'ajout au démarrage (en respectant le mode visualisation)
            const fabAdd = document.getElementById('fab-add');
            if (fabAdd) {
                fabAdd.style.display = 'flex';
                fabAdd.style.visibility = 'visible';
                
                if (isViewMode) {
                    // Mode visualisation : bouton visible mais désactivé
                    fabAdd.style.opacity = '0.5';
                    fabAdd.style.pointerEvents = 'none';
                    fabAdd.style.cursor = 'not-allowed';
                    fabAdd.title = 'Mode visualisation actif - Ajout de lignes désactivé';
                } else {
                    // Mode normal : bouton pleinement fonctionnel
                    fabAdd.style.opacity = '1';
                    fabAdd.style.pointerEvents = 'auto';
                    fabAdd.style.cursor = 'pointer';
                    fabAdd.title = 'Ajouter une nouvelle ligne';
                }
                
                // Clean: Removed debug log
            }
        } catch(_) { 
            lastFocusInfo = null; 
        }
        
        try { 
            lastCellPos = JSON.parse(localStorage.getItem('lastCellPos') || 'null'); 
        } catch(_) { 
            lastCellPos = null; 
        }
        
        try { 
            rowColorMap = JSON.parse(localStorage.getItem('rowColors') || '{}'); 
        } catch(_) { 
            rowColorMap = {}; 
        }

        // Excel-style operation tracking - only real data changes
        function startOperation(type, data = {}) {
            // Check if undo/redo is disabled
            if (snapshotMode === 'snapshot' || isViewMode) {
                // Clean: Removed debug log
                return;
            }
            
            // Only track operations that modify table content
            if (!CONTENT_MODIFICATION_TYPES.includes(type)) {
                // Clean: Removed debug log
                return;
            }
            
            // Clear any pending operations first
            if (currentOperation) {
                // Clean: Removed debug log
                completeOperation();
            }
            
            // Clear any operation timeout
            clearOperationTimeout();
            
            // Reset undo/redo sync timeout when starting new operations
            clearUndoRedoSyncTimeout();
            
            // For row operations, check if there are conflicting operations in history
            if (type === OPERATION_TYPES.ROW_INSERT || 
                type === OPERATION_TYPES.ROW_DELETE) {
                
                // Clean up any conflicting row operations in history
                const conflictingOps = operationHistory.filter(op => 
                    op.type === OPERATION_TYPES.ROW_INSERT || 
                    op.type === OPERATION_TYPES.ROW_DELETE
                );
                
                if (conflictingOps.length > 0) {
                    // Clean: Removed debug log
                    operationHistory = operationHistory.filter(op => 
                        op.type !== OPERATION_TYPES.ROW_INSERT && 
                        op.type !== OPERATION_TYPES.ROW_DELETE
                    );
                }
            }
            
            currentOperation = {
                type: type,
                data: data,
                timestamp: Date.now(),
                tableState: collectTableData(),
                rowColors: { ...rowColorMap }
            };
            
                            // Clean: Removed debug log
        }
        
        function addToOperation(data) {
            if (currentOperation && CONTENT_MODIFICATION_TYPES.includes(currentOperation.type)) {
                Object.assign(currentOperation.data, data);
                // Clean: Removed debug log
                
                // Excel-style: Clear redo stack on ANY modification
                redoHistory = [];
                                    // Clean: Removed debug log
            }
            persistHistoryStacks();
        }
        
        function completeOperation() {
            if (currentOperation) {
                // Only complete operations that modify table content
                if (!CONTENT_MODIFICATION_TYPES.includes(currentOperation.type)) {
                    // Clean: Removed debug log
                    currentOperation = null;
                    return;
                }
                
                // Add final table state
                currentOperation.finalState = collectTableData();
                currentOperation.finalRowColors = { ...rowColorMap };
                
                // Add to operation history
                operationHistory.push(currentOperation);
                
                // Excel-style: Clear redo stack on ANY new user modification
                redoHistory = [];
                // Clean: Removed debug log
                
                persistHistoryStacks();
                
                // Keep exactly 10 operations for circular history navigation
                if (operationHistory.length > 10) {
                    const toRemove = operationHistory.length - 10;
                    for (let i = 0; i < toRemove; i++) {
                        operationHistory.shift();
                    }
                    // Clean: Removed debug log
                }
                
                // Clean: Removed debug log
                
                // Also save to regular history for backward compatibility
                saveStateToHistory();
                
                currentOperation = null;
                updateUndoButtonState();
            }
        }
        
        function cancelOperation() {
            if (currentOperation) {
                // Clean: Removed debug log
                currentOperation = null;
            }
        }

        // Persist/restore undo/redo stacks in sessionStorage
        function persistHistoryStacks() {
            try {
                sessionStorage.setItem('operationHistory', JSON.stringify(operationHistory));
                sessionStorage.setItem('redoHistory', JSON.stringify(redoHistory));
            } catch(_) {}
        }
        function restoreHistoryStacks() {
            try {
                const ops = JSON.parse(sessionStorage.getItem('operationHistory') || '[]');
                const red = JSON.parse(sessionStorage.getItem('redoHistory') || '[]');
                
                // Enhanced validation for operation history
                if (Array.isArray(ops)) {
                    operationHistory = ops.filter(op => 
                        op && op.type && OPERATION_TYPES[Object.keys(OPERATION_TYPES).find(k => OPERATION_TYPES[k] === op.type)]
                    );
                } else {
                    operationHistory = [];
                }
                
                // Enhanced validation for redo history
                if (Array.isArray(red)) {
                    redoHistory = red.filter(op => 
                        op && op.type && OPERATION_TYPES[Object.keys(OPERATION_TYPES).find(k => OPERATION_TYPES[k] === op.type)]
                    );
                } else {
                    redoHistory = [];
                }
                
                log(`📚 Restored ${operationHistory.length} undo operations, ${redoHistory.length} redo operations`, 'info');
            } catch(error) {
                console.warn('⚠️ Error restoring history stacks:', error);
                operationHistory = [];
                redoHistory = [];
            }
            updateUndoButtonState();
        }
        
        // Enhanced undo function - performs 2 operations with 1 click
        function undo() {
            // Check if we have operations to undo
            if (operationHistory.length === 0) {
                log('Aucune opération à annuler.', 'info');
                return;
            }
            
            // Perform 2 undo operations in sequence
            const operationsToUndo = [];
            
            // Get first operation
            if (operationHistory.length > 0) {
                operationsToUndo.push(operationHistory.pop());
            }
            
            // Get second operation if available
            if (operationHistory.length > 0) {
                operationsToUndo.push(operationHistory.pop());
            }
            
            console.log(`🔄 Undoing ${operationsToUndo.length} operation(s)`);
            
            try {
                // Set flag to prevent interference
                isPerformingUndoRedo = true;
                
                // Clear any pending operations
                if (currentOperation) {
                    currentOperation = null;
                }
                clearOperationTimeout();
                
                // Use the oldest operation's table state for restoration (to go back 2 steps)
                let operationToRestore = operationsToUndo[operationsToUndo.length - 1]; // Get the oldest (second) operation
                if (!operationToRestore && operationsToUndo.length > 0) {
                    operationToRestore = operationsToUndo[0]; // Fallback to first if only one operation
                }
                
                // Direct table restoration - simplified logic
                if (operationToRestore && operationToRestore.tableState && operationToRestore.tableState.rows && Array.isArray(operationToRestore.tableState.rows)) {
                    console.log(`📊 Restoring table state from operation: ${operationToRestore.type}`);
                    loadTableData(operationToRestore.tableState.rows);
                } else {
                    console.warn('⚠️ No valid table state found for restoration');
                }
                
                // Restore row colors from the oldest operation if available
                if (operationToRestore && operationToRestore.rowColors) {
                    rowColorMap = { ...operationToRestore.rowColors };
                    persistRowColors();
                    
                    // Apply colors to visible rows
                    Array.from(document.querySelectorAll('#table-body tr')).forEach(tr => {
                        const k = keyForRow(tr);
                        const c = rowColorMap[k];
                        if (c && c !== '') {
                            setRowColor(tr, c);
                        }
                    });
                }
                
                // Move ALL undone operations to redo stack
                operationsToUndo.forEach(operation => {
                    redoHistory.push(operation);
                });
                
                // Keep redo stack limited to 10 operations
                while (redoHistory.length > 10) {
                    redoHistory.shift();
                }
                
                console.log(`📚 Added ${operationsToUndo.length} operation(s) to redo stack`);
                
                // Update states and persistence
                persistHistoryStacks();
                updateUndoButtonState();
                
                // 🔄 AUTOMATIC SAVE after undo operation
                console.log('💾 Triggering automatic save after undo...');
                
                // Show brief save indicator
                if (typeof showMessage === 'function') {
                    showMessage('💾 Sauvegarde automatique...', 'info', 1000);
                }
                
                TimerManager.setTimeout(() => {
                    try {
                        // Save locally first (fast backup)
                        if (typeof saveLocalDraft === 'function') {
                            saveLocalDraft();
                        }
                        
                        // Then sync to master database
                        if (typeof syncToMaster === 'function') {
                            syncToMaster(true, false); // Manual save, no pruning
                            console.log('✅ Automatic save completed after undo');
                            
                            // Show success message briefly
                            TimerManager.setTimeout(() => {
                                if (typeof showMessage === 'function') {
                                    showMessage('✅ Sauvegardé', 'success', 1500);
                                }
                            }, 200);
                        }
                    } catch (saveError) {
                        console.error('❌ Error during automatic save after undo:', saveError);
                        if (typeof showMessage === 'function') {
                            showMessage('❌ Erreur de sauvegarde', 'error', 2000);
                        }
                    }
                }, 100); // Small delay to ensure undo is fully complete
                
            } catch (error) {
                console.error('❌ Error during undo:', error);
                // Re-add operation if failed
                operationHistory.push(lastOperation);
            } finally {
                isPerformingUndoRedo = false;
            }
        }

        // Redo function - restores 2 operations to match undo behavior
        function redo() {
            if (isPerformingUndoRedo) {
                log('⚠️ Opération undo/redo déjà en cours, veuillez patienter.', 'warning');
                return;
            }
            
            if (redoHistory.length === 0) {
                log('Aucune opération à rétablir.', 'info');
                return;
            }
            
            // Get up to 2 operations from redo stack
            const operationsToRedo = [];
            
            // Get first operation
            if (redoHistory.length > 0) {
                operationsToRedo.push(redoHistory.pop());
            }
            
            // Get second operation if available
            if (redoHistory.length > 0) {
                operationsToRedo.push(redoHistory.pop());
            }
            
            console.log(`🔄 Redoing ${operationsToRedo.length} operation(s)`);
            
            try {
                isPerformingUndoRedo = true;
                clearOperationTimeout();
                
                // Use the most recent operation's final state for restoration (to go forward 2 steps)
                let operationToRestore = operationsToRedo[0]; // Get the most recent operation
                
                // Re-apply the final state of the operation - only if we have valid data
                if (operationToRestore && operationToRestore.finalState && operationToRestore.finalState.rows && Array.isArray(operationToRestore.finalState.rows)) {
                    console.log(`📊 Restoring final state from operation: ${operationToRestore.type}`);
                    loadTableData(operationToRestore.finalState.rows);
                } else {
                    console.warn('⚠️ No valid final state found for redo restoration');
                }
                
                // Restore row colors from the most recent operation if available
                if (operationToRestore && operationToRestore.finalRowColors) {
                    rowColorMap = { ...operationToRestore.finalRowColors };
                    persistRowColors();
                    Array.from(document.querySelectorAll('#table-body tr')).forEach(tr => {
                        const k = keyForRow(tr);
                        const c = rowColorMap[k];
                        if (c && c !== '') setRowColor(tr, c);
                    });
                }
                
                // After redoing, push ALL operations back to operation history
                operationsToRedo.reverse().forEach(operation => {
                    operationHistory.push(operation);
                });
                
                // Keep operation history limited
                while (operationHistory.length > 10) {
                    operationHistory.shift();
                }
                
                persistHistoryStacks();
                updateUndoButtonState();
                
                console.log(`📚 Added ${operationsToRedo.length} operation(s) back to history`);
                
                // 🔄 AUTOMATIC SAVE after redo operation
                console.log('💾 Triggering automatic save after redo...');
                
                // Show brief save indicator
                if (typeof showMessage === 'function') {
                    showMessage('💾 Sauvegarde automatique...', 'info', 1000);
                }
                
                TimerManager.setTimeout(() => {
                    try {
                        // Save locally first (fast backup)
                        if (typeof saveLocalDraft === 'function') {
                            saveLocalDraft();
                        }
                        
                        // Then sync to master database
                        if (typeof syncToMaster === 'function') {
                            syncToMaster(true, false); // Manual save, no pruning
                            console.log('✅ Automatic save completed after redo');
                            
                            // Show success message briefly
                            TimerManager.setTimeout(() => {
                                if (typeof showMessage === 'function') {
                                    showMessage('✅ Sauvegardé', 'success', 1500);
                                }
                            }, 200);
                        }
                    } catch (saveError) {
                        console.error('❌ Error during automatic save after redo:', saveError);
                        if (typeof showMessage === 'function') {
                            showMessage('❌ Erreur de sauvegarde', 'error', 2000);
                        }
                    }
                }, 100); // Small delay to ensure redo is fully complete
                
            } catch (e) {
                console.error('❌ Error during redo:', e);
                log('Erreur lors du rétablissement.', 'error');
            } finally {
                isPerformingUndoRedo = false;
            }
        }
        

        
        // ENHANCED: Function to get detailed operation description for display
        function getOperationDescription(operation) {
            switch (operation.type) {
                case OPERATION_TYPES.CELL_EDIT:
                    const cellInfo = operation.data.columnLabel || 'cellule';
                    const rowInfo = operation.data.rowKey ? `ligne ${operation.data.rowKey}` : '';
                    const oldValue = operation.data.initialValue || '';
                    const newValue = operation.data.currentValue || '';
                    if (oldValue && newValue) {
                        return `Modification: ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''} - "${oldValue}" → "${newValue}"`;
                    }
                    return `Modification: ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''}`;
                case OPERATION_TYPES.ROW_INSERT:
                    return 'Insertion de ligne';
                case OPERATION_TYPES.ROW_DELETE:
                    if (operation.data.deletedRows && operation.data.deletedRows > 1) {
                        return `Suppression de ${operation.data.deletedRows} ligne(s)`;
                    }
                    return 'Suppression de ligne';
                case OPERATION_TYPES.BULK_EDIT:
                    if (operation.data.edits && operation.data.edits.length > 0) {
                        return `Modifications en lot: ${operation.data.edits.length} cellule(s) modifiée(s)`;
                    }
                    return 'Modifications en lot';
                default:
                    return 'Opération';
            }
        }
        
        // ENHANCED: Function to get detailed operation description for undo/redo messages
        function getDetailedOperationDescription(operation, isUndo = true) {
            switch (operation.type) {
                case OPERATION_TYPES.CELL_EDIT:
                    const cellInfo = operation.data.columnLabel || 'cellule';
                    const rowInfo = operation.data.rowKey ? `ligne ${operation.data.rowKey}` : '';
                    const oldValue = operation.data.initialValue || '';
                    const newValue = operation.data.currentValue || '';
                    
                    if (isUndo) {
                        if (oldValue && newValue) {
                            return `🔄 Annulation: ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''} - "${newValue}" → "${oldValue}"`;
                        }
                        return `🔄 Annulation: modification de ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''}`;
                    } else {
                        if (oldValue && newValue) {
                            return `⏩ Rétablissement: ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''} - "${oldValue}" → "${newValue}"`;
                        }
                        return `⏩ Rétablissement: modification de ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''}`;
                    }
                    
                case OPERATION_TYPES.ROW_INSERT:
                    if (isUndo) {
                        return `🔄 Annulation: suppression de la ligne insérée`;
                    } else {
                        return `⏩ Rétablissement: insertion de ligne`;
                    }
                    
                case OPERATION_TYPES.ROW_DELETE:
                    if (operation.data.deletedRows && operation.data.deletedRows > 1) {
                        if (isUndo) {
                            return `🔄 Annulation: restauration de ${operation.data.deletedRows} ligne(s) supprimée(s)`;
                        } else {
                            return `⏩ Rétablissement: suppression de ${operation.data.deletedRows} ligne(s)`;
                        }
                    } else {
                        if (isUndo) {
                            return `🔄 Annulation: restauration de la ligne supprimée`;
                        } else {
                            return `⏩ Rétablissement: suppression de ligne`;
                        }
                    }
                    
                case OPERATION_TYPES.BULK_EDIT:
                    if (operation.data.edits && operation.data.edits.length > 0) {
                        if (isUndo) {
                            return `🔄 Annulation: restauration de ${operation.data.edits.length} modification(s) de cellule(s)`;
                        } else {
                            return `⏩ Rétablissement: ${operation.data.edits.length} modification(s) de cellule(s)`;
                        }
                    } else {
                        if (isUndo) {
                            return `🔄 Annulation: restauration des modifications en lot`;
                        } else {
                            return `⏩ Rétablissement: modifications en lot`;
                        }
                    }
                    
                default:
                    if (isUndo) {
                        return `🔄 Annulation: ${operation.type}`;
                    } else {
                        return `⏩ Rétablissement: ${operation.type}`;
                    }
            }
        }
        
        // Clean: Removed debug function for production
        
        // Expose undo/redo functions globally so buttons can access them
        window.undo = undo;
        window.redo = redo;
        window.getDetailedOperationDescription = getDetailedOperationDescription;
        
        // Function to clear operation timeout
        function clearOperationTimeout() {
            if (operationTimeout) {
                clearTimeout(operationTimeout);
                operationTimeout = null;
            }
        }
        
        // Function to schedule automatic sync after undo/redo operations
        function scheduleUndoRedoSync() {
            // Clear any existing timeout
            if (undoRedoSyncTimeout) {
                clearTimeout(undoRedoSyncTimeout);
            }
            
            // Schedule sync after 500ms of user inactivity
            undoRedoSyncTimeout = setTimeout(() => {
                if (!isPerformingUndoRedo) {
                    // Clean: Removed debug log
                    syncToMaster(true);
                    undoRedoSyncTimeout = null;
                }
            }, 500);
        }
        
        // Function to group multiple cell edits into a single operation
        function groupCellEdits() {
            if (currentOperation && currentOperation.type === OPERATION_TYPES.CELL_EDIT) {
                // If we have multiple cell edits, group them into a bulk edit
                if (currentOperation.data.editCount > 1) {
                    currentOperation.type = OPERATION_TYPES.BULK_EDIT;
                    currentOperation.data.description = `${currentOperation.data.editCount} modifications de cellules`;
                    // Clean: Removed debug log
                }
            }
        }
        
        // Function to clear undo/redo sync timeout
        function clearUndoRedoSyncTimeout() {
            if (undoRedoSyncTimeout) {
                clearTimeout(undoRedoSyncTimeout);
                undoRedoSyncTimeout = null;
            }
        }
        
        // Enhanced timeout cleanup for better memory management
        function clearAllUndoRedoTimeouts() {
            clearUndoRedoSyncTimeout();
            if (cellEditTimeout) {
                clearTimeout(cellEditTimeout);
                cellEditTimeout = null;
            }
            clearOperationTimeout();
        }
        
        // Debugging function for undo/redo system
        function debugUndoRedoSystem() {
            const debugInfo = {
                operationHistoryLength: operationHistory.length,
                redoHistoryLength: redoHistory.length,
                isPerformingUndoRedo,
                currentOperation: currentOperation ? {
                    type: currentOperation.type,
                    timestamp: currentOperation.timestamp
                } : null,
                suppressRealtimeUntil: new Date(suppressRealtimeUntil).toISOString(),
                suppressAutosaveUntil: new Date(suppressAutosaveUntil).toISOString(),
                pendingTimeouts: {
                    cellEditTimeout: !!cellEditTimeout,
                    undoRedoSyncTimeout: !!undoRedoSyncTimeout
                },
                lastOperations: operationHistory.slice(-3).map(op => ({
                    type: op.type,
                    timestamp: op.timestamp,
                    hasData: !!op.data,
                    hasTableState: !!(op.tableState && op.tableState.rows)
                }))
            };
            
            console.group('🔍 Undo/Redo System Debug Info');
            console.table(debugInfo);
            console.log('📝 Operation History:', operationHistory);
            console.log('🔄 Redo History:', redoHistory);
            console.groupEnd();
            
            return debugInfo;
        }
        
        // Make debug function globally available
        window.debugUndoRedoSystem = debugUndoRedoSystem;
        
        // Handle page unload to complete pending operations
        window.addEventListener('beforeunload', () => {
            if (currentOperation) {
                completeOperation();
            }
            clearOperationTimeout();
            clearUndoRedoSyncTimeout();
            
            // Cleanup all timers to prevent infinite loops
            cleanupAllTimers();
        });
        
        // Handle page visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && currentOperation) {
                completeOperation();
            }
            clearUndoRedoSyncTimeout();
        });
        
        // Function to reset operation history (useful for testing)
        function resetOperationHistory() {
            operationHistory = [];
            if (currentOperation) {
                currentOperation = null;
            }
            clearOperationTimeout();
            updateUndoButtonState();
            // Clean: Removed debug log
        }
        
        // Function to safely start new operations after undo
        function safeStartOperation(type, data = {}) {
            // Clear any pending operations
            if (currentOperation) {
                completeOperation();
            }
            
            // Clean up conflicting operations
            if (type === OPERATION_TYPES.ROW_ADD || 
                type === OPERATION_TYPES.ROW_DELETE || 
                type === OPERATION_TYPES.MULTIPLE_ROWS_DELETE) {
                
                operationHistory = operationHistory.filter(op => 
                    op.type !== OPERATION_TYPES.ROW_ADD && 
                    op.type !== OPERATION_TYPES.ROW_DELETE && 
                    op.type !== OPERATION_TYPES.MULTIPLE_ROWS_DELETE
                );
            }
            
            startOperation(type, data);
        }
        
        // Expose functions globally for debugging
        window.resetOperationHistory = resetOperationHistory;
        window.safeStartOperation = safeStartOperation;
        window.updateRowCount = updateRowCount;
        
        // Fonction pour forcer l'affichage du bouton d'ajout
        window.forceFabAddVisible = function() {
            const fabAdd = document.getElementById('fab-add');
            if (fabAdd) {
                fabAdd.style.display = 'flex';
                fabAdd.style.visibility = 'visible';
                
                if (isViewMode) {
                    // Mode visualisation : bouton visible mais désactivé
                    fabAdd.style.opacity = '0.5';
                    fabAdd.style.pointerEvents = 'none';
                    fabAdd.style.cursor = 'not-allowed';
                    fabAdd.title = 'Mode visualisation actif - Ajout de lignes désactivé';
                } else {
                    // Mode normal : bouton pleinement fonctionnel
                    fabAdd.style.opacity = '1';
                    fabAdd.style.pointerEvents = 'auto';
                    fabAdd.style.cursor = 'pointer';
                    fabAdd.title = 'Ajouter une nouvelle ligne';
                }
                
                // Clean: Removed debug log
                return true;
            } else {
                console.error('❌ FAB add button not found');
                return false;
            }
        };
        
        // Utility functions
        function log(message, type = 'info') { 
            console.log(`[${new Date().toLocaleTimeString()}] ${type.toUpperCase()}: ${message}`); 
        }
        
        function showMessage(message, type = 'success') { 
            const box = document.getElementById('message-box'); 
            const txt = document.getElementById('message-text'); 
            
            if (window._msgTimer) clearTimeout(window._msgTimer); 
            
            // Remove all existing type classes
            box.classList.remove('success', 'info', 'error', 'warning', 'show'); 
            txt.textContent = message; 
            
            // Add the new type class
            box.classList.add('message-box', type); 
            
            // Force reflow for smooth animation
            void box.offsetWidth; 
            box.classList.add('show'); 
            box.classList.remove('hidden'); 
            
            // Auto-hide after appropriate time based on type (shorter for discretion)
            let displayTime = 2000; // Default 2 seconds
            switch(type) {
                case 'error':
                    displayTime = 3500; // Errors stay longer but not too long
                    break;
                case 'warning':
                    displayTime = 3000; // Warnings stay medium
                    break;
                case 'info':
                    displayTime = 2500; // Info stays briefly
                    break;
                case 'success':
                    displayTime = 2000; // Success messages are quick
                    break;
            }
            
            window._msgTimer = setTimeout(() => {
                box.classList.remove('show'); 
                setTimeout(() => box.classList.add('hidden'), 500); 
            }, displayTime); 
            
            // Log to console for debugging
            console.log(`📢 [${type.toUpperCase()}] ${message}`);
        }
        
        // Optimized status update with DOM caching
        const updateStatus = (function() {
            let statusEl = null;
            let textEl = null;
            let iconEl = null;
            
            return function(message, type = 'pending') {
                // Cache elements on first use
                if (!statusEl) {
                    statusEl = domCache.status || document.getElementById('sync-status');
                    if (statusEl) {
                        textEl = statusEl.querySelector('.sync-text');
                        iconEl = statusEl.querySelector('.sync-icon');
                    }
                }
                
                if (!statusEl) return;
            
                // Mettre à jour le texte et l'icône
                if (textEl) textEl.textContent = message;
                if (iconEl) {
                    // Choisir l'icône appropriée selon le type
                    if (type === 'success') {
                        iconEl.className = 'sync-icon fa-solid fa-check';
                    } else if (type === 'error') {
                        iconEl.className = 'sync-icon fa-solid fa-exclamation-triangle';
                    } else if (type === 'saving') {
                        iconEl.className = 'sync-icon fa-solid fa-sync-alt fa-spin';
                    } else {
                        iconEl.className = 'sync-icon fa-solid fa-clock';
                    }
                }
                
                statusEl.className = `px-3 py-1 rounded-full text-xs font-semibold border-2 bg-white shadow-sm transition-all duration-300 ${getSyncStatusClasses(type)}`;
                
                // Mettre à jour le point coloré si il existe (pour petits écrans)
                const dotEl = statusEl.querySelector('.sync-dot');
                if (dotEl) {
                applyDotColor(dotEl, type);
            }
            
            // Update icon-only indicator for small/medium screens
            const iconOnlyContainer = document.querySelector('.lg\\:hidden .bg-green-500, .lg\\:hidden .bg-yellow-500, .lg\\:hidden .bg-red-500, .lg\\:hidden .bg-blue-500');
            if (iconOnlyContainer) {
                const iconOnlyIndicator = iconOnlyContainer.querySelector('.fa-solid');
                
                iconOnlyContainer.classList.remove('bg-green-500', 'bg-yellow-500', 'bg-red-500', 'bg-blue-500');
                iconOnlyIndicator.classList.remove('fa-check', 'fa-sync-alt', 'fa-exclamation-triangle', 'fa-spin', 'fa-clock');
                
                switch (type) {
                    case 'success':
                        iconOnlyContainer.classList.add('bg-green-500');
                        iconOnlyIndicator.classList.add('fa-check');
                        break;
                    case 'error':
                        iconOnlyContainer.classList.add('bg-red-500');
                        iconOnlyIndicator.classList.add('fa-exclamation-triangle');
                        break;
                    case 'saving':
                        iconOnlyContainer.classList.add('bg-blue-500');
                        iconOnlyIndicator.classList.add('fa-sync-alt', 'fa-spin');
                        break;
                    default:
                        iconOnlyContainer.classList.add('bg-yellow-500');
                        iconOnlyIndicator.classList.add('fa-clock');
                }
            }
            
            // Adapter l'affichage selon la taille d'écran
            adaptStatusDisplay();
            
            };
        })();
        
        function getSyncStatusClasses(type) { 
            switch(type) { 
                case 'success': 
                    return 'bg-green-100 text-green-800 border-green-400 shadow-green-200/50'; 
                case 'error': 
                    return 'bg-red-100 text-red-800 border-red-400 shadow-red-200/50'; 
                case 'saving': 
                    return 'bg-blue-100 text-blue-800 border-blue-400 shadow-blue-200/50 sync-pending-animation'; 
                default: 
                    return 'bg-yellow-100 text-yellow-800 border-yellow-400 shadow-yellow-200/50 sync-pending-animation'; 
            } 
        }
        
        function adaptStatusDisplay() {
            const el = document.getElementById('sync-status');
            if (!el) return;
            
            const textEl = el.querySelector('.sync-text');
            const iconEl = el.querySelector('.sync-icon');
            
            if (!textEl || !iconEl) return;
            
            // Trouver le titre "Tableau de Staff" par son ID
            const titleEl = document.getElementById('staff-title');
            
            // Sur petits écrans, afficher seulement un point coloré et cacher le titre
            if (window.innerWidth <= 768) {
                // Keep all elements visible - don't hide on small screens
                textEl.classList.remove('hidden');
                iconEl.classList.remove('hidden');
                
                // Keep the title visible on small screens
                if (titleEl) {
                    titleEl.classList.remove('hidden');
                }
                
                // Créer ou mettre à jour le point coloré
                let dotEl = el.querySelector('.sync-dot');
                if (!dotEl) {
                    dotEl = document.createElement('div');
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full';
                    dotEl.setAttribute('aria-label', 'Statut de synchronisation');
                    dotEl.setAttribute('title', 'Statut de synchronisation');
                    el.appendChild(dotEl);
                }
                
                // Hide dot since we're showing text and icon
                dotEl.classList.add('hidden');
                
                // Appliquer la couleur selon le type actuel
                const currentType = getCurrentStatusType(el);
                applyDotColor(dotEl, currentType);
                
                el.classList.add('px-1', 'py-0.5'); // Padding minimal
                el.classList.remove('px-2', 'px-3');
            } else {
                // Sur grands écrans, afficher le texte et le titre, cacher le point
                textEl.classList.remove('hidden');
                iconEl.classList.remove('hidden');
                
                // Afficher le titre sur grands écrans
                if (titleEl) {
                    titleEl.classList.remove('hidden');
                }
                
                const dotEl = el.querySelector('.sync-dot');
                if (dotEl) {
                    dotEl.classList.add('hidden');
                    // Optionnel: supprimer complètement le point pour économiser la mémoire
                    // dotEl.remove();
                }
                
                el.classList.add('px-2');
                el.classList.remove('px-1', 'px-3');
            }
        }
        
        function getCurrentStatusType(el) {
            if (!el) return 'pending';
            
            // Détecter le type actuel basé sur les classes CSS
            if (el.classList.contains('bg-green-100')) return 'success';
            if (el.classList.contains('bg-red-100')) return 'error';
            if (el.classList.contains('bg-blue-100')) return 'saving';
            return 'pending';
        }
        
        function applyDotColor(dotEl, type) {
            if (!dotEl) return;
            
            // Appliquer la couleur appropriée au point
            switch(type) {
                case 'success':
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-green-500';
                    break;
                case 'error':
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-red-500';
                    break;
                case 'saving':
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-blue-500 animate-pulse';
                    break;
                default:
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-yellow-500';
                    break;
            }
        }
        

        
                function updateUndoButtonState() { 
            const undoButton = document.getElementById('undo-button');
            const redoButton = document.getElementById('redo-button');
            if (undoButton) {
                // Only count content modification operations
                const contentOperations = operationHistory.filter(op => CONTENT_MODIFICATION_TYPES.includes(op.type));
                const hasOperations = contentOperations.length > 0;
                undoButton.disabled = !hasOperations;
                
                // Update button title with operation info (keep icon unchanged)
                if (hasOperations) {
                    const lastOp = contentOperations[contentOperations.length - 1];
                    const description = getOperationDescription(lastOp);
                    undoButton.title = `Annuler: ${description} (${contentOperations.length} modification(s) de contenu disponible(s))`;
                } else {
                    undoButton.title = 'Aucune modification de contenu à annuler';
                }
            }
            if (redoButton) {
                // Only count content modification operations
                const contentRedoOperations = redoHistory.filter(op => CONTENT_MODIFICATION_TYPES.includes(op.type));
                const hasRedo = contentRedoOperations.length > 0;
                redoButton.disabled = !hasRedo;
                if (hasRedo) {
                    const lastRedo = contentRedoOperations[contentRedoOperations.length - 1];
                    const descRedo = getOperationDescription(lastRedo);
                    redoButton.title = `Rétablir: ${descRedo} (${contentRedoOperations.length} modification(s) de contenu disponible(s))`;
                } else {
                    redoButton.title = 'Aucune modification de contenu à rétablir';
                }
            }
        }
        
        function getFormattedDate() { 
            const d = new Date(); 
            return `${String(d.getDate()).padStart(2, '0')}/${String(d.getMonth() + 1).padStart(2, '0')}/${String(d.getFullYear()).slice(-2)}`; 
        }
        
        function generateDataHash(data) { 
            return JSON.stringify(data.rows.map(r => ({...r, [supabaseConfig.primaryKeyColumn]: undefined}))).split('').reduce((a, b) => {
                a = ((a << 5) - a) + b.charCodeAt(0);
                return a & a;
            }, 0).toString(16); 
        }

        // Zoom functionality
        function updateZoomDisplay() {
            const btn = document.getElementById('zoom-display');
            if (!btn) return;
            
            const pct = Math.round(zoomFactor * 100);
            btn.textContent = pct + '%';
            btn.title = `Réinitialiser à 100% (actuel : ${pct}%)`;
        }
        
        function applyZoom() {
            try {
                const clamped = Math.max(0.3, Math.min(2, zoomFactor));
                zoomFactor = clamped;
                document.documentElement.style.fontSize = (16 * zoomFactor) + 'px';
                localStorage.setItem('zoomFactor', String(zoomFactor));
                updateZoomDisplay();
            } catch(_) {}
        }
        
        function zoomIn() { 
            zoomFactor += 0.05; 
            applyZoom(); 
        }
        
        function zoomOut() { 
            zoomFactor -= 0.05; 
            applyZoom(); 
        }
        
        function zoomReset() { 
            zoomFactor = 1; 
            applyZoom(); 
        }

        // Row color management
        function persistRowColors() { 
            try { 
                localStorage.setItem('rowColors', JSON.stringify(rowColorMap)); 
            } catch(_) {} 
        }
        
        function setRowColor(tr, color) {
            if (!tr) return;
            
            // S'assurer que tr est bien un élément TR
            if (tr.tagName !== 'TR') {
                console.warn('setRowColor: tr parameter is not a TR element:', tr);
                return;
            }
            
            if (color) { 
                // Colorer toute la ligne
                tr.style.backgroundColor = color; 
                tr.dataset.rowColored = '1'; 
                
                // S'assurer que toutes les cellules de la ligne héritent de la couleur
                Array.from(tr.cells).forEach(cell => {
                    if (cell.style.backgroundColor !== color) {
                        cell.style.backgroundColor = color;
                    }
                });
            } else { 
                // Décolorer toute la ligne
                tr.style.backgroundColor = ''; 
                tr.dataset.rowColored = '0'; 
                
                // S'assurer que toutes les cellules de la ligne sont décolorées
                Array.from(tr.cells).forEach(cell => {
                    cell.style.backgroundColor = '';
                });
            }
        }
        
        function keyForRow(tr) {
            return tr.dataset.key || (Array.from(tr.parentElement.children).indexOf(tr) + 1);
        }

        function toggleRowColor(tr) {
            // S'assurer que tr est bien un élément tr (ligne)
            if (!tr || tr.tagName !== 'TR') {
                console.warn('toggleRowColor: tr parameter is not a TR element:', tr);
                return;
            }
            
            const key = keyForRow(tr);
            
            // Respecter le mode de peinture actuel
            if (paintMode === 'color') {
                // Mode Colorer : toujours colorer
                setRowColor(tr, currentRowColor);
                rowColorMap[key] = currentRowColor;
            } else if (paintMode === 'clear') {
                // Mode Effacer : toujours effacer
                setRowColor(tr, null);
                delete rowColorMap[key];
            } else {
                // Mode Auto : basculer selon l'état actuel
                if (tr.dataset.rowColored === '1') {
                    setRowColor(tr, null);
                    delete rowColorMap[key];
                } else {
                    setRowColor(tr, currentRowColor);
                    rowColorMap[key] = currentRowColor;
                }
            }
            
            persistRowColors();
        }

        // Drag-to-paint functionality
        function applyRowPaint(row) {
            if (!row) return;
            
            // Row color operations are NOT tracked for undo/redo (content modification only)
            // No need to start, track, or complete these operations
            
            const key = keyForRow(row);
            if (rowPaintAction === 'color') {
                setRowColor(row, currentRowColor);
                rowColorMap[key] = currentRowColor;
            } else {
                setRowColor(row, null);
                delete rowColorMap[key];
            }
            persistRowColors();
            
            // No operation timeout needed for non-tracked operations
        }
        
        function startRowPaint(row) {
            // Respecter le mode de peinture actuel
            if (paintMode === 'color') {
                rowPaintAction = 'color';
            } else if (paintMode === 'clear') {
                rowPaintAction = 'clear';
            } else {
                // Mode Auto : basculer selon l'état actuel
                rowPaintAction = (row && row.dataset.rowColored === '1') ? 'clear' : 'color';
            }
            
            isRowPaintDragging = true;
            applyRowPaint(row);
            
            // Note: Row color operations are NOT tracked for undo/redo (content modification only)
        }
        
        function endRowPaint() { 
            isRowPaintDragging = false; 
            
            // Row color operations are NOT tracked for undo/redo (content modification only)
            // No need to complete or track these operations
        }

        // Paint mode management
        function getPaintActionForRow(row) {
            if (paintMode === 'auto') {
                // En mode auto : si la ligne est colorée, on la décolore, sinon on la colorie
                const isColored = row && (row.dataset.rowColored === '1' || 
                                        (row.style.backgroundColor && row.style.backgroundColor !== ''));
                return isColored ? 'clear' : 'color';
            }
            return paintMode;
        }
        
        function updatePaintModeButton() {
            const btn = document.getElementById('paint-mode-toggle');
            if (!btn) return;
            
            if (paintMode === 'auto') { 
                SafeDOM.safeSetHTML(btn, '<i class="fa-solid fa-arrows-rotate w-4 h-4"></i>'); 
                btn.title = 'Mode Auto: Cliquez pour colorer/décolorer (P pour changer)'; 
            } else if (paintMode === 'color') { 
                SafeDOM.safeSetHTML(btn, '<i class="fa-solid fa-paintbrush w-4 h-4"></i>'); 
                btn.title = 'Mode Colorer (P pour changer)'; 
            } else { 
                SafeDOM.safeSetHTML(btn, '<i class="fa-solid fa-eraser w-4 h-4"></i>'); 
                btn.title = 'Mode Effacer (P pour changer)'; 
            }
        }
        
        function cyclePaintMode() {
            paintMode = (paintMode === 'auto') ? 'color' : (paintMode === 'color' ? 'clear' : 'auto');
            localStorage.setItem('rowPaintMode', paintMode);
            updatePaintModeButton();
            
            let message = paintMode === 'auto' ? 'Auto' : (paintMode === 'color' ? 'Coloré' : 'Effacer');
            showMessage(message, 'info');
        }

        // Filter functionality
        function applyColoredFilter() {
            try {
                const tbody = document.getElementById('table-body');
                Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                    const colored = tr.dataset.rowColored === '1' || (tr.style.backgroundColor && tr.style.backgroundColor !== '');
                    tr.style.display = (showOnlyColored && !colored) ? 'none' : '';
                });
            } catch(_) {}
        }

        function updateFilterColoredButton() {
            const btn = document.getElementById('filter-colored-toggle');
            if (!btn) return;
            
            if (showOnlyColored) {
                SafeDOM.safeSetHTML(btn, '<i class="fa-solid fa-eye w-4 h-4"></i>');
                btn.title = 'Afficher toutes les lignes';
                btn.setAttribute('aria-pressed', 'true');
            } else {
                btn.innerHTML = '<i class="fa-solid fa-filter w-4 h-4"></i>';
                btn.title = 'Afficher seulement les lignes colorées';
                btn.setAttribute('aria-pressed', 'false');
            }
        }

        function toggleColoredFilter() {
            showOnlyColored = !showOnlyColored;
            applyColoredFilter();
            updateFilterColoredButton();
        }
        
        // Fonction pour basculer le mode visualisation
        function toggleViewMode() {
            isViewMode = !isViewMode;
            
            // Sauvegarder immédiatement l'état dans localStorage
            localStorage.setItem('viewMode', isViewMode.toString());
            
            updateViewModeButton();
            applyViewMode();
        }
        
        // Mettre à jour l'apparence du bouton de mode visualisation
        function updateViewModeButton() {
            const btn = document.getElementById('view-mode-toggle');
            if (!btn) return;
            
            if (isViewMode) {
                btn.className = 'bg-green-200 text-green-800 p-2 rounded-lg hover:bg-green-300 transition-colors flex items-center justify-center w-8 h-8';
                btn.title = 'Désactiver le mode visualisation (lecture seule)';
                btn.innerHTML = '<i class="fa-solid fa-eye-slash w-4 h-4"></i>';
            } else {
                btn.className = 'bg-blue-200 text-blue-800 p-2 rounded-lg hover:bg-blue-300 transition-colors flex items-center justify-center w-8 h-8';
                btn.title = 'Activer le mode visualisation (lecture seule)';
                SafeDOM.safeSetHTML(btn, '<i class="fa-solid fa-eye w-4 h-4"></i>');
            }
        }
        
        // Appliquer le mode visualisation
        function applyViewMode() {
            const editableCells = document.querySelectorAll('.editable-cell');
            const fabAdd = document.getElementById('fab-add');
            const mobileAddButton = document.getElementById('mobile-add-button');
            
            // Désactiver TEMPORAIREMENT TOUTES les sauvegardes si on passe en mode visualisation
            let originalFunctions = {};
            if (isViewMode) {
                // Sauvegarder toutes les fonctions originales
                originalFunctions.markEdited = window.markEdited;
                originalFunctions.saveStateToHistory = window.saveStateToHistory;
                originalFunctions.saveLocalDraft = window.saveLocalDraft;
                
                // Remplacer par des fonctions vides
                window.markEdited = function() { return; };
                window.saveStateToHistory = function() { return; };
                window.saveLocalDraft = function() { return; };
            }
            
            editableCells.forEach(cell => {
                if (isViewMode) {
                    cell.contentEditable = 'false';
                    cell.style.backgroundColor = '#f8f9fa';
                    cell.style.cursor = 'default';
                } else {
                    cell.contentEditable = 'true';
                    cell.style.backgroundColor = '';
                    cell.style.cursor = 'text';
                }
            });
            
            // Activer la protection renforcée sur mobile en mode visualisation
            if (isViewMode && isMobile()) {
                isViewModeProtected = true;
            } else {
                isViewModeProtected = false;
            }
            
            // Le bouton d'ajout FAB doit toujours être visible, mais désactivé en mode visualisation
            if (fabAdd) {
                fabAdd.style.display = 'flex';
                fabAdd.style.visibility = 'visible';
                
                if (isViewMode) {
                    // Mode visualisation : bouton visible mais désactivé
                    fabAdd.style.opacity = '0.5';
                    fabAdd.style.pointerEvents = 'none';
                    fabAdd.style.cursor = 'not-allowed';
                    fabAdd.title = 'Mode visualisation actif - Ajout de lignes désactivé';
                } else {
                    // Mode normal : bouton pleinement fonctionnel
                    fabAdd.style.opacity = '1';
                    fabAdd.style.pointerEvents = 'auto';
                    fabAdd.style.cursor = 'pointer';
                    fabAdd.title = 'Ajouter une nouvelle ligne';
                }
            }
            
            // Sauvegarder l'état dans localStorage
            localStorage.setItem('viewMode', isViewMode);
            
            // Réactiver les sauvegardes après un délai adaptatif selon l'appareil
            if (isViewMode && Object.keys(originalFunctions).length > 0) {
                const restoreDelay = isMobile() ? 6000 : 3000;
                TimerManager.setTimeout(() => {
                    if (originalFunctions.markEdited) {
                        window.markEdited = originalFunctions.markEdited;
                    }
                    if (originalFunctions.saveStateToHistory) {
                        window.saveStateToHistory = originalFunctions.saveStateToHistory;
                    }
                    if (originalFunctions.saveLocalDraft) {
                        window.saveLocalDraft = originalFunctions.saveLocalDraft;
                    }
                }, restoreDelay);
            }
        }
        
        // Appliquer le mode visualisation après restauration des données
        function applyViewModeAfterRestore() {
            if (isViewMode) {
                const editableCells = document.querySelectorAll('.editable-cell');
                editableCells.forEach(cell => {
                    cell.contentEditable = 'false';
                    cell.style.backgroundColor = '#f8f9fa';
                    cell.style.cursor = 'default';
                });
            }
        }
        
        // Détecter automatiquement l'état du bouton œil et agir en conséquence
        function detectAndApplyViewMode() {
            const btn = document.getElementById('view-mode-toggle');
            if (!btn) return;
            
            // Restaurer l'état depuis localStorage
            const savedViewMode = localStorage.getItem('viewMode') === 'true';
            if (savedViewMode !== isViewMode) {
                isViewMode = savedViewMode;
            }
            
            // Mettre à jour l'apparence du bouton selon l'état sauvegardé
            updateViewModeButton();
            
            // Appliquer le mode sauvegardé
            applyViewMode();
        }
        
        // Fonction pour forcer le mode visualisation et empêcher les sauvegardes
        function forceViewMode() {
            if (isViewMode) {
                // Désactiver temporairement les sauvegardes automatiques
                const originalMarkEdited = window.markEdited;
                window.markEdited = function() {
                    // Ne rien faire si on est en mode visualisation
                    return;
                };
                
                // Appliquer le mode visualisation
                applyViewMode();
                
                // Réactiver les sauvegardes après un délai adaptatif selon l'appareil
                const restoreDelay = isMobile() ? 4000 : 2000;
                TimerManager.setTimeout(() => {
                    window.markEdited = originalMarkEdited;
                }, restoreDelay);
            }
        }
        


        // Row color utilities
        function clearAllRowColors() {
            try {
                const tbody = document.getElementById('table-body');
                Array.from(tbody.querySelectorAll('tr')).forEach(tr => setRowColor(tr, null));
                rowColorMap = {};
                persistRowColors();
                showMessage('Couleurs des lignes effacées.', 'info');
            } catch(_) {}
        }

        // Focus management
        let isInitialLoad = true; // Flag to prevent automatic capture on initial load
        
        function captureSimplePos() {
            // Skip capture during initial load to prevent overwriting user's intended position
            if (isInitialLoad) {
                log(`🚫 captureSimplePos SKIPPED - initial load in progress`);
                return;
            }
            
            const active = document.activeElement;
            if (!(active && active.tagName === 'TD' && active.isContentEditable)) return;
            
            const rowEl = active.closest('tr');
            const tbody = document.getElementById('table-body');
            const rowIndex = Array.from(tbody.querySelectorAll('tr')).indexOf(rowEl);
            const cellIndex = Array.from(rowEl.cells).indexOf(active);
            
            // DEBUG: Log detailed information about the cell being captured
            if (active && rowEl) {
                const cellLabel = active.getAttribute('data-label') || 'NO_LABEL';
                const cellText = active.textContent.substring(0, 20) + '...';
                const totalCells = rowEl.cells.length;
                const totalRows = tbody.querySelectorAll('tr').length;
                
                log(`🔍 CAPTURE DEBUG: row=${rowIndex}/${totalRows}, cell=${cellIndex}/${totalCells}, label="${cellLabel}", text="${cellText}"`);
            }
            
            if (rowIndex >= 0 && cellIndex >= 0) {
                lastCellPos = { rowIndex, cellIndex };
                
                // UNIFY: Also update lastFocusInfo to use the same position
                const colLabel = active.getAttribute('data-label') || '';
                const rowKey = rowEl ? rowEl.dataset.key || null : null;
                const caret = getCaretOffsetWithin(active);
                
                lastFocusInfo = { rowKey, rowIndex, colLabel, caret };
                log(`🔄 UNIFIED CAPTURE: Updated both lastCellPos and lastFocusInfo with same rowIndex=${rowIndex}`);
            }
            
            if (lastCellPos) { 
                log(`captureSimplePos -> row=${lastCellPos.rowIndex}, cell=${lastCellPos.cellIndex}`); 
            }
            
            try { 
                localStorage.setItem('lastCellPos', JSON.stringify(lastCellPos)); 
                localStorage.setItem('lastFocusInfo', JSON.stringify(lastFocusInfo)); 
            } catch(_) {}
        }

        // Mobile zoom control functionality
        let currentZoom = 0.7; // Default 70% zoom
        
        function setMobileZoom(zoom) {
            if (isMobile()) {
                currentZoom = zoom;
                document.body.style.transform = `scale(${zoom})`;
                document.body.style.transformOrigin = 'top left';
                document.body.style.width = `calc(100vw / ${zoom})`;
                document.body.style.height = `calc(100vh / ${zoom})`;
                localStorage.setItem('mobileZoom', zoom.toString());
            }
        }
        
        function resetMobileZoom() {
            if (isMobile()) {
                document.body.classList.add('user-zoom-override');
                localStorage.removeItem('mobileZoom');
            }
        }
        
        // Load saved zoom level on page load
        window.addEventListener('DOMContentLoaded', () => {
            if (isMobile()) {
                const savedZoom = localStorage.getItem('mobileZoom');
                if (savedZoom) {
                    currentZoom = parseFloat(savedZoom);
                    setMobileZoom(currentZoom);
                } else {
                    // Apply default 70% zoom using transform
                    setMobileZoom(0.7);
                }
            }
        });

        // Optimized mobile orientation change handler
        window.addEventListener('orientationchange', throttle(() => {
            if (isMobile()) {
                PerformanceMonitor.start('orientation-change');
                _isMobileCache = null; // Reset cache on orientation change
                
                // Use batch manager for efficient DOM updates
                batchManager.schedule(() => {
                    const tableContainer = DOM_CACHE.get('table-container');
                    if (tableContainer) {
                        DOMUtils.setStyles(tableContainer, {
                            'height': '100vh',
                            'max-height': '100vh'
                        });
                    }
                    PerformanceMonitor.end('orientation-change');
                });
            }
        }, 100));

        // Mobile detection and support - Enhanced version
        // Cache mobile detection result for performance
        let _isMobileCache = null;
        
        function isMobile() {
            if (_isMobileCache !== null) return _isMobileCache;
            
            try { 
                // Professional healthcare application user agent detection
                const userAgent = navigator.userAgent + ' HospitalStaffManager/2.5.4';
                const mobileRegex = /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
                const isSmallScreen = window.innerWidth <= 768;
                const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                const hasOrientation = 'onorientationchange' in window;
                const userAgentMobile = mobileRegex.test(userAgent);
                const capabilitiesMobile = isSmallScreen && (hasTouch || hasOrientation);
                
                _isMobileCache = userAgentMobile || capabilitiesMobile;
                return _isMobileCache;
            } catch(_) { 
                return false; 
            }
        }

        function getScrollContainer() {
            return document.getElementById('table-container');
        }

        function ensureCellVisible(cell) {
            try {
                if (!cell) return;
                
                const sc = getScrollContainer();
                if (!sc) { 
                    cell.scrollIntoView({block: 'center', inline: 'nearest'}); 
                    return; 
                }
                
                const vv = window.visualViewport;
                const rect = cell.getBoundingClientRect();
                const viewportHeight = vv ? vv.height : window.innerHeight;
                const bottomSafe = viewportHeight - 64;
                
                if (rect.bottom > bottomSafe || rect.top < 0) {
                    const delta = rect.bottom - bottomSafe;
                    sc.scrollTop += Math.max(delta, -20);
                    try { 
                        cell.scrollIntoView({block: 'center', inline: 'nearest'}); 
                    } catch(_) {}
                }
            } catch(_) {}
        }

        function focusCellWithMobileSupport(cell) {
            // Skip cell focusing on mobile during undo/redo to prevent keyboard popup
            if (isMobile() && isPerformingUndoRedo) {
                log('🚫 [MOBILE] focusCellWithMobileSupport blocked during undo/redo to prevent keyboard popup');
                return false;
            }
            
            try {
                try { 
                    cell.scrollIntoView({ block: 'center', inline: 'nearest' }); 
                } catch(_) {}
                
                TimerManager.setTimeout(() => {
                    try {
                        cell.dispatchEvent(new Event('pointerdown', { bubbles: true }));
                        cell.dispatchEvent(new Event('mousedown', { bubbles: true }));
                        cell.dispatchEvent(new Event('mouseup', { bubbles: true }));
                        cell.click();
                        
                        try { 
                            cell.focus({ preventScroll: true }); 
                        } catch(_) { 
                            try { 
                                cell.focus(); 
                            } catch(__) {} 
                        }
                        
                        setCaretAt(cell, null);
                        
                        try {
                            requestAnimationFrame(() => {
                                setCaretAt(cell, null);
                                requestAnimationFrame(() => { 
                                    setCaretAt(cell, null); 
                                });
                            });
                        } catch(_) {}
                        
                        TimerManager.setTimeout(() => { 
                            setCaretAt(cell, null); 
                        }, 250);
                    } catch(_) {
                        try { 
                            cell.focus(); 
                            setCaretAt(cell, null); 
                        } catch(__) {}
                    }
                }, 350);
                
                ensureCellVisible(cell);
                return true;
            } catch(_) { 
                return false; 
            }
        }

        // Caret management
        function getCaretOffsetWithin(el) {
            try {
                const sel = window.getSelection();
                if (!sel || sel.rangeCount === 0) return null;
                
                const range = sel.getRangeAt(0);
                if (!el.contains(range.startContainer)) return null;
                
                const preRange = range.cloneRange();
                preRange.selectNodeContents(el);
                preRange.setEnd(range.startContainer, range.startOffset);
                
                return preRange.toString().length;
            } catch(_) { 
                return null; 
            }
        }

        function setCaretAt(el, offset) {
            // Skip caret positioning on mobile during undo/redo to prevent keyboard popup
            if (isMobile() && isPerformingUndoRedo) {
                log('🚫 [MOBILE] setCaretAt blocked during undo/redo to prevent keyboard popup');
                return;
            }
            
            try {
                el.focus();
                const selection = window.getSelection();
                selection.removeAllRanges();
                const range = document.createRange();
                
                let remaining = (typeof offset === 'number' && offset >= 0) ? offset : null;
                const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
                let node = walker.nextNode();
                
                if (remaining === null) {
                    // Always place cursor at end of text content
                    let lastNode = null;
                    while (node) { 
                        lastNode = node; 
                        node = walker.nextNode(); 
                    }
                    
                    if (lastNode) {
                        range.setStart(lastNode, lastNode.textContent.length);
                        range.collapse(true);
                        selection.addRange(range);
                    } else {
                        // If no text node exists, place cursor at end of element
                        range.selectNodeContents(el);
                        range.collapse(false);
                        selection.addRange(range);
                    }
                    return;
                }
                
                while (node) {
                    const len = node.textContent.length;
                    if (remaining <= len) {
                        range.setStart(node, remaining);
                        range.collapse(true);
                        selection.addRange(range);
                        return;
                    }
                    remaining -= len;
                    node = walker.nextNode();
                }
                
                const endNode = el.lastChild;
                if (endNode && endNode.nodeType === Node.TEXT_NODE) {
                    range.setStart(endNode, endNode.textContent.length);
                } else {
                    range.selectNodeContents(el);
                    range.collapse(false);
                }
                selection.addRange(range);
            } catch(_) {}
        }

        function captureFocusInfo() {
            // Skip capture during initial load to prevent overwriting user's intended position
            if (isInitialLoad) {
                log(`🚫 captureFocusInfo SKIPPED - initial load in progress`);
                return;
            }
            
            const active = document.activeElement;
            if (!(active && active.tagName === 'TD' && active.isContentEditable)) return;
            
            const row = active.closest('tr');
            const tbody = document.getElementById('table-body');
            const rowIndex = Array.from(tbody.querySelectorAll('tr')).indexOf(row);
            const colLabel = active.getAttribute('data-label') || '';
            const rowKey = row ? row.dataset.key || null : null;
            const caret = getCaretOffsetWithin(active);
            
            lastFocusInfo = { rowKey, rowIndex, colLabel, caret };
            
            try { 
                localStorage.setItem('lastFocusInfo', JSON.stringify(lastFocusInfo)); 
            } catch(_) {}
        }

        function focusCellFromInfo(info, caretPosition = null) {
            if (!info) return false;
            
            // Skip cell focusing on mobile during undo/redo to prevent keyboard popup
            if (isMobile() && isPerformingUndoRedo) {
                log('🚫 [MOBILE] focusCellFromInfo blocked during undo/redo to prevent keyboard popup');
                return false;
            }
            
            log(`🔍 focusCellFromInfo: Looking for rowKey="${info.rowKey}", rowIndex=${info.rowIndex}, colLabel="${info.colLabel}"`);
            
            const tbody = document.getElementById('table-body');
            let targetRow = null;
            
            if (info.rowKey) {
                targetRow = Array.from(tbody.querySelectorAll('tr')).find(tr => tr.dataset.key === String(info.rowKey));
                log(`🔍 focusCellFromInfo: Found row by key: ${!!targetRow}`);
            }
            
            if (!targetRow) {
                const rows = tbody.querySelectorAll('tr');
                targetRow = rows[info.rowIndex] || null;
                log(`🔍 focusCellFromInfo: Found row by index: ${!!targetRow}`);
            }
            
            if (!targetRow) {
                log(`❌ focusCellFromInfo: No target row found`);
                return false;
            }
            
            const cells = Array.from(targetRow.querySelectorAll('td'));
            log(`🔍 focusCellFromInfo: Row has ${cells.length} cells, looking for label "${info.colLabel}"`);
            
            // Use absolute cell index like focusCellByPos, not sliced cells
            const cell = cells.find(td => (td.getAttribute('data-label') || '') === info.colLabel) || null;
            
            if (!cell) {
                log(`❌ focusCellFromInfo: No cell found with label "${info.colLabel}"`);
                // Debug: show all available labels
                const availableLabels = cells.map((td, i) => `${i}:"${td.getAttribute('data-label') || 'NO_LABEL'}"`).join(', ');
                log(`🔍 Available labels: ${availableLabels}`);
                return false;
            }
            
            log(`✅ focusCellFromInfo: Found cell at index ${cells.indexOf(cell)} with label "${info.colLabel}"`);
            
            if (isMobile()) {
                return focusCellWithMobileSupport(cell);
            }
            
            try { 
                cell.scrollIntoView({ block: 'center', inline: 'nearest' }); 
            } catch(_) {}
            
            // Use the provided caret position or default to end
            const targetPosition = (typeof caretPosition === 'number') ? caretPosition : null;
            log(`🎯 focusCellFromInfo: Setting caret position to ${targetPosition}`);
            
            let placed = false;
            try { 
                setCaretAt(cell, targetPosition); 
                placed = true; 
            } catch(_) {}
            
            if (!placed) { 
                TimerManager.setTimeout(() => { 
                    try { 
                        setCaretAt(cell, targetPosition); 
                    } catch(_) {} 
                }, 50); 
            }
            
            try {
                requestAnimationFrame(() => {
                    setCaretAt(cell, targetPosition);
                    requestAnimationFrame(() => { 
                        setCaretAt(cell, targetPosition); 
                    });
                });
            } catch(_) {}
            
            if (document.activeElement !== cell) { 
                try { 
                    cell.focus(); 
                } catch(_) {} 
            }
            
            return true;
        }

        function focusCellByPos(pos) {
            try {
                if (!pos) return false;
                
                // Skip cell focusing on mobile during undo/redo to prevent keyboard popup
                if (isMobile() && isPerformingUndoRedo) {
                    log('🚫 [MOBILE] focusCellByPos blocked during undo/redo to prevent keyboard popup');
                    return false;
                }
                
                const tbody = document.getElementById('table-body');
                const totalRows = tbody.querySelectorAll('tr').length;
                const row = tbody.querySelectorAll('tr')[pos.rowIndex];
                
                if (!row) {
                    log(`❌ RESTORE DEBUG: Row ${pos.rowIndex} not found (total rows: ${totalRows})`);
                    return false;
                }
                
                const totalCells = row.cells.length;
                const cell = row.cells[pos.cellIndex];
                
                if (!cell) {
                    log(`❌ RESTORE DEBUG: Cell ${pos.cellIndex} not found in row ${pos.rowIndex} (total cells: ${totalCells})`);
                    return false;
                }
                
                // DEBUG: Log detailed information about the cell being restored
                const cellLabel = cell.getAttribute('data-label') || 'NO_LABEL';
                const cellText = cell.textContent.substring(0, 20) + '...';
                
                log(`🔍 RESTORE DEBUG: row=${pos.rowIndex}/${totalRows}, cell=${pos.cellIndex}/${totalCells}, label="${cellLabel}", text="${cellText}"`);
                
                if (isMobile()) {
                    return focusCellWithMobileSupport(cell);
                }
                
                setCaretAt(cell, null);
                
                try {
                    cell.dispatchEvent(new MouseEvent('pointerdown', { bubbles: true }));
                    cell.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
                    cell.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
                    cell.click();
                } catch(_) {}
                
                log(`focusCellByPos -> active=${document.activeElement === cell}`);
                
                try {
                    requestAnimationFrame(() => {
                        setCaretAt(cell, null);
                        requestAnimationFrame(() => { 
                            setCaretAt(cell, null); 
                        });
                    });
                } catch(_) {}
                
                return document.activeElement === cell;
            } catch(_) { 
                return false; 
            }
        }

        // Data collection and management
        function collectTableData() { 
            const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent); 
            const rows = []; 
            
            document.querySelectorAll('#data-table tbody tr').forEach((rowEl, index) => { 
                const rowData = {}; 
                
                // Gestion améliorée de la clé primaire compatible smallint
                if (rowEl.dataset.key && rowEl.dataset.key !== '') { 
                    const keyValue = parseInt(rowEl.dataset.key);
                    // S'assurer que la clé est dans la plage smallint (-32,768 à 32,767)
                    if (keyValue >= -32768 && keyValue <= 32767) {
                        rowData[supabaseConfig.primaryKeyColumn] = keyValue;
                    } else {
                        // Si la clé est hors plage, utiliser l'index + 1
                        rowData[supabaseConfig.primaryKeyColumn] = index + 1;
                    }
                } else {
                    // Si pas de clé, utiliser l'index + 1 comme clé temporaire
                    rowData[supabaseConfig.primaryKeyColumn] = index + 1;
                }
                
                const cells = Array.from(rowEl.querySelectorAll('td')).slice(2); 
                cells.forEach((td, i) => { 
                    const label = headers[i]; 
                    const key = label; 
                    rowData[key] = td.textContent === '' ? null : td.textContent; 
                }); 
                
                rows.push(rowData); 
            }); 
            
            return { headers, rows }; 
        }
        
        function saveStateToHistory() { 
            // Clean: Removed debug logging
            
            // Protection renforcée : ne rien faire si on est en mode visualisation protégé
            if (isViewModeProtected || (isViewMode && isMobile()) || isPerformingUndoRedo) {
                // Clean: Removed debug log
                return;
            }
            
            if (historyDebounceTimeout) clearTimeout(historyDebounceTimeout); 
            
            historyDebounceTimeout = setTimeout(() => { 
                const s = collectTableData(); 
                const last = history[history.length - 1]; 
                
                if (!last || generateDataHash(s) !== generateDataHash(last)) { 
                    history.push(s); 
                    
                    // Use optimized history management to prevent memory leaks
                    history = performanceUtils.manageHistory(history, 15); // Increased from 10 to 15
                    
                    // Pushing a new state clears redo stack
                    redoHistory = [];
                    // Also record as an operation if none in progress
                    if (!currentOperation) {
                        const op = {
                            type: OPERATION_TYPES.BULK_EDIT,
                            data: {},
                            timestamp: Date.now(),
                            tableState: s,
                            rowColors: { ...rowColorMap },
                            finalState: s,
                            finalRowColors: { ...rowColorMap }
                        };
                        operationHistory.push(op);
                        if (operationHistory.length > 50) operationHistory.shift();
                    }
                    persistHistoryStacks();
                    updateUndoButtonState(); 
                    log('État de l\'historique enregistré.'); 
                } 
            }, 500); 
        }
        
        function saveLocalDraft() { 
            // Protection renforcée : ne rien faire si on est en mode visualisation protégé
            if (isViewModeProtected || (isViewMode && isMobile())) {
                return;
            }
            
            try { 
                localStorage.setItem('staffTableDraft', document.getElementById('data-table').outerHTML); 
                
                // Schedule delayed synchronization to update all devices
                if (typeof scheduleDelayedSync === 'function') {
                    console.log('🔄 [SAVE] Scheduling delayed sync after local draft save...');
                    scheduleDelayedSync();
                }
            } catch(e) {} 
        }
        
        function restoreLocalDraft() {
            try {
                const draft = localStorage.getItem('staffTableDraft');
                if (draft) {
                    const el = document.getElementById('data-table');
                    if (el) {
                        // Sauvegarder l'état du mode visualisation avant la restauration
                        const wasViewMode = isViewMode;
                        
                        // NUCLEAR OPTION: Désactiver TOUTES les sauvegardes si on est en mode visualisation
                        let originalFunctions = {};
                        if (wasViewMode) {
                            // Sauvegarder toutes les fonctions originales
                            originalFunctions.markEdited = window.markEdited;
                            originalFunctions.saveStateToHistory = window.saveStateToHistory;
                            originalFunctions.saveLocalDraft = window.saveLocalDraft;
                            
                            // Remplacer par des fonctions vides avec debug
                            window.markEdited = function() { 
                                // Clean: Removed debug log 
                                return; 
                            };
                            window.saveStateToHistory = function() { 
                                // Clean: Removed debug log 
                                return; 
                            };
                            window.saveLocalDraft = function() { 
                                // Clean: Removed debug log 
                                return; 
                            };
                            
                            // Activer la protection renforcée
                            isViewModeProtected = true;
                            // Clean: Removed debug log
                        }
                        
                        el.outerHTML = draft;
                        log('Brouillon local restauré.');
                        
                        // Restaurer le mode visualisation immédiatement après la restauration
                        if (wasViewMode) {
                            isViewMode = true;
                            
                            // Adaptive delays for mobile performance
                            const delay = isMobile() ? MOBILE_DEBOUNCE_DELAY : DESKTOP_DEBOUNCE_DELAY;
                            const restoreDelay = isMobile() ? 10000 : 6000;
                            
                            // Clean: Removed debug log
                            
                            // Appliquer le mode visualisation aux nouvelles cellules
                            TimerManager.setTimeout(() => {
                                // Clean: Removed debug log
                                const editableCells = document.querySelectorAll('.editable-cell');
                                editableCells.forEach(cell => {
                                    cell.contentEditable = 'false';
                                    cell.style.backgroundColor = '#f8f9fa';
                                    cell.style.cursor = 'default';
                                });
                                
                                // Mettre à jour l'apparence du bouton
                                updateViewModeButton();
                                
                                // Le bouton d'ajout FAB doit toujours être visible, mais désactivé en mode visualisation
                                const fabAdd = document.getElementById('fab-add');
                                if (fabAdd) {
                                    fabAdd.style.display = 'flex';
                                    fabAdd.style.visibility = 'visible';
                                    
                                    if (isViewMode) {
                                        // Mode visualisation : bouton visible mais désactivé
                                        fabAdd.style.opacity = '0.5';
                                        fabAdd.style.pointerEvents = 'none';
                                        fabAdd.style.cursor = 'not-allowed';
                                        fabAdd.title = 'Mode visualisation actif - Ajout de lignes désactivé';
                                    } else {
                                        // Mode normal : bouton pleinement fonctionnel
                                        fabAdd.style.opacity = '1';
                                        fabAdd.style.pointerEvents = 'auto';
                                        fabAdd.style.cursor = 'pointer';
                                        fabAdd.title = 'Ajouter une nouvelle ligne';
                                    }
                                }
                                
                                // Clean: Removed debug log
                                
                                // Réactiver les sauvegardes après un délai adaptatif
                                TimerManager.setTimeout(() => {
                                    // Clean: Removed debug log
                                    if (originalFunctions.markEdited) {
                                        window.markEdited = originalFunctions.markEdited;
                                    }
                                    if (originalFunctions.saveStateToHistory) {
                                        window.saveStateToHistory = originalFunctions.saveStateToHistory;
                                    }
                                    if (originalFunctions.saveLocalDraft) {
                                        window.saveLocalDraft = originalFunctions.saveLocalDraft;
                                    }
                                    
                                    // Désactiver la protection renforcée
                                    isViewModeProtected = false;
                                    // Clean: Removed debug log
                                }, restoreDelay);
                            }, delay);
                        }
                        
                        rebindRowNumberCells();
                        
                        try {
                            const tbody = document.getElementById('table-body');
                            Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                                const k = keyForRow(tr);
                                const col = rowColorMap[k];
                                if (col) setRowColor(tr, col);
                            });
                        } catch(_) {}
                    }
                }
            } catch(e) {}
        }
        
        // Optimized markEdited with performance-focused throttling
        let lastMarkEditedTime = 0;
        const MARK_EDITED_THROTTLE = 50; // Prevent excessive calls
        
        function markEdited() {
            // Don't mark edited during cursor restoration to prevent save cascades
            if (isRestoringCursor) {
                console.log('⚠️ markEdited BLOCKED - cursor restoration in progress', new Error().stack.split('\n')[2]);
                return;
            }
            
            const now = Date.now();
            
            // Throttle to prevent excessive execution
            if (now - lastMarkEditedTime < MARK_EDITED_THROTTLE) {
                console.log('⚠️ markEdited throttled');
                return;
            }
            lastMarkEditedTime = now;
            
            console.log('⚠️ [EXCEL-SAVE] markEdited called (Excel mode - no timer autosave):', new Error().stack.split('\n')[2]);
            
            isDirty = true;
            isTyping = true;
            lastEditAt = now;
            updateUserEditTime();
            
            // Clear existing typing timer
            if (typingTimer) clearTimeout(typingTimer);
            
            // ✅ EXCEL MODE: No automatic timer-based autosave
            // Save only happens on cell blur (when moving between cells)
            console.log('📝 [EXCEL-SAVE] Changes marked but autosave disabled - save on cell blur only');
            
            // Set typing state timeout
            typingTimer = setTimeout(() => { isTyping = false; }, 1200);
        }

        // Autosave functionality with enhanced undo/redo conflict prevention
        function scheduleAutosaveCountdown() {
            // Use enhanced version for better conflict prevention
            scheduleAutosaveCountdownEnhanced();
        }
        
        function startPeriodicSync() {
            // Use enhanced version for better conflict prevention
            startPeriodicSyncEnhanced();
        }

        // ===== Helpers & constants (DRY) =====
        const BOLD_HEADERS = ['nom_prénom','pec finale','diagnostic_initial'];
        function getHeaders(){
          return Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th=>th.textContent);
        }
        
        // Fonction pour mettre à jour l'affichage du nombre de lignes
        function updateRowCount() {
            const tbody = document.getElementById('table-body');
            const rowCountNumber = document.getElementById('row-count-number');
            
            if (tbody && rowCountNumber) {
                const rowCount = tbody.children.length;
                rowCountNumber.textContent = rowCount;
                // Clean: Removed debug log
            }
        }
        function createDeleteCell(row){
          const deleteCell=document.createElement('td');
          deleteCell.className='p-0 text-center';
          deleteCell.setAttribute('data-label','Effacer');
          const sel=document.createElement('input');
          sel.type='checkbox';
          sel.className='m-1 align-middle';
          sel.addEventListener('change',()=>{ row.classList.toggle('selected-row', sel.checked); });
          const deleteButton=document.createElement('button');
          deleteButton.className='text-red-500 hover:text-red-700 font-bold p-2 transition-colors';
          deleteButton.textContent='🗑️';
          deleteButton.onclick=(e)=>{
            e.stopPropagation();
            const selected = Array.from(document.querySelectorAll('#table-body tr.selected-row'));
            if (selected.length > 0) {
              // Multiple rows selected: confirm before deleting
              promptKeyConfirm(`Supprimer ${selected.length} ligne(s) ?`, () => deleteRows(selected));
            } else {
              // Single row via trash icon: delete immediately without confirmation
              deleteRows([row]);
            }
          };
          const wrap=document.createElement('div');
          wrap.className='flex items-center justify-center gap-1';
          wrap.appendChild(sel); wrap.appendChild(deleteButton);
          deleteCell.appendChild(wrap);
          return deleteCell;
        }
        function createEditableCell(header, value=''){
          const cell=document.createElement('td');
          const dbKey=header; // names are identical (no mapping)
          cell.textContent=value||'';
          cell.contentEditable=true;
          cell.className='py-2 px-2 md:px-4 editable-cell';
          cell.setAttribute('data-label',header);
          cell.setAttribute('data-dbkey',dbKey);
          
          // Force inline red color for Information complementaire to override any cascade
          if (header === 'Information complementaire' || header === 'information complementaire') {
            cell.style.color = '#dc2626';
          }
          
          // Remove any previous inline font size for numero_tel to keep 1.1rem via CSS
          if (header === 'Numero_tel' || header === 'numero_tel') {
            cell.style.fontSize = '';
          }
          
          // Sélection automatique du contenu lors du double-clic/double-tap
          cell.addEventListener('dblclick', (e) => {
            e.preventDefault();
            // Sélectionner tout le contenu de la cellule
            const range = document.createRange();
            range.selectNodeContents(cell);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
          });
          
          // Optimized double-tap handling for mobile
          let lastTap = 0;
          cell.addEventListener('touchstart', (e) => {
            if (!isMobile()) return;
            
            const currentTime = performance.now(); // More precise timing
            const tapLength = currentTime - lastTap;
            if (tapLength < 500 && tapLength > 0) {
              e.preventDefault();
              e.stopPropagation(); // Prevent event bubbling
              
              // Request animation frame for smooth selection
              requestAnimationFrame(() => {
                const range = document.createRange();
                range.selectNodeContents(cell);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
              });
            }
            lastTap = currentTime;
          });
          
          // Stocker la valeur initiale pour détecter les vraies modifications
          let initialValue = value || '';
          let hasBeenModified = false;
          
          // --- Nom_Prénom auto-formatting logic ---
          if (isNomPrenomLabel(header)) {
            // Ensure initial display is formatted when creating the cell
            if (value) {
              value = formatNomPrenom(value);
              cell.textContent = value;
              initialValue = value;
            }
            
            // Format when the user leaves the cell (Excel-like behavior)
            cell.addEventListener('blur', async () => {
              // Remove selection styling
              cell.classList.remove('selected');
              
              const currentValue = cell.textContent;
              const formattedValue = formatNomPrenom(currentValue);
              cell.textContent = formattedValue;
              
              // Excel-like save: save immediately when moving to another cell
              if (hasBeenModified || formattedValue !== initialValue) {
                console.log('📝 [EXCEL-SAVE] Cell blur detected - saving modified cell');
                await saveModifiedCell(cell, initialValue, formattedValue);
                // Mettre à jour la valeur initiale pour les prochaines comparaisons
                initialValue = formattedValue;
                hasBeenModified = false;
              }
            });
            
            // Gérer le collage (seulement si le contenu change)
            cell.addEventListener('paste', () => {
              TimerManager.setTimeout(() => {
                const pastedValue = cell.textContent;
                const formattedValue = formatNomPrenom(pastedValue);
                cell.textContent = formattedValue;
                
                // Sauvegarder seulement si le contenu collé est différent
                if (formattedValue !== initialValue) {
                  saveStateToHistory();
                  saveLocalDraft();
                  markEdited();
                  initialValue = formattedValue;
                  hasBeenModified = false;
                }
              }, 0);
            });
          } else {
            // Pour les autres colonnes, Excel-like behavior
            cell.addEventListener('blur', async () => {
              // Remove selection styling
              cell.classList.remove('selected');
              
              const currentValue = cell.textContent;
              // Excel-like save: save immediately when moving to another cell
              if (hasBeenModified || currentValue !== initialValue) {
                console.log('📝 [EXCEL-SAVE] Cell blur detected - saving modified cell');
                await saveModifiedCell(cell, initialValue, currentValue);
                initialValue = currentValue;
                hasBeenModified = false;
              }
            });
            
            cell.addEventListener('paste', () => {
              TimerManager.setTimeout(() => {
                const pastedValue = cell.textContent;
                // Sauvegarder seulement si le contenu collé est différent
                if (pastedValue !== initialValue) {
                  saveStateToHistory();
                  saveLocalDraft();
                  markEdited();
                  initialValue = pastedValue;
                  hasBeenModified = false;
                }
              }, 0);
            });
          }
          
          if(BOLD_HEADERS.includes(header.toLowerCase())){
            cell.style.fontWeight='bold';
            cell.style.color='#000';
          }
          cell.setAttribute('tabindex','0');
          
          // Add focus event handler for selection styling
          cell.addEventListener('focus', () => {
            // Remove selection from other cells
            document.querySelectorAll('.editable-cell.selected').forEach(otherCell => {
              if (otherCell !== cell) {
                otherCell.classList.remove('selected');
              }
            });
            
            // Add selection styling to current cell
            cell.classList.add('selected');
          });
          
          // Sauvegarder seulement lors de vraies modifications (input)
          cell.oninput=()=>{
            hasBeenModified = true;
            
            // Reset undo/redo sync timeout when user starts editing
            clearUndoRedoSyncTimeout();
            
            // Start or continue operation tracking for cell edits
            if (!currentOperation || currentOperation.type !== OPERATION_TYPES.CELL_EDIT) {
                startOperation(OPERATION_TYPES.CELL_EDIT, {
                    cellLabel: header,
                    initialValue: initialValue,
                    rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                    columnLabel: header,
                    editCount: 1,
                    edits: [{
                        columnLabel: header,
                        rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                        initialValue: initialValue,
                        currentValue: cell.textContent
                    }]
                });
            } else {
                // Increment edit count and add to edits array
                currentOperation.data.editCount = (currentOperation.data.editCount || 1) + 1;
                currentOperation.data.edits.push({
                    columnLabel: header,
                    rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                    initialValue: initialValue,
                    currentValue: cell.textContent
                });
                
                addToOperation({
                    cellLabel: header,
                    currentValue: cell.textContent,
                    rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                    columnLabel: header
                });
            }
            
            // Debounce operation completion for cell edits
            if (operationTimeout) clearTimeout(operationTimeout);
            operationTimeout = setTimeout(() => {
                completeOperation();
            }, 1000); // 1 second delay for cell edits
            
            // Excel mode: Save history and local draft but no timer-based autosave
            saveStateToHistory();
            saveLocalDraft();
            
            // Mark as dirty but don't trigger timer-based autosave (Excel mode)
            isDirty = true;
            isTyping = true;
            lastEditAt = Date.now();
            updateUserEditTime();
            console.log('📝 [EXCEL-SAVE] Cell input detected - marked dirty, save on blur only');
            
            // keep caret/position updated while typing
            captureFocusInfo();
            captureSimplePos();
          };
          
          cell.addEventListener('keyup', (e) => {
            // update caret after navigation keys
            if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Home','End','PageUp','PageDown'].includes(e.key)) {
              captureFocusInfo();
              captureSimplePos();
            }
          });
          return cell;
        }

        // Ensure DDN column exists visually even if an older HTML version is served (Live Server/mobile cache)
        function ensureDDNHeader(){
          try {
            const theadRow = document.querySelector('#data-table thead tr');
            if (!theadRow) return;
            const labels = Array.from(theadRow.children).map(th=>th.textContent.trim());
            if (labels.includes('DDN')) return; // already there

            // Create the DDN header cell
            const th = document.createElement('th');
            th.setAttribute('scope','col');
            th.className = 'py-2 px-2 md:px-4';
            th.textContent = 'DDN';

            // Insert right after Nom_Prénom if present, else before Diagnostic_initial, else at the end
            let insertIndex = labels.indexOf('Nom_Prénom');
            if (insertIndex !== -1) {
              theadRow.insertBefore(th, theadRow.children[insertIndex + 1]);
            } else {
              const diagIdx = labels.indexOf('Diagnostic_initial');
              if (diagIdx !== -1) theadRow.insertBefore(th, theadRow.children[diagIdx]);
              else theadRow.appendChild(th);
            }

            // For each body row, insert a new editable DDN cell at the same index
            const headersNow = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th=>th.textContent);
            const ddnPos = headersNow.indexOf('DDN');
            if (ddnPos !== -1) {
              document.querySelectorAll('#table-body tr').forEach(tr => {
                const cell = createEditableCell('DDN', '');
                // Insert after the first two fixed cells (No, Effacer) + ddnPos offset
                const insertAt = 2 + ddnPos;
                const ref = tr.cells[insertAt];
                if (ref) tr.insertBefore(cell, ref); else tr.appendChild(cell);
              });
            }

            // Adjust tfoot colspan to match new column count
            const tfootLast = document.querySelector('#data-table tfoot td:last-child');
            const totalCols = document.querySelectorAll('#data-table thead th').length;
            if (tfootLast) {
              // first two tds in tfoot row are No/Effacer holders; last td should span the remainder
              const span = Math.max(0, totalCols - 2);
              tfootLast.setAttribute('colspan', String(span));
            }
          } catch(e) { /* noop */ }
        }

        // Keep tfoot colspan in sync with the current number of columns
        function updateTfootColspan() {
            try {
                const totalCols = document.querySelectorAll('#data-table thead th').length;
                const tfootRow = document.querySelector('#data-table tfoot tr');
                if (!tfootRow) return;
                // First cell spans the first two utility columns (No, Effacer)
                const firstTd = tfootRow.querySelector('td:first-child');
                if (firstTd) firstTd.setAttribute('colspan', '2');
                // Last cell spans the remainder
                const lastTd = tfootRow.querySelector('td:last-child');
                if (lastTd) lastTd.setAttribute('colspan', String(Math.max(0, totalCols - 2)));
            } catch(_) {}
        }
        // Align table headers with server column keys (case-insensitive)
        function reconcileHeadersWithServer() {
          try {
            if (!appState.serverColumns || appState.serverColumns.length === 0) return;
            const server = appState.serverColumns;
            const theadTh = Array.from(document.querySelectorAll('#data-table thead th')).slice(2);
            theadTh.forEach((th) => {
              const label = th.textContent;
              if (server.includes(label)) return; // exact match OK
              const found = server.find(k => k.toLowerCase() === label.toLowerCase());
              if (found) {
                th.textContent = found; // normalize header to the exact server key
              }
            });
          } catch (e) { /* no-op */ }
        }
        // === Excel import helpers ===
        function normalizeKey(k){
          if(!k) return '';
          return String(k).trim().toLowerCase().replace(/[_\-\s]+/g,' ').replace(/\s+/g,' ').normalize('NFD').replace(/[\u0300-\u036f]/g,'');
        }
        // === Name formatting helpers ===
        function _titleCasePart(s) {
          if (!s) return '';
          return s.split(' ').map(word => {
            if (word.length <= 2) return word.toLowerCase();
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
          }).join(' ');
        }
        
        function formatNomPrenom(raw){
          if(raw==null) return '';
          let s = String(raw).trim().replace(/\s+/g, ' ');
          if(!s) return '';
          // If there's a comma, interpret as "LAST, First ..."
          if(s.includes(',')){
            const [last, rest] = s.split(',');
            const nom = last.trim().toUpperCase();
            const prenom = _titleCasePart((rest||'').trim());
            return prenom ? `${nom}\n${prenom}` : nom;
          }
          // Default: first token is last name; remainder is first name(s)
          const parts = s.split(' ');
          const nom = (parts.shift()||'').toUpperCase();
          const prenom = _titleCasePart(parts.join(' ').trim());
          return prenom ? `${nom}\n${prenom}` : nom;
        }
        
        function isNomPrenomLabel(label){
          try {
            const n = normalizeKey(label);
            return n === 'nom prenom' || n.includes('nom prenom');
          } catch(_) {
            return label === 'Nom_Prénom';
          }
        }
        function buildHeaderMap(sheetKeys, tableHeaders){
          const map = {};
          const nSheet = sheetKeys.map(k=>({raw:k, norm:normalizeKey(k)}));
          const nTable = tableHeaders.map(k=>({raw:k, norm:normalizeKey(k)}));

          // Raw alias definitions (human-friendly)
          const aliasesRaw = {
            'date de saisie': ['date', 'date saisie', 'date d\'entree', 'date entree', 'datesaisie', 'date d\'enregistrement'],
            'pec finale': ['pec finale', 'pec finale (definitive)', 'prise en charge finale', 'prise en charge def'],
            'pec initiale': ['pec initiale', 'prise en charge initiale', 'prise en charge init'],
            'nom_prenom': ['nom prenom', 'nom_prénom', 'nom et prenom', 'nom et prénom', 'patient', 'nom complet', 'fullname', 'name'],
            'ddn': ['date de naissance', 'date naissance', 'naissance', 'dob', 'date of birth', 'birth date', 'dn'],
            'diagnostic_initial': ['diagnostic initial', 'diagnostic', 'diag initial', 'diagnostic de depart'],
            'information complementaire': ['infos', 'information complementaire', 'commentaire', 'notes', 'remarques', 'obs', 'observations'],
            'numero_tel': ['tel', 'telephone', 'numero tel', 'numero telephone', 'phone', 'portable', 'gsm', 'mobile']
          };
          // Normalize alias values once for consistent matching
          const aliases = Object.fromEntries(
            Object.entries(aliasesRaw).map(([k, arr]) => [normalizeKey(k), arr.map(v => normalizeKey(v))])
          );

          nTable.forEach(t => {
            // 1) exact normalized match
            let match = nSheet.find(s => s.norm === t.norm);

            // 2) alias match (normalized)
            if(!match){
              const listNorm = aliases[t.norm] || [];
              match = nSheet.find(s => listNorm.includes(s.norm));
            }

            // 3) fuzzy for DDN — accept any column that contains naiss/birth/dob tokens
            if(!match && t.norm === 'ddn'){
              match = nSheet.find(s => /\b(naiss|birth|dob|date naissance|date de naissance)\b/.test(s.norm))
                    || nSheet.find(s => s.norm.includes('naiss') || s.norm.includes('birth') || s.norm.includes('dob'));
            }

            if(match) map[t.raw] = match.raw; // map table header -> sheet column
          });
          return map;
        }
        function coerceCellValue(header, val){
          if(val==null) return '';
          const h = normalizeKey(header);

          // Excel serial number handling for date-like headers
          if((h.includes('date') || h==='ddn') && typeof val === 'number'){
            try {
              const epoch = new Date(Date.UTC(1899,11,30));
              const d = new Date(epoch.getTime() + val*86400000);
              const dd = String(d.getUTCDate()).padStart(2,'0');
              const mm = String(d.getUTCMonth()+1).padStart(2,'0');
              const yy = String(d.getUTCFullYear()).slice(-2);
              return `${dd}/${mm}/${yy}`;
            } catch(_) { /* fallthrough */ }
          }

          // Parse common textual date forms
          if((h.includes('date') || h==='ddn') && typeof val === 'string'){
            const s = val.trim();
            // Normalize separators
            const norm = s.replace(/[.\-]/g,'/').replace(/\s+/g,'');

            // YYYY/MM/DD or YYYY/M/D
            let m = norm.match(/^(\d{4})\/(\d{1,2})\/(\d{1,2})$/);
            if(m){
              const y = parseInt(m[1],10), mo = parseInt(m[2],10), d = parseInt(m[3],10);
              if(mo>=1 && mo<=12 && d>=1 && d<=31){
                return `${String(d).padStart(2,'0')}/${String(mo).padStart(2,'0')}/${String(y).slice(-2)}`;
              }
            }

            // DD/MM/YYYY or D/M/YY etc.
            m = norm.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
            if(m){
              const d = parseInt(m[1],10), mo = parseInt(m[2],10), y = parseInt(m[3],10);
              if(mo>=1 && mo<=12 && d>=1 && d<=31){
                return `${String(d).padStart(2,'0')}/${String(mo).padStart(2,'0')}/${String(y).toString().slice(-2)}`;
              }
            }

            // Fallback: try Date.parse cautiously
            const t = Date.parse(s);
            if(!isNaN(t)){
              const d = new Date(t);
              const dd = String(d.getUTCDate()).padStart(2,'0');
              const mm = String(d.getUTCMonth()+1).padStart(2,'0');
              const yy = String(d.getUTCFullYear()).slice(-2);
              return `${dd}/${mm}/${yy}`;
            }
          }

          return String(val);
        }
        async function importExcelFromFile(file){
          try{
            if(!file){ showMessage('Aucun fichier sélectionné','info'); return; }
            const ext = (file.name.split('.').pop()||'').toLowerCase();
            if(!['xlsx','xls','csv'].includes(ext)){
              showMessage('Format non pris en charge. Utilisez .xlsx, .xls ou .csv','info');
              return;
            }
            updateStatus('Import en cours...','saving');
            const data = await file.arrayBuffer();
            const wb = XLSX.read(data, { type:'array' });
            const sheetName = wb.SheetNames[0];
            const ws = wb.Sheets[sheetName];
            const rows = XLSX.utils.sheet_to_json(ws, { defval:'', raw:false });
            if(!Array.isArray(rows) || rows.length===0){ showMessage('Feuille vide','info'); updateStatus('Synchronisé','success'); return; }

            // Colonnes système à ignorer lors de l'import
            const systemColumns = ['No', 'Effacer', 'Date de saisie'];
            
            // Colonnes de données à importer (excluant les colonnes système)
            const dataColumns = getHeaders().filter(header => !systemColumns.includes(header));
            
            // Filtrer les lignes : seulement celles avec Nom_Prénom rempli
            const validRows = rows.filter(row => {
              const nomPrenom = row['Nom_Prénom'] || row['Nom_Prénom'] || row['Nom Prénom'] || row['NomPrénom'];
              return nomPrenom && nomPrenom.trim() !== '';
            });

            if(validRows.length === 0){
              showMessage('Aucune ligne avec Nom_Prénom rempli trouvée dans le fichier','info');
              updateStatus('Import terminé','success');
              return;
            }

                            // Clean: Removed debug log

            // Construire les données d'import avec gestion intelligente
            const importData = validRows.map((row, index) => {
              const obj = {};
              
              // Générer automatiquement une clé primaire unique compatible smallint
              // Utiliser un index simple pour éviter les dépassements de type
              obj[supabaseConfig.primaryKeyColumn] = index + 1;
              
              // Ajouter automatiquement la date de saisie
              obj['Date de saisie'] = getFormattedDate();
              
              // Importer seulement les colonnes de données (pas les colonnes système)
              dataColumns.forEach(column => {
                const sheetKey = findBestMatch(column, Object.keys(row));
                if (sheetKey && row[sheetKey] !== undefined && row[sheetKey] !== '') {
                  obj[column] = coerceCellValue(column, row[sheetKey]);
                } else {
                  obj[column] = '';
                }
              });
              
              return obj;
            });

            // Charger dans le tableau
            if(loadTableData(importData)){
              saveStateToHistory();
              saveLocalDraft();
              markEdited();
              updateStatus('Importé (non sauvegardé)','success');
              showMessage(`Import réussi: ${importData.length} ligne(s) avec Nom_Prénom. Colonnes système générées automatiquement.`);
            } else {
              updateStatus('Erreur import','error');
              showMessage('Échec du chargement des données importées.','info');
            }
          } catch(err){
            console.error(err);
            updateStatus('Erreur import','error');
            showMessage('Erreur lors de l\'import. Vérifiez le fichier.','info');
          }
        }

        // Fonction pour trouver la meilleure correspondance de colonne
        function findBestMatch(targetColumn, availableColumns) {
          // Correspondance exacte
          if (availableColumns.includes(targetColumn)) {
            return targetColumn;
          }
          
          // Correspondance sans espaces ni caractères spéciaux
          const normalizedTarget = targetColumn.replace(/[\s\-_]/g, '').toLowerCase();
          for (const col of availableColumns) {
            const normalizedCol = col.replace(/[\s\-_]/g, '').toLowerCase();
            if (normalizedCol === normalizedTarget) {
              return col;
            }
          }
          
          // Correspondance partielle
          for (const col of availableColumns) {
            const normalizedCol = col.replace(/[\s\-_]/g, '').toLowerCase();
            if (normalizedCol.includes(normalizedTarget) || normalizedTarget.includes(normalizedCol)) {
              return col;
            }
          }
          
          return null;
        }

        function loadTableData(data) {
            if (!data) { 
                log('Structure invalide', 'error'); 
                return false; 
            }
            
            // Protection supplémentaire contre l'effacement du tableau
            if (!Array.isArray(data) || data.length === 0) {
                console.warn('⚠️ loadTableData: data is not a valid array or is empty, refusing to clear table');
                log('Données invalides - tableau non modifié', 'warning');
                return false;
            }
            
            const tbody = document.getElementById('table-body');
            tbody.innerHTML = '';
            const headers = getHeaders();
            
            data.forEach((rowData, index) => {
                const row = document.createElement('tr');
                row.className = 'bg-white hover:bg-gray-100 transition-colors cursor-pointer';
                
                if (rowData[supabaseConfig.primaryKeyColumn]) {
                    row.dataset.key = rowData[supabaseConfig.primaryKeyColumn];
                }

                // Create row number cell
                const numCell = document.createElement('td');
                numCell.textContent = index + 1;
                numCell.className = 'py-2 px-2 md:px-4 font-bold text-gray-800 whitespace-nowrap cursor-pointer frozen-column frozen-1';
                numCell.setAttribute('data-label', 'No');
                numCell.title = 'Cliquer pour colorer/effacer la ligne';
                
                // Add event listeners for row painting
                            numCell.addEventListener('mousedown', (e) => { 
                if (e.button !== 0) return; 
                startRowPaint(row); 
                e.preventDefault(); 
            });
            
            numCell.addEventListener('mouseenter', () => { 
                if (isRowPaintDragging) applyRowPaint(row); 
            });
            
            numCell.addEventListener('click', (e) => { 
                e.preventDefault();
                // En mode auto, on colorie/décolore directement au clic
                if (paintMode === 'auto') {
                    rowPaintAction = getPaintActionForRow(row);
                    applyRowPaint(row);
                } else if (!isRowPaintDragging) {
                    // En mode manuel, on utilise l'action sélectionnée
                    rowPaintAction = getPaintActionForRow(row);
                    applyRowPaint(row);
                }
            });
                
                numCell.addEventListener('touchstart', (e) => { 
                    startRowPaint(row); 
                    e.preventDefault(); 
                }, { passive: false });
                
                numCell.addEventListener('touchmove', (e) => { 
                    const t = e.touches && e.touches[0]; 
                    if (!t) return; 
                    const el = document.elementFromPoint(t.clientX, t.clientY); 
                    const tr = el ? el.closest('#table-body tr') : null; 
                    if (tr) applyRowPaint(tr); 
                    e.preventDefault(); 
                }, { passive: false });
                
                row.appendChild(numCell);

                // Add delete/selection cell
                row.appendChild(createDeleteCell(row));

                // Add data cells
                headers.forEach(header => {
                    let value = rowData[header] || '';
                    if (isNomPrenomLabel(header)) {
                        value = formatNomPrenom(value);
                    }
                    row.appendChild(createEditableCell(header, value));
                });

                tbody.appendChild(row);
            });
            
            // Re-apply stored row colors after rebuilding the tbody
            try {
                Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                    const k = keyForRow(tr);
                    const col = rowColorMap[k];
                    if (col) setRowColor(tr, col);
                });
            } catch(_) {}
            
            // Silent data loading for faster undo/redo
            if (!isPerformingUndoRedo) {
                log('Données du tableau chargées.', 'success');
            }
            appState.localData = collectTableData();
            appState.dataHash = generateDataHash(appState.localData);
            document.dispatchEvent(new CustomEvent('table:reloaded'));
            updateTfootColspan();
            if (!isPerformingUndoRedo) {
                log('table:reloaded dispatched');
            }
            
            // Mettre à jour l'affichage du nombre de lignes
            updateRowCount();
            
            return true;
        }

        async function addRow() {
            // Empêcher l'ajout en mode visualisation
            if (isViewMode) {
                showMessage('Impossible d\'ajouter des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                return;
            }
            
            // Start operation tracking for row addition
            startOperation(OPERATION_TYPES.ROW_INSERT, {
                newRowKey: Date.now() + Math.random()
            });
            
            const tbody = document.getElementById('table-body');
            const row = document.createElement('tr');
            row.className = 'bg-white hover:bg-gray-100 transition-colors cursor-pointer';
            
            // Générer une clé primaire unique compatible smallint
            const existingKeys = Array.from(tbody.querySelectorAll('tr'))
                .map(tr => parseInt(tr.dataset.key) || 0)
                .filter(key => key > 0);
            
            let newKey = 1;
            if (existingKeys.length > 0) {
                newKey = Math.max(...existingKeys) + 1;
            }
            
            // S'assurer que la clé est dans la plage smallint
            if (newKey > 32767) {
                newKey = 1; // Recommencer à 1 si on dépasse la limite
            }
            
            row.dataset.key = newKey.toString();

            // Create row number cell
            const numCell = document.createElement('td');
            numCell.textContent = tbody.children.length + 1;
            numCell.className = 'py-2 px-2 md:px-4 font-bold text-gray-800 whitespace-nowrap cursor-pointer frozen-column frozen-1';
            numCell.setAttribute('data-label', 'No');
            numCell.title = 'Cliquer pour colorer/effacer la ligne';
            
                            numCell.addEventListener('mousedown', (e) => { 
                    if (e.button !== 0) return; 
                    startRowPaint(row); 
                    e.preventDefault(); 
                });
                
                numCell.addEventListener('mouseenter', () => { 
                    if (isRowPaintDragging) applyRowPaint(row); 
                });
                
                numCell.addEventListener('click', (e) => { 
                    e.preventDefault();
                    // En mode auto, on colorie/décolore directement au clic
                    if (paintMode === 'auto') {
                        rowPaintAction = getPaintActionForRow(row);
                        applyRowPaint(row);
                    } else if (!isRowPaintDragging) {
                        // En mode manuel, on utilise l'action sélectionnée
                        rowPaintAction = getPaintActionForRow(row);
                        applyRowPaint(row);
                    }
                });
            
            numCell.addEventListener('touchstart', (e) => { 
                startRowPaint(row); 
                e.preventDefault(); 
            }, { passive: false });
            
            numCell.addEventListener('touchmove', (e) => { 
                const t = e.touches && e.touches[0]; 
                if (!t) return; 
                const el = document.elementFromPoint(t.clientX, t.clientY); 
                const tr = el ? el.closest('#table-body tr') : null; 
                if (tr) applyRowPaint(tr); 
                e.preventDefault(); 
            }, { passive: false });
            
            row.appendChild(numCell);

            // Add delete/selection cell
            row.appendChild(createDeleteCell(row));

            // Add date cell (pre-filled)
            const dateCell = createEditableCell('Date de saisie', getFormattedDate());
            row.appendChild(dateCell);

            // Add remaining headers
            const headers = getHeaders().slice(1);
            headers.forEach(header => { 
                row.appendChild(createEditableCell(header, '')); 
            });

            tbody.appendChild(row);
            
            try { 
                const k = keyForRow(row); 
                const col = rowColorMap[k]; 
                if (col) setRowColor(row, col); 
            } catch(_) {}
            
            // Complete the operation
            completeOperation();
            
            markEdited();
            
            // Mettre à jour l'affichage du nombre de lignes
            updateRowCount();
        }

        async function deleteRows(rows) { 
            if (!rows || rows.length === 0) return;
            
            // Empêcher la suppression dans les snapshots ET en mode visualisation
            if (snapshotMode === 'snapshot') {
                showMessage('Impossible de supprimer des lignes dans un snapshot. Retournez aux données en direct pour modifier le tableau.', 'warning');
                return;
            }
            
            // Empêcher la suppression en mode visualisation
            if (isViewMode) {
                showMessage('Impossible de supprimer des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                return;
            }
            
            // Safety check: ensure we're not in the middle of an undo operation
            if (currentOperation && currentOperation.type.includes('undo')) {
                // Clean: Removed debug log
                return;
            }
            
            // Start operation tracking for deletion (Excel-style: single operation for multiple rows)
            startOperation(OPERATION_TYPES.ROW_DELETE, {
                deletedRows: rows.length,
                rowKeys: rows.map(r => r.dataset.key).filter(Boolean),
                rowData: rows.map(r => {
                    const rowData = {};
                    const cells = Array.from(r.querySelectorAll('td')).slice(2); // Skip No and Delete columns
                    const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                    cells.forEach((cell, i) => {
                        if (headers[i]) {
                            rowData[headers[i]] = rowData[headers[i]] = cell.textContent;
                        }
                    });
                    return rowData;
                }),
                rowNumbers: rows.map(r => {
                    const noCell = r.querySelector('td:first-child');
                    return noCell ? parseInt(noCell.textContent) : null;
                }).filter(n => !isNaN(n))
            });
            
            const keys = rows.map(r => r.dataset.key).filter(Boolean); 
            
            try { 
                if (keys.length > 0) { 
                    const { error } = await supabase
                        .from(supabaseConfig.tableName)
                        .delete()
                        .in(supabaseConfig.primaryKeyColumn, keys); 
                    
                    if (error) throw error; 
                    log(`Supprimé ${keys.length} ligne(s) côté serveur.`, 'success'); 
                } 
                

                
                // Remove rows from DOM
                rows.forEach(r => r.remove()); 
                
                // Renumber rows
                document.querySelectorAll('#table-body tr').forEach((tr, idx) => { 
                    const noCell = tr.querySelector('td:first-child'); 
                    if (noCell) noCell.textContent = idx + 1; 
                    tr.classList.remove('selected-row'); 
                });
                
                // Rebuild color map after deletions and renumbering
                rowColorMap = {};
                Array.from(document.querySelectorAll('#table-body tr')).forEach(tr => {
                    const k = keyForRow(tr);
                    const c = tr.style.backgroundColor;
                    if (c && c !== '') rowColorMap[k] = c;
                });
                
                persistRowColors();
                
                // Complete the operation
                completeOperation();
                
                saveLocalDraft(); 
                markEdited(); 
                updateStatus('Ligne(s) supprimée(s)', 'success'); 
                
                // Mettre à jour l'affichage du nombre de lignes
                updateRowCount();
                
                // Immediately sync with prune to avoid server reintroducing deleted rows
                await syncToMaster(true, true);
            } catch(err) { 
                // Cancel operation on error
                cancelOperation();
                log('Erreur lors de la suppression: ' + err.message, 'error'); 
                updateStatus('Erreur de suppression', 'error'); 
            } 
        }

        // Optimized Data synchronization with caching
        const dataCache = {
            lastFetch: 0,
            cacheDuration: 30000, // 30 seconds
            data: null,
            hash: null,
            
            isStale() {
                return Date.now() - this.lastFetch > this.cacheDuration;
            },
            
            set(data) {
                this.data = data;
                this.lastFetch = Date.now();
                this.hash = JSON.stringify(data).slice(0, 100); // Simple hash
            }
        };

        async function fetchInitialData(forceRefresh = false) { 
            // 🏥 HOSPITAL PC CONFLICT PREVENTION
            const operationId = 'fetch-data-' + Date.now();
            
            // Register operation with hospital conflict detector
            if (window.hospitalPCSyncDetector) {
                // Check for existing fetch operations
                const existingOps = Array.from(window.hospitalPCSyncDetector.activeOperations.entries())
                    .filter(([id, op]) => op.type === 'fetch-data' && Date.now() - op.startTime < 2000);
                
                if (existingOps.length > 0) {
                    console.log('🚨 HOSPITAL CONFLICT: Data fetch already in progress, skipping duplicate');
                    return;
                }
                
                // Register this operation
                window.hospitalPCSyncDetector.registerOperation(operationId, 'fetch-data');
            }
            
            log('Chargement des données (full fetch)...'); 
            updateStatus('Connexion...'); 
            
            // Use cached data if available and not stale
            if (!forceRefresh && dataCache.data && !dataCache.isStale()) {
                log('Utilisation des données mises en cache');
                if (loadTableData(dataCache.data)) {
                    updateStatus('Synchronisé (cache)', 'success');
                }
                // Complete operation
                if (window.hospitalPCSyncDetector) {
                    window.hospitalPCSyncDetector.completeOperation(operationId);
                }
                return;
            }
            
            try { 
                // Restore undo/redo stacks for this session
                restoreHistoryStacks();
                
                // Optimized query with only necessary columns first
                const { data, error } = await supabase
                    .from(supabaseConfig.tableName)
                    .select('*')
                    .order(supabaseConfig.primaryKeyColumn, { ascending: true })
                    .limit(1000); // Prevent massive queries 
                
                if (error) throw error; 
                
                if (Array.isArray(data) && data.length > 0) { 
                    appState.serverColumns = Object.keys(data[0]); 
                }
                
                // Cache the fetched data
                dataCache.set(data);
                
                reconcileHeadersWithServer();
                ensureDDNHeader();
                
                if (loadTableData(data)) { 
                    updateStatus('Synchronisé', 'success'); 
                    saveStateToHistory(); 
                }
                
                // Complete operation successfully
                if (window.hospitalPCSyncDetector) {
                    window.hospitalPCSyncDetector.completeOperation(operationId);
                }
            } catch(e) { 
                log('Erreur lors du chargement des données : ' + e.message, 'error'); 
                updateStatus('Erreur de connexion', 'error'); 
                
                // Complete operation with error
                if (window.hospitalPCSyncDetector) {
                    window.hospitalPCSyncDetector.completeOperation(operationId);
                }
            }
        }

        async function syncToMaster(isManualSave = false, pruneMissing = false) {
            // ENHANCED: Block sync during undo/redo operations (except manual saves)
            if (!isManualSave && isPerformingUndoRedo) {
                log('🚫 Sync BLOCKED - undo/redo in progress (manual save allowed)');
                return;
            }
            
            // ENHANCED: Block sync during undo/redo sync windows (except manual saves)
            if (!isManualSave && Date.now() < suppressAutosaveUntil) {
                log('🚫 Sync BLOCKED - undo/redo sync window active (manual save allowed)');
                return;
            }
            
            try { 
                if (autosaveTicker) clearInterval(autosaveTicker); 
            } catch(_) {}
            
            lastShownCountdown = null;
            
            const modal = document.getElementById('confirmation-modal');
            if (modal && !modal.classList.contains('hidden')) { 
                log('Sync ignorée: modale ouverte.'); 
                return; 
            }
            
            // ✅ CAPTURER LA CELLULE SÉLECTIONNÉE AVANT LA SAUVEGARDE
            const activeElement = document.activeElement;
            
            if (activeElement && activeElement.tagName === 'TD' && activeElement.contentEditable === 'true') {
                updateGlobalFocusState({
                    element: activeElement,
                    position: getCaretOffsetWithin(activeElement),
                    timestamp: Date.now(),
                    rowIndex: Array.from(activeElement.closest('tr').parentNode.querySelectorAll('tr')).indexOf(activeElement.closest('tr')),
                    colLabel: activeElement.getAttribute('data-label') || ''
                });
                
                log(`📝 Cellule sélectionnée capturée avant sauvegarde: ${capturedFocusState.colLabel}, position ${capturedFocusState.position}`, 'info');
            } else {
                log('⚠️ Aucune cellule active trouvée pour capture avant sauvegarde', 'warning');
                updateGlobalFocusState(null); // Clear any stale state
            }
            
            // Remember which cell and caret position were active before saving (legacy)
            captureFocusInfo();
            captureSimplePos();
            
            if (isManualSave && saveTimeout) { 
                clearTimeout(saveTimeout); 
            }
            
            const current = collectTableData();
            const currentHash = generateDataHash(current);
            
            let rowsForSync = current.rows.map(row => { 
                if (!appState.serverColumns) return row; 
                
                const allowed = new Set([supabaseConfig.primaryKeyColumn, ...appState.serverColumns]); 
                const filtered = {}; 
                
                for (const k in row) { 
                    if (allowed.has(k)) filtered[k] = row[k]; 
                } 
                
                return filtered; 
            });
            
            if (!isManualSave && currentHash === appState.dataHash) { 
                log('Pas de changement détecté.'); 
                isDirty = false; 
                updateStatus('Synchronisé', 'success'); 
                return; 
            }
            
            log('Synchronisation des données vers Supabase...');
            updateStatus('Sauvegarde en cours...', 'saving');
            isDirty = false;
            
            try {
                // Utiliser upsert pour toutes les opérations pour éviter les conflits de clé primaire
                if (rowsForSync.length > 0) {
                    const { error: upsertError } = await supabase
                        .from(supabaseConfig.tableName)
                        .upsert(rowsForSync, { 
                            onConflict: supabaseConfig.primaryKeyColumn,
                            ignoreDuplicates: false
                        });
                    if (upsertError) {
                        console.error('❌ Erreur upsert:', upsertError);
                        throw upsertError;
                    }
                }

                // Optionally prune server rows that are missing locally (for undo/redo or explicit deletions)
                if (pruneMissing) {
                    try {
                        const { data: serverKeysRows, error: fetchKeysErr } = await supabase
                            .from(supabaseConfig.tableName)
                            .select(supabaseConfig.primaryKeyColumn);
                        if (fetchKeysErr) throw fetchKeysErr;
                        const localKeys = new Set(current.rows.map(r => r[supabaseConfig.primaryKeyColumn]).filter(k => k != null));
                        const serverKeys = (serverKeysRows || []).map(r => r[supabaseConfig.primaryKeyColumn]).filter(k => k != null);
                        const keysToDelete = serverKeys.filter(k => !localKeys.has(k));
                        if (keysToDelete.length > 0) {
                            const { error: delErr } = await supabase
                                .from(supabaseConfig.tableName)
                                .delete()
                                .in(supabaseConfig.primaryKeyColumn, keysToDelete);
                            if (delErr) throw delErr;
                            log(`🧹 Serveur nettoyé: ${keysToDelete.length} ligne(s) supprimée(s) absentes localement.`);
                        }
                    } catch (pruneErr) {
                        console.error('❌ Erreur lors du prune des lignes manquantes:', pruneErr);
                    }
                }
                
                updateStatus('Sauvegardé', 'success');
                
                // Enregistrer le timestamp de sauvegarde pour éviter les conflits temps réel
                lastSaveTime = Date.now();
                log(`✅ Sauvegarde réussie à ${new Date(lastSaveTime).toLocaleTimeString()} - Cooldown temps réel activé pour ${REALTIME_COOLDOWN_MS}ms`);
                
                // ✅ RESTAURER LA CELLULE SÉLECTIONNÉE APRÈS LA SAUVEGARDE
                if (capturedFocusState && (capturedFocusState.element || (capturedFocusState.rowIndex >= 0 && capturedFocusState.colLabel))) {
                    log(`🔄 Restauration de la cellule sélectionnée après sauvegarde: ${capturedFocusState.colLabel}`, 'info');
                    
                    TimerManager.setTimeout(() => {
                        try {
                            // Set restoration flag to prevent save cascades
                            isRestoringCursor = true;
                            console.log('🔒 Cursor restoration started - blocking save operations');
                            
                            let targetElement = capturedFocusState.element;
                            
                            // If the original element reference is stale, find the element by position
                            if (!targetElement || !document.contains(targetElement)) {
                                log(`⚠️ Element référence obsolète, recherche par position: ligne ${capturedFocusState.rowIndex}, colonne ${capturedFocusState.colLabel}`, 'warning');
                                
                                const tbody = document.querySelector('#data-table tbody');
                                if (tbody) {
                                    const rows = tbody.querySelectorAll('tr');
                                    if (rows[capturedFocusState.rowIndex]) {
                                        const row = rows[capturedFocusState.rowIndex];
                                        targetElement = row.querySelector(`td[data-label="${capturedFocusState.colLabel}"]`);
                                        
                                        if (targetElement) {
                                            log(`✅ Élément trouvé par position: ${capturedFocusState.colLabel}`, 'success');
                                        } else {
                                            log(`❌ Impossible de trouver l'élément par position: ${capturedFocusState.colLabel}`, 'error');
                                        }
                                    }
                                }
                            }
                            
                            if (targetElement && document.contains(targetElement)) {
                                // Restaurer le focus sur la cellule
                                targetElement.focus();
                                log(`✅ Focus restauré sur la cellule: ${capturedFocusState.colLabel}`, 'success');
                                
                                // Restaurer la position du curseur
                                if (capturedFocusState.position !== null && capturedFocusState.position !== undefined) {
                                    try {
                                        setCaretAt(targetElement, capturedFocusState.position);
                                        log(`✅ Curseur restauré à la position ${capturedFocusState.position} dans ${capturedFocusState.colLabel}`, 'success');
                                    } catch (caretError) {
                                        log(`⚠️ Erreur lors de la restauration du curseur: ${caretError.message}`, 'warning');
                                        // Fallback: placer le curseur à la fin
                                        try {
                                            setCaretAt(targetElement, null);
                                            log(`✅ Curseur placé à la fin (fallback) dans ${capturedFocusState.colLabel}`, 'success');
                                        } catch (fallbackError) {
                                            log(`❌ Erreur fallback: ${fallbackError.message}`, 'error');
                                        }
                                    }
                                } else {
                                    log(`⚠️ Position du curseur non disponible dans ${capturedFocusState.colLabel}, placement à la fin`, 'warning');
                                    // Placer le curseur à la fin
                                    try {
                                        setCaretAt(targetElement, null);
                                        log(`✅ Curseur placé à la fin dans ${capturedFocusState.colLabel}`, 'success');
                                    } catch (fallbackError) {
                                        log(`❌ Erreur fallback: ${fallbackError.message}`, 'error');
                                    }
                                }
                                
                                // Faire défiler vers la cellule restaurée (sans effet visuel)
                                targetElement.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                                
                                // Clear captured focus state after successful restoration
                                TimerManager.setTimeout(() => {
                                    updateGlobalFocusState(null);
                                    log('🧹 Captured focus state cleared after successful restoration');
                                }, 1000);
                                
                            } else {
                                log(`❌ Impossible de restaurer la cellule - élément non trouvé: ${capturedFocusState.colLabel}`, 'error');
                            }
                            
                        } catch (error) {
                            log(`❌ Erreur lors de la restauration de la cellule sélectionnée: ${error.message}`, 'error');
                        } finally {
                            // Always clear the restoration flag
                            TimerManager.setTimeout(() => {
                                isRestoringCursor = false;
                                console.log('🔓 Cursor restoration completed - save operations re-enabled');
                            }, 1500); // Give extra time for all restoration operations to complete
                        }
                    }, 100);
                    
                } else {
                    log('⚠️ Aucune cellule sélectionnée à restaurer après sauvegarde', 'warning');
                }
                
                // ✅ NOUVELLE LOGIQUE: Si notre restauration a réussi, ne pas utiliser l'ancienne
                if (capturedFocusState && capturedFocusState.element) {
                    log(`✅ Restauration personnalisée réussie, ancienne restauration ignorée pour éviter les conflits`);
                } else {
                    log(`syncToMaster -> Focus restoration (lastCellPos=${JSON.stringify(lastCellPos)}, lastFocusInfo.col=${lastFocusInfo ? lastFocusInfo.colLabel : ''})`);
                    
                    // Restaurer le focus directement sans recharger les données
                    // car les données sont déjà synchronisées avec Supabase
                    TimerManager.setTimeout(() => {
                        log('🔍 Restauration directe du focus sans rechargement...');
                        
                        // Try simple row/cell index first
                        const posResult = focusCellByPos(lastCellPos);
                        log(`🔍 focusCellByPos result: ${posResult}`);
                        
                        if (!posResult) {
                            // Fallback to the richer label+caret based restore
                            const infoResult = focusCellFromInfo(lastFocusInfo, lastFocusInfo?.caret);
                            log(`🔍 focusCellFromInfo result: ${infoResult}, caret: ${lastFocusInfo?.caret}`);
                            
                            if (!infoResult) {
                                log('🔍 Both focus methods failed, trying delayed retry...');
                                TimerManager.setTimeout(() => { 
                                    if (!focusCellByPos(lastCellPos) && !focusCellFromInfo(lastFocusInfo, lastFocusInfo?.caret)) { 
                                        log('🔍 Delayed retry also failed, trying final attempt...');
                                        TimerManager.setTimeout(() => { 
                                            const finalPos = focusCellByPos(lastCellPos);
                                            const finalInfo = focusCellFromInfo(lastFocusInfo, lastFocusInfo?.caret);
                                            log(`🔍 Final attempt - pos: ${finalPos}, info: ${finalInfo}`);
                                        }, 250); 
                                    } 
                                }, 50);
                            }
                        }
                    }, 100);
                }
            } catch(e) {
                log('Erreur de sauvegarde : ' + e.message, 'error');
                updateStatus('Erreur de sauvegarde', 'error');
            }
            
            // Schedule delayed synchronization to update all devices after successful save
            if (typeof scheduleDelayedSync === 'function') {
                console.log('🔄 [SYNC] Scheduling delayed sync after master sync...');
                scheduleDelayedSync();
            }
        }

        async function pullFromMaster() { 
            log('Récupération des dernières données...'); 
            await fetchInitialData(); 
        }
        
        // Handle realtime updates from Supabase
        function handleRealtimeUpdate(payload) {
            console.log('🔄 [REALTIME] ========== REALTIME UPDATE START ==========');
            console.log('🔄 [REALTIME] Update received:', payload);
            console.log('🔄 [REALTIME] Event type:', payload.event);
            console.log('🔄 [REALTIME] Timestamp:', new Date().toISOString());
            console.log('🔄 [REALTIME] Current state - isRestoringCursor:', isRestoringCursor);
            console.log('🔄 [REALTIME] Current state - capturedFocusState:', capturedFocusState?.colLabel || 'none');
            
            // Performance monitoring
            if (typeof eventManager !== 'undefined' && eventManager.monitor) {
                eventManager.monitor.mark('realtime-update-start');
            }
            
            // Avoid update loops
            if (window.isLocalSaveInProgress) {
                console.log('⚠️ [REALTIME] Update BLOCKED - local save in progress');
                return;
            }
            
            // ✅ PRIORITY: Block if cursor restoration is actively happening
            if (isRestoringCursor) {
                console.log('⚠️ [REALTIME] Update BLOCKED - cursor restoration in progress (primary protection)');
                // Retry after cursor restoration is complete
                TimerManager.setTimeout(() => {
                    console.log('🔄 [REALTIME] Retrying update after cursor restoration...');
                    if (typeof fetchInitialData === 'function' && !isRestoringCursor && !RaceConditionGuard.getFlag('isExcelSaveInProgress')) {
                        fetchInitialData(true); // Force refresh for retry
                    }
                }, 2000); // Wait for cursor restoration to complete
                return;
            }
            
            // ✅ HIGH PRIORITY: Block if Excel-like save is in progress
            if (RaceConditionGuard.getFlag('isExcelSaveInProgress')) {
                console.log('⚠️ [REALTIME] Update BLOCKED - Excel-like save in progress (Excel protection)');
                // Retry after Excel save is complete
                TimerManager.setTimeout(() => {
                    console.log('🔄 [REALTIME] Retrying update after Excel save...');
                    if (typeof fetchInitialData === 'function' && !isRestoringCursor && !RaceConditionGuard.getFlag('isExcelSaveInProgress')) {
                        fetchInitialData(true); // Force refresh for retry
                    }
                }, 4000); // Wait for Excel save to complete
                return;
            }

            // Process update based on event type
            switch (payload.event) {
                case 'INSERT':
                    console.log('➕ New row inserted via realtime');
                    break;
                case 'UPDATE':
                    console.log('✏️ Row updated via realtime');
                    break;
                case 'DELETE':
                    console.log('🗑️ Row deleted via realtime');
                    break;
            }

            // ✅ Secondary protection: Extended focus restoration window for Excel-like saves
            if (capturedFocusState && capturedFocusState.element && capturedFocusState.timestamp && (Date.now() - capturedFocusState.timestamp < 5000)) {
                console.log('⚠️ [REALTIME] Update DELAYED - Excel-like save protection window active (5 seconds)');
                // Extended retry delay for Excel-like saves
                TimerManager.setTimeout(() => {
                    console.log('🔄 [REALTIME] Retrying update after Excel-like save window...');
                    if (typeof fetchInitialData === 'function' && !isRestoringCursor) {
                        fetchInitialData(true); // Force refresh for retry
                    }
                }, 5500); // Extended delay for Excel-like save completion
                return;
            }
            
            console.log('✅ [REALTIME] Proceeding with data refresh...');
            
            // ALWAYS capture current cursor position before realtime refresh
            const activeElement = document.activeElement;
            let wasCursorCaptured = false;
            
            if (activeElement && activeElement.tagName === 'TD' && activeElement.contentEditable === 'true') {
                // Force fresh capture of current cursor position
                updateGlobalFocusState({
                    element: activeElement,
                    position: getCaretOffsetWithin(activeElement),
                    timestamp: Date.now(),
                    rowIndex: Array.from(activeElement.closest('tr').parentNode.querySelectorAll('tr')).indexOf(activeElement.closest('tr')),
                    colLabel: activeElement.getAttribute('data-label') || '',
                    realtimeCapture: true // Flag to indicate this was captured during realtime sync
                });
                wasCursorCaptured = true;
                console.log('📝 [REALTIME] Fresh cursor captured before realtime refresh:', capturedFocusState.colLabel, 'position:', capturedFocusState.position);
            } else {
                console.log('⚠️ [REALTIME] No editable cell focused - cursor restoration not possible');
            }
            
            // Refresh data from Supabase after a short delay
            TimerManager.setTimeout(() => {
                if (typeof fetchInitialData === 'function') {
                    console.log('🔄 [REALTIME] Starting data refresh...');
                    fetchInitialData(true).then(() => { // Force refresh for realtime updates
                        console.log('✅ [REALTIME] Data refresh completed successfully');
                        updateStatus('Données synchronisées via temps réel', 'success');
                        
                        // Invalidate cache to ensure fresh data for future requests
                        if (typeof dataCache !== 'undefined') {
                            dataCache.lastFetch = 0; // Force cache invalidation
                        }
                        
                        // Force UI refresh to ensure changes are visible
                        if (typeof renderTable === 'function') {
                            console.log('🔄 [REALTIME] Force rendering table');
                            renderTable();
                        } else {
                            console.warn('⚠️ [REALTIME] renderTable function not available');
                        }
                        
                        // Trigger table update event for other components
                        document.dispatchEvent(new CustomEvent('table:updated', { detail: { source: 'realtime', timestamp: new Date().toISOString() } }));
                        console.log('✅ [REALTIME] Table update event dispatched');
                        
                        // ✅ Enhanced cursor restoration with stronger protection
                        console.log('🔍 [REALTIME DEBUG] Checking cursor restoration conditions...');
                        console.log('🔍 [REALTIME DEBUG] capturedFocusState exists:', !!capturedFocusState);
                        console.log('🔍 [REALTIME DEBUG] capturedFocusState.colLabel:', capturedFocusState?.colLabel);
                        console.log('🔍 [REALTIME DEBUG] capturedFocusState.position:', capturedFocusState?.position);
                        console.log('🔍 [REALTIME DEBUG] capturedFocusState.rowIndex:', capturedFocusState?.rowIndex);
                        
                        if (capturedFocusState && capturedFocusState.colLabel) {
                            console.log('🔄 [REALTIME] Starting enhanced cursor restoration after realtime refresh...');
                            
                            // Use retry logic with progressive delays to ensure DOM is ready
                            const attemptCursorRestoration = (attemptNum = 1, maxAttempts = 5) => {
                                const baseDelay = 100; // Start with 100ms
                                const delay = attemptNum * baseDelay; // Progressive: 100ms, 200ms, 300ms, etc.
                                
                                TimerManager.setTimeout(() => {
                                    console.log(`🔄 [REALTIME] Cursor restoration attempt ${attemptNum}/${maxAttempts} (delay: ${delay}ms)`);
                                    isRestoringCursor = true; // Primary flag
                                    RaceConditionGuard.setFlag('isExcelSaveInProgress', true); // Secondary protection during restoration
                                    
                                    try {
                                        let targetElement = capturedFocusState.element;
                                        
                                        // Element might be stale after refresh, find by position with enhanced search
                                        console.log('🔍 [REALTIME DEBUG] targetElement exists:', !!targetElement);
                                        console.log('🔍 [REALTIME DEBUG] targetElement in DOM:', targetElement ? document.contains(targetElement) : false);
                                        
                                        if (!targetElement || !document.contains(targetElement)) {
                                            console.log('🔄 [REALTIME] Element stale, searching by position and label...');
                                            const tbody = document.querySelector('#table-body') || document.querySelector('#data-table tbody');
                                            console.log('🔍 [REALTIME DEBUG] tbody found:', !!tbody);
                                            
                                            if (!tbody) {
                                                if (attemptNum < maxAttempts) {
                                                    console.log(`⚠️ [REALTIME] Table body not found yet, retrying (attempt ${attemptNum})...`);
                                                    isRestoringCursor = false;
                                                    RaceConditionGuard.clearFlag('isExcelSaveInProgress');
                                                    attemptCursorRestoration(attemptNum + 1, maxAttempts);
                                                    return;
                                                } else {
                                                    console.warn('⚠️ [REALTIME] Table body not found after all attempts');
                                                }
                                            } else {
                                                const rows = tbody.querySelectorAll('tr');
                                                console.log(`🔄 [REALTIME] Found ${rows.length} rows, looking for row ${capturedFocusState.rowIndex}`);
                                                if (rows[capturedFocusState.rowIndex]) {
                                                    const row = rows[capturedFocusState.rowIndex];
                                                    console.log('🔍 [REALTIME DEBUG] Target row found:', !!row);
                                                    targetElement = row.querySelector(`td[data-label="${capturedFocusState.colLabel}"]`);
                                                    console.log('🔄 [REALTIME] Found target element by label:', !!targetElement);
                                                    if (targetElement) {
                                                        console.log('🔍 [REALTIME DEBUG] Target element contentEditable:', targetElement.contentEditable);
                                                    }
                                                } else {
                                                    if (attemptNum < maxAttempts) {
                                                        console.log(`⚠️ [REALTIME] Row ${capturedFocusState.rowIndex} not found yet in ${rows.length} rows, retrying...`);
                                                        isRestoringCursor = false;
                                                        RaceConditionGuard.clearFlag('isExcelSaveInProgress');
                                                        attemptCursorRestoration(attemptNum + 1, maxAttempts);
                                                        return;
                                                    } else {
                                                        console.warn('⚠️ [REALTIME] Row index out of bounds after all attempts:', capturedFocusState.rowIndex, 'of', rows.length);
                                                    }
                                                }
                                            }
                                        }
                                        
                                        if (targetElement && document.contains(targetElement) && targetElement.contentEditable === 'true') {
                                            console.log(`🔄 [REALTIME] Focusing target element and restoring caret (attempt ${attemptNum})...`);
                                            
                                            // Multiple strategies for focus and caret restoration
                                            targetElement.focus();
                                            
                                            // Give focus time to settle, then restore caret
                                            TimerManager.setTimeout(() => {
                                                try {
                                                    // Restore caret position with validation
                                                    if (capturedFocusState.position !== null && capturedFocusState.position !== undefined) {
                                                        const textLength = targetElement.textContent.length;
                                                        const safePosition = Math.min(capturedFocusState.position, textLength);
                                                        setCaretAt(targetElement, safePosition);
                                                        console.log(`🔄 [REALTIME] Caret set to position ${safePosition} (original: ${capturedFocusState.position})`);
                                                        
                                                        // Verify the caret was actually set correctly
                                                        TimerManager.setTimeout(() => {
                                                            try {
                                                                const currentCaretPos = getCaretOffsetWithin(targetElement);
                                                                const isElementFocused = document.activeElement === targetElement;
                                                                console.log(`🔍 [REALTIME] Post-restoration verification (attempt ${attemptNum}):`);
                                                                console.log(`    - Element focused: ${isElementFocused}`);
                                                                console.log(`    - Current caret position: ${currentCaretPos}`);
                                                                console.log(`    - Expected caret position: ${safePosition}`);
                                                                
                                                                if ((!isElementFocused || currentCaretPos !== safePosition) && attemptNum < maxAttempts) {
                                                                    console.log(`⚠️ [REALTIME] Cursor not properly restored (attempt ${attemptNum}), retrying...`);
                                                                    isRestoringCursor = false;
                                                                    RaceConditionGuard.clearFlag('isExcelSaveInProgress');
                                                                    attemptCursorRestoration(attemptNum + 1, maxAttempts);
                                                                    return;
                                                                } else if (isElementFocused && (currentCaretPos === safePosition || attemptNum >= maxAttempts)) {
                                                                    console.log(`✅ [REALTIME] Cursor restoration successful (attempt ${attemptNum}):`, capturedFocusState.colLabel);
                                                                    
                                                                    // Clear restoration flags on success
                                                                    TimerManager.setTimeout(() => {
                                                                        isRestoringCursor = false;
                                                                        console.log('✅ [REALTIME] Cursor restoration flag cleared');
                                                                    }, 500);
                                                                    
                                                                    TimerManager.setTimeout(() => {
                                                                        RaceConditionGuard.clearFlag('isExcelSaveInProgress');
                                                                        console.log('✅ [REALTIME] Excel save protection flag cleared');
                                                                    }, 1500);
                                                                    
                                                                    TimerManager.setTimeout(() => {
                                                                        if (wasCursorCaptured) {
                                                                            updateGlobalFocusState(null);
                                                                            console.log('✅ [REALTIME] Focus state cleared (was captured during realtime)');
                                                                        } else {
                                                                            console.log('🔄 [REALTIME] Focus state preserved (was pre-existing)');
                                                                        }
                                                                    }, 2500);
                                                                }
                                                            } catch (verifyError) {
                                                                console.error('❌ [REALTIME] Error during cursor verification:', verifyError);
                                                            }
                                                        }, 50); // Give caret setting time to take effect
                                                        
                                                    } else {
                                                        // Position at end if no specific position
                                                        setCaretAt(targetElement, null);
                                                        console.log(`🔄 [REALTIME] Caret positioned at end (no specific position stored)`);
                                                        console.log(`✅ [REALTIME] Cursor restoration completed (attempt ${attemptNum}):`, capturedFocusState.colLabel);
                                                    }
                                                } catch (caretError) {
                                                    console.error(`❌ [REALTIME] Error setting caret (attempt ${attemptNum}):`, caretError);
                                                    if (attemptNum < maxAttempts) {
                                                        console.log(`⚠️ [REALTIME] Retrying caret restoration...`);
                                                        isRestoringCursor = false;
                                                        RaceConditionGuard.clearFlag('isExcelSaveInProgress');
                                                        attemptCursorRestoration(attemptNum + 1, maxAttempts);
                                                        return;
                                                    }
                                                }
                                            }, 30); // Small delay for focus to settle
                                            
                                        } else {
                                            if (attemptNum < maxAttempts) {
                                                console.log(`⚠️ [REALTIME] Target element not ready (attempt ${attemptNum}), retrying...`);
                                                console.log(`    - Element exists: ${!!targetElement}`);
                                                console.log(`    - Element in DOM: ${targetElement ? document.contains(targetElement) : false}`);
                                                console.log(`    - Element editable: ${targetElement ? targetElement.contentEditable : 'N/A'}`);
                                                isRestoringCursor = false;
                                                RaceConditionGuard.clearFlag('isExcelSaveInProgress');
                                                attemptCursorRestoration(attemptNum + 1, maxAttempts);
                                                return;
                                            } else {
                                                console.warn(`⚠️ [REALTIME] Target element not available after all attempts`);
                                            }
                                        }
                                        
                                    } catch (error) {
                                        console.error(`❌ [REALTIME] Error during cursor restoration (attempt ${attemptNum}):`, error);
                                        if (attemptNum < maxAttempts) {
                                            console.log(`⚠️ [REALTIME] Retrying after error...`);
                                            isRestoringCursor = false;
                                            RaceConditionGuard.clearFlag('isExcelSaveInProgress');
                                            attemptCursorRestoration(attemptNum + 1, maxAttempts);
                                            return;
                                        }
                                    } finally {
                                        // Only clear flags on final attempt if not retrying
                                        if (attemptNum >= maxAttempts) {
                                            TimerManager.setTimeout(() => {
                                                isRestoringCursor = false;
                                                console.log('✅ [REALTIME] Cursor restoration flag cleared (final attempt)');
                                            }, 800);
                                            
                                            TimerManager.setTimeout(() => {
                                                RaceConditionGuard.clearFlag('isExcelSaveInProgress');
                                                console.log('✅ [REALTIME] Excel save protection flag cleared (final attempt)');
                                            }, 2000);
                                            
                                            TimerManager.setTimeout(() => {
                                                if (wasCursorCaptured) {
                                                    updateGlobalFocusState(null);
                                                    console.log('✅ [REALTIME] Focus state cleared (was captured during realtime)');
                                                } else {
                                                    console.log('🔄 [REALTIME] Focus state preserved (was pre-existing)');
                                                }
                                            }, 3000);
                                        }
                                    }
                                }, delay);
                            };
                            
                            // Start the cursor restoration attempts
                            attemptCursorRestoration();
                        } else {
                            console.log('🔄 [REALTIME] No focus state to restore');
                        }
                        
                        // Performance monitoring
                        if (typeof eventManager !== 'undefined' && eventManager.monitor) {
                            eventManager.monitor.mark('realtime-update-complete');
                        }
                        
                    }).catch(error => {
                        console.error('❌ [REALTIME] Data refresh failed:', error);
                        
                        // Performance monitoring
                        if (typeof eventManager !== 'undefined' && eventManager.monitor) {
                            eventManager.monitor.mark('realtime-update-error');
                        }
                    });
                } else {
                    console.error('❌ [REALTIME] fetchInitialData function not available!');
                }
            }, 1000);
        }

        // Immediate synchronization system for real-time updates across all devices
        function forceImmediateSync() {
            console.log('🚀 [IMMEDIATE SYNC] Forcing immediate synchronization across all devices...');
            
            // Force refresh data from server
            if (typeof fetchInitialData === 'function') {
                console.log('🔄 [IMMEDIATE SYNC] Fetching fresh data from server...');
                fetchInitialData(true).then(() => {
                    console.log('✅ [IMMEDIATE SYNC] Data fetch completed');
                    
                    // Force UI refresh
                    if (typeof renderTable === 'function') {
                        console.log('🔄 [IMMEDIATE SYNC] Force rendering table...');
                        renderTable();
                    }
                    
                    // Invalidate cache to ensure fresh data
                    if (typeof dataCache !== 'undefined') {
                        dataCache.lastFetch = 0;
                    }
                    
                    // Dispatch update event for other components
                    document.dispatchEvent(new CustomEvent('table:updated', { 
                        detail: { 
                            source: 'immediate-sync', 
                            timestamp: new Date().toISOString() 
                        } 
                    }));
                    
                    console.log('✅ [IMMEDIATE SYNC] Immediate synchronization completed');
                }).catch(error => {
                    console.error('❌ [IMMEDIATE SYNC] Error during immediate sync:', error);
                });
            } else {
                console.error('❌ [IMMEDIATE SYNC] fetchInitialData function not available');
            }
        }

        // Delayed synchronization system - waits 5 seconds after user stops editing
        let delayedSyncTimeout = null;
        const DELAYED_SYNC_DELAY = 5000; // 5 seconds after user stops editing
        
        function scheduleDelayedSync() {
            // Clear any existing timeout
            if (delayedSyncTimeout) {
                clearTimeout(delayedSyncTimeout);
                delayedSyncTimeout = null;
            }
            
            console.log('⏰ [DELAYED SYNC] Scheduling delayed sync in 5 seconds...');
            
            // Schedule sync after 5 seconds of inactivity
            delayedSyncTimeout = setTimeout(() => {
                console.log('🔄 [DELAYED SYNC] 5 seconds passed, triggering sync...');
                forceImmediateSync();
                delayedSyncTimeout = null;
            }, DELAYED_SYNC_DELAY);
        }
        
        function cancelDelayedSync() {
            if (delayedSyncTimeout) {
                console.log('❌ [DELAYED SYNC] Cancelling delayed sync...');
                clearTimeout(delayedSyncTimeout);
                delayedSyncTimeout = null;
            }
        }

        // Enhanced realtime update handler that schedules delayed sync
        function handleRealtimeUpdateWithImmediateSync(payload) {
            console.log('🔄 [ENHANCED REALTIME] Processing update with delayed sync...');
            console.log('🔍 [DEBUG] Update received:', {
                event: payload.event,
                table: payload.table,
                timestamp: new Date().toISOString(),
                url: window.location.href,
                userAgent: navigator.userAgent.substring(0, 50) + '...'
            });
            
            // First, handle the normal realtime update
            handleRealtimeUpdate(payload);
            
            // Then, schedule delayed synchronization on all devices
            // This ensures that all devices get the latest data 5 seconds after the user stops editing
            scheduleDelayedSync();
        }

        // Realtime connection state management
        let realtimeRetryCount = 0;
        const MAX_RETRY_ATTEMPTS = 5;
        const BASE_RETRY_DELAY = 2000; // 2 seconds
        let isRealtimeEnabled = true;
        let fallbackMode = false;
        let retryTimeout = null;
        
        // Timestamp-based sync system for hospital networks that block WebSockets
        let timestampSyncInterval = null;
        const TIMESTAMP_SYNC_INTERVAL = 1000; // Check every 1 second for user activity
        let lastSyncTimestamp = null;
        let isTimestampSyncActive = false;
        let lastKnownDataVersion = null;
        let userInactivityTimeout = null;
        const USER_INACTIVITY_DELAY = 5000; // Wait 5 seconds after user stops editing

        // Fallback save system for when realtime sync fails
        let fallbackSaveTimeout = null;
        const FALLBACK_SAVE_DELAY = 3000; // 3 seconds after user stops editing
        let lastUserEditTime = 0;
        let isFallbackSaveActive = false;


        // Setup realtime subscription for live data synchronization with resilient connection handling
        function setupRealtimeSubscription() {
            try {
                if (realtimeSubscription) {
                    console.log('🔄 Cleaning up existing realtime subscription...');
                    supabase.removeChannel(realtimeSubscription);
                }

                console.log('🔄 Setting up realtime subscription...');
                console.log('🔍 [DEBUG] Supabase client status:', !!supabase);
                console.log('🔍 [DEBUG] Current URL:', window.location.href);
                
                realtimeSubscription = supabase.channel('table-changes')
                    .on('postgres_changes', { 
                        event: 'INSERT', 
                        schema: 'public', 
                        table: 'staffTable' 
                    }, handleRealtimeUpdateWithImmediateSync)
                    .on('postgres_changes', { 
                        event: 'UPDATE', 
                        schema: 'public', 
                        table: 'staffTable' 
                    }, handleRealtimeUpdateWithImmediateSync)
                    .on('postgres_changes', { 
                        event: 'DELETE', 
                        schema: 'public', 
                        table: 'staffTable' 
                    }, handleRealtimeUpdateWithImmediateSync)
                    .subscribe(status => {
                        console.log('📡 Realtime subscription status:', status);
                        console.log('🔍 [DEBUG] Subscription details:', {
                            status: status,
                            timestamp: new Date().toISOString(),
                            url: window.location.href,
                            userAgent: navigator.userAgent.substring(0, 50) + '...'
                        });
                        
                        if (status === 'SUBSCRIBED') {
                            console.log('✅ Realtime synchronization activated');
                            realtimeRetryCount = 0; // Reset retry count on successful connection
                            fallbackMode = false;
                            stopFallbackSave(); // Stop fallback save when realtime sync is restored
                            stopTimestampSync(); // Stop timestamp sync when realtime sync is restored
                            const message = getAdaptiveMessage('Sync activée', 'Synchronisation temps réel activée');
                            updateStatus(message, 'success');
                        } else if (status === 'CHANNEL_ERROR' || status === 'CLOSED') {
                            console.log('❌ Realtime synchronization error - status:', status);
                            console.log('🔍 [DEBUG] Error details:', {
                                status: status,
                                retryCount: realtimeRetryCount,
                                maxRetries: MAX_RETRY_ATTEMPTS,
                                timestamp: new Date().toISOString()
                            });
                            handleRealtimeConnectionError();
                        }
                    });
                    
                console.log('✅ Realtime subscription configured');
            } catch (error) {
                console.error('❌ Error setting up realtime subscription:', error);
                handleRealtimeConnectionError();
            }
        }


        // Fallback save system for when realtime sync fails
        function startFallbackSave() {
            if (isFallbackSaveActive) return;
            
            console.log('🔄 Starting fallback save system...');
            isFallbackSaveActive = true;
            
            // Clear existing timeout
            if (fallbackSaveTimeout) {
                clearTimeout(fallbackSaveTimeout);
            }
            
            // Set up periodic check for user activity
            const fallbackInterval = setInterval(() => {
                const timeSinceLastEdit = Date.now() - lastUserEditTime;
                
                // If user has stopped editing for 3 seconds and realtime sync is not working
                if (timeSinceLastEdit >= FALLBACK_SAVE_DELAY && !isRealtimeWorking()) {
                    console.log('💾 Triggering fallback save - realtime sync not working');
                    performFallbackSave();
                }
            }, 1000); // Check every second
            
            // Store interval ID for cleanup
            fallbackSaveTimeout = fallbackInterval;
        }

        function stopFallbackSave() {
            if (!isFallbackSaveActive) return;
            
            console.log('🛑 Stopping fallback save system...');
            isFallbackSaveActive = false;
            
            if (fallbackSaveTimeout) {
                clearTimeout(fallbackSaveTimeout);
                fallbackSaveTimeout = null;
            }
        }

        function isRealtimeWorking() {
            // Check if realtime subscription is active and working
            return realtimeSubscription && 
                   realtimeRetryCount < MAX_RETRY_ATTEMPTS && 
                   isRealtimeEnabled;
        }

        function performFallbackSave() {
            try {
                console.log('💾 Performing fallback save...');
                
                // Use the existing save function if available
                if (typeof saveLocalDraft === 'function') {
                    saveLocalDraft();
                    console.log('✅ Fallback save completed');
                } else {
                    console.warn('⚠️ saveLocalDraft function not available for fallback save');
                }
            } catch (error) {
                console.error('❌ Error in fallback save:', error);
            }
        }

        function updateUserEditTime() {
            lastUserEditTime = Date.now();
            
            // Cancel any pending delayed sync when user starts editing again
            if (typeof cancelDelayedSync === 'function') {
                cancelDelayedSync();
            }
        }

        // Timestamp-based sync system for hospital networks with user activity detection
        function startTimestampSync() {
            if (isTimestampSyncActive) return;
            
            console.log('🔄 [TIMESTAMP SYNC] Starting timestamp-based sync system...');
            isTimestampSyncActive = true;
            
            // Get initial timestamp
            getLastModificationTimestamp().then(timestamp => {
                lastSyncTimestamp = timestamp;
                console.log('🔄 [TIMESTAMP SYNC] Initial timestamp:', new Date(timestamp).toISOString());
            });
            
            // Start periodic checking for user activity
            timestampSyncInterval = setInterval(async () => {
                try {
                    await checkUserActivityAndScheduleSync();
                } catch (error) {
                    console.log('⚠️ [TIMESTAMP SYNC] Error checking user activity:', error.message);
                }
            }, TIMESTAMP_SYNC_INTERVAL);
            
            console.log('✅ [TIMESTAMP SYNC] Timestamp-based sync started (waits 5s after user stops editing)');
        }
        
        function stopTimestampSync() {
            if (timestampSyncInterval) {
                clearInterval(timestampSyncInterval);
                timestampSyncInterval = null;
            }
            if (userInactivityTimeout) {
                clearTimeout(userInactivityTimeout);
                userInactivityTimeout = null;
            }
            isTimestampSyncActive = false;
            console.log('🛑 [TIMESTAMP SYNC] Timestamp-based sync stopped');
        }
        
        async function getLastModificationTimestamp() {
            try {
                const { data, error } = await supabase
                    .from('staffTable')
                    .select('updated_at')
                    .order('updated_at', { ascending: false })
                    .limit(1);
                
                if (error) throw error;
                
                if (data && data.length > 0) {
                    return new Date(data[0].updated_at).getTime();
                }
                
                return Date.now();
            } catch (error) {
                console.error('❌ [TIMESTAMP SYNC] Error getting timestamp:', error);
                return Date.now();
            }
        }
        
        async function checkUserActivityAndScheduleSync() {
            try {
                // Check if user is currently editing
                const timeSinceLastEdit = Date.now() - lastUserEditTime;
                const isUserCurrentlyEditing = timeSinceLastEdit < USER_INACTIVITY_DELAY;
                
                if (isUserCurrentlyEditing) {
                    // User is still editing, clear any existing timeout and wait
                    if (userInactivityTimeout) {
                        clearTimeout(userInactivityTimeout);
                        userInactivityTimeout = null;
                    }
                    console.log('⏸️ [TIMESTAMP SYNC] User is editing, waiting for inactivity...');
                    return;
                }
                
                // User has stopped editing for 5+ seconds, check for changes
                if (!userInactivityTimeout) {
                    console.log('🔄 [TIMESTAMP SYNC] User inactive for 5+ seconds, checking for changes...');
                    await checkForDataChanges();
                }
            } catch (error) {
                console.error('❌ [TIMESTAMP SYNC] Error checking user activity:', error);
            }
        }
        
        async function checkForDataChanges() {
            try {
                const currentTimestamp = await getLastModificationTimestamp();
                
                if (lastSyncTimestamp && currentTimestamp > lastSyncTimestamp) {
                    console.log('🔄 [TIMESTAMP SYNC] Data changes detected, syncing...');
                    console.log('🔄 [TIMESTAMP SYNC] Last sync:', new Date(lastSyncTimestamp).toISOString());
                    console.log('🔄 [TIMESTAMP SYNC] Current:', new Date(currentTimestamp).toISOString());
                    
                    // Update timestamp
                    lastSyncTimestamp = currentTimestamp;
                    
                    // Force data refresh
                    if (typeof fetchInitialData === 'function') {
                        await fetchInitialData(true);
                        console.log('✅ [TIMESTAMP SYNC] Data synced successfully');
                    }
                } else {
                    console.log('✅ [TIMESTAMP SYNC] No changes detected');
                }
            } catch (error) {
                console.error('❌ [TIMESTAMP SYNC] Error checking for changes:', error);
            }
        }

        // Handle realtime connection errors with exponential backoff retry and fallback save
        function handleRealtimeConnectionError() {
            if (!isRealtimeEnabled) return;

            if (realtimeRetryCount >= MAX_RETRY_ATTEMPTS) {
                console.log('⚠️ Max retry attempts reached - starting fallback systems');
                startFallbackSave();
                startTimestampSync(); // Start timestamp-based sync for hospital networks
                return;
            }

            realtimeRetryCount++;
            const delay = BASE_RETRY_DELAY * Math.pow(2, realtimeRetryCount - 1); // Exponential backoff
            
            console.log(`🔄 Retrying realtime connection in ${delay/1000}s (attempt ${realtimeRetryCount}/${MAX_RETRY_ATTEMPTS})`);

            if (retryTimeout) {
                clearTimeout(retryTimeout);
            }

            retryTimeout = setTimeout(() => {
                setupRealtimeSubscription();
            }, delay);
        }




        // Password authentication
        function checkPassword() { 
            const passwordElement = SafeDOM.getElementById('password');
            const pwd = passwordElement ? passwordElement.value : ''; 
            const err = document.getElementById('error-message'); 
            const passwordInput = document.getElementById('password');
            const togglePassword = document.getElementById('toggle-password');
            
            if (pwd === APP_CONFIG.password) { 
                appState.isLoggedIn = true; 
                sessionStorage.setItem('isLoggedIn', '1'); 
                
                // Masquer le login et afficher le tableau immédiatement
                SafeDOM.safeAddClass('login-container', 'hidden'); 
                SafeDOM.safeRemoveClass('table-container', 'hidden'); 
                
                // S'assurer que le tableau est visible
                const tableContainer = document.getElementById('table-container');
                const table = document.getElementById('data-table');
                
                if (tableContainer) {
                    tableContainer.style.display = 'block';
                    tableContainer.style.visibility = 'visible';
                }
                
                if (table) {
                    table.style.display = 'table';
                    table.style.visibility = 'visible';
                }
                
                // Initialiser complètement l'application après la connexion
                initializeApp();
                
            } else { 
                err.textContent = 'Mot de passe incorrect. Le champ est maintenant visible pour faciliter la correction.';
                
                // Transformer automatiquement le champ en texte visible pour faciliter la correction
                passwordInput.type = 'text';
                togglePassword.checked = true;
                
                // Remettre le focus dans le champ pour permettre la correction immédiate
                passwordInput.focus();
                
                // Sélectionner tout le texte pour faciliter la correction
                passwordInput.select();
                
                // Ajouter une classe CSS pour indiquer visuellement l'erreur
                passwordInput.classList.add('password-error');
                
                // Retirer la classe d'erreur quand l'utilisateur commence à taper
                passwordInput.addEventListener('input', function clearErrorStyle() {
                    passwordInput.classList.remove('password-error');
                    passwordInput.removeEventListener('input', clearErrorStyle);
                }, { once: true });
            } 
        }

        // Export functionality
        function downloadExcel() { 
            const table = document.getElementById('data-table'); 
            const ws = XLSX.utils.table_to_sheet(table); 
            const wb = XLSX.utils.book_new(); 
            XLSX.utils.book_append_sheet(wb, ws, 'Staff Data'); 
            XLSX.writeFile(wb, 'Tableau_Staff.xlsx'); 
            showMessage('Excel téléchargé.'); 
        }
        
        function downloadPDF() { 
            const { jsPDF } = window.jspdf; 
            const doc = new jsPDF('l', 'pt', 'a4'); 
            doc.autoTable({ html: '#data-table' }); 
            doc.save('Tableau_Staff.pdf'); 
            showMessage('PDF téléchargé.'); 
        }
        
        function downloadImage() { 
            const table = document.getElementById('data-table'); 
            html2canvas(table).then(canvas => { 
                const link = document.createElement('a'); 
                link.href = canvas.toDataURL('image/png'); 
                link.download = 'Tableau_Staff.png'; 
                link.click(); 
                showMessage('Image téléchargée.'); 
            }); 
        }

        // Manual save function
        function saveManually() { 
            syncToMaster(true); 
        }


        // Row color binding
        function rebindRowNumberCells() {
            try {
                const rows = document.querySelectorAll('#table-body tr');
                rows.forEach((row) => {
                    const numCell = row.cells && row.cells[0];
                    if (!numCell) return;
                    
                    // Ensure proper classes/title
                    if (!numCell.className.includes('cursor-pointer')) {
                        numCell.className += ' cursor-pointer';
                    }
                    if (!numCell.getAttribute('title')) {
                        numCell.title = 'Cliquer pour colorer/effacer la ligne';
                    }
                    
                    // Replace the cell to drop old listeners
                    const newCell = numCell.cloneNode(true);
                    
                    // Drag start (mouse)
                    newCell.addEventListener('mousedown', (e) => { 
                        if (e.button !== 0) return; 
                        startRowPaint(row); 
                        e.preventDefault(); 
                    });
                    
                    // Drag over other rows (mouse)
                    newCell.addEventListener('mouseenter', () => { 
                        if (isRowPaintDragging) applyRowPaint(row); 
                    });
                    
                    // Simple toggle on click when not dragging
                    newCell.addEventListener('click', (e) => { 
                        e.preventDefault();
                        if (isRowPaintDragging) return;
                        rowPaintAction = getPaintActionForRow(row);
                        applyRowPaint(row);
                    });
                    
                    // Touch support
                    newCell.addEventListener('touchstart', (e) => { 
                        startRowPaint(row); 
                        e.preventDefault(); 
                    }, { passive: false });
                    
                    newCell.addEventListener('touchmove', (e) => {
                        const t = e.touches && e.touches[0]; 
                        if (!t) return; 
                        const el = document.elementFromPoint(t.clientX, t.clientY);
                        const tr = el ? el.closest('#table-body tr') : null; 
                        if (tr) applyRowPaint(tr); 
                        e.preventDefault();
                    }, { passive: false });
                    
                    row.replaceChild(newCell, numCell);
                });
            } catch(_) {}
        }

        // First use hint
        function maybeShowFirstUseHint() {
            try {
                if (localStorage.getItem('rowPaintHintShown') === '1') return;
                showMessage('Astuce: cliquez puis faites glisser sur les numéros de ligne pour colorer/effacer.', 'info');
                localStorage.setItem('rowPaintHintShown', '1');
            } catch(_) {}
        }

        // Event listeners setup
        function setupEventListeners() {
            // Before unload warning
            window.addEventListener('beforeunload', function (e) { 
                if (isDirty) { 
                    e.preventDefault(); 
                    e.returnValue = 'Des modifications non sauvegardées seront perdues si vous quittez.'; 
                } 
            });

            // Password toggle
            document.getElementById('toggle-password').addEventListener('change', function() { 
                const el = document.getElementById('password'); 
                el.type = this.checked ? 'text' : 'password'; 
            });
            
            // Password enter key
            document.getElementById('password').addEventListener('keydown', function (e) { 
                // Stop any global keyboard shortcuts from interfering
                e.stopPropagation();
                
                if (e.key === 'Enter') { 
                    e.preventDefault(); 
                    checkPassword(); 
                } 
                
                return true;
            });
            
            // Global keyboard shortcuts
            document.addEventListener('keydown', function (e) {
                // Manual save shortcut: Cmd+Z (Mac) or Ctrl+Z (Windows/Linux)
                if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
                    e.preventDefault(); // Prevent browser undo dialog
                    
                    // Only trigger if not in password input
                    const passwordInput = document.getElementById('password');
                    if (passwordInput && document.activeElement === passwordInput) {
                        return;
                    }
                    
                    // Only trigger if not in table cells (to avoid interfering with cell editing)
                    if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                        return;
                    }
                    
                    console.log('💾 Raccourci clavier de sauvegarde manuelle activé (Cmd+Z/Ctrl+Z)');
                    saveManually();
                }
                
                // Alternative save shortcut: Cmd+S (Mac) or Ctrl+S (Windows/Linux)
                if ((e.metaKey || e.ctrlKey) && e.key === 's') {
                    e.preventDefault(); // Prevent browser save dialog
                    
                    // Only trigger if not in password input
                    const passwordInput = document.getElementById('password');
                    if (passwordInput && document.activeElement === passwordInput) {
                        return;
                    }
                    
                    // Only trigger if not in table cells (to avoid interfering with cell editing)
                    if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                        return;
                    }
                    
                    console.log('💾 Raccourci clavier de sauvegarde manuelle activé (Cmd+S/Ctrl+S)');
                    saveManually();
                }
                
                // Undo shortcut: Cmd+Y (Mac) or Ctrl+Y (Windows/Linux)
                if ((e.metaKey || e.ctrlKey) && e.key === 'y') {
                    e.preventDefault(); // Prevent browser history dialog
                    
                    // Only trigger if not in password input
                    const passwordInput = document.getElementById('password');
                    if (passwordInput && document.activeElement === passwordInput) {
                        return;
                    }
                    
                    // Only trigger if not in table cells (to avoid interfering with cell editing)
                    if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                        return;
                    }
                    
                    // Check if undo is available
                    if (typeof undo === 'function' && operationHistory && operationHistory.length > 0) {
                        console.log('↩️ Raccourci clavier undo activé (Cmd+Y/Ctrl+Y)');
                        undo();
                    } else {
                        console.log('⚠️ Undo non disponible - aucune action à annuler');
                        showMessage('Aucune action à annuler', 'info');
                    }
                }
            });
            
            // Additional password field protection
            document.getElementById('password').addEventListener('input', function (e) {
                e.stopPropagation();
                return true;
            });
            
            document.getElementById('password').addEventListener('keypress', function (e) {
                e.stopPropagation();
                return true;
            });
            
            document.getElementById('password').addEventListener('keyup', function (e) {
                e.stopPropagation();
                return true;
            });

            // Table body paste handling
            document.getElementById('table-body').addEventListener('paste', function(e) {
                const active = document.activeElement;
                if (!(active && active.tagName === 'TD' && active.isContentEditable === 'true')) return;
                
                const text = (e.clipboardData || window.clipboardData).getData('text');
                if (!text || (text.indexOf('\t') === -1 && text.indexOf('\n') === -1)) return;
                
                e.preventDefault();
                const rows = text.split(/\r?\n/).filter(r => r.length > 0).map(r => r.split('\t'));
                const startCell = active;
                const startRow = startCell.closest('tr');
                const startIndex = Array.from(startRow.cells).indexOf(startCell);
                let r = startRow;
                
                rows.forEach((cols, ridx) => {
                    if (ridx > 0) {
                        r = r.nextElementSibling;
                        if (!r) {
                            const tbody = document.getElementById('table-body');
                            r = document.createElement('tr');
                            r.className = 'bg-white hover:bg-gray-100 transition-colors cursor-pointer';
                            
                            // Create row number cell
                            const n = document.createElement('td');
                            n.textContent = tbody.children.length + 1;
                            n.className = 'py-2 px-2 md:px-4 font-bold text-gray-800 whitespace-nowrap cursor-pointer';
                            n.setAttribute('data-label', 'No');
                            n.title = 'Cliquer pour colorer/effacer la ligne';
                            
                            n.addEventListener('mousedown', (e) => { 
                                if (e.button !== 0) return; 
                                startRowPaint(r); 
                                e.preventDefault(); 
                            });
                            
                            n.addEventListener('mouseenter', () => { 
                                if (isRowPaintDragging) applyRowPaint(r); 
                            });
                            
                            n.addEventListener('click', (e) => { 
                                e.preventDefault();
                                if (isRowPaintDragging) return;
                                rowPaintAction = getPaintActionForRow(r);
                                applyRowPaint(r);
                            });
                            
                            n.addEventListener('touchstart', (e) => { 
                                startRowPaint(r); 
                                e.preventDefault(); 
                            }, { passive: false });
                            
                            n.addEventListener('touchmove', (e) => { 
                                const t = e.touches && e.touches[0]; 
                                if (!t) return; 
                                const el = document.elementFromPoint(t.clientX, t.clientY);
                                const tr = el ? el.closest('#table-body tr') : null; 
                                if (tr) applyRowPaint(tr); 
                                e.preventDefault();
                            }, { passive: false });
                            
                            r.appendChild(n);
                            
                            // Add delete/selection cell
                            r.appendChild(createDeleteCell(r));
                            
                            // Add data cells using current headers
                            const heads = getHeaders();
                            heads.forEach(h => { 
                                r.appendChild(createEditableCell(h, '')); 
                            });
                            
                            tbody.appendChild(r);
                        }
                    }
                    
                    cols.forEach((val, cidx) => {
                        const cell = r.cells[startIndex + cidx];
                        if (cell && cell.contentEditable === 'true') { 
                            cell.textContent = val; 
                        }
                    });
                    
                    // Normalize Nom_Prénom in the affected row after paste
                    try {
                        const nameCell = r.querySelector('td[data-label="Nom_Prénom"]');
                        if (nameCell) { 
                            nameCell.textContent = formatNomPrenom(nameCell.textContent); 
                        }
                    } catch(_) {}
                });
                
                saveStateToHistory(); 
                saveLocalDraft(); 
                markEdited();
            });

            // Double-click date input
            document.getElementById('table-body').addEventListener('dblclick', function(e) {
                const cell = e.target.closest('td');
                if (!cell) return;
                
                const label = (cell.getAttribute('data-label') || '').toLowerCase();
                if (label.includes('date de saisie') || label.includes('ddn')) {
                    if (!dateInputOverlay) {
                        dateInputOverlay = document.createElement('input');
                        dateInputOverlay.type = 'date';
                        dateInputOverlay.className = 'border rounded px-2 py-1';
                        dateInputOverlay.style.position = 'fixed';
                        dateInputOverlay.style.zIndex = '1000';
                        document.body.appendChild(dateInputOverlay);
                        
                        dateInputOverlay.addEventListener('change', () => {
                            const v = dateInputOverlay.value;
                            if (v) {
                                const [y, m, d] = v.split('-');
                                cell.textContent = `${d}/${m}/${y.slice(-2)}`;
                                saveStateToHistory();
                                saveLocalDraft();
                                markEdited();
                            }
                            dateInputOverlay.style.display = 'none';
                        });
                        
                        dateInputOverlay.addEventListener('blur', () => {
                            dateInputOverlay.style.display = 'none';
                        });
                    }
                    
                    const rect = cell.getBoundingClientRect();
                    dateInputOverlay.style.left = `${rect.left + window.scrollX}px`;
                    dateInputOverlay.style.top = `${rect.top + window.scrollY}px`;
                    dateInputOverlay.style.display = 'block';
                    dateInputOverlay.focus();
                }
            });

            // Select all checkbox
            document.addEventListener('change', function(e) { 
                if (e.target && e.target.id === 'select-all') { 
                    const checked = e.target.checked; 
                    document.querySelectorAll('#table-body tr').forEach(tr => { 
                        const cb = tr.querySelector('td:nth-child(2) input[type="checkbox"]'); 
                        if (cb) { 
                            cb.checked = checked; 
                            tr.classList.toggle('selected-row', checked); 
                        } 
                    }); 
                } 
            });

            // Focus management
            document.addEventListener('focusin', (e) => {
                if (e.target && e.target.tagName === 'TD' && e.target.contentEditable === 'true') {
                    captureSimplePos();
                }
            });

            // Mobile focus support
            document.addEventListener('focusin', (e) => {
                if (!isMobile()) return;
                const cell = (e.target && e.target.tagName === 'TD' && e.target.isContentEditable) ? e.target : null;
                if (cell) {
                    setTimeout(() => ensureCellVisible(cell), 100);
                }
            });

            // Table reloaded event
            try {
                document.addEventListener('table:reloaded', () => { 
                    if (showOnlyColored) applyColoredFilter(); 
                });
            } catch(_) {}

            // Global end-drag listeners
            try { 
                document.addEventListener('mouseup', endRowPaint, true); 
            } catch(_) {}
            
            try { 
                document.addEventListener('touchend', endRowPaint, true); 
            } catch(_) {}
            
            // Mobile touch support for history toggle button
            try {
                const toggleBtn = document.getElementById('history-toggle-btn');
                if (toggleBtn) {
                    // Simplified touch events - just visual feedback, let onclick handle the toggle
                    toggleBtn.addEventListener('touchstart', function(e) {
                        // Visual feedback only
                        this.style.transform = 'scale(0.95)';
                        this.style.transition = 'transform 0.1s ease-out';
                    }, { passive: true });
                    
                    toggleBtn.addEventListener('touchend', function(e) {
                        // Reset visual feedback only
                        this.style.transform = '';
                        this.style.transition = 'all 0.2s ease-in-out';
                        // Let the onclick="toggleHistoryBarSimple()" handle the actual toggle
                    }, { passive: true });
                    
                    // Keyboard accessibility
                    toggleBtn.addEventListener('keydown', function(e) {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            toggleHistoryBarSimple();
                        }
                    });
                }
            } catch(_) {}
        }

        // Keyboard navigation
        function setupKeyboardNavigation() {
            document.addEventListener('keydown', function(e) {
                const active = document.activeElement;
                if (active && active.tagName === 'TD' && active.contentEditable === 'true') {
                    const modal = document.getElementById('confirmation-modal');
                    if (modal && !modal.classList.contains('hidden')) return;
                    
                    // ✅ CORRECTION: Éviter le double traitement des touches de navigation
                    if (e.defaultPrevented) return;
                    
                    // Prevent cursor restoration during keyboard navigation
                    if (['Tab', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter'].includes(e.key)) {
                        cursorManager.preventNextRestore();
                    }
                    
                    const row = active.parentElement;
                    const idx = Array.from(row.cells).indexOf(active);
                    let next = null;
                    
                    if (e.key === 'ArrowRight' || (e.key === 'Tab' && !e.shiftKey)) {
                        next = row.cells[idx + 1] || (row.nextElementSibling && row.nextElementSibling.cells[2]);
                    } else if (e.key === 'ArrowLeft' || (e.key === 'Tab' && e.shiftKey)) {
                        next = row.cells[idx - 1];
                        if ((!next || idx === 2) && row.previousElementSibling) {
                            next = row.previousElementSibling.cells[row.previousElementSibling.cells.length - 1];
                        }
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        const nx = row.nextElementSibling;
                        if (nx) {
                            next = nx.cells[idx];
                        } else {
                            // Empêcher l'ajout en mode visualisation
                            if (isViewMode) {
                                showMessage('Impossible d\'ajouter des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                                return;
                            }
                            addRow();
                            TimerManager.setTimeout(() => {
                                const nr = document.querySelector('#table-body tr:last-child');
                                if (nr && nr.cells.length > idx) {
                                    nr.cells[idx].focus();
                                    // Position cursor at end of text content
                                    TimerManager.setTimeout(() => {
                                        setCaretAt(nr.cells[idx], null);
                                    }, 0);
                                }
                            }, 0);
                        }
                    } else if (e.key === 'ArrowDown') {
                        const nx = row.nextElementSibling;
                        if (nx) {
                            next = nx.cells[idx];
                        } else {
                            // Empêcher l'ajout en mode visualisation
                            if (isViewMode) {
                                showMessage('Impossible d\'ajouter des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                                return;
                            }
                            addRow();
                            TimerManager.setTimeout(() => {
                                const nr = document.querySelector('#table-body tr:last-child');
                                if (nr && nr.cells.length > idx) {
                                    nr.cells[idx].focus();
                                    // Position cursor at end of text content
                                    TimerManager.setTimeout(() => {
                                        setCaretAt(nr.cells[idx], null);
                                    }, 0);
                                }
                            }, 0);
                        }
                    } else if (e.key === 'ArrowUp') {
                        const pv = row.previousElementSibling;
                        if (pv) {
                            next = pv.cells[idx];
                        }
                    }
                    
                    if (next) {
                        e.preventDefault();
                        next.focus();
                        // Position cursor at end of text content
                        TimerManager.setTimeout(() => {
                            setCaretAt(next, null);
                        }, 0);
                        if (isMobile()) ensureCellVisible(next);
                    }
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                const active = document.activeElement;
                const inCell = active && active.tagName === 'TD' && active.contentEditable === 'true';
                
                // Check if we're in a form field (input, textarea, select, or contentEditable)
                const inFormField = active && (
                    active.tagName === 'INPUT' || 
                    active.tagName === 'TEXTAREA' || 
                    active.tagName === 'SELECT' || 
                    active.contentEditable === 'true'
                );
                
                // Shortcut: cycle paint mode with P (only when NOT in form fields)
                if (!e.ctrlKey && !e.metaKey && !e.altKey && (e.key === 'p' || e.key === 'P') && !inFormField) {
                    e.preventDefault();
                    cyclePaintMode();
                    return;
                }
                
                // Excel-style Undo/Redo shortcuts
                if ((e.ctrlKey || e.metaKey) && !e.shiftKey && (e.key === 'z' || e.key === 'Z')) {
                    e.preventDefault();
                    if (operationHistory.length > 0) {
                        undo();
                    }
                    return;
                }
                
                // Excel-style Redo shortcuts: Ctrl+Shift+Z or Ctrl+Y
                if ((e.ctrlKey || e.metaKey) && (
                    (e.shiftKey && (e.key === 'z' || e.key === 'Z')) || 
                    (e.key === 'y' || e.key === 'Y')
                )) {
                    e.preventDefault();
                    if (redoHistory.length > 0) {
                        redo();
                    }
                    return;
                }
                
                // Ctrl+D: Duplicate row
                if ((e.ctrlKey || e.metaKey) && (e.key === 'd' || e.key === 'D') && inCell) {
                    e.preventDefault();
                    
                    // Empêcher la duplication en mode visualisation
                    if (isViewMode) {
                        showMessage('Impossible de dupliquer des lignes en mode visualisation. Désactivez le mode visualisation pour modifier le tableau.', 'warning');
                        return;
                    }
                    
                    const row = active.closest('tr');
                    if (row) {
                        const clone = row.cloneNode(true);
                        delete clone.dataset.key;
                        
                        // Clear any background color on the clone
                        clone.style.backgroundColor = '';
                        
                        // Fix the No cell text and rebind click handler
                        if (clone.cells[0]) {
                            clone.cells[0].textContent = document.querySelectorAll('#table-body tr').length + 1;
                        }
                        
                        // Rebind the line-number toggle and input handlers
                        const numCell = clone.cells[0];
                        if (numCell) {
                            const newNum = numCell.cloneNode(true);
                            if (!newNum.className.includes('cursor-pointer')) {
                                newNum.className += ' cursor-pointer';
                            }
                            newNum.title = 'Cliquer pour colorer/effacer la ligne';
                            newNum.addEventListener('click', () => toggleRowColor(clone));
                            clone.replaceChild(newNum, numCell);
                        }
                        
                        Array.from(clone.cells).forEach((c, i) => {
                            if (i <= 1) return;
                            c.addEventListener('input', (e) => { 
                                const oldValue = c.dataset.originalValue || '';
                                const newValue = c.textContent;
                                const columnLabel = getColumnLabelForCell(c);
                                
                                // Track cell edit for undo/redo
                                trackCellEdit(c, oldValue, newValue, columnLabel);
                                
                                // Update original value for next edit
                                c.dataset.originalValue = newValue;
                                
                                saveStateToHistory(); 
                                saveLocalDraft(); 
                                markEdited(); 
                            });
                        });
                        
                        row.after(clone);
                        
                        // Update color map persistently
                        persistRowColors();
                        saveStateToHistory(); 
                        saveLocalDraft(); 
                        markEdited();
                    }
                }
                
                // Ctrl+Backspace/Delete: Delete row(s)
                if ((e.ctrlKey || e.metaKey) && (e.key === 'Backspace' || e.key === 'Delete') && inCell) {
                    e.preventDefault();
                    const selected = Array.from(document.querySelectorAll('#table-body tr.selected-row'));
                    if (selected.length > 0) {
                        promptKeyConfirm(`Appuyez sur Entrée pour supprimer ${selected.length} ligne(s), Échap pour annuler.`, () => deleteRows(selected));
                    } else {
                        const row = active.closest('tr');
                        if (row) {
                            promptKeyConfirm('Appuyez sur Entrée pour supprimer cette ligne, Échap pour annuler.', () => deleteRows([row]));
                        }
                    }
                }
            });
        }

        // Confirmation prompt
        function promptKeyConfirm(message, onConfirm) {
            // Show ephemeral banner
            showMessage(message, 'info');

            // Create (or reuse) a hidden input to trigger the mobile keyboard
            let keyCapture = document.getElementById('key-capture');
            if (!keyCapture) {
                keyCapture = document.createElement('input');
                keyCapture.type = 'text';
                keyCapture.id = 'key-capture';
                keyCapture.autocapitalize = 'off';
                keyCapture.autocomplete = 'off';
                keyCapture.spellcheck = false;
                keyCapture.style.position = 'fixed';
                keyCapture.style.opacity = '0';
                keyCapture.style.width = '1px';
                keyCapture.style.height = '1px';
                keyCapture.style.left = '-10000px';
                keyCapture.style.top = '0';
                keyCapture.style.pointerEvents = 'none';
                document.body.appendChild(keyCapture);
            }
            
            // Focus to bring up the soft keyboard on mobile
            keyCapture.value = '';
            keyCapture.focus({ preventScroll: true });
            try { 
                keyCapture.setSelectionRange(0, 0); 
            } catch(_) {}
            
            // Some mobile browsers need a second tick to reliably open the keyboard
            TimerManager.setTimeout(() => { 
                if (document.activeElement !== keyCapture) {
                    keyCapture.focus({ preventScroll: true }); 
                }
            }, 0);

            function handleKey(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    cleanup();
                    onConfirm();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cleanup();
                    showMessage('Suppression annulée.', 'info');
                }
            }

            function cleanup() {
                document.removeEventListener('keydown', handleKey, true);
                // Blur and hide the hidden input after finishing
                const cap = document.getElementById('key-capture');
                if (cap) { 
                    try { 
                        cap.blur(); 
                    } catch(_) {} 
                }
            }

            document.addEventListener('keydown', handleKey, true);
        }

        // ===== SNAPSHOT SYSTEM FUNCTIONS =====
        
        // Fonction de nettoyage automatique des anciens snapshots
        async function cleanupOldSnapshots(keepCount = 20) {
            try {
                // Récupérer tous les snapshots triés par date (plus récents en premier)
                const { data: snapshots, error: fetchError } = await supabase
                    .from('table_snapshots_index')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (fetchError) {
                    console.error('❌ Error fetching snapshots for cleanup:', fetchError);
                    return;
                }
                
                if (snapshots.length > keepCount) {
                    // Supprimer les snapshots les plus anciens
                    const toDelete = snapshots.slice(keepCount);
                    let deletedCount = 0;
                    
                    for (const snapshot of toDelete) {
                        try {
                            // Supprimer du stockage Supabase
                            const { error: storageError } = await supabase.storage
                                .from('table-snapshots')
                                .remove([snapshot.object_path]);
                            
                            if (storageError) {
                                console.warn(`⚠️ Warning: Could not delete file ${snapshot.object_path}:`, storageError);
                            }
                            
                            // Supprimer de la base de données
                            const { error: dbError } = await supabase
                                .from('table_snapshots_index')
                                .delete()
                                .eq('id', snapshot.id);
                            
                            if (dbError) {
                                console.warn(`⚠️ Warning: Could not delete database record for ${snapshot.snapshot_date}:`, dbError);
                            } else {
                                deletedCount++;
                            }
                            
                        } catch (error) {
                            console.warn(`⚠️ Warning: Error deleting snapshot ${snapshot.snapshot_date}:`, error);
                        }
                    }
                    
                    if (deletedCount > 0) {
                        console.log(`🧹 Cleanup completed: ${deletedCount} old snapshots removed`);
                        if (typeof showMessage === 'function') {
                            showMessage(`🧹 Nettoyage automatique : ${deletedCount} anciens snapshots supprimés`, 'info');
                        }
                    }
                }
                
            } catch (error) {
                console.error('❌ Error in cleanupOldSnapshots:', error);
            }
        }

        // Fonction de vérification de la capacité de stockage
        async function checkStorageCapacity() {
            try {
                const { data: snapshots, error: fetchError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (fetchError) {
                    console.error('❌ Error checking storage capacity:', fetchError);
                    return { count: 0, needsCleanup: false };
                }
                
                const snapshotCount = snapshots.length;
                
                // Calculer la taille totale des snapshots
                let totalSize = 0;
                snapshots.forEach(snapshot => {
                    totalSize += snapshot.file_size_bytes || 0;
                });
                
                // Limite de stockage : 100 MB (100 * 1024 * 1024 bytes)
                const MAX_BUCKET_SIZE = 100 * 1024 * 1024;
                const usagePercentage = (totalSize / MAX_BUCKET_SIZE) * 100;
                
                // Si on dépasse 95% de la capacité, déclencher le nettoyage
                if (usagePercentage >= 95) {
                    // Calculer combien de snapshots garder pour libérer de l'espace
                    const targetSize = MAX_BUCKET_SIZE * 0.7; // Cibler 70% d'utilisation
                    const snapshotsToKeep = calculateOptimalSnapshotCount(snapshots, targetSize);
                    
                    return { 
                        count: snapshotCount, 
                        needsCleanup: true, 
                        target: snapshotsToKeep,
                        currentSize: totalSize,
                        maxSize: MAX_BUCKET_SIZE,
                        usagePercentage: usagePercentage
                    };
                }
                
                return { 
                    count: snapshotCount, 
                    needsCleanup: false,
                    currentSize: totalSize,
                    maxSize: MAX_BUCKET_SIZE,
                    usagePercentage: usagePercentage
                };
                
            } catch (error) {
                console.error('❌ Error checking storage capacity:', error);
                return { count: 0, needsCleanup: false };
            }
        }

        // Fonction pour calculer le nombre optimal de snapshots à garder
        function calculateOptimalSnapshotCount(snapshots, targetSize) {
            // Trier les snapshots par date (plus récents en premier)
            const sortedSnapshots = [...snapshots].sort((a, b) => 
                new Date(b.snapshot_date) - new Date(a.snapshot_date)
            );
            
            let currentSize = 0;
            let snapshotsToKeep = 0;
            
            // Garder les snapshots les plus récents jusqu'à atteindre la taille cible
            for (const snapshot of sortedSnapshots) {
                const snapshotSize = snapshot.file_size_bytes || 0;
                if (currentSize + snapshotSize <= targetSize) {
                    currentSize += snapshotSize;
                    snapshotsToKeep++;
                } else {
                    break;
                }
                }
            
            // Toujours garder au minimum 5 snapshots
            return Math.max(snapshotsToKeep, 5);
        }

        // Fonction de monitoring et d'alertes du stockage
        async function monitorStorageHealth() {
            try {
                const { data: snapshots, error: fetchError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (fetchError) {
                    console.error('❌ Error monitoring storage health:', fetchError);
                    return;
                }
                
                const snapshotCount = snapshots.length;
                
                // Calculer la taille totale des snapshots
                let totalSize = 0;
                snapshots.forEach(snapshot => {
                    totalSize += snapshot.file_size_bytes || 0;
                });
                
                const MAX_BUCKET_SIZE = 100 * 1024 * 1024; // 100 MB
                const usagePercentage = (totalSize / MAX_BUCKET_SIZE) * 100;
                
                // Alertes automatiques selon l'utilisation de l'espace
                if (usagePercentage >= 95) {
                    // 🚨 CRITIQUE : Stockage presque plein
                    if (typeof showMessage === 'function') {
                        showMessage(`🚨 Stockage critique : ${usagePercentage.toFixed(1)}% utilisé (${(totalSize / 1024 / 1024).toFixed(2)} MB). Nettoyage automatique en cours...`, 'error');
                    }
                } else if (usagePercentage >= 85) {
                    // ⚠️ ATTENTION : Stockage élevé
                    if (typeof showMessage === 'function') {
                        showMessage(`⚠️ Stockage élevé : ${usagePercentage.toFixed(1)}% utilisé (${(totalSize / 1024 / 1024).toFixed(2)} MB). Nettoyage préventif recommandé.`, 'warning');
                    }
                } else if (usagePercentage >= 70) {
                    // ℹ️ INFO : Surveillance
                    if (typeof showMessage === 'function') {
                        showMessage(`ℹ️ Stockage modéré : ${usagePercentage.toFixed(1)}% utilisé (${(totalSize / 1024 / 1024).toFixed(2)} MB).`, 'info');
                    }
                }
                
                // Log des informations de stockage
                console.log(`📊 Storage Health: ${snapshotCount} snapshots, ${(totalSize / 1024 / 1024).toFixed(2)} MB used (${usagePercentage.toFixed(1)}% of ${(MAX_BUCKET_SIZE / 1024 / 1024).toFixed(0)} MB)`);
                
            } catch (error) {
                console.error('❌ Error in monitorStorageHealth:', error);
            }
        }

        // Create a demo snapshot with unique date logic and automatic cleanup
        async function createDemoSnapshot(useCurrentData = false) {
            try {
                // VÉRIFICATION ET NETTOYAGE AUTOMATIQUE AVANT CRÉATION
                const capacityInfo = await checkStorageCapacity();
                if (capacityInfo.needsCleanup) {
                    await cleanupOldSnapshots(capacityInfo.target);
                }
                
                // Check current state
                const { data: existing, error: checkError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (checkError) {
                    console.error('❌ Error checking existing snapshots:', checkError);
                    return;
                }
                
                // Clean: Removed debug log
                
                // Generate a truly unique date
                let dateString;
                let attempts = 0;
                const maxAttempts = 50; // Increased to handle more date variations
                
                do {
                    attempts++;
                    if (attempts === 1) {
                        // First attempt: today's date
                        const today = new Date();
                        dateString = today.toISOString().split('T')[0];
                    } else if (attempts <= 10) {
                        // Next 10 attempts: dates with small offset (yesterday, day before, etc.)
                        const offsetDate = new Date();
                        offsetDate.setDate(offsetDate.getDate() - attempts + 1);
                        dateString = offsetDate.toISOString().split('T')[0];
                    } else if (attempts <= 20) {
                        // Next 10 attempts: dates with larger offset (1 week ago, 2 weeks ago, etc.)
                        const offsetDate = new Date();
                        offsetDate.setDate(offsetDate.getDate() - (attempts * 7));
                        dateString = offsetDate.toISOString().split('T')[0];
                    } else if (attempts <= 30) {
                        // Next 10 attempts: dates with month offset
                        const offsetDate = new Date();
                        offsetDate.setMonth(offsetDate.getMonth() - (attempts - 20));
                        dateString = offsetDate.toISOString().split('T')[0];
                    } else {
                        // Final attempts: use random dates from previous years
                        const randomYear = 2020 + Math.floor(Math.random() * 5); // 2020-2024
                        const randomMonth = 1 + Math.floor(Math.random() * 12);
                        const randomDay = 1 + Math.floor(Math.random() * 28);
                        dateString = `${randomYear}-${String(randomMonth).padStart(2, '0')}-${String(randomDay).padStart(2, '0')}`;
                    }
                    
                    // Check if this date already exists
                    const { data: existingDate, error: dateCheckError } = await supabase
                        .from('table_snapshots_index')
                        .select('snapshot_date')
                        .eq('snapshot_date', dateString)
                        .limit(1);
                    
                    if (dateCheckError) {
                        console.error('❌ Error checking date:', dateCheckError);
                        break;
                    }
                    
                    if (!existingDate || existingDate.length === 0) {
                        break;
                    }
                    
                } while (attempts < maxAttempts);
                
                if (attempts >= maxAttempts) {
                    console.error('❌ Unable to find unique date after 50 attempts');
                    
                    // Show message to user
                    if (typeof showMessage === 'function') {
                        showMessage('Impossible de trouver une date unique. Utilisez le bouton "Nettoyer" pour vider la base.', 'warning');
                    }
                    
                    return;
                }
                
                // Create the JSON content for the snapshot
                let snapshotData;
                let actualRowCount = 3;
                
                if (useCurrentData && window.tableData && window.tableData.length > 0) {
                    // Use current table data
                    actualRowCount = window.tableData.length;
                    snapshotData = {
                        snapshot_metadata: {
                            created_at: new Date().toISOString(),
                            row_count: actualRowCount,
                            version: "1.0",
                            description: "Snapshot des données actuelles du tableau"
                        },
                        data: window.tableData
                    };
                    // Clean: Removed debug log
                } else {
                    // Use demo data
                    snapshotData = {
                        snapshot_metadata: {
                            created_at: new Date().toISOString(),
                            row_count: 3,
                            version: "1.0",
                            description: "Demo snapshot for testing"
                        },
                        data: [
                            {
                                id: 1,
                                nom: "Dupont",
                                prenom: "Jean",
                                status: "En service",
                                specialite: "Cardiologie",
                                date_embauche: "2020-03-15",
                                salaire: 4500,
                                notes: "Excellent médecin, très apprécié des patients"
                            },
                            {
                                id: 2,
                                nom: "Martin",
                                prenom: "Marie",
                                status: "En service",
                                specialite: "Pédiatrie",
                                date_embauche: "2019-07-22",
                                salaire: 4200,
                                notes: "Spécialiste en maladies infantiles"
                            },
                            {
                                id: 3,
                                nom: "Bernard",
                                prenom: "Pierre",
                                status: "Congé",
                                specialite: "Chirurgie",
                                date_embauche: "2018-11-10",
                                salaire: 5200,
                                notes: "Chirurgien expérimenté"
                            }
                        ]
                    };
                    // Clean: Removed debug log
                }

                // Generate unique filename with timestamp
                const now = new Date();
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                const seconds = now.getSeconds().toString().padStart(2, '0');
                const timeStamp = `${hours}-${minutes}-${seconds}`;
                let fileName = `staff_table_${dateString}_${timeStamp}.json`;
                const jsonBlob = new Blob([JSON.stringify(snapshotData, null, 2)], { type: 'application/json' });

                // Check if file already exists in storage before uploading
                // Clean: Removed debug log
                const { data: existingFiles, error: listError } = await supabase.storage
                    .from('table-snapshots')
                    .list('', { limit: 100 });
                
                if (listError) {
                    console.warn('⚠️ Could not list storage files:', listError);
                } else {
                    const fileExists = existingFiles?.some(file => file.name === fileName);
                    if (fileExists) {
                        console.warn(`⚠️ File already exists in storage: ${fileName}`);
                        // Clean: Removed debug log
                        
                        // Try to remove the existing file
                        const { error: removeError } = await supabase.storage
                            .from('table-snapshots')
                            .remove([fileName]);
                        
                        if (removeError) {
                            console.error('❌ Error removing existing file:', removeError);
                            // If we can't remove it, try with a different filename
                            const timestamp = Date.now();
                            const newFileName = `staff_table_${dateString}_${timestamp}.json`;
                            // Clean: Removed debug log
                            fileName = newFileName;
                        } else {
                            // Clean: Removed debug log
                        }
                    }
                }

                // Upload the JSON file to storage
                // Clean: Removed debug log
                const { data: uploadData, error: uploadError } = await supabase.storage
                    .from('table-snapshots')
                    .upload(fileName, jsonBlob);

                if (uploadError) {
                    console.error('❌ Error uploading file to storage:', uploadError);
                    throw new Error(`Failed to upload file: ${uploadError.message}`);
                }

                                    // Clean: Removed debug log

                // Now create the database record
                const { error } = await supabase
                    .from('table_snapshots_index')
                    .insert({
                        snapshot_date: dateString,
                        object_path: fileName,
                        row_count: actualRowCount,
                        file_size_bytes: jsonBlob.size,
                        metadata: JSON.stringify({
                            table: 'staffTable',
                            version: '1.0.0',
                            description: 'Demo snapshot for testing'
                        })
                    });
                
                if (error) {
                    console.error('❌ Error creating snapshot:', error);
                    
                    // If it's still a key error, try with a timestamp
                    if (error.code === '23505') {
                        // Clean: Removed debug log
                        const timestamp = Date.now();
                        const uniqueDate = new Date(timestamp);
                        const uniqueDateString = uniqueDate.toISOString().split('T')[0];
                        
                        const { error: retryError } = await supabase
                            .from('table_snapshots_index')
                            .insert({
                                snapshot_date: uniqueDateString,
                                object_path: `staff_table_${uniqueDateString}_${timestamp}_retry.json`,
                                row_count: 3,
                                file_size_bytes: 1500,
                                metadata: JSON.stringify({
                                    table: 'staffTable',
                                    version: '1.0.0',
                                    description: 'Demo snapshot for testing (retry)'
                                })
                            });
                        
                        if (retryError) {
                            console.error('❌ Retry error:', retryError);
                        } else {
                            // Clean: Removed debug log
                            await loadAvailableSnapshots();
                            // Update the calendar display
                            populateSnapshotCalendar();
                        }
                    }
                } else {
                    // Clean: Removed debug log
                    // Reload snapshots after creation
                    await loadAvailableSnapshots();
                    // Update the calendar display
                    populateSnapshotCalendar();
                    
                    // MONITORING : Vérifier la santé du stockage après création
                    await monitorStorageHealth();
                }
                
            } catch (err) {
                console.error('❌ Exception error:', err);
            }
        }
        
        // DEBUG WRAPPER for manual snapshot button
        async function debugManualSnapshot() {
            console.log('🚀 DEBUG: Manual Snapshot Button Clicked!');
            console.log('=' .repeat(60));
            
            // Debug current state
            console.log('📊 DEBUG: Current App State:');
            console.log('   - snapshotMode:', window.snapshotMode || 'undefined');
            console.log('   - currentSnapshotDate:', window.currentSnapshotDate || 'undefined');
            console.log('   - availableSnapshots count:', window.availableSnapshots?.length || 0);
            
            // Debug window.tableData
            console.log('📋 DEBUG: window.tableData status:');
            console.log('   - Exists:', typeof window.tableData !== 'undefined');
            console.log('   - Is Array:', Array.isArray(window.tableData));
            console.log('   - Length:', window.tableData?.length || 0);
            if (window.tableData && window.tableData.length > 0) {
                console.log('   - First row keys:', Object.keys(window.tableData[0] || {}));
                console.log('   - First row sample:', JSON.stringify(window.tableData[0], null, 2));
            }
            
            // Debug DOM table data
            console.log('🏗️ DEBUG: DOM Table Analysis:');
            const table = document.getElementById('data-table');
            if (table) {
                const tbody = table.querySelector('tbody');
                const rows = tbody?.querySelectorAll('tr') || [];
                console.log('   - Table found:', !!table);
                console.log('   - Rows in DOM:', rows.length);
                
                if (rows.length > 0) {
                    const firstRow = rows[0];
                    const cells = firstRow.querySelectorAll('td');
                    console.log('   - Cells in first row:', cells.length);
                    
                    // Sample cell values
                    const cellValues = Array.from(cells).slice(0, 3).map(cell => {
                        const input = cell.querySelector('input, textarea, select');
                        return input ? input.value : cell.textContent.trim();
                    });
                    console.log('   - First 3 cell values:', cellValues);
                }
            } else {
                console.log('   - Table NOT found in DOM!');
            }
            
            // Extract current data from DOM for comparison
            console.log('🔍 DEBUG: Extracting current data from DOM...');
            const domData = extractDOMTableData();
            console.log('   - DOM extraction result:', domData?.length || 0, 'rows');
            if (domData && domData.length > 0) {
                console.log('   - DOM first row:', JSON.stringify(domData[0], null, 2));
            }
            
            // Update window.tableData with current DOM state
            if (domData && domData.length > 0) {
                console.log('🔄 DEBUG: Updating window.tableData with current DOM data...');
                window.tableData = domData;
                console.log('   - window.tableData updated with', domData.length, 'rows');
            }
            
            console.log('🎯 DEBUG: About to call createManualSnapshot()...');
            console.log('=' .repeat(60));
            
            // Call the actual function
            try {
                await createManualSnapshot();
                console.log('✅ DEBUG: createManualSnapshot() completed');
            } catch (error) {
                console.error('❌ DEBUG: createManualSnapshot() failed:', error);
            }
        }
        
        // Helper function to extract data from DOM
        function extractDOMTableData() {
            const table = document.getElementById('data-table');
            if (!table) return null;
            
            const tbody = table.querySelector('tbody');
            if (!tbody) return null;
            
            const headerRow = table.querySelector('thead tr');
            const headers = Array.from(headerRow?.querySelectorAll('th') || []).map(th => 
                th.textContent.trim()
            );
            
            const rows = tbody.querySelectorAll('tr');
            const data = [];
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                const rowData = {};
                
                cells.forEach((cell, index) => {
                    if (headers[index]) {
                        const input = cell.querySelector('input, textarea, select');
                        let value = input ? input.value : cell.textContent.trim();
                        
                        // Convert numbers
                        if (!isNaN(value) && value !== '' && !isNaN(parseFloat(value))) {
                            value = parseFloat(value);
                        }
                        
                        rowData[headers[index]] = value;
                    }
                });
                
                if (Object.keys(rowData).length > 0) {
                    data.push(rowData);
                }
            });
            
            return data;
        }
        
        // Create a manual snapshot with current table data
        async function createManualSnapshot() {
            console.log('🎯 FUNCTION CALLED: createManualSnapshot() STARTED');
            console.log('⏰ Timestamp:', new Date().toISOString());
            
            // Check if manual snapshot is enabled (toggle must be on)
            const historyBarContainer = document.getElementById('history-bar-container');
            if (!historyBarContainer || historyBarContainer.classList.contains('hidden') || historyBarContainer.style.display === 'none') {
                console.log('❌ Manual snapshot creation blocked - History bar is not visible');
                showMessage('❌ Création de snapshot désactivée - Barre d\'historique fermée', 'error');
                return;
            }
            
            try {
                console.log('🚀 Création d\'un snapshot manuel...');
                
                // Créer un client Supabase avec la clé de service pour contourner les politiques RLS
                console.log('🔑 Création du client Supabase avec la clé de service...');
                
                // Utiliser une approche simple et robuste
                let supabaseService;
                try {
                    // Essayer d'importer et créer le client
                    const { createClient: createClientService } = await import('https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm');
                    supabaseService = createClientService(supabaseConfig.supabaseUrl, supabaseConfig.supabaseServiceKey);
                    console.log('✅ Client Supabase créé avec la clé de service');
                } catch (error) {
                    console.error('❌ Erreur lors de la création du client Supabase:', error);
                    throw new Error(`Impossible de créer le client Supabase: ${error.message}`);
                }
                
                // 🔧 FIXED: Capturer les données actuellement éditées dans le navigateur
                console.log('📊 Capture des données actuelles du tableau (état édité)...');
                
                let tableData = null;
                
                // PRIORITÉ 1: Utiliser les données éditées actuellement dans le navigateur
                if (window.tableData && Array.isArray(window.tableData) && window.tableData.length > 0) {
                    tableData = window.tableData;
                    console.log(`✅ Données capturées depuis le navigateur (état édité): ${tableData.length} lignes`);
                    console.log('📝 DEBUG: Premier élément des données éditées:', JSON.stringify(tableData[0], null, 2));
                } else {
                    // FALLBACK: Si pas de données éditées, récupérer depuis la base
                    console.log('⚠️ Aucune donnée éditée trouvée, récupération depuis la base de données...');
                    const { data: dbData, error: fetchError } = await supabaseService
                        .from('staffTable')
                        .select('*')
                        .order('No', { ascending: true });
                    
                    if (fetchError) {
                        throw new Error(`Erreur lors de la récupération des données: ${fetchError.message}`);
                    }
                    
                    tableData = dbData;
                    console.log(`📊 Données récupérées depuis la base: ${tableData?.length || 0} lignes`);
                }
                
                if (!tableData || tableData.length === 0) {
                    showMessage('❌ Aucune donnée trouvée (ni éditée, ni en base)', 'error');
                    return;
                }
                
                console.log(`📊 Données récupérées: ${tableData.length} lignes`);
                
                // Vérifier la capacité de stockage
                const capacityInfo = await checkStorageCapacity();
                if (capacityInfo.needsCleanup) {
                    await cleanupOldSnapshots(capacityInfo.target);
                }
                
                // Générer un nom de fichier unique avec timestamp
                const now = new Date();
                const timestamp = now.getTime();
                const dateString = now.toISOString().split('T')[0];
                const timeString = now.toTimeString().split(' ')[0].replace(/:/g, '-');
                
                // Créer le chemin de stockage : YYYY/MM/DD/MANUAL_HH-MM-SS_staffTable.json
                const year = now.getFullYear();
                const month = (now.getMonth() + 1).toString().padStart(2, '0');
                const day = now.getDate().toString().padStart(2, '0');
                const objectPath = `${year}/${month}/${day}/MANUAL_${timeString}_staffTable.json`;
                
                // Préparer les données du snapshot
                const snapshotData = {
                    data: tableData,
                    metadata: {
                        table: 'staffTable',
                        rowCount: tableData.length,
                        createdAt: now.toISOString(),
                        snapshotDate: dateString,
                        type: 'MANUAL_SNAPSHOT',
                        version: '2.0.0',
                        description: 'Snapshot manuel créé par l\'utilisateur',
                        timestamp: timestamp,
                        userAction: 'manual_creation'
                    }
                };
                
                // Sérialiser en JSON
                const jsonContent = JSON.stringify(snapshotData, null, 2);
                const fileSize = new TextEncoder().encode(jsonContent).length;
                
                console.log(`📊 Création du snapshot manuel: ${tableData.length} lignes, ${(fileSize / 1024).toFixed(2)} KB`);
                console.log(`📁 Object path: ${objectPath}`);
                console.log(`🔑 Using service client: ${!!supabaseService}`);
                
                // Upload vers le stockage avec le client de service
                console.log(`📤 DEBUT UPLOAD vers table-snapshots...`);
                const uploadResult = await supabaseService.storage
                    .from('table-snapshots')
                    .upload(objectPath, jsonContent, {
                        contentType: 'application/json',
                        upsert: true
                    });
                
                console.log(`📤 RESULTAT UPLOAD:`, uploadResult);
                
                if (uploadResult.error) {
                    console.error(`❌ ERREUR UPLOAD:`, uploadResult.error);
                    throw new Error(`Erreur lors de l'upload: ${uploadResult.error.message}`);
                }
                
                console.log(`💾 Snapshot manuel uploadé vers: ${objectPath}`);
                console.log(`✅ Upload data:`, uploadResult.data);
                
                // Créer l'enregistrement dans l'index avec le client de service
                const { error: indexError } = await supabaseService
                    .from('table_snapshots_index')
                    .insert({
                        snapshot_date: dateString,
                        object_path: objectPath,
                        row_count: tableData.length,
                        file_size_bytes: fileSize,
                        metadata: snapshotData.metadata
                    });
                
                if (indexError) {
                    throw new Error(`Erreur lors de la création de l'index: ${indexError.message}`);
                }
                
                console.log(`✅ Snapshot manuel indexé avec succès pour la date: ${dateString}`);
                
                // Log dans le journal de restauration avec le client de service
                try {
                    await supabaseService
                        .from('snapshot_restore_log')
                        .insert({
                            snapshot_date: dateString,
                            restored_at: now.toISOString(),
                            restored_by: 'user_manual',
                            restore_reason: 'Snapshot manuel créé par l\'utilisateur'
                        });
                    console.log('📝 Entrée de log créée dans snapshot_restore_log');
                } catch (logError) {
                    console.warn(`⚠️ Warning: Impossible de créer l'entrée de log: ${logError.message}`);
                }
                
                // Recharger les snapshots disponibles
                await loadAvailableSnapshots();
                
                // Mettre à jour l'interface
                populateSnapshotCalendar();
                updateHistoryNavigation();
                
                // Message de succès
                showMessage(`✅ Snapshot manuel créé avec succès! ${tableData.length} lignes sauvegardées`, 'success');
                
                // Monitoring de la santé du stockage
                await monitorStorageHealth();
                
                // Retourner le résultat pour les tests
                return {
                    success: true,
                    objectPath: objectPath,
                    dateString: dateString,
                    rowCount: tableData.length,
                    fileSize: fileSize
                };
                
            } catch (error) {
                console.error('❌ Erreur lors de la création du snapshot manuel:', error);
                showMessage(`❌ Erreur lors de la création du snapshot: ${error.message}`, 'error');
                
                // Retourner l'erreur pour les tests
                throw error;
            }
        }
        
        // Load available snapshots from the database
        async function loadAvailableSnapshots() {
            try {
                console.log('🔄 loadAvailableSnapshots: Début du chargement...');
                
                // Vérifier que supabase est initialisé
                if (!supabase) {
                    console.error('❌ Client Supabase non initialisé');
                    return;
                }
                
                // First, test the database connection
                console.log('🔄 Test de connexion à la table table_snapshots_index...');
                const { data: testData, error: testError } = await supabase
                    .from('table_snapshots_index')
                    .select('*')
                    .limit(1);
                
                if (testError) {
                    console.error('❌ Database connection error:', testError);
                    
                    // Analyser le type d'erreur
                    if (testError.code === 'PGRST116') { // No rows returned
                        console.log('ℹ️ Table vide - état normal, pas de snapshot automatique');
                        // Don't create demo snapshot automatically
                        return;
                    } else if (testError.code === 'PGRST301') { // Table doesn't exist
                        console.error('❌ Table table_snapshots_index n\'existe pas. Vérifiez la configuration SQL.');
                        showMessage('❌ Table des snapshots manquante. Vérifiez la configuration Supabase.', 'error');
                        return;
                    } else if (testError.code === 'PGRST301' || testError.message.includes('permission')) {
                        console.error('❌ Problème de permissions. Vérifiez les politiques RLS.');
                        showMessage('❌ Problème de permissions. Vérifiez les politiques RLS Supabase.', 'error');
                        return;
                    }
                    
                    showMessage('❌ Erreur de connexion à la base de données: ' + testError.message, 'error');
                    return;
                }
                
                console.log('✅ Connexion à la table réussie, testData:', testData);
                
                console.log('🔄 Chargement de tous les snapshots...');
                const { data, error } = await supabase
                    .from('table_snapshots_index')
                    .select('id, snapshot_date, created_at, row_count, object_path, file_size_bytes')
                    .order('created_at', { ascending: false });
                
                if (error) {
                    console.error('❌ Error loading snapshots:', error);
                    showMessage('❌ Erreur lors du chargement des snapshots: ' + error.message, 'error');
                    return;
                }
                
                console.log('✅ Snapshots chargés depuis la base:', data);
                
                availableSnapshots = data || [];
                // Update global variable
                window.availableSnapshots = availableSnapshots;
                
                console.log(`📊 ${availableSnapshots.length} snapshots disponibles:`, availableSnapshots);
                
                // If no snapshots exist, just show empty state
                if (availableSnapshots.length === 0) {
                    console.log('ℹ️ Aucun snapshot trouvé - état vide normal');
                    // Don't create demo snapshot automatically
                } else {
                    console.log('✅ Snapshots trouvés, mise à jour de l\'interface...');
                    updateHistoryNavigation();
                    // Update the calendar display
                    populateSnapshotCalendar();
                }
                
                // MONITORING : Vérifier la santé du stockage après chargement
                await monitorStorageHealth();
        
            } catch (error) {
                console.error('❌ Error in loadAvailableSnapshots:', error);
                showMessage('❌ Erreur inattendue lors du chargement des snapshots: ' + error.message, 'error');
            }
        }

        // Fonction utilitaire pour forcer le nettoyage manuel
        async function forceStorageCleanup() {
            try {
                if (typeof showMessage === 'function') {
                    showMessage('🧹 Déclenchement du nettoyage manuel du stockage...', 'info');
                }
                
                // Vérifier la capacité actuelle
                const capacityInfo = await checkStorageCapacity();
                
                // Calculer le nombre optimal de snapshots à garder
                const targetSize = capacityInfo.maxSize * 0.6; // Cibler 60% d'utilisation
                const snapshotsToKeep = calculateOptimalSnapshotCount(availableSnapshots, targetSize);
                
                console.log(`🧹 Manual cleanup: targeting ${snapshotsToKeep} snapshots to reach ${(targetSize / 1024 / 1024).toFixed(2)} MB usage`);
                
                // Forcer le nettoyage en gardant le nombre optimal de snapshots
                await cleanupOldSnapshots(snapshotsToKeep);
                
                // Recharger les snapshots disponibles
                await loadAvailableSnapshots();
                
                if (typeof showMessage === 'function') {
                    showMessage(`✅ Nettoyage manuel terminé ! Gardé ${snapshotsToKeep} snapshots les plus récents.`, 'success');
                }
                
            } catch (error) {
                console.error('❌ Error in forceStorageCleanup:', error);
                if (typeof showMessage === 'function') {
                    showMessage('❌ Erreur lors du nettoyage manuel', 'error');
                }
            }
        }
        
        // Enhanced mobile-responsive history navigation update function
        function updateHistoryNavigation() {
            // Update both mobile and desktop buttons
            const backBtn = document.getElementById('history-back');
            const nextBtn = document.getElementById('history-next');
            const backBtnDesktop = document.getElementById('history-back-desktop');
            const nextBtnDesktop = document.getElementById('history-next-desktop');
            
            // Always update button states for both mobile and desktop
            if (snapshotMode === 'live') {
                // Enable back/next if snapshots exist
                if (backBtn) backBtn.disabled = availableSnapshots.length === 0;
                if (nextBtn) nextBtn.disabled = availableSnapshots.length === 0;
                if (backBtnDesktop) backBtnDesktop.disabled = availableSnapshots.length === 0;
                if (nextBtnDesktop) nextBtnDesktop.disabled = availableSnapshots.length === 0;
            } else {
                // Update back/next button states
                if (backBtn) backBtn.disabled = currentSnapshotIndex <= 0;
                if (nextBtn) nextBtn.disabled = currentSnapshotIndex >= availableSnapshots.length - 1;
                if (backBtnDesktop) backBtnDesktop.disabled = currentSnapshotIndex <= 0;
                if (nextBtnDesktop) nextBtnDesktop.disabled = currentSnapshotIndex >= availableSnapshots.length - 1;
            }
            
            // Update calendar button text if calendar is open
            const calendarBtnText = document.getElementById('calendar-btn-text');
            if (calendarBtnText) {
                calendarBtnText.textContent = `Calendrier (${availableSnapshots.length})`;
            }
            
            // Update current snapshot date display for both mobile and desktop
            const currentSnapshotDateText = document.getElementById('current-snapshot-date-text');
            const currentSnapshotDateTextDesktop = document.getElementById('current-snapshot-date-text-desktop');
            
            const updateDateText = (element) => {
                if (element) {
                    if (snapshotMode === 'live') {
                        element.textContent = 'Données en direct';
                    } else if (currentSnapshotDate && currentSnapshotIndex >= 0) {
                        // Get the current snapshot info for better display
                        const currentSnapshot = availableSnapshots[currentSnapshotIndex];
                        if (currentSnapshot) {
                            const date = new Date(currentSnapshot.snapshot_date);
                            const createdTime = new Date(currentSnapshot.created_at);
                            const formattedDate = date.toLocaleDateString('fr-FR', {
                                day: '2-digit',
                                month: '2-digit',
                                year: 'numeric'
                            });
                            const timeString = createdTime.toLocaleTimeString('fr-FR', {
                                hour: '2-digit',
                                minute: '2-digit'
                            });
                            element.textContent = `Snapshot du ${formattedDate} à ${timeString}`;
                        } else {
                            element.textContent = 'Snapshot en cours...';
                        }
                    }
                }
            };
            
            // Update both mobile and desktop date displays
            updateDateText(currentSnapshotDateText);
            updateDateText(currentSnapshotDateTextDesktop);
        }
        
        // Check and fix inconsistencies between database and storage
        async function checkAndFixInconsistencies() {
            try {
                // Clean: Removed debug log
                
                // Get database snapshots
                const { data: dbSnapshots, error: dbError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (dbError) {
                    console.error('❌ Error checking database:', dbError);
                    return;
                }
                
                // Get storage files
                        const { data: storageFiles, error: storageError } = await supabase.storage
            .from('table-snapshots')
            .list('', { limit: 100 });
                
                if (storageError) {
                    console.error('❌ Error checking storage:', storageError);
                    return;
                }
                
                // Clean: Removed debug logs
                
                // Check for orphaned database records (no corresponding file)
                const orphanedRecords = [];
                for (const snapshot of dbSnapshots || []) {
                    // Extract filename from object_path (remove directory part)
                    const fileName = snapshot.object_path.split('/').pop();
                    const fileExists = storageFiles?.some(file => file.name === fileName);
                    if (!fileExists) {
                        orphanedRecords.push(snapshot);
                        console.warn(`⚠️ Orphaned record: ${snapshot.snapshot_date} -> ${snapshot.object_path} (filename: ${fileName})`);
                    }
                }
                
                // Check for orphaned storage files (no corresponding database record)
                const orphanedFiles = [];
                for (const file of storageFiles || []) {
                    if (file.name.includes('staff_table_') || file.name.includes('staffTable_')) {
                        // Check if any database record has this filename in its object_path
                        const recordExists = dbSnapshots?.some(s => s.object_path.endsWith(file.name));
                        if (!recordExists) {
                            orphanedFiles.push(file);
                            console.warn(`⚠️ Orphaned file: ${file.name}`);
                        }
                    }
                }
                
                if (orphanedRecords.length > 0 || orphanedFiles.length > 0) {
                    // Clean: Removed debug log
                    showMessage(`Incohérences détectées. Utilisez le bouton "Nettoyer" pour corriger.`, 'warning');
                } else {
                    // Clean: Removed debug log
                    showMessage('Aucune incohérence détectée', 'success');
                }
                
            } catch (err) {
                console.error('❌ Error checking inconsistencies:', err);
            }
        }
        
                // Clean database and create fresh snapshot
        async function cleanDatabaseAndCreateSnapshot() {
            try {
                // Clean: Removed debug log
                
                // Check current state
                const { data: current, error: checkError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (checkError) {
                    console.error('❌ Error checking current state:', checkError);
                    return;
                }
                
                // Clean: Removed debug log
                
                if (current && current.length > 0) {
                    // Delete all existing snapshots
                    const { error: deleteError } = await supabase
                        .from('table_snapshots_index')
                        .delete()
                        .neq('id', '00000000-0000-0000-0000-000000000000');
                    
                    if (deleteError) {
                        console.error('❌ Error deleting snapshots:', deleteError);
                        return;
                    }
                    
                    // Clean: Removed debug log
                }
                
                // Create new snapshot with unique date
                await createDemoSnapshot();
                
                // Reload snapshots after cleanup
                await loadAvailableSnapshots();
                
                // Update the calendar display
                populateSnapshotCalendar();
                
                showMessage('Base de données nettoyée et nouveau snapshot créé', 'success');
                
            } catch (err) {
                console.error('❌ Error cleaning database:', err);
                showMessage('Erreur lors du nettoyage de la base', 'error');
            }
        }
        
        // Enter snapshot mode for a specific date
        async function enterSnapshotMode(date) {
            if (snapshotMode === 'snapshot' && currentSnapshotDate === date) {
                return; // Already in this snapshot
            }
            
            try {
                // Clean: Removed debug log
                
                // Find snapshot info
                const snapshotInfo = availableSnapshots.find(s => s.snapshot_date === date);
                if (!snapshotInfo) {
                    showMessage(`Aucun snapshot trouvé pour le ${formatDateForDisplay(date)}`, 'error');
                    return;
                }
                
                // Check if the file exists in storage first
                // Clean: Removed debug log
                
                        const { data: fileList, error: listError } = await supabase.storage
            .from('table-snapshots')
            .list('', { limit: 100 });
                
                if (listError) {
                    console.warn('⚠️ Could not list storage files:', listError);
                } else {
                    // Extract filename from object_path for comparison
                    const fileName = snapshotInfo.object_path.split('/').pop() || snapshotInfo.object_path;
                    const fileExists = fileList?.some(file => file.name === fileName);
                    if (!fileExists) {
                        console.warn(`⚠️ File not found in storage: ${fileName} (from path: ${snapshotInfo.object_path})`);
                        // Clean: Removed debug log
                        
                        // Try to find a similar file or suggest cleanup
                        const similarFiles = fileList?.filter(f => f.name.includes('staffTable_'));
                        if (similarFiles && similarFiles.length > 0) {
                            console.log('📋 Similar files found:', similarFiles.map(f => f.name));
                            showMessage('Fichier snapshot introuvable. Utilisez le bouton "Nettoyer" pour corriger.', 'warning');
                            return;
                        }
                    }
                }
                
                // Get snapshot data from storage - Handle both old and new path formats
                let fileName = snapshotInfo.object_path;
                let isHierarchicalPath = false;
                
                // Check if this is a new hierarchical path (YYYY/MM/DD/HH-MM-SS_staffTable.json)
                if (fileName.match(/^\d{4}\/\d{2}\/\d{2}\/\d{2}-\d{2}-\d{2}_staffTable\.json$/)) {
                    isHierarchicalPath = true;
                    console.log('🔄 Nouveau format hiérarchique détecté:', fileName);
                } else if (fileName.includes('/')) {
                    // Old format with slashes, extract filename
                    fileName = fileName.split('/').pop();
                    console.log('🔄 Ancien format détecté, nom extrait:', fileName);
                } else {
                    // Flat format (staffTable_YYYY-MM-DD_HH-MM-SS.json)
                    console.log('🔄 Format plat détecté:', fileName);
                }
                
                console.log('🔍 Debug - Reading snapshot:', {
                    originalPath: snapshotInfo.object_path,
                    finalFileName: fileName,
                    snapshotDate: snapshotInfo.snapshot_date,
                    created_at: snapshotInfo.created_at,
                    snapshotId: snapshotInfo.id
                });
                
                // RADICAL SOLUTION: Force fresh Supabase client + multiple download methods
                let snapshotData;
                
                // STEP 1: Create a completely fresh Supabase client for this download
                const freshSupabase = createClient(
                    'https://fiecugxopjxzqfdnaqsu.supabase.co',
                    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ1MDU2NTcsImV4cCI6MjA3MDA4MTY1N30.xd9Thasg4r8Nrwxx5nFwyGB_ufPIvok4XB-78dilpsw'
                );
                
                console.log('🔄 Created fresh Supabase client for download');
                
                // STEP 2: Try multiple download methods with fresh client
                try {
                    // METHOD 1: Fresh Supabase client download
                    console.log('🔄 METHOD 1: Fresh Supabase client download...');
                    
                    // Always use the full object path for download
                    const downloadPath = snapshotInfo.object_path;
                    console.log('📁 Téléchargement avec chemin:', downloadPath);
                    
                    const result = await freshSupabase.storage
                        .from('table-snapshots')
                        .download(downloadPath);
                    
                    if (result.error) {
                        throw new Error(`Fresh client download failed: ${result.error.message}`);
                    }
                    
                    if (!result.data) {
                        throw new Error(`No data from fresh client for: ${downloadPath}`);
                    }
                    
                    snapshotData = result.data;
                    console.log('✅ METHOD 1 SUCCESS: Fresh Supabase client, Size:', snapshotData.size);
                    
                } catch (method1Err) {
                    console.error('❌ METHOD 1 failed:', method1Err);
                    
                    // METHOD 2: Direct URL fetch with cache busting
                    try {
                        console.log('🔄 METHOD 2: Direct URL with cache busting...');
                        const timestamp = Date.now();
                        const downloadPath = snapshotInfo.object_path;
                        const directUrl = `https://fiecugxopjxzqfdnaqsu.supabase.co/storage/v1/object/public/table-snapshots/${downloadPath}?t=${timestamp}`;
                        
                        const response = await fetch(directUrl, {
                            method: 'GET',
                            headers: {
                                'Cache-Control': 'no-cache, no-store, must-revalidate',
                                'Pragma': 'no-cache',
                                'Expires': '0'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Direct URL failed: HTTP ${response.status}`);
                        }
                        
                        const textData = await response.text();
                        console.log('✅ METHOD 2 SUCCESS: Direct URL, Size:', textData.length);
                        
                        // Create a mock File object
                        snapshotData = new File([textData], fileName, { type: 'application/json' });
                        
                    } catch (method2Err) {
                        console.error('❌ METHOD 2 failed:', method2Err);
                        
                        // METHOD 3: Service role key with fresh client
                        try {
                            console.log('🔄 METHOD 3: Service role with fresh client...');
                            // SECURITY WARNING: This operation requires server-side implementation
                            // Service keys should never be exposed in client-side code
                            console.error('SECURITY: Service key operations disabled - implement server-side API');
                            throw new Error('Service key operations disabled for security');
                            
                        } catch (method3Err) {
                            console.error('❌ All methods failed - Service key operations disabled for security!');
                            throw new Error(`All download methods failed - Service operations are disabled for security reasons.`);
                        }
                    }
                }
                
                // Parse snapshot data with verification
                const snapshotText = await snapshotData.text();
                console.log('📄 Raw snapshot content preview:', snapshotText.substring(0, 200) + '...');
                
                const snapshot = JSON.parse(snapshotText);
                
                // VERIFICATION: Check if this is the right snapshot
                if (snapshot.data && snapshot.data.length !== snapshotInfo.row_count) {
                    console.warn('⚠️ WARNING: Snapshot row count mismatch!', {
                        expected: snapshotInfo.row_count,
                        actual: snapshot.data.length,
                        fileName: fileName,
                        snapshotId: snapshotInfo.id
                    });
                }
                
                // Update state
                snapshotMode = 'snapshot';
                currentSnapshotDate = date;
                currentSnapshotIndex = availableSnapshots.findIndex(s => s.snapshot_date === date);
                
                // Disable realtime updates
                if (realtimeSubscription) {
                    supabase.removeChannel(realtimeSubscription);
                    realtimeSubscription = null;
                }
                
                // Load snapshot data into table
                loadTableData(snapshot.data);
                
                // Update UI
                updateHistoryNavigation();
                updateSnapshotBanner();
                updateHistoryDateButton();
                
                // Disable editing
                disableTableEditing();
                
                showMessage(`Snapshot chargé du ${formatDateForDisplay(date)} (${snapshot.data.length} lignes)`, 'success');
                
            } catch (error) {
                console.error('❌ Error entering snapshot mode:', error);
                showMessage(`Erreur lors du chargement du snapshot: ${error.message}`, 'error');
            }
        }
        
        // Enter snapshot mode using unique snapshot object (fixes multiple snapshots per day issue)
        async function enterSnapshotModeByUniqueId(snapshotInfo) {
            console.log('🚀 DEBUG: enterSnapshotModeByUniqueId called with:', {
                snapshotInfo,
                currentMode: snapshotMode,
                currentDate: currentSnapshotDate,
                currentIndex: currentSnapshotIndex,
                availableCount: availableSnapshots?.length || 0
            });
            
            if (snapshotMode === 'snapshot' && currentSnapshotDate === snapshotInfo.snapshot_date && 
                currentSnapshotIndex >= 0 && availableSnapshots[currentSnapshotIndex]?.id === snapshotInfo.id) {
                console.log('⚠️ DEBUG: Already in this snapshot, returning early');
                return; // Already in this exact snapshot
            }
            
            try {
                console.log('🔄 enterSnapshotModeByUniqueId: Loading snapshot with ID:', snapshotInfo.id);
                console.log('📊 DEBUG: Full snapshot info:', JSON.stringify(snapshotInfo, null, 2));
                
                // Check if the file exists in storage first
                // For organized paths like "2025/08/24/file.json", extract the folder
                const pathParts = snapshotInfo.object_path.split('/');
                const searchPath = pathParts.length > 1 ? pathParts.slice(0, -1).join('/') : '';
                
                console.log('📁 DEBUG: Searching in folder:', searchPath || 'root');
                
                const { data: fileList, error: listError } = await supabase.storage
                    .from('table-snapshots')
                    .list(searchPath, { limit: 200 });
                
                if (listError) {
                    console.warn('⚠️ Could not list storage files:', listError);
                } else {
                    console.log('📁 DEBUG: Files in storage folder:', fileList?.map(f => f.name) || []);
                    console.log('🔍 DEBUG: Looking for file path:', snapshotInfo.object_path);
                    
                    // Extract filename from object_path since we're searching in the specific folder
                    const fileName = snapshotInfo.object_path.split('/').pop() || snapshotInfo.object_path;
                    console.log('🔍 DEBUG: Looking for filename:', fileName);
                    
                    // Look for the file in the folder
                    const fileMatch = fileList?.find(file => file.name === fileName);
                    console.log('🎯 DEBUG: File found in folder:', !!fileMatch);
                    
                    let actualFilePath = null;
                    let fileExists = false;
                    
                    if (fileMatch) {
                        actualFilePath = snapshotInfo.object_path;
                        fileExists = true;
                        console.log('✅ DEBUG: File found in organized folder structure');
                    } else {
                        // Fallback: try to find by filename pattern matching
                        const fallbackMatch = fileList?.find(file => 
                            file.name.includes(fileName.replace('_staffTable.json', '')) ||
                            fileName.includes(file.name.replace('_staffTable.json', ''))
                        );
                        
                        if (fallbackMatch) {
                            actualFilePath = searchPath ? `${searchPath}/${fallbackMatch.name}` : fallbackMatch.name;
                            fileExists = true;
                            console.log('✅ DEBUG: Fallback filename match found:', fallbackMatch.name);
                        }
                    }
                    
                    if (!fileExists) {
                        console.log('❌ DEBUG: No file found in folder');
                        console.log('🔍 DEBUG: Available files:', fileList?.map(f => f.name) || []);
                        console.log('🔍 DEBUG: Searched for:', fileName);
                        showMessage(`❌ Fichier snapshot introuvable: ${fileName}`, 'error');
                        return;
                    }
                    
                    // File exists, proceed with loading
                    console.log('✅ DEBUG: Using file path:', actualFilePath);
                    // Update the snapshotInfo to use the actual file path
                    snapshotInfo.object_path = actualFilePath;
                }
                
                // Get snapshot data from storage - Handle both old and new path formats
                let fileName = snapshotInfo.object_path;
                let isHierarchicalPath = false;
                
                // Check if this is a new hierarchical path (YYYY/MM/DD/HH-MM-SS_staffTable.json)
                if (fileName.match(/^\d{4}\/\d{2}\/\d{2}\/\d{2}-\d{2}-\d{2}_staffTable\.json$/)) {
                    isHierarchicalPath = true;
                    console.log('🔄 Nouveau format hiérarchique détecté:', fileName);
                } else if (fileName.includes('/')) {
                    // Old format with slashes, extract filename
                    fileName = fileName.split('/').pop();
                    console.log('🔄 Ancien format détecté, nom extrait:', fileName);
                } else {
                    // Flat format (staffTable_YYYY-MM-DD_HH-MM-SS.json)
                    console.log('🔄 Format plat détecté:', fileName);
                }
                
                console.log('🔍 Debug - Reading snapshot:', {
                    snapshotId: snapshotInfo.id,
                    originalPath: snapshotInfo.object_path,
                    finalFileName: fileName,
                    snapshotDate: snapshotInfo.snapshot_date,
                    created_at: snapshotInfo.created_at
                });
                
                // RADICAL SOLUTION: Force fresh Supabase client + multiple download methods
                let snapshotData;
                
                // STEP 1: Create a completely fresh Supabase client for this download
                const freshSupabase = createClient(
                    'https://fiecugxopjxzqfdnaqsu.supabase.co',
                    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ1MDU2NTcsImV4cCI6MjA3MDA4MTY1N30.xd9Thasg4r8Nrwxx5nFwyGB_ufPIvok4XB-78dilpsw'
                );
                
                console.log('🔄 Created fresh Supabase client for download');
                
                // STEP 2: Try multiple download methods with fresh client
                try {
                    // METHOD 1: Fresh Supabase client download
                    console.log('🔄 METHOD 1: Fresh Supabase client download...');
                    
                    // Always use the full object path for download
                    const downloadPath = snapshotInfo.object_path;
                    console.log('📁 Téléchargement avec chemin:', downloadPath);
                    
                    const result = await freshSupabase.storage
                        .from('table-snapshots')
                        .download(downloadPath);
                    
                    if (result.error) {
                        throw new Error(`Fresh client download failed: ${result.error.message}`);
                    }
                    
                    if (!result.data) {
                        throw new Error(`No data from fresh client for: ${downloadPath}`);
                    }
                    
                    snapshotData = result.data;
                    console.log('✅ METHOD 1 SUCCESS: Fresh Supabase client, Size:', snapshotData.size);
                    
                } catch (method1Err) {
                    console.error('❌ METHOD 1 failed:', method1Err);
                    
                    // METHOD 2: Direct URL fetch with cache busting
                    try {
                        console.log('🔄 METHOD 2: Direct URL with cache busting...');
                        const timestamp = Date.now();
                        const downloadPath = snapshotInfo.object_path;
                        const directUrl = `https://fiecugxopjxzqfdnaqsu.supabase.co/storage/v1/object/public/table-snapshots/${downloadPath}?t=${timestamp}`;
                        
                        const response = await fetch(directUrl, {
                            method: 'GET',
                            headers: {
                                'Cache-Control': 'no-cache, no-store, must-revalidate',
                                'Pragma': 'no-cache',
                                'Expires': '0'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Direct URL failed: HTTP ${response.status}`);
                        }
                        
                        const textData = await response.text();
                        console.log('✅ METHOD 2 SUCCESS: Direct URL, Size:', textData.length);
                        
                        // Create a mock File object
                        snapshotData = new File([textData], fileName, { type: 'application/json' });
                        
                    } catch (method2Err) {
                        console.error('❌ METHOD 2 failed:', method2Err);
                        
                        // METHOD 3: Service role key with fresh client
                        try {
                            console.log('🔄 METHOD 3: Service role with fresh client...');
                            // SECURITY WARNING: This operation requires server-side implementation
                            // Service keys should never be exposed in client-side code
                            console.error('SECURITY: Service key operations disabled - implement server-side API');
                            throw new Error('Service key operations disabled for security');
                            
                        } catch (method3Err) {
                            console.error('❌ All methods failed - Service key operations disabled for security!');
                            throw new Error(`All download methods failed - Service operations are disabled for security reasons.`);
                        }
                    }
                }
                
                // Parse snapshot data with verification
                const snapshotText = await snapshotData.text();
                console.log('📄 Raw snapshot content preview:', snapshotText.substring(0, 200) + '...');
                
                const snapshot = JSON.parse(snapshotText);
                
                // VERIFICATION: Check if this is the right snapshot
                if (snapshot.data && snapshot.data.length !== snapshotInfo.row_count) {
                    console.warn('⚠️ WARNING: Snapshot row count mismatch!', {
                        expected: snapshotInfo.row_count,
                        actual: snapshot.data.length,
                        fileName: fileName,
                        snapshotId: snapshotInfo.id
                    });
                }
                
                // Update state using unique identifier
                snapshotMode = 'snapshot';
                currentSnapshotDate = snapshotInfo.snapshot_date;
                currentSnapshotIndex = availableSnapshots.findIndex(s => s.id === snapshotInfo.id);
                
                // Disable realtime updates
                if (realtimeSubscription) {
                    supabase.removeChannel(realtimeSubscription);
                    realtimeSubscription = null;
                }
                
                // Load snapshot data into table
                loadTableData(snapshot.data);
                
                // Update UI
                updateHistoryNavigation();
                updateSnapshotBanner();
                updateHistoryDateButton();
                
                // Disable editing
                disableTableEditing();
                
                showMessage(`Snapshot chargé du ${formatDateForDisplay(snapshotInfo.snapshot_date)} (${snapshot.data.length} lignes) - ID: ${snapshotInfo.id}`, 'success');
                
            } catch (error) {
                console.error('❌ Error entering snapshot mode by unique ID:', error);
                showMessage(`Erreur lors du chargement du snapshot: ${error.message}`, 'error');
            }
        }
        
        // Return to today's live view
        async function returnToToday() {
            if (snapshotMode === 'live') {
                return; // Already in live mode
            }
            
            try {
                // Clean: Removed debug log
                
                // Update state
                snapshotMode = 'live';
                currentSnapshotDate = null;
                currentSnapshotIndex = -1;
                
                // Re-enable realtime updates
                setupRealtimeSubscription();
                
                // Refresh data from Supabase (no cache)
                await fetchInitialData();
                
                // Update UI
                updateHistoryNavigation();
                updateSnapshotBanner();
                updateHistoryDateButton();
                
                // Re-enable editing
                enableTableEditing();
                
                showMessage('Retour au mode en direct avec données actuelles', 'success');
                
            } catch (error) {
                console.error('❌ Error returning to today:', error);
                showMessage(`Erreur lors du retour au mode en direct: ${error.message}`, 'error');
            }
        }
        
        // Navigate to previous snapshot
        function goToPreviousSnapshot() {
            if (currentSnapshotIndex > 0) {
                const prevSnapshot = availableSnapshots[currentSnapshotIndex - 1];
                enterSnapshotModeByUniqueId(prevSnapshot);
            }
        }
        
        // Navigate to next snapshot
        function goToNextSnapshot() {
            if (currentSnapshotIndex < availableSnapshots.length - 1) {
                const nextSnapshot = availableSnapshots[currentSnapshotIndex + 1];
                enterSnapshotModeByUniqueId(nextSnapshot);
            }
        }
        
        // Open date picker for snapshot selection
        function openDatePicker() {
            if (availableSnapshots.length === 0) {
                showMessage('Aucun snapshot disponible', 'info');
                return;
            }
            
            // Create a simple date picker
            const dates = availableSnapshots.map(s => s.snapshot_date);
            const currentDate = snapshotMode === 'snapshot' ? currentSnapshotDate : null;
            
            // Find current index
            let currentIndex = currentDate ? dates.indexOf(currentDate) : -1;
            if (currentIndex === -1) currentIndex = 0;
            
            // Show next available date
            const nextIndex = (currentIndex + 1) % dates.length;
            const nextDate = dates[nextIndex];
            
            // Find the snapshot object for this date
            const nextSnapshot = availableSnapshots.find(s => s.snapshot_date === nextDate);
            if (nextSnapshot) {
                enterSnapshotModeByUniqueId(nextSnapshot);
            } else {
                showMessage('Snapshot non trouvé pour cette date', 'error');
            }
        }
        
        // Toggle snapshot calendar dropdown
        function toggleSnapshotCalendar() {
            const dropdown = document.getElementById('snapshot-calendar-dropdown');
            const isVisible = !dropdown.classList.contains('hidden');
            
            if (isVisible) {
                dropdown.classList.add('hidden');
            } else {
                // Populate and show calendar
                populateSnapshotCalendar();
                dropdown.classList.remove('hidden');
            }
        }
        
        // Populate snapshot calendar with available dates
        function populateSnapshotCalendar() {
            const datesList = document.getElementById('snapshot-dates-list');
            const calendarBtnText = document.getElementById('calendar-btn-text');
            
            if (!datesList) return;
            
            // Clear existing content
            datesList.innerHTML = '';
            
            if (availableSnapshots.length === 0) {
                datesList.innerHTML = `
                    <div class="p-3 text-center text-gray-500 text-sm">
                        <i class="fa-solid fa-calendar-xmark w-5 h-5 mx-auto mb-2"></i>
                        Aucun snapshot disponible
                    </div>
                `;
                calendarBtnText.textContent = 'Calendrier (0)';
                return;
            }
            
            // Update button text with count
            calendarBtnText.textContent = `Calendrier (${availableSnapshots.length})`;
            
            // Sort snapshots by created_at (most recent first) to ensure proper ordering
            const sortedSnapshots = [...availableSnapshots].sort((a, b) => 
                new Date(b.created_at) - new Date(a.created_at)
            );
            
            // Group snapshots by month/year for better organization
            const groupedSnapshots = {};
            sortedSnapshots.forEach(snapshot => {
                const date = new Date(snapshot.snapshot_date);
                const monthYear = date.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long' });
                
                if (!groupedSnapshots[monthYear]) {
                    groupedSnapshots[monthYear] = [];
                }
                groupedSnapshots[monthYear].push(snapshot);
            });
            
            // Get unique months for navigation
            const months = Object.keys(groupedSnapshots).sort((a, b) => {
                const dateA = new Date(sortedSnapshots.find(s => {
                    const date = new Date(s.snapshot_date);
                    return date.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long' }) === a;
                })?.snapshot_date || 0);
                const dateB = new Date(sortedSnapshots.find(s => {
                    const date = new Date(s.snapshot_date);
                    return date.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long' }) === b;
                })?.snapshot_date || 0);
                return dateB - dateA; // Most recent first
            });
            
            // Create month navigation header
            const monthNavHeader = document.createElement('div');
            monthNavHeader.className = 'sticky top-0 bg-white border-b border-gray-200 p-3 mb-3 z-10 sticky-month-nav';
            monthNavHeader.innerHTML = `
                <div class="flex items-center justify-between mb-2">
                    <h4 class="text-sm font-semibold text-gray-700">📅 Navigation par mois</h4>
                    <span class="text-xs text-gray-500">${availableSnapshots.length} snapshots</span>
                </div>
                <div class="flex items-center gap-2 overflow-x-auto pb-2">
                    ${months.map((month, index) => `
                        <button 
                            onclick="showMonthSnapshots('${month}')" 
                            class="month-nav-btn px-3 py-1.5 text-xs rounded-lg border transition-colors whitespace-nowrap ${
                                index === 0 ? 'bg-blue-100 border-blue-300 text-blue-700 font-medium' : 'bg-gray-50 border-gray-200 text-gray-600 hover:bg-gray-100'
                            }"
                            data-month="${month}"
                        >
                            ${month}
                        </button>
                    `).join('')}
                </div>
            `;
            datesList.appendChild(monthNavHeader);
            
            // Show the most recent month by default
            if (months.length > 0) {
                showMonthSnapshots(months[0]);
            }
        }
        
        // Function to delete a snapshot
        async function deleteSnapshot(snapshotId, snapshotDate, objectPath, isCurrentSnapshot = false) {
            try {
                // Confirmation de suppression
                const confirmMessage = isCurrentSnapshot 
                    ? `⚠️ ATTENTION: Vous êtes actuellement dans ce snapshot!\n\nÊtes-vous sûr de vouloir le supprimer ?\n\nDate: ${snapshotDate}\nID: ${snapshotId}`
                    : `Êtes-vous sûr de vouloir supprimer ce snapshot ?\n\nDate: ${snapshotDate}\nID: ${snapshotId}`;
                
                if (!confirm(confirmMessage)) {
                    return;
                }
                
                console.log(`🗑️ Suppression du snapshot: ${snapshotId} (${snapshotDate})`);
                
                // Si c'est le snapshot actuel, sortir du mode snapshot d'abord
                if (isCurrentSnapshot) {
                    console.log('🔄 Sortie du mode snapshot avant suppression...');
                    await exitSnapshotMode();
                }
                
                // Créer un client Supabase avec la clé de service pour la suppression
                const { createClient: createClientService } = await import('https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm');
                const supabaseService = createClientService(supabaseConfig.supabaseUrl, supabaseConfig.supabaseServiceKey);
                
                // 1. Supprimer le fichier du stockage
                console.log('🗑️ Suppression du fichier du stockage...');
                const { error: storageError } = await supabaseService.storage
                    .from('table-snapshots')
                    .remove([objectPath]);
                
                if (storageError) {
                    console.warn('⚠️ Erreur lors de la suppression du fichier:', storageError);
                    // Continuer même si le fichier n'existe pas
                } else {
                    console.log('✅ Fichier supprimé du stockage');
                }
                
                // 2. Supprimer l'enregistrement de la base de données
                console.log('🗑️ Suppression de l\'enregistrement de la base...');
                const { error: dbError } = await supabaseService
                    .from('table_snapshots_index')
                    .delete()
                    .eq('id', snapshotId);
                
                if (dbError) {
                    throw new Error(`Erreur lors de la suppression de l'enregistrement: ${dbError.message}`);
                }
                
                console.log('✅ Enregistrement supprimé de la base');
                
                // 3. Supprimer l'entrée du log de restauration
                console.log('🗑️ Suppression de l\'entrée du log...');
                const { error: logError } = await supabaseService
                    .from('snapshot_restore_log')
                    .delete()
                    .eq('snapshot_date', snapshotDate);
                
                if (logError) {
                    console.warn('⚠️ Erreur lors de la suppression du log:', logError);
                    // Continuer même si l'entrée n'existe pas
                } else {
                    console.log('✅ Entrée du log supprimée');
                }
                
                // 4. Mettre à jour la liste des snapshots disponibles
                console.log('🔄 Mise à jour de la liste des snapshots...');
                await loadAvailableSnapshots();
                
                // 5. Rafraîchir l'affichage du calendrier
                populateSnapshotCalendar();
                
                // 6. Afficher le message de succès
                showMessage(`✅ Snapshot supprimé avec succès: ${snapshotDate}`, 'success');
                
                console.log('🎉 Snapshot supprimé avec succès!');
                
            } catch (error) {
                console.error('❌ Erreur lors de la suppression du snapshot:', error);
                showMessage(`❌ Erreur lors de la suppression: ${error.message}`, 'error');
            }
        }

        // Function to show snapshots for a specific month
        function showMonthSnapshots(monthYear) {
            const datesList = document.getElementById('snapshot-dates-list');
            if (!datesList) return;
            
            // Update active month button
            const monthButtons = datesList.querySelectorAll('.month-nav-btn');
            monthButtons.forEach(btn => {
                if (btn.dataset.month === monthYear) {
                    btn.className = 'month-nav-btn px-3 py-1.5 text-xs rounded-lg border transition-colors whitespace-nowrap bg-blue-100 border-blue-300 text-blue-700 font-medium';
                } else {
                    btn.className = 'month-nav-btn px-3 py-1.5 text-xs rounded-lg border transition-colors whitespace-nowrap bg-gray-50 border-gray-200 text-gray-600 hover:bg-gray-100';
                }
            });
            
            // Find the month content container or create it
            let monthContent = datesList.querySelector('.month-content');
            if (!monthContent) {
                monthContent = document.createElement('div');
                monthContent.className = 'month-content';
                datesList.appendChild(monthContent);
            }
            
            // Clear previous month content
            monthContent.innerHTML = '';
            
            // Get snapshots for this month
            const monthSnapshots = availableSnapshots.filter(snapshot => {
                const date = new Date(snapshot.snapshot_date);
                const snapshotMonth = date.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long' });
                return snapshotMonth === monthYear;
            });
            
            if (monthSnapshots.length === 0) {
                monthContent.innerHTML = `
                    <div class="p-3 text-center text-gray-500 text-sm">
                        <i class="fa-solid fa-calendar-xmark w-5 h-3 mx-auto mb-2"></i>
                        Aucun snapshot pour ${monthYear}
                    </div>
                `;
                return;
            }
            
            // Sort snapshots by date (most recent first)
            monthSnapshots.sort((a, b) => new Date(b.snapshot_date) - new Date(a.snapshot_date));
            
            // Create month header
            const monthHeader = document.createElement('div');
            monthHeader.className = 'px-3 py-2 month-header-gradient rounded-r-lg mb-3';
            monthHeader.innerHTML = `
                <div class="flex items-center justify-between">
                    <h3 class="text-sm font-semibold text-blue-800">${monthYear}</h3>
                    <span class="text-xs text-blue-600 bg-blue-100 px-2 py-1 rounded-full">${monthSnapshots.length} snapshot${monthSnapshots.length > 1 ? 's' : ''}</span>
                </div>
            `;
            monthContent.appendChild(monthHeader);
            
            // Group snapshots by week for better organization
            const weeklySnapshots = {};
            monthSnapshots.forEach(snapshot => {
                const date = new Date(snapshot.snapshot_date);
                const weekStart = new Date(date);
                weekStart.setDate(date.getDate() - date.getDay()); // Start of week (Sunday)
                const weekKey = weekStart.toISOString().split('T')[0];
                
                if (!weeklySnapshots[weekKey]) {
                    weeklySnapshots[weekKey] = [];
                }
                weeklySnapshots[weekKey].push(snapshot);
            });
            
            // Create weekly sections
            Object.entries(weeklySnapshots).forEach(([weekStart, weekSnapshots]) => {
                // Week header
                const weekHeader = document.createElement('div');
                weekHeader.className = 'px-3 py-1 week-header text-xs font-medium text-gray-600 rounded mb-2';
                const weekDate = new Date(weekStart);
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekDate.getDate() + 6);
                weekHeader.textContent = `Semaine du ${weekDate.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' })} au ${weekEnd.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short' })}`;
                monthContent.appendChild(weekHeader);
                
                // Sort snapshots within the week by date
                weekSnapshots.sort((a, b) => new Date(b.snapshot_date) - new Date(a.snapshot_date));
                
                // Create snapshot entries for this week
                weekSnapshots.forEach(snapshot => {
                    const dateItem = document.createElement('div');
                    dateItem.className = 'px-4 py-2 hover:bg-blue-50 cursor-pointer rounded-lg text-sm transition-colors border-l-2 border-transparent hover:border-blue-300 ml-2 snapshot-item';
                    
                    // Use unique identifier combining date and time for current snapshot detection
                    const snapshotUniqueId = `${snapshot.snapshot_date}_${snapshot.created_at}`;
                    const currentUniqueId = snapshotMode === 'snapshot' && currentSnapshotDate ? 
                        `${currentSnapshotDate}_${currentSnapshotDate}` : null;
                    const isCurrent = snapshotUniqueId === currentUniqueId;
                    
                    if (isCurrent) {
                        dateItem.className += ' current';
                    }
                    
                    const date = new Date(snapshot.snapshot_date);
                    const formattedDate = date.toLocaleDateString('fr-FR', {
                        weekday: 'long',
                        day: 'numeric',
                        month: 'short'
                    });
                    
                    // Extract time from created_at for unique identification
                    const createdTime = new Date(snapshot.created_at);
                    const timeString = createdTime.toLocaleTimeString('fr-FR', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    
                    // Add unique identifier to help with debugging
                    const uniqueTimeId = createdTime.getTime();
                    
                    dateItem.innerHTML = `
                        <div class="flex items-center justify-between">
                            <div class="flex flex-col flex-1 cursor-pointer" onclick="enterSnapshotModeByUniqueId(${JSON.stringify(snapshot).replace(/"/g, '&quot;')})">
                                <span class="${isCurrent ? 'font-semibold text-blue-700' : 'text-gray-700'}">${formattedDate}</span>
                                <span class="text-xs text-gray-400">${timeString}</span>
                                <span class="text-xs text-gray-300">ID: ${uniqueTimeId}</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="text-xs text-gray-500">${snapshot.row_count} lignes</span>
                                ${isCurrent ? '<span class="text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded-full">Actuel</span>' : ''}
                                <button onclick="event.stopPropagation(); deleteSnapshot('${snapshot.id}', '${snapshot.snapshot_date}', '${snapshot.object_path}', ${isCurrent})" 
                                        class="text-red-500 hover:text-red-700 p-1.5 rounded hover:bg-red-50 transition-colors ml-2" 
                                        title="Supprimer ce snapshot">
                                    <i class="fas fa-trash text-xs"></i>
                                </button>
                            </div>
                        </div>
                    `;
                    
                    // Remove the old onclick handler since we now handle clicks on the content div
                    // and the delete button has its own handler
                    
                    monthContent.appendChild(dateItem);
                });
            });
        }
        
        // Update snapshot banner
        function updateSnapshotBanner() {
            // Note: snapshot-banner HTML element has been removed from the interface
            // This function is kept for compatibility but does nothing
            const banner = document.getElementById('snapshot-banner');
            if (!banner) {
                // Element doesn't exist anymore, silently return
                return;
            }
            
            const bannerText = document.getElementById('snapshot-banner-text');
            
            // Only show banner when actively viewing history (snapshot mode)
            if (snapshotMode === 'snapshot' && currentSnapshotDate) {
                banner.classList.remove('hidden');
                banner.classList.add('flex');
                if (bannerText) {
                    bannerText.textContent = `Snapshot du ${formatDateForDisplay(currentSnapshotDate)}`;
                }
            } else {
                // Always hidden in live mode or when no snapshot is selected
                banner.classList.add('hidden');
                banner.classList.remove('flex');
            }
        }
        
        // Update history date button
        function updateHistoryDateButton() {
            const dateText = document.getElementById('current-snapshot-date-text');
            
            if (snapshotMode === 'snapshot' && currentSnapshotDate) {
                dateText.textContent = formatDateForDisplay(currentSnapshotDate);
            } else {
                dateText.textContent = 'Données en direct';
            }
        }
        
        // Disable table editing
        function disableTableEditing() {
            console.log('🔒 DEBUG: disableTableEditing called');
            
            // Wait for DOM to be ready
            TimerManager.setTimeout(() => {
                const cells = document.querySelectorAll('#table-body td.editable-cell');
                console.log('🔒 DEBUG: Found', cells.length, 'editable cells to disable');
                
                cells.forEach((cell, index) => {
                    cell.contentEditable = false;
                    cell.classList.add('snapshot-readonly');
                    console.log(`🔒 DEBUG: Cell ${index} disabled and marked readonly`);
                });
                
                // Disable all function buttons in snapshot mode
                const functionButtons = document.querySelectorAll('#button-bar button');
                console.log('🔒 DEBUG: Found', functionButtons.length, 'function buttons to disable');
                
                functionButtons.forEach((btn, index) => {
                    btn.disabled = true;
                    console.log(`🔒 DEBUG: Button ${index} disabled`);
                });
                
                // Disable FAB add button
                const fabAdd = document.getElementById('fab-add');
                if (fabAdd) {
                    fabAdd.style.pointerEvents = 'none';
                    console.log('🔒 DEBUG: FAB add button disabled');
                } else {
                    console.warn('⚠️ DEBUG: FAB add button not found');
                }
                
                console.log('✅ DEBUG: Table editing disabled successfully');
            }, 100); // Small delay to ensure DOM is ready
        }
        
        // Enable table editing
        function enableTableEditing() {
            console.log('🔓 DEBUG: enableTableEditing called');
            
            // Wait for DOM to be ready
            TimerManager.setTimeout(() => {
                const cells = document.querySelectorAll('#table-body td.editable-cell');
                console.log('🔓 DEBUG: Found', cells.length, 'editable cells to enable');
                
                cells.forEach((cell, index) => {
                    if (!isViewMode) { // Only enable if not in view mode
                        cell.contentEditable = true;
                        console.log(`🔓 DEBUG: Cell ${index} enabled for editing`);
                    } else {
                        console.log(`🔓 DEBUG: Cell ${index} kept disabled (view mode)`);
                    }
                    cell.classList.remove('snapshot-readonly');
                    console.log(`🔓 DEBUG: Cell ${index} readonly class removed`);
                });
                
                // Re-enable function buttons
                const functionButtons = document.querySelectorAll('#button-bar button');
                console.log('🔓 DEBUG: Found', functionButtons.length, 'function buttons to enable');
                
                functionButtons.forEach((btn, index) => {
                    btn.disabled = false;
                    console.log(`🔓 DEBUG: Button ${index} enabled`);
                });
                
                // Re-enable FAB add button
                const fabAdd = document.getElementById('fab-add');
                if (fabAdd) {
                    fabAdd.style.pointerEvents = 'auto';
                    console.log('🔓 DEBUG: FAB add button enabled');
                } else {
                    console.warn('⚠️ DEBUG: FAB add button not found');
                }
                
                console.log('✅ DEBUG: Table editing enabled successfully');
            }, 100); // Small delay to ensure DOM is ready
        }
        
        // Format date for display
        function formatDateForDisplay(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('fr-FR', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        }
        

        

        
        // Fonction pour actualiser le tableau avec les données les plus récentes
        function refreshTableData() {
            // Clean: Removed debug log
            
            // Si on est en mode snapshot, retourner aux données en direct
            if (snapshotMode === 'snapshot') {
                // Clean: Removed debug log
                returnToToday();
            }
            
            // Recharger les données depuis Supabase
            fetchInitialData().then(() => {
                showMessage('Tableau actualisé avec les données les plus récentes', 'success');
            }).catch(error => {
                console.error('❌ Erreur lors de l\'actualisation:', error);
                showMessage('Erreur lors de l\'actualisation du tableau', 'error');
            });
        }
        
        // Enhanced mobile-responsive history bar toggle function
        function toggleHistoryBarSimple() {
            if (document.readyState !== 'complete') {
                setTimeout(toggleHistoryBarSimple, 100);
                return;
            }
            
            const historyBarContainer = document.getElementById('history-bar-container');
            const toggleBtn = document.getElementById('history-toggle-btn');
            const toggleIcon = document.getElementById('history-toggle-icon');
            const screenReader = toggleBtn?.querySelector('.sr-only');
            
            if (!historyBarContainer || !toggleBtn || !toggleIcon) {
                console.error('❌ Toggle elements not found');
                console.error('   - historyBarContainer:', !!historyBarContainer);
                console.error('   - toggleBtn:', !!toggleBtn);
                console.error('   - toggleIcon:', !!toggleIcon);
                return;
            }
            
            // Check current state with enhanced debugging
            const hasHiddenClass = historyBarContainer.classList.contains('hidden');
            const displayStyle = historyBarContainer.style.display;
            const computedDisplay = window.getComputedStyle(historyBarContainer).display;
            const offsetHeight = historyBarContainer.offsetHeight;
            
            console.log('🔍 Toggle state check:');
            console.log('   - Hidden class:', hasHiddenClass);
            console.log('   - Inline display style:', displayStyle);
            console.log('   - Computed display:', computedDisplay);
            console.log('   - Offset height:', offsetHeight);
            
            const isCurrentlyVisible = !hasHiddenClass && 
                                    displayStyle !== 'none' && 
                                    computedDisplay !== 'none' &&
                                    offsetHeight > 0;
            
            console.log('   - Is currently visible:', isCurrentlyVisible);
            
            if (isCurrentlyVisible) {
                // Hide history bar
                historyBarContainer.classList.add('hidden');
                historyBarContainer.style.display = 'none';
                
                // Force hide with additional CSS properties
                historyBarContainer.style.visibility = 'hidden';
                historyBarContainer.style.opacity = '0';
                historyBarContainer.style.height = '0';
                historyBarContainer.style.overflow = 'hidden';
                
                // Update accessibility attributes
                toggleBtn.setAttribute('aria-expanded', 'false');
                toggleBtn.setAttribute('title', 'Afficher l\'historique des snapshots');
                if (screenReader) screenReader.textContent = 'Afficher l\'historique';
                
                // Update icon with better mobile sizing
                toggleIcon.className = 'fa-solid fa-plus';
                if (isMobile()) {
                    toggleIcon.style.fontSize = '18px';
                }
                
                console.log('🔽 History bar hidden with enhanced hiding');
            } else {
                // Show history bar
                historyBarContainer.classList.remove('hidden');
                historyBarContainer.style.display = 'flex';
                
                // Force show with additional CSS properties
                historyBarContainer.style.visibility = 'visible';
                historyBarContainer.style.opacity = '1';
                historyBarContainer.style.height = 'auto';
                historyBarContainer.style.overflow = 'visible';
                
                // Update accessibility attributes
                toggleBtn.setAttribute('aria-expanded', 'true');
                toggleBtn.setAttribute('title', 'Masquer l\'historique des snapshots');
                if (screenReader) screenReader.textContent = 'Masquer l\'historique';
                
                // Update icon with better mobile sizing
                toggleIcon.className = 'fa-solid fa-minus';
                if (isMobile()) {
                    toggleIcon.style.fontSize = '18px';
                }
                
                console.log('🔼 History bar shown with enhanced showing');
                
                // Ensure proper mobile layout
                if (isMobile() && window.innerWidth <= 768) {
                    historyBarContainer.style.width = '100%';
                    historyBarContainer.style.maxWidth = 'none';
                    console.log('📱 Mobile layout applied');
                }
            }
            
            // Add haptic feedback on mobile
            if (isMobile() && navigator.vibrate) {
                navigator.vibrate(50); // Short vibration feedback
                console.log('📱 Haptic feedback provided');
            }
            
            // Final state verification
            TimerManager.setTimeout(() => {
                const finalState = {
                    hiddenClass: historyBarContainer.classList.contains('hidden'),
                    display: historyBarContainer.style.display,
                    computedDisplay: window.getComputedStyle(historyBarContainer).display,
                    visibility: historyBarContainer.style.visibility,
                    opacity: historyBarContainer.style.opacity,
                    height: historyBarContainer.style.height
                };
                console.log('✅ Final toggle state:', finalState);
                
                // Update manual snapshot button state after toggle
                updateManualSnapshotButtonState();
            }, 100);
        }
        
        // Mobile event listeners removed - consistent behavior across all screen sizes
        
        // Mobile breakpoint and layout optimization functions removed - consistent display across all screen sizes
        
        // Test function for history bar functionality (mobile-specific features removed)
        function testHistoryBar() {
            const historyBarContainer = document.getElementById('history-bar-container');
            const toggleBtn = document.getElementById('history-toggle-btn');
            const toggleIcon = document.getElementById('history-toggle-icon');
            
            console.log('🧪 Testing History Bar...');
            console.log('🔄 Screen size:', window.innerWidth, 'x', window.innerHeight);
            
            if (!historyBarContainer || !toggleBtn || !toggleIcon) {
                console.error('❌ Test failed: Required elements not found');
                return false;
            }
            
            console.log('✅ All elements found');
            console.log('🔍 History bar container:', historyBarContainer);
            console.log('🔍 Toggle button:', toggleBtn);
            console.log('🔍 Toggle icon:', toggleIcon);
            
            // Test initial state
            const initialHidden = historyBarContainer.classList.contains('hidden');
            const initialDisplay = historyBarContainer.style.display;
            const initialHeight = historyBarContainer.offsetHeight;
            
            console.log('📊 Initial state:');
            console.log('  - Hidden class:', initialHidden);
            console.log('  - Display style:', initialDisplay);
            console.log('  - Offset height:', initialHeight);
            
            // Test toggle functionality
            console.log('🔄 Testing toggle functionality...');
            toggleHistoryBarSimple();
            
            TimerManager.setTimeout(() => {
                const afterToggleHidden = historyBarContainer.classList.contains('hidden');
                const afterToggleDisplay = historyBarContainer.style.display;
                const afterToggleHeight = historyBarContainer.offsetHeight;
                
                console.log('📊 After toggle:');
                console.log('  - Hidden class:', afterToggleHidden);
                console.log('  - Display style:', afterToggleDisplay);
                console.log('  - Offset height:', afterToggleHeight);
                
                // Test toggle back
                TimerManager.setTimeout(() => {
                    console.log('🔄 Testing toggle back...');
                    toggleHistoryBarSimple();
                    
                    TimerManager.setTimeout(() => {
                        const finalHidden = historyBarContainer.classList.contains('hidden');
                        const finalDisplay = historyBarContainer.style.display;
                        const finalHeight = historyBarContainer.offsetHeight;
                        
                        console.log('📊 Final state:');
                        console.log('  - Hidden class:', finalHidden);
                        console.log('  - Display style:', finalDisplay);
                        console.log('  - Offset height:', finalHeight);
                        
                        console.log('✅ History Bar test completed');
                    }, 100);
                }, 100);
            }, 100);
            
            return true;
        }

        // ===== END SNAPSHOT SYSTEM FUNCTIONS =====



        // Initialize application
        function initializeApp() {
            // Professional healthcare application initialization
            console.log('🏥 Système de Gestion Personnel Hospitalier v2.5.4 - Initialisation...');
            console.log('🔒 Application sécurisée - Conforme aux standards de sécurité hospitalière');
            console.log('👨‍💻 Développé par Georges Bassil - Healthcare IT Solutions');
            
            // Set up event listeners
            setupEventListeners();
            setupKeyboardNavigation();
            
            // Initialize zoom
            applyZoom();
            
            // Initialize color picker
            const picker = document.getElementById('row-color-picker');
            if (picker) {
                try { 
                    picker.value = currentRowColor; 
                } catch(_) {}
                
                picker.addEventListener('input', (e) => {
                    currentRowColor = e.target.value || '#FFF59D';
                    try { 
                        localStorage.setItem('rowColor', currentRowColor); 
                    } catch(_) {}
                });
            }
            
                        // Initialize UI state
            updatePaintModeButton();
            maybeShowFirstUseHint();
            updateFilterColoredButton();
            
            // Détecter automatiquement l'état du bouton œil et agir en conséquence
            detectAndApplyViewMode();
            
            // Adapter l'affichage du statut selon la taille d'écran
            adaptStatusDisplay();
            window.addEventListener('resize', adaptStatusDisplay);
            
            // Configurer le clic sur les noms de patients pour les images
            setupPatientImageClick();
            
            // Initialiser l'état de la barre d'historique : cachée par défaut
            const historyBarContainer = document.getElementById('history-bar-container');
            const toggleIcon = document.getElementById('history-toggle-icon');
            if (historyBarContainer && toggleIcon) {
                // S'assurer que la barre est cachée
                historyBarContainer.classList.add('hidden');
                historyBarContainer.style.display = 'none';
                
                // S'assurer que l'icône est en mode "plus" (fermé)
                toggleIcon.className = 'fa-solid fa-plus w-2 h-2 flex items-center justify-center text-center leading-none';
                
                // Vérification post-initialisation pour mobile
                TimerManager.setTimeout(() => {
                    if (isMobile()) {
                        const isHidden = historyBarContainer.classList.contains('hidden') && 
                                        historyBarContainer.style.display === 'none';
                        console.log('🔍 Post-init mobile check:', isHidden ? 'Hidden' : 'Visible');
                        
                        // Force mobile-specific layout
                        if (window.innerWidth <= 768) {
                            historyBarContainer.style.width = '100%';
                            historyBarContainer.style.maxWidth = 'none';
                        }
                    }
                }, 100);
            }
            
            // Initialiser l'affichage du nombre de lignes
            updateRowCount();
            
            // Check if already logged in
            const already = sessionStorage.getItem('isLoggedIn') === '1';
            if (already) {
                document.getElementById('login-container').classList.add('hidden');
                document.getElementById('table-container').classList.remove('hidden');
                
                // Détecter l'état du mode visualisation MAIS ne pas l'appliquer encore
                const savedViewMode = localStorage.getItem('viewMode') === 'true';
                if (savedViewMode !== isViewMode) {
                    isViewMode = savedViewMode;
                }
                
                restoreLocalDraft(); 
                ensureDDNHeader();
                
                // Consolidated cursor restoration function
                const performCursorRestoration = () => {
                    // Skip cursor restoration on mobile during undo/redo to prevent keyboard popup
                    if (isMobile() && isPerformingUndoRedo) {
                        log('🚫 [MOBILE] Cursor restoration blocked during undo/redo to prevent keyboard popup');
                        return false;
                    }
                    
                    log(`🔄 CURSOR RESTORATION: lastFocusInfo=${JSON.stringify(lastFocusInfo)}, lastCellPos=${JSON.stringify(lastCellPos)}`);
                    
                    // Try focusCellFromInfo first (more reliable)
                    let restorationSuccess = false;
                    if (lastFocusInfo && lastFocusInfo.rowIndex >= 0 && lastFocusInfo.colLabel) {
                        restorationSuccess = focusCellFromInfo(lastFocusInfo, lastFocusInfo?.caret);
                        log(`🔄 focusCellFromInfo result: ${restorationSuccess}, caret: ${lastFocusInfo?.caret}`);
                    }
                    
                    // Fallback to focusCellByPos if focusCellFromInfo fails
                    if (!restorationSuccess && lastCellPos && lastCellPos.rowIndex >= 0 && lastCellPos.cellIndex >= 0) {
                            log(`🔄 Trying focusCellByPos with ${JSON.stringify(lastCellPos)}`);
                        restorationSuccess = focusCellByPos(lastCellPos);
                        log(`🔄 focusCellByPos result: ${restorationSuccess}`);
                    }
                    
                    if (restorationSuccess) {
                        log(`✅ Cursor restoration successful`);
                        } else {
                        log(`⚠️ Cursor restoration failed - no valid position information`);
                    }
                };
                
                const restoreAfterReload = () => {
                    document.removeEventListener('table:reloaded', restoreAfterReload);
                    
                    // Skip cursor restoration on mobile during undo/redo to prevent keyboard popup
                    if (isMobile() && isPerformingUndoRedo) {
                        log('🚫 Skipping cursor restoration on mobile during undo/redo to prevent keyboard popup');
                        return;
                    }
                    
                    // For undo/redo operations, restore immediately without delays
                    if (isPerformingUndoRedo) {
                        // Immediate restoration for undo/redo - no delays
                        if (!isMobile()) {
                            performCursorRestoration();
                        }
                        return;
                    }
                    
                    // Wait for table to be fully rendered and image icons updated (only for regular loads)
                    // Use a longer delay to ensure all table updates are complete
                    TimerManager.setTimeout(() => {
                        // Double-check undo/redo state before performing cursor restoration
                        if (isMobile() && isPerformingUndoRedo) {
                            log('🚫 Skipping delayed cursor restoration on mobile during undo/redo');
                            return;
                        }
                        
                        performCursorRestoration();
                        
                        // Additional mobile retry if needed
                        if (isMobile() && !isPerformingUndoRedo) {
                            TimerManager.setTimeout(() => { 
                                if (!isPerformingUndoRedo) {
                                    performCursorRestoration();
                                }
                            }, 350);
                        }
                    }, 200); // Increased delay to ensure table and image icons are fully ready
                };
                
                document.addEventListener('table:reloaded', restoreAfterReload, { once: true });
                fetchInitialData(); 
                setupRealtimeSubscription(); 
                startPeriodicSync(); 
                scheduleAutosaveCountdown();
                
                // Initialize snapshot system
                loadAvailableSnapshots();
                
                // Ensure snapshot banner is hidden by default
                updateSnapshotBanner();
                
                // Update calendar display after loading snapshots
                TimerManager.setTimeout(() => {
                    populateSnapshotCalendar();
                }, 500);
                
                // Clean: Removed debug verification for production
                
                // Force UI update to ensure everything is visible
                // Clean: Removed debug UI update for production
                

                
                // Appliquer le mode visualisation APRÈS la restauration des données
                // Clean: Removed debug view mode application for production
                
                // Adapter l'affichage après le chargement des données
                setTimeout(adaptStatusDisplay, 100);
                
                // Mettre à jour les indicateurs d'images
                setTimeout(updateImageIndicators, 200);
                
                // Charger les images depuis Supabase
                setTimeout(loadImagesFromSupabase, 300);
                
                // Mettre à jour les icônes de la colonne Images après le chargement
                setTimeout(updateAllImageColumnIcons, 500);
                
                // Afficher le statut de synchronisation des images
                setTimeout(showImageSyncStatus, 600);
                
                // Enable focus capture after initialization is complete
                TimerManager.setTimeout(() => {
                    isInitialLoad = false;
                    log(`✅ Initial load complete - focus capture now enabled`);
                    
                    // Ensure cursor restoration happens after all updates are complete
                    if (lastFocusInfo || lastCellPos) {
                        // Clean: Removed debug log
                        TimerManager.setTimeout(() => {
                            performCursorRestoration();
                        }, 100);
                    }
                }, 1000);
                
                // Add click outside handler for calendar dropdown
                document.addEventListener('click', (e) => {
                    const calendarBtn = document.getElementById('snapshot-calendar-btn');
                    const calendarDropdown = document.getElementById('snapshot-calendar-dropdown');
                    
                    if (calendarDropdown && !calendarDropdown.classList.contains('hidden')) {
                        if (!calendarBtn?.contains(e.target) && !calendarDropdown?.contains(e.target)) {
                            calendarDropdown.classList.add('hidden');
                        }
                    }
                });
            } else {
                document.getElementById('login-container').classList.remove('hidden');
            }
            

        }
        

        

        

        

        

        
        function displayPatientImages(patientName) {
            const gallery = document.getElementById('image-gallery');
            const images = patientImages[patientName] || [];
            
            gallery.innerHTML = '';
            
            if (images.length === 0) {
                gallery.innerHTML = '<p class="text-gray-500 text-center col-span-full">Aucune image pour ce patient</p>';
                return;
            }
            
            images.forEach((image, index) => {
                const imageDiv = document.createElement('div');
                imageDiv.className = 'relative group';
                
                imageDiv.innerHTML = `
                    <img src="${image.data}" alt="${image.name}" class="w-full h-24 object-cover rounded-lg cursor-pointer hover:opacity-80 transition-opacity" 
                         onclick="viewImage('${patientName}', ${index})"
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
                    <div class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs cursor-pointer hover:bg-red-600 opacity-0 group-hover:opacity-100 transition-opacity"
                         onclick="deleteImage('${patientName}', ${index})">×</div>
                    <p class="text-xs text-gray-600 mt-1 truncate">${image.name}</p>
                    <div class="hidden text-xs text-gray-400 text-center mt-2">Image corrompue</div>
                `;
                
                gallery.appendChild(imageDiv);
            });
        }
        
        function viewImage(patientName, imageIndex) {
            const images = patientImages[patientName] || [];
            if (images.length === 0) return;
            
            currentPatientImages = images;
            currentImageIndex = imageIndex;
            
            const modal = document.getElementById('image-viewer-modal');
            const currentImage = document.getElementById('current-image');
            const counter = document.getElementById('image-counter');
            
            currentImage.src = images[imageIndex].data;
            currentImage.onerror = () => {
                showMessage('Erreur lors du chargement de l\'image', 'error');
                currentImage.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzY2NzM4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vbiB0cm91dsOpZTwvdGV4dD48L3N2Zz4=';
            };
            counter.textContent = `${imageIndex + 1} / ${images.length}`;
            
            modal.classList.remove('hidden');
        }
        
        function closeImageViewer() {
            document.getElementById('image-viewer-modal').classList.add('hidden');
        }
        
        function nextImage() {
            if (currentPatientImages.length === 0) return;
            currentImageIndex = (currentImageIndex + 1) % currentPatientImages.length;
            updateImageViewer();
        }
        
        function previousImage() {
            if (currentPatientImages.length === 0) return;
            currentImageIndex = currentImageIndex === 0 ? currentPatientImages.length - 1 : currentImageIndex - 1;
            updateImageViewer();
        }
        
        function updateImageViewer() {
            const currentImage = document.getElementById('current-image');
            const counter = document.getElementById('image-counter');
            
            currentImage.src = currentPatientImages[currentImageIndex].data;
            currentImage.onerror = () => {
                showMessage('Erreur lors du chargement de l\'image', 'error');
                currentImage.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzY2NzM4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vbiB0cm91dsOpZTwvdGV4dD48L3N2Zz4=';
            };
            counter.textContent = `${currentImageIndex + 1} / ${currentPatientImages.length}`;
        }
        
        async function deleteImage(patientName, imageIndex) {
            try {
                // Vérifier que l'image existe
                if (!patientImages[patientName] || !patientImages[patientName][imageIndex]) {
                    showMessage('Image non trouvée', 'error');
                    return;
                }

                // Demander confirmation
                if (!confirm(`Voulez-vous vraiment supprimer cette image ?`)) {
                    return;
                }

                const imageToDelete = patientImages[patientName][imageIndex];
                
                // Supprimer de Supabase si l'image a un ID
                if (imageToDelete.id) {
                    try {
                        const { error } = await supabase
                            .from('gallery_images')
                            .delete()
                            .eq('id', imageToDelete.id);
                        
                        if (error) {
                            console.error('Erreur lors de la suppression depuis Supabase:', error);
                            showMessage('Erreur lors de la suppression depuis le serveur', 'error');
                            return;
                        }
                    } catch (supabaseError) {
                        console.error('Erreur de connexion Supabase:', supabaseError);
                        showMessage('Erreur de connexion au serveur', 'error');
                        return;
                    }
                }

                // Supprimer du stockage local
                patientImages[patientName].splice(imageIndex, 1);
                
                // Si c'était la dernière image du patient, supprimer l'entrée du patient
                if (patientImages[patientName].length === 0) {
                    delete patientImages[patientName];
                }
                
                // Sauvegarder les changements
                savePatientImages();
                
                // Mettre à jour l'affichage
                displayPatientImages(patientName);
                updateAllImageColumnIcons(true); // Éviter les sauvegardes automatiques
                
                // Réinitialiser les indicateurs de modification pour éviter l'autosave
                isDirty = false;
                lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // Désactiver l'autosave
                
                // Fermer le visualiseur si c'était la dernière image
                if (!patientImages[patientName] || patientImages[patientName].length === 0) {
                    closeImageViewer();
                }
                
                showMessage('Image supprimée avec succès', 'success');
                
            } catch (error) {
                console.error('Erreur lors de la suppression de l\'image:', error);
                showMessage('Erreur lors de la suppression de l\'image', 'error');
            }
                }

        // Fonction pour supprimer toutes les images d'un patient
        async function deleteAllImagesForPatient(patientName) {
            try {
                if (!patientImages[patientName] || patientImages[patientName].length === 0) {
                    showMessage('Aucune image à supprimer pour ce patient', 'info');
                    return;
                }

                const imageCount = patientImages[patientName].length;
                
                // Supprimer toutes les images de Supabase
                for (const image of patientImages[patientName]) {
                    if (image.id) {
                        try {
                            const { error } = await supabase
                                .from('gallery_images')
                                .delete()
                                .eq('id', image.id);
                            
                            if (error) {
                                console.error('Erreur lors de la suppression de l\'image depuis Supabase:', error);
                            }
                        } catch (supabaseError) {
                            console.error('Erreur de connexion Supabase:', supabaseError);
                        }
                    }
                }

                // Supprimer du stockage local
                delete patientImages[patientName];
                savePatientImages();
                
                // Mettre à jour l'affichage
                updateAllImageColumnIcons(true); // Éviter les sauvegardes automatiques
                
                // Réinitialiser les indicateurs de modification pour éviter l'autosave
                isDirty = false;
                lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // Désactiver l'autosave
                
                // Fermer le visualiseur si il était ouvert pour ce patient
                if (currentPatientImages && currentPatientImages.length > 0) {
                    const firstImage = currentPatientImages[0];
                    if (firstImage.patientName === patientName) {
                        closeImageViewer();
                    }
                }
                
                showMessage(`${imageCount} image(s) supprimée(s) pour ${patientName}`, 'success');
                
            } catch (error) {
                console.error('Erreur lors de la suppression de toutes les images:', error);
                showMessage('Erreur lors de la suppression des images', 'error');
            }
        }

        async function syncImageToSupabase(imageData) {
            try {
                // Créer une entrée dans la table des images
                const { error } = await supabase
                    .from('gallery_images')
                    .upsert({
                        id: imageData.id,
                        patient_name: imageData.patientName,
                        image_name: imageData.name,
                        image_data: imageData.data,
                        image_type: imageData.type,
                        image_size: imageData.size,
                        upload_date: imageData.uploadDate,
                        last_sync: new Date().toISOString()
                    });
                
                if (error) {
                    console.error('Erreur Supabase:', error);
                    // Stocker pour synchronisation ultérieure
                    storeImageForLaterSync(imageData);
                }
            } catch (error) {
                console.error('Erreur de synchronisation:', error);
                // Stocker pour synchronisation ultérieure
                storeImageForLaterSync(imageData);
            }
        }
        
        function storeImageForLaterSync(imageData) {
            let pendingImages = JSON.parse(localStorage.getItem('pendingImageSync') || '[]');
            pendingImages.push(imageData);
            localStorage.setItem('pendingImageSync', JSON.stringify(pendingImages));
        }
        
        async function syncPendingImages() {
            try {
                let pendingImages = JSON.parse(localStorage.getItem('pendingImageSync') || '[]');
                if (pendingImages.length === 0) return;
                
                for (const imageData of pendingImages) {
                    await syncImageToSupabase(imageData);
                }
                
                // Vider la liste des images en attente
                localStorage.removeItem('pendingImageSync');
                
                // Mettre à jour les icônes de la colonne Images
                updateAllImageColumnIcons(true); // Éviter les sauvegardes automatiques
                
                // Réinitialiser les indicateurs de modification pour éviter l'autosave
                isDirty = false;
                lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // Désactiver l'autosave
                
                showMessage('Images synchronisées avec le serveur', 'success');
            } catch (error) {
                console.error('Erreur lors de la synchronisation des images en attente:', error);
            }
        }
        
        function savePatientImages() {
            try {
                localStorage.setItem('patientImages', JSON.stringify(patientImages));
            } catch (e) {
                console.error('Erreur lors de la sauvegarde des images:', e);
            }
        }
        
        // Fonction pour afficher les images au clic sur le nom du patient
        function setupPatientImageClick() {
            const tbody = document.getElementById('table-body');
            if (!tbody) return;
            
            tbody.addEventListener('click', function(e) {
                const nameCell = e.target.closest('td:nth-child(6)'); // Colonne Nom_Prénom
                if (nameCell && nameCell.textContent.trim()) {
                    const patientName = nameCell.textContent.trim();
                    const images = patientImages[patientName] || [];
                    
                    if (images.length > 0) {
                        // Ouvrir directement le visualiseur d'images
                        currentPatientImages = images;
                        currentImageIndex = 0;
                        viewImage(patientName, 0);
                    } else {
                        // Aucune image pour ce patient - afficher un message
                        showMessage('Aucune image pour ce patient. Utilisez le bouton ➕ dans la colonne Images pour ajouter des images.', 'info');
                    }
                }
            });
        }
        
        // Fonction pour afficher le statut de synchronisation des images
        function showImageSyncStatus() {
            const pendingImages = JSON.parse(localStorage.getItem('pendingImageSync') || '[]');
            if (pendingImages.length > 0) {
                showMessage(`${pendingImages.length} image(s) en attente de synchronisation`, 'warning');
            }
        }
        
        // Fonction pour mettre à jour les indicateurs d'images (maintenant uniquement dans la colonne Images)
        function updateImageIndicators() {
            // Cette fonction est maintenant remplacée par updateAllImageColumnIcons
            // qui met à jour uniquement les icônes dans la colonne Images
            updateAllImageColumnIcons();
        }
        
        // Fonction pour charger les images depuis Supabase
        async function loadImagesFromSupabase() {
            // Skip if cursor restoration is in progress to avoid conflicts
            if (isRestoringFocus) {
                log('🔄 loadImagesFromSupabase skipped - cursor restoration in progress');
                return;
            }
            
            try {
                const { data, error } = await supabase
                    .from('gallery_images')
                    .select('*')
                    .order('upload_date', { ascending: false });
                
                if (error) {
                    console.error('Erreur lors du chargement des images:', error);
                    
                    // Handle specific error types
                    if (error.code === 'PGRST301' || error.message?.includes('401')) {
                        console.warn('🔒 Gallery images: Authentication required or insufficient permissions');
                        // Don't show error to user as this might be expected behavior
                    } else if (error.code === 'PGRST116') {
                        console.warn('🚫 Gallery images: Table not accessible or doesn\'t exist');
                    } else {
                        console.error('💥 Gallery images: Unexpected error:', error.message);
                    }
                    
                    return;
                }
                
                if (data && data.length > 0) {
                    // Réorganiser les images par patient
                    const newPatientImages = {};
                    data.forEach(image => {
                        if (!newPatientImages[image.patient_name]) {
                            newPatientImages[image.patient_name] = [];
                        }
                        newPatientImages[image.patient_name].push({
                            id: image.id,
                            name: image.image_name,
                            data: image.image_data,
                            type: image.image_type,
                            size: image.image_size,
                            uploadDate: image.upload_date,
                            patientName: image.patient_name
                        });
                    });
                    
                    // Mettre à jour les images locales
                    patientImages = { ...patientImages, ...newPatientImages };
                    savePatientImages();
                    
                    // Synchroniser les images en attente
                    await syncPendingImages();
                    
                    // Mettre à jour les icônes de la colonne Images
                    updateAllImageColumnIcons(true); // Éviter les sauvegardes automatiques
                    
                    // Réinitialiser les indicateurs de modification pour éviter l'autosave
                    isDirty = false;
                    lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // Désactiver l'autosave
                    
                    showMessage(`${data.length} image(s) chargée(s) depuis le serveur`, 'success');
                }
            } catch (error) {
                console.error('Erreur lors du chargement des images:', error);
            }
        }

        // Fonction pour mettre à jour toutes les icônes de la colonne Images
        function updateAllImageColumnIcons(skipAutoSave = false) {
            const tbody = document.getElementById('table-body');
            if (!tbody) return;
            
            // Skip if cursor restoration is in progress to avoid conflicts
            if (isRestoringFocus) {
                log('🔄 updateAllImageColumnIcons skipped - cursor restoration in progress');
                return;
            }
            
            Array.from(tbody.querySelectorAll('tr')).forEach(row => {
                const imageCell = row.querySelector('[data-label="Images"]');
                if (imageCell) {
                    const mainButton = imageCell.querySelector('button:first-child');
                    const trashButton = imageCell.querySelector('button:last-child');
                    const container = imageCell.querySelector('div');
                    
                    if (mainButton && trashButton && container) {
                        const nameCell = row.querySelector('[data-label="Nom_Prénom"]');
                        if (nameCell) {
                            const patientName = nameCell.textContent.trim();
                            

                            
                            // Vérifier si l'état actuel correspond à l'état souhaité pour éviter les modifications inutiles
                            const hasImages = patientName && patientImages[patientName] && patientImages[patientName].length > 0;
                            const currentHasImages = mainButton.innerHTML === '📷';
                            
                            // Ne mettre à jour que si l'état a changé
                            if (hasImages !== currentHasImages) {
                                if (hasImages) {
                                    // Il y a des photos - afficher le bouton caméra et la poubelle
                                    mainButton.innerHTML = '📷';
                                    mainButton.title = `${patientImages[patientName].length} image(s) - Cliquez pour voir`;
                                    mainButton.onclick = (e) => {
                                        e.stopPropagation();
                                        viewImage(patientName, 0);
                                    };
                                    mainButton.className = 'p-1 rounded-full hover:bg-gray-200 transition-colors text-blue-500';
                                    
                                    // Afficher la poubelle
                                    trashButton.style.opacity = '1';
                                    trashButton.onclick = (e) => {
                                        e.stopPropagation();
                                        if (confirm(`Voulez-vous vraiment supprimer toutes les images de ${patientName} ?`)) {
                                            deleteAllImagesForPatient(patientName);
                                        }
                                    };
                                    
                                    // Ajouter un bouton + pour ajouter plus d'images (seulement s'il n'existe pas déjà)
                                    let addMoreButton = container.querySelector('.add-more-button');
                                    if (!addMoreButton) {
                                        addMoreButton = document.createElement('button');
                                        addMoreButton.innerHTML = '➕';
                                        addMoreButton.className = 'add-more-button p-1 rounded-full hover:bg-green-200 transition-colors text-green-600 ml-1';
                                        addMoreButton.title = 'Ajouter plus d\'images pour ce patient';
                                        addMoreButton.onclick = (e) => {
                                            e.stopPropagation();
                                            const fileInput = imageCell.querySelector('input[type="file"]');
                                            if (fileInput) fileInput.click();
                                        };
                                        container.appendChild(addMoreButton);
                                    }
                                    
                                } else {
                                // Pas de photos - afficher le bouton ajouter et cacher la poubelle
                                mainButton.innerHTML = '➕';
                                mainButton.title = 'Ajouter des images pour ce patient';
                                mainButton.onclick = (e) => {
                                    e.stopPropagation();
                                    const fileInput = imageCell.querySelector('input[type="file"]');
                                    if (fileInput) fileInput.click();
                                };
                                mainButton.className = 'p-1 rounded-full hover:bg-green-200 transition-colors text-green-600';
                                
                                    // Cacher la poubelle
                                    trashButton.style.opacity = '0';
                                    trashButton.onclick = null;
                                    
                                    // Supprimer le bouton + s'il existe
                                    const addMoreButton = container.querySelector('.add-more-button');
                                    if (addMoreButton) {
                                        addMoreButton.remove();
                                    }
                                }
                            } else if (hasImages) {
                                // Mettre à jour seulement le titre si le nombre d'images a changé
                                const currentTitle = mainButton.title;
                                const newTitle = `${patientImages[patientName].length} image(s) - Cliquez pour voir`;
                                if (currentTitle !== newTitle) {
                                    mainButton.title = newTitle;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Make functions globally available
        window.checkPassword = checkPassword;
        window.syncToMaster = syncToMaster;
        window.addRow = addRow;
        window.saveManually = saveManually;
        window.undo = undo;
        window.redo = redo;
        window.trackCellEdit = trackCellEdit;
        window.getColumnLabelForCell = getColumnLabelForCell;
        window.isUndoRedoInProgress = isUndoRedoInProgress;
        window.getUndoRedoStatus = getUndoRedoStatus;
        window.downloadExcel = downloadExcel;
        window.downloadPDF = downloadPDF;
        window.downloadImage = downloadImage;
        window.importExcelFromFile = importExcelFromFile;
        window.zoomIn = zoomIn;
        window.zoomOut = zoomOut;
        window.zoomReset = zoomReset;
        window.clearAllRowColors = clearAllRowColors;
        window.cyclePaintMode = cyclePaintMode;
        window.toggleColoredFilter = toggleColoredFilter;
        window.toggleViewMode = toggleViewMode;
        
        // Expose history bar toggle functions
        window.toggleHistoryBarSimple = toggleHistoryBarSimple;

        window.viewImage = viewImage;
        
        // Expose snapshot system functions
        window.loadAvailableSnapshots = loadAvailableSnapshots;
        window.enterSnapshotMode = enterSnapshotMode;
        window.enterSnapshotModeByUniqueId = enterSnapshotModeByUniqueId;
        window.returnToToday = returnToToday; // Use the existing function instead
        window.goToPreviousSnapshot = goToPreviousSnapshot;
        window.goToNextSnapshot = goToNextSnapshot;
        window.refreshTableData = refreshTableData;
        window.toggleSnapshotCalendar = toggleSnapshotCalendar;
        window.showMonthSnapshots = showMonthSnapshots;
        window.populateSnapshotCalendar = populateSnapshotCalendar;
        window.openDatePicker = openDatePicker;
        window.formatDateForDisplay = formatDateForDisplay;
        window.disableTableEditing = disableTableEditing;
        window.createManualSnapshot = createManualSnapshot;
        
        // Add debug wrapper to window
        window.debugManualSnapshot = async function() {
            try {
                console.log('🚀 DEBUG: Manual Snapshot Button Clicked!');
                console.log('🎯 About to call createManualSnapshot...');
                
                await createManualSnapshot();
                console.log('✅ DEBUG: createManualSnapshot completed');
                
            } catch (error) {
                console.error('❌ DEBUG ERROR:', error);
            }
        };
        
        // Add DOM extraction helper to window
        window.extractDOMTableData = function() {
            const table = document.getElementById('data-table');
            if (!table) return null;
            
            const tbody = table.querySelector('tbody');
            if (!tbody) return null;
            
            const headerRow = table.querySelector('thead tr');
            const headers = Array.from(headerRow?.querySelectorAll('th') || []).map(th => 
                th.textContent.trim()
            );
            
            const rows = tbody.querySelectorAll('tr');
            const data = [];
            
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                const rowData = {};
                
                cells.forEach((cell, index) => {
                    if (headers[index]) {
                        const input = cell.querySelector('input, textarea, select');
                        let value = input ? input.value : cell.textContent.trim();
                        
                        // Convert numbers
                        if (!isNaN(value) && value !== '' && !isNaN(parseFloat(value))) {
                            value = parseFloat(value);
                        }
                        
                        rowData[headers[index]] = value;
                    }
                });
                
                if (Object.keys(rowData).length > 0) {
                    data.push(rowData);
                }
            });
            
            return data;
        };
        
        // Expose storage management functions globally
        window.cleanupOldSnapshots = cleanupOldSnapshots;
        window.checkStorageCapacity = checkStorageCapacity;
        window.monitorStorageHealth = monitorStorageHealth;
        window.forceStorageCleanup = forceStorageCleanup;
        window.calculateOptimalSnapshotCount = calculateOptimalSnapshotCount;
        window.deleteSnapshot = deleteSnapshot;
        
        // Timer cleanup function to prevent infinite loops
        function cleanupAllTimers() {
            try {
                if (autosaveTicker) {
                    clearInterval(autosaveTicker);
                    autosaveTicker = null;
                }
                if (window._syncTimer) {
                    clearInterval(window._syncTimer);
                    window._syncTimer = null;
                }
                if (window._msgTimer) {
                    clearTimeout(window._msgTimer);
                    window._msgTimer = null;
                }
                if (cellEditTimeout) {
                    clearTimeout(cellEditTimeout);
                    cellEditTimeout = null;
                }
                if (undoRedoSyncTimeout) {
                    clearTimeout(undoRedoSyncTimeout);
                    undoRedoSyncTimeout = null;
                }
                if (historyDebounceTimeout) {
                    clearTimeout(historyDebounceTimeout);
                    historyDebounceTimeout = null;
                }
                if (typingTimer) {
                    clearTimeout(typingTimer);
                    typingTimer = null;
                }
                if (operationTimeout) {
                    clearTimeout(operationTimeout);
                    operationTimeout = null;
                }
                
                console.log('🧹 All timers cleaned up successfully');
            } catch (error) {
                console.error('❌ Error cleaning up timers:', error);
            }
        }
        
        // Enhanced conflict detection and prevention system
        function detectAndPreventConflicts() {
            const conflicts = [];
            
            // Check for autosave conflicts
            if (autosaveTicker && isPerformingUndoRedo) {
                conflicts.push('AUTOSAVE_UNDO_REDO_CONFLICT');
            }
            
            // Check for realtime conflicts
            if (realtimeSubscription && isPerformingUndoRedo) {
                conflicts.push('REALTIME_UNDO_REDO_CONFLICT');
            }
            
            // Check for sync conflicts
            if (window._syncTimer && isPerformingUndoRedo) {
                conflicts.push('SYNC_UNDO_REDO_CONFLICT');
            }
            
            // Check for timer conflicts
            if (autosaveTicker && window._syncTimer) {
                const autosaveInterval = 1000; // 1000ms from scheduleAutosaveCountdown
                const syncInterval = 500; // 500ms from startPeriodicSync
                
                if (syncInterval % autosaveInterval === 0) {
                    conflicts.push('TIMER_INTERVAL_CONFLICT');
                }
            }
            
            return conflicts;
        }
        
        // Enhanced autosave with conflict prevention
        function scheduleAutosaveCountdownEnhanced() {
            try {
                // Cleanup existing timer
                if (autosaveTicker) {
                    clearInterval(autosaveTicker);
                    autosaveTicker = null;
                }
                
                // Check for conflicts before starting
                const conflicts = detectAndPreventConflicts();
                if (conflicts.length > 0) {
                    console.warn('⚠️ Autosave conflicts detected:', conflicts);
                    return;
                }
                
                lastShownCountdown = null;
                autosaveTicker = setInterval(() => {
                    try {
                        // Enhanced conflict prevention
                        if (isSyncing || isPerformingUndoRedo) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        const modal = document.getElementById('confirmation-modal');
                        if (modal && !modal.classList.contains('hidden')) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        if (isTyping) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        // Check suppression windows
                        if (Date.now() < suppressAutosaveUntil) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        // Check pending operations
                        if (currentOperation && currentOperation.type) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        const remaining = AUTOSAVE_DELAY_MS - (Date.now() - lastEditAt);
                        if (remaining > 0) {
                            const secs = Math.ceil(remaining / 1000);
                            // Only show countdown for last 3 seconds to reduce flickering
                            if (secs <= 3 && secs !== lastShownCountdown) {
                                showMessage(`Sauvegarde dans ${secs} s`, 'info');
                                lastShownCountdown = secs;
                            }
                        } else {
                            if (lastShownCountdown !== 0) {
                                showMessage('Sauvegarde imminente…', 'info');
                                lastShownCountdown = 0;
                            }
                        }
                    } catch (error) {
                        console.error('❌ Error in autosave ticker:', error);
                    }
                }, 1000); // Reduced from 250ms to 1s to prevent flickering
                
                console.log('✅ Enhanced autosave scheduled successfully');
            } catch (error) {
                console.error('❌ Error scheduling enhanced autosave:', error);
            }
        }
        
        // Enhanced periodic sync with conflict prevention
        function startPeriodicSyncEnhanced() {
            try {
                // Cleanup existing timer
                if (window._syncTimer) {
                    clearInterval(window._syncTimer);
                    window._syncTimer = null;
                }
                
                // Check for conflicts before starting
                const conflicts = detectAndPreventConflicts();
                if (conflicts.length > 0) {
                    console.warn('⚠️ Sync conflicts detected:', conflicts);
                    return;
                }
                
                window._syncTimer = setInterval(async () => {
                    try {
                        // Enhanced conflict prevention
                        if (isTyping || isPerformingUndoRedo) {
                            return;
                        }
                        
                        if (Date.now() - lastEditAt < AUTOSAVE_DELAY_MS) {
                            return;
                        }
                        
                        const modal = document.getElementById('confirmation-modal');
                        if (modal && !modal.classList.contains('hidden')) {
                            return;
                        }
                        
                        if (isSyncing || !isDirty) {
                            return;
                        }
                        
                        // Check suppression windows
                        if (Date.now() < suppressAutosaveUntil) {
                            return;
                        }
                        
                        // Check pending operations
                        if (currentOperation && currentOperation.type) {
                            return;
                        }
                        
                        isSyncing = true;
                        log('Auto-sync (500ms poll, 3s idle) vers Supabase…');
                        await syncToMaster(false);
                    } catch (error) {
                        console.error('❌ Error in periodic sync:', error);
                    } finally {
                        isSyncing = false;
                    }
                }, 500);
                
                console.log('✅ Enhanced periodic sync started successfully');
            } catch (error) {
                console.error('❌ Error starting enhanced periodic sync:', error);
            }
        }
        
        // Expose timer cleanup function globally
        window.cleanupAllTimers = cleanupAllTimers;
        
        // Expose conflict detection and prevention functions globally
        window.detectAndPreventConflicts = detectAndPreventConflicts;
        window.scheduleAutosaveCountdownEnhanced = scheduleAutosaveCountdownEnhanced;
        window.startPeriodicSyncEnhanced = startPeriodicSyncEnhanced;
        
        // Function to test and report all potential conflicts
        window.testSystemConflicts = function() {
            try {
                console.log('🔍 Testing system for potential conflicts...');
                
                // Test timer conflicts
                const timerConflicts = detectAndPreventConflicts();
                if (timerConflicts.length > 0) {
                    console.warn('⚠️ Timer conflicts detected:', timerConflicts);
                } else {
                    console.log('✅ No timer conflicts detected');
                }
                
                // Test autosave state
                console.log('📊 Autosave state:', {
                    autosaveTicker: !!autosaveTicker,
                    isPerformingUndoRedo,
                    suppressAutosaveUntil: Date.now() < suppressAutosaveUntil,
                    currentOperation: !!currentOperation
                });
                
                // Test sync state
                console.log('📊 Sync state:', {
                    syncTimer: !!window._syncTimer,
                    isSyncing,
                    isDirty,
                    lastEditAt: new Date(lastEditAt).toLocaleTimeString()
                });
                
                // Test realtime state
                console.log('📊 Realtime state:', {
                    realtimeSubscription: !!realtimeSubscription,
                    suppressRealtimeUntil: Date.now() < suppressRealtimeUntil
                });
                
                // Test undo/redo state
                console.log('📊 Undo/Redo state:', {
                    operationHistoryLength: operationHistory.length,
                    redoHistoryLength: redoHistory.length,
                    isPerformingUndoRedo
                });
                
                console.log('✅ System conflict test completed');
                return {
                    timerConflicts,
                    autosaveState: { autosaveTicker: !!autosaveTicker, isPerformingUndoRedo, suppressAutosaveUntil: Date.now() < suppressAutosaveUntil, currentOperation: !!currentOperation },
                    syncState: { syncTimer: !!window._syncTimer, isSyncing, isDirty, lastEditAt: new Date(lastEditAt).toLocaleTimeString() },
                    realtimeState: { realtimeSubscription: !!realtimeSubscription, suppressRealtimeUntil: Date.now() < suppressRealtimeUntil },
                    undoRedoState: { operationHistoryLength: operationHistory.length, redoHistoryLength: redoHistory.length, isPerformingUndoRedo }
                };
                
            } catch (error) {
                console.error('❌ Error testing system conflicts:', error);
                return null;
            }
        };
        
        // Function to test keyboard shortcuts
        window.testKeyboardShortcuts = function() {
            try {
                console.log('⌨️ Testing keyboard shortcuts...');
                
                // Test manual save shortcuts
                console.log('💾 Manual save shortcuts:');
                console.log('   - Cmd+Z (Mac) / Ctrl+Z (Windows/Linux)');
                console.log('   - Cmd+S (Mac) / Ctrl+S (Windows/Linux)');
                console.log('✅ Both shortcuts should trigger saveManually() function');
                
                // Test undo shortcut
                console.log('↩️ Undo shortcut: Cmd+Y (Mac) / Ctrl+Y (Windows/Linux)');
                console.log('✅ Shortcut should trigger undo() function');
                
                // Test other shortcuts
                console.log('⌨️ Other shortcuts:');
                console.log('   - Enter: Add new row');
                console.log('   - Ctrl+D: Delete selected row');
                console.log('   - Arrow keys: Navigate between cells');
                
                console.log('✅ Keyboard shortcuts test completed');
                return {
                    manualSave: ['Cmd+Z (Mac) / Ctrl+Z (Windows/Linux)', 'Cmd+S (Mac) / Ctrl+S (Windows/Linux)'],
                    undo: 'Cmd+Y (Mac) / Ctrl+Y (Windows/Linux)',
                    addRow: 'Enter',
                    deleteRow: 'Ctrl+D',
                    navigation: 'Arrow keys'
                };
                
            } catch (error) {
                console.error('❌ Error testing keyboard shortcuts:', error);
                return null;
            }
        };
        
        // Function to show keyboard shortcuts help
        window.showKeyboardShortcutsHelp = function() {
            try {
                const shortcuts = [
                    { key: 'Cmd+Z / Ctrl+Z', action: 'Sauvegarde manuelle', description: 'Équivalent au clic sur le bouton Sauvegarder' },
                    { key: 'Cmd+S / Ctrl+S', action: 'Sauvegarde manuelle', description: 'Alternative pour la sauvegarde manuelle' },
                    { key: 'Cmd+Y / Ctrl+Y', action: 'Annuler', description: 'Annuler la dernière action (équivalent au bouton Annuler)' },
                    { key: 'Enter', action: 'Nouvelle ligne', description: 'Ajouter une nouvelle ligne au tableau' },
                    { key: 'Ctrl+D', action: 'Supprimer ligne', description: 'Supprimer la ligne sélectionnée' },
                    { key: 'Flèches', action: 'Navigation', description: 'Se déplacer entre les cellules' }
                ];
                
                let helpText = '⌨️ Raccourcis clavier disponibles:\n\n';
                shortcuts.forEach(shortcut => {
                    helpText += `🔸 ${shortcut.key}: ${shortcut.action}\n   ${shortcut.description}\n\n`;
                });
                
                console.log(helpText);
                showMessage('Raccourcis clavier affichés dans la console', 'info');
                
                return shortcuts;
                
            } catch (error) {
                console.error('❌ Error showing keyboard shortcuts help:', error);
                return null;
            }
        };
        
        // Function to test mobile history bar functionality
        window.testMobileHistoryBar = function() {
            try {
                console.log('📱 Testing mobile history bar functionality...');
                
                // Check if we're on mobile
                const isMobileDevice = isMobile();
                console.log('📱 Is mobile device:', isMobileDevice);
                
                // Check required elements
                const toggleBtn = document.getElementById('history-toggle-btn');
                const historyBarContainer = document.getElementById('history-bar-container');
                const toggleIcon = document.getElementById('history-toggle-icon');
                
                console.log('🔍 Elements found:');
                console.log('  - Toggle button:', !!toggleBtn);
                console.log('  - History bar container:', !!historyBarContainer);
                console.log('  - Toggle icon:', !!toggleIcon);
                
                if (toggleBtn && historyBarContainer && toggleIcon) {
                    // Test current state
                    const isVisible = !historyBarContainer.classList.contains('hidden') && 
                                    historyBarContainer.style.display !== 'none' && 
                                    historyBarContainer.offsetHeight > 0;
                    
                    console.log('📊 Current state:', isVisible ? 'Visible' : 'Hidden');
                    console.log('🔍 CSS classes:', historyBarContainer.className);
                    console.log('🔍 Inline styles:', historyBarContainer.style.display);
                    console.log('🔍 Offset height:', historyBarContainer.offsetHeight);
                    
                    // Test toggle functionality
                    console.log('🧪 Testing toggle function...');
                    toggleHistoryBarSimple();
                    
                    // Check new state after toggle
                    TimerManager.setTimeout(() => {
                        const newState = !historyBarContainer.classList.contains('hidden') && 
                                       historyBarContainer.style.display !== 'none' && 
                                       historyBarContainer.offsetHeight > 0;
                        
                        console.log('📊 New state after toggle:', newState ? 'Visible' : 'Hidden');
                        console.log('✅ Toggle test completed');
                    }, 100);
                    
                } else {
                    console.error('❌ Required elements not found for testing');
                }
                
                return {
                    isMobile: isMobileDevice,
                    elementsFound: {
                        toggleBtn: !!toggleBtn,
                        historyBarContainer: !!historyBarContainer,
                        toggleIcon: !!toggleIcon
                    }
                };
                
            } catch (error) {
                console.error('❌ Error testing mobile history bar:', error);
                return null;
            }
        };
        
        // Fonction utilitaire pour afficher les informations détaillées du stockage
        window.showStorageInfo = async function() {
            try {
                const capacityInfo = await checkStorageCapacity();
                const info = `
📊 INFORMATIONS DÉTAILLÉES DU STOCKAGE :

🔢 Nombre de snapshots : ${capacityInfo.count}
💾 Espace utilisé : ${(capacityInfo.currentSize / 1024 / 1024).toFixed(2)} MB
📦 Capacité totale : ${(capacityInfo.maxSize / 1024 / 1024).toFixed(0)} MB
📈 Pourcentage utilisé : ${capacityInfo.usagePercentage.toFixed(1)}%

${capacityInfo.needsCleanup ? 
    `⚠️ NETTOYAGE RECOMMANDÉ : Garder ${capacityInfo.target} snapshots pour libérer de l'espace` : 
    `✅ Stockage en bon état - Aucun nettoyage nécessaire`
}

🧹 Fonctions disponibles :
- window.forceStorageCleanup() : Nettoyage manuel
- window.monitorStorageHealth() : Vérification de santé
- window.checkStorageCapacity() : Vérification de capacité
                `;
                
                console.log(info);
                if (typeof showMessage === 'function') {
                    showMessage('📊 Informations du stockage affichées dans la console', 'info');
                }
                
            } catch (error) {
                console.error('❌ Error showing storage info:', error);
            }
        };
        window.enableTableEditing = enableTableEditing;
        window.updateHistoryNavigation = updateHistoryNavigation;
        window.updateSnapshotBanner = updateSnapshotBanner;
        window.updateHistoryDateButton = updateHistoryDateButton;
        window.fetchInitialData = fetchInitialData;
        window.handleRealtimeUpdate = handleRealtimeUpdate;
        window.forceImmediateSync = forceImmediateSync; // Force immediate sync across all devices
        window.scheduleDelayedSync = scheduleDelayedSync; // Schedule delayed sync (5 seconds)
        window.cancelDelayedSync = cancelDelayedSync; // Cancel delayed sync
        window.startTimestampSync = startTimestampSync; // Start timestamp-based sync
        window.stopTimestampSync = stopTimestampSync; // Stop timestamp-based sync
        window.markEdited = markEdited;
        
        // Debug function to check realtime sync status
        window.debugRealtimeSync = function() {
            console.log('🔍 [DEBUG] Realtime Sync Status:');
            console.log('  - realtimeSubscription:', !!realtimeSubscription);
            console.log('  - isRealtimeEnabled:', isRealtimeEnabled);
            console.log('  - realtimeRetryCount:', realtimeRetryCount);
            console.log('  - MAX_RETRY_ATTEMPTS:', MAX_RETRY_ATTEMPTS);
            console.log('  - fallbackMode:', fallbackMode);
            console.log('  - isFallbackSaveActive:', isFallbackSaveActive);
            console.log('  - isTimestampSyncActive:', isTimestampSyncActive);
            console.log('  - lastSyncTimestamp:', lastSyncTimestamp ? new Date(lastSyncTimestamp).toISOString() : 'null');
            console.log('  - supabase client:', !!supabase);
            console.log('  - current URL:', window.location.href);
            console.log('  - user agent:', navigator.userAgent.substring(0, 100));
            
            if (realtimeSubscription) {
                console.log('  - subscription state:', realtimeSubscription.state);
                console.log('  - subscription topic:', realtimeSubscription.topic);
            }
            
            return {
                realtimeSubscription: !!realtimeSubscription,
                isRealtimeEnabled,
                realtimeRetryCount,
                fallbackMode,
                isFallbackSaveActive,
                isTimestampSyncActive,
                lastSyncTimestamp: lastSyncTimestamp ? new Date(lastSyncTimestamp).toISOString() : null,
                supabaseClient: !!supabase,
                url: window.location.href
            };
        };
        
        // Function to force reset realtime sync
        window.resetRealtimeSync = function() {
            console.log('🔄 [RESET] Forcing realtime sync reset...');
            
            // Clean up existing subscription
            if (realtimeSubscription) {
                console.log('🔄 [RESET] Removing existing subscription...');
                supabase.removeChannel(realtimeSubscription);
                realtimeSubscription = null;
            }
            
            // Reset retry count
            realtimeRetryCount = 0;
            isRealtimeEnabled = true;
            fallbackMode = false;
            
            // Stop fallback save
            if (typeof stopFallbackSave === 'function') {
                stopFallbackSave();
            }
            
            // Wait a moment then setup new subscription
            setTimeout(() => {
                console.log('🔄 [RESET] Setting up new subscription...');
                setupRealtimeSubscription();
            }, 1000);
            
            console.log('✅ [RESET] Realtime sync reset completed');
        };
        
        window.updateGlobalFocusState = updateGlobalFocusState;
        window.saveModifiedCell = saveModifiedCell; // Excel-like save function
        window.isRestoringCursor = function() { return isRestoringCursor; }; // For debugging
        window.debugCursorRestoration = function() {
            console.log('🔍 ========== CURSOR RESTORATION DEBUG ==========');
            console.log('📊 Current State:');
            console.log('  - isRestoringCursor:', isRestoringCursor);
            console.log('  - isExcelSaveInProgress:', isExcelSaveInProgress);
            console.log('  - isDirty:', isDirty);
            console.log('  - isTyping:', isTyping);
            console.log('  - preventNextRestore:', window.cursorManager?.preventRestore);
            
            console.log('🎯 Focus State:');
            console.log('  - Current active element:', document.activeElement);
            console.log('  - Active element type:', document.activeElement?.tagName);
            console.log('  - Active element contentEditable:', document.activeElement?.contentEditable);
            console.log('  - capturedFocusState:', window.capturedFocusState);
            
            console.log('⏰ Timing:');
            const focusAge = window.capturedFocusState?.timestamp ? Date.now() - window.capturedFocusState.timestamp : null;
            console.log('  - Focus protection age:', focusAge ? `${focusAge}ms ago` : 'none');
            console.log('  - Focus is fresh (< 3s):', focusAge ? focusAge < 3000 : false);
            
            console.log('💾 Save State:');
            console.log('  - Last user edit time:', lastUserEditTime ? new Date(lastUserEditTime).toLocaleTimeString() : 'none');
            console.log('  - Time since last edit:', lastUserEditTime ? `${Date.now() - lastUserEditTime}ms` : 'none');
            
            console.log('🔄 Cursor Position Details:');
            if (window.capturedFocusState) {
                console.log('  - Captured element:', window.capturedFocusState.element);
                console.log('  - Captured position:', window.capturedFocusState.position);
                console.log('  - Element still in DOM:', window.capturedFocusState.element ? document.contains(window.capturedFocusState.element) : false);
            }
            
            console.log('🧪 Quick Tests:');
            const activeCell = document.activeElement;
            if (activeCell && activeCell.tagName === 'TD') {
                const selection = window.getSelection();
                const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
                console.log('  - Current selection:', selection.toString());
                console.log('  - Current caret position:', range ? range.startOffset : 'none');
            }
            
            return {
                isRestoringCursor,
                isExcelSaveInProgress,
                capturedFocusState: window.capturedFocusState,
                activeElement: document.activeElement,
                isDirty,
                isTyping,
                focusProtectionAge: focusAge,
                elementInDOM: window.capturedFocusState?.element ? document.contains(window.capturedFocusState.element) : null
            };
        };
        
        // Debug function to test realtime sync with cursor preservation
        window.testRealtimeWithCursor = function() {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.tagName === 'TD' && activeElement.contentEditable === 'true') {
                console.log('🧪 Testing realtime sync with cursor preservation...');
                
                // Simulate a realtime update by calling the handler directly
                TimerManager.setTimeout(() => {
                    console.log('🔄 Simulating realtime update...');
                    if (typeof window.handleRealtimeUpdate === 'function') {
                        window.handleRealtimeUpdate({
                            event: 'UPDATE',
                            table: 'staffTable',
                            record: { id: 'test' }
                        });
                    }
                }, 1000);
            } else {
                console.log('❌ Please select a cell first and place cursor in it');
            }
        };
        
        // Enhanced test function for cursor restoration
        window.testCursorRestoration = function() {
            console.log('🧪 ========== CURSOR RESTORATION TEST ==========');
            
            const activeElement = document.activeElement;
            if (!activeElement || activeElement.tagName !== 'TD' || activeElement.contentEditable !== 'true') {
                console.log('❌ Please focus on an editable table cell first');
                return false;
            }
            
            console.log('✅ Starting cursor restoration test...');
            
            // Step 1: Capture current state
            console.log('📸 Step 1: Capturing current focus state...');
            const focusState = updateGlobalFocusState();
            console.log('   - Element:', focusState?.element?.tagName);
            console.log('   - Text content:', focusState?.element?.textContent);
            console.log('   - Caret position:', focusState?.position);
            
            // Step 2: Simulate losing focus
            console.log('🔄 Step 2: Simulating focus loss...');
            activeElement.blur();
            console.log('   - Active element after blur:', document.activeElement?.tagName || 'none');
            
            // Step 3: Test restoration
            TimerManager.setTimeout(() => {
                console.log('🎯 Step 3: Testing focus restoration...');
                
                if (focusState && focusState.element && document.contains(focusState.element)) {
                    // Restore focus
                    focusState.element.focus();
                    console.log('   - Focus restored to:', document.activeElement?.tagName || 'none');
                    
                    // Restore caret position
                    if (typeof focusState.position === 'number' && focusState.element.textContent.length > 0) {
                        try {
                            const range = document.createRange();
                            const selection = window.getSelection();
                            const textNode = focusState.element.childNodes[0] || focusState.element;
                            
                            if (textNode) {
                                const pos = Math.min(focusState.position, focusState.element.textContent.length);
                                range.setStart(textNode, pos);
                                range.collapse(true);
                                selection.removeAllRanges();
                                selection.addRange(range);
                                
                                // Verify position
                                const newRange = selection.getRangeAt(0);
                                const actualPos = newRange.startOffset;
                                console.log('   - Requested position:', pos);
                                console.log('   - Actual position:', actualPos);
                                console.log(actualPos === pos ? '   ✅ Position restored correctly' : '   ⚠️ Position mismatch');
                            }
                        } catch (error) {
                            console.log('   ❌ Error restoring cursor position:', error.message);
                        }
                    }
                } else {
                    console.log('   ❌ Cannot restore - element not found or removed from DOM');
                }
                
                console.log('🏁 Test completed. Check results above.');
            }, 500);
            
            return true;
        };
        
        // Function to trace cursor restoration issues
        window.traceCursorIssues = function() {
            console.log('🔍 ========== CURSOR ISSUE TRACER ==========');
            
            // Find all potential issues
            const issues = [];
            
            // Check 1: Multiple focus states
            if (window.capturedFocusState && window.lastFocusInfo) {
                if (window.capturedFocusState.element !== window.lastFocusInfo.element) {
                    issues.push('⚠️ Conflicting focus states detected');
                }
            }
            
            // Check 2: Stale elements
            if (window.capturedFocusState?.element && !document.contains(window.capturedFocusState.element)) {
                issues.push('❌ Captured focus element is no longer in DOM');
            }
            
            // Check 3: Protection flags
            if (isRestoringCursor && Date.now() - window.cursorRestorationStart > 5000) {
                issues.push('⚠️ Cursor restoration flag stuck for too long');
            }
            
            // Check 4: Excel save conflicts
            if (isExcelSaveInProgress && isTyping) {
                issues.push('⚠️ Excel save in progress while user is typing');
            }
            
            // Check 5: Focus age
            const focusAge = window.capturedFocusState?.timestamp ? Date.now() - window.capturedFocusState.timestamp : null;
            if (focusAge && focusAge > 30000) {
                issues.push('⚠️ Focus state is very old (> 30s)');
            }
            
            if (issues.length === 0) {
                console.log('✅ No obvious cursor restoration issues detected');
            } else {
                console.log('🚨 Issues found:');
                issues.forEach(issue => console.log('  ' + issue));
            }
            
            return issues;
        };
        
        // Debug function to test Excel-like autosave behavior
        window.testExcelSave = function() {
            console.log('🧪 Testing Excel-like autosave behavior...');
            console.log('📋 Instructions:');
            console.log('  1. Click on a cell and type some text');
            console.log('  2. Press Tab or click another cell to move away');
            console.log('  3. Save should trigger automatically on blur');
            console.log('  4. While typing, no timer-based saves should occur');
            console.log('');
            console.log('🔍 Current state:');
            console.log('  - isDirty:', isDirty);
            console.log('  - isTyping:', isTyping);
            console.log('  - Active element:', document.activeElement?.getAttribute?.('data-label') || 'none');
            
            // Add temporary event listener to track blur events
            document.addEventListener('blur', function testBlurListener(e) {
                if (e.target && e.target.tagName === 'TD' && e.target.contentEditable === 'true') {
                    console.log('👁️ BLUR detected on cell:', e.target.getAttribute('data-label'));
                    // Remove listener after first test
                    document.removeEventListener('blur', testBlurListener, true);
                }
            }, true);
        };
        
        window.loadTableData = loadTableData;
        
        // Debug function to test cursor restoration
        window.testCursorRestoration = function() {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.tagName === 'TD' && activeElement.contentEditable === 'true') {
                console.log('🧪 Testing cursor restoration...');
                
                // Capture current state
                updateGlobalFocusState({
                    element: activeElement,
                    position: getCaretOffsetWithin(activeElement),
                    timestamp: Date.now(),
                    rowIndex: Array.from(activeElement.closest('tr').parentNode.querySelectorAll('tr')).indexOf(activeElement.closest('tr')),
                    colLabel: activeElement.getAttribute('data-label') || ''
                });
                
                console.log('📝 Captured:', window.capturedFocusState);
                
                // Blur and then restore after 2 seconds
                activeElement.blur();
                TimerManager.setTimeout(() => {
                    console.log('🔄 Restoring cursor...');
                    isRestoringCursor = true; // Set flag during test restoration
                    
                    if (window.capturedFocusState) {
                        const tbody = document.querySelector('#data-table tbody');
                        const rows = tbody.querySelectorAll('tr');
                        if (rows[window.capturedFocusState.rowIndex]) {
                            const row = rows[window.capturedFocusState.rowIndex];
                            const targetElement = row.querySelector(`td[data-label="${window.capturedFocusState.colLabel}"]`);
                            if (targetElement) {
                                targetElement.focus();
                                setCaretAt(targetElement, window.capturedFocusState.position);
                                console.log('✅ Cursor restoration test completed');
                                
                                // Clear flag after test
                                TimerManager.setTimeout(() => {
                                    isRestoringCursor = false;
                                    console.log('🔓 Test restoration flag cleared');
                                }, 1000);
                            }
                        }
                    }
                }, 2000);
            } else {
                console.log('❌ Please select a cell first');
            }
        };
        window.showMessage = showMessage;
        window.closeImageViewer = closeImageViewer;
        window.nextImage = nextImage;
        window.previousImage = previousImage;
        window.deleteImage = deleteImage;
        window.deleteAllImagesForPatient = deleteAllImagesForPatient;
        window.syncPendingImages = syncPendingImages;
        window.loadImagesFromSupabase = loadImagesFromSupabase;
        window.updateAllImageColumnIcons = updateAllImageColumnIcons;

        // Fonction pour ouvrir la galerie simple
        function openSimpleGallery() {
            window.open('simple-gallery.html', '_blank', 'width=1200,height=800,scrollbars=yes,resizable=yes');
        }
        
        // Exposer la fonction globalement
        window.openSimpleGallery = openSimpleGallery;
        window.setupMobileViewport = setupMobileViewport;
        window.setupExtendedKeyboardShortcuts = setupExtendedKeyboardShortcuts;
        window.initializeApp = initializeApp;
        window.adaptStatusDisplay = adaptStatusDisplay;
        window.getCurrentStatusType = getCurrentStatusType;
        window.applyDotColor = applyDotColor;

        // Raccourcis clavier étendus

        
        function setupMobileViewport() {
            // Gérer la hauteur dynamique du viewport sur mobile
            function updateViewportHeight() {
                if (window.innerWidth <= 768) {
                    const vh = window.innerHeight * 0.01;
                    document.documentElement.style.setProperty('--vh', `${vh}px`);
                    
                    // Ajuster la hauteur du conteneur principal
                    const tableContainer = document.getElementById('table-container');
                    if (tableContainer) {
                        tableContainer.style.height = `${window.innerHeight}px`;
                        tableContainer.style.minHeight = `${window.innerHeight}px`;
                    }
                    
                    // Ajuster la position du bouton FAB pour éviter la barre de navigation
                    const fabButton = document.getElementById('fab-add');
                    if (fabButton) {
                        const bottomOffset = Math.max(16, window.innerHeight - window.visualViewport.height + 16);
                        fabButton.style.bottom = `${bottomOffset}px`;
                        
                        // Sur mobile, positionner le bouton plus discrètement
                        if (window.innerWidth <= 768) {
                            fabButton.style.right = '12px';
                            fabButton.style.bottom = `${Math.max(12, bottomOffset - 4)}px`;
                        }
                    }
                }
            }
            
            // Mettre à jour lors du redimensionnement
            window.addEventListener('resize', updateViewportHeight);
            window.addEventListener('orientationchange', updateViewportHeight);
            
            // Mettre à jour lors du changement de la barre de navigation mobile
            if ('visualViewport' in window) {
                window.visualViewport.addEventListener('resize', updateViewportHeight);
            }
            
            // Mise à jour initiale
            updateViewportHeight();
            
            // Mettre à jour périodiquement pour s'assurer de la synchronisation
            setInterval(updateViewportHeight, 1000);
        }
        
        function ensureMobileButtonVisibility() {
            // Ensure unified header is visible on mobile devices
            function checkAndFixButtonVisibility() {
                const buttonBar = document.getElementById('button-bar');
                const headerContainer = buttonBar?.closest('.flex.flex-col.md\\:flex-row.items-start.md\\:items-center.justify-between.mb-2.p-2.bg-gradient-to-r.from-gray-50.to-gray-100.rounded-lg.border.border-gray-200');
                
                if (!buttonBar || !headerContainer) return;
                
                if (window.innerWidth <= 768) {
                    // Force mobile styling for the entire unified header
                    headerContainer.style.position = 'fixed';
                    headerContainer.style.top = 'calc(env(safe-area-inset-top, 0px) + 20px)'; // Increased upper padding
                    headerContainer.style.left = '0';
                    headerContainer.style.right = '0';
                    headerContainer.style.width = '100%';
                    headerContainer.style.margin = '0';
                    headerContainer.style.padding = '0.75rem'; // Reduced padding for better spacing
                    headerContainer.style.backgroundColor = 'rgba(249, 250, 251, 0.98)';
                    headerContainer.style.border = '1px solid #e5e7eb';
                    headerContainer.style.borderRadius = '0 0 0.5rem 0.5rem';
                    headerContainer.style.zIndex = '1000';
                    headerContainer.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
                    headerContainer.style.minHeight = '100px'; // Reduced height for better proportions
                    
                    // Style the button bar within the unified header
                    buttonBar.style.marginLeft = '0';
                    buttonBar.style.justifyContent = 'center';
                    buttonBar.style.flexWrap = 'nowrap'; // Never wrap buttons
                    buttonBar.style.gap = '0.5rem';
                    buttonBar.style.padding = '0.5rem';
                    buttonBar.style.backgroundColor = 'transparent';
                    buttonBar.style.border = 'none';
                    buttonBar.style.borderRadius = '0';
                    
                    // Ensure all buttons are visible with original desktop sizing
                    const buttons = buttonBar.querySelectorAll('button');
                    buttons.forEach(button => {
                        button.style.display = 'flex';
                        button.style.visibility = 'visible';
                        button.style.opacity = '1';
                        button.style.transform = 'scale(1.2)'; // Original desktop size
                        button.style.transformOrigin = 'center';
                    });
                    
                    console.log('📱 Mobile unified header visibility enforced with browser bar positioning');
                }
            }
            
            // Check on load
            checkAndFixButtonVisibility();
            
            // Check on resize
            window.addEventListener('resize', checkAndFixButtonVisibility);
            
            // Check on orientation change
            window.addEventListener('orientationchange', checkAndFixButtonVisibility);
            
            // Check periodically
            setInterval(checkAndFixButtonVisibility, 2000);
        }
        
        function setupExtendedKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Seulement appliquer les raccourcis quand pas dans les champs de formulaire
                const active = document.activeElement;
                const inFormField = active && (
                    active.tagName === 'INPUT' || 
                    active.tagName === 'TEXTAREA' || 
                    active.tagName === 'SELECT' || 
                    active.contentEditable === 'true'
                );

                // Ignorer les raccourcis si dans les champs de formulaire
                if (inFormField) return;

                // G: Ouvrir galerie
                if (!e.ctrlKey && !e.metaKey && !e.altKey && (e.key === 'g' || e.key === 'G')) {
                    e.preventDefault();
                    openSimpleGallery();
                    return;
                }

                // N: Ajouter nouvelle ligne
                if (!e.ctrlKey && !e.metaKey && !e.altKey && (e.key === 'n' || e.key === 'N')) {
                    e.preventDefault();
                    if (typeof addRow === 'function') {
                        addRow();
                    }
                    return;
                }

                // Supprimer: Supprimer lignes sélectionnées
                if (e.key === 'Delete') {
                    e.preventDefault();
                    
                    // Empêcher la suppression dans les snapshots
                    if (snapshotMode === 'snapshot') {
                        showMessage('Impossible de supprimer des lignes dans un snapshot. Retournez aux données en direct pour modifier le tableau.', 'warning');
                        return;
                    }
                    
                    // Récupérer les lignes sélectionnées
                    const selectedRows = Array.from(document.querySelectorAll('#table-body tr.selected-row'));
                    if (selectedRows.length > 0) {
                        promptKeyConfirm(`Supprimer ${selectedRows.length} ligne(s) ?`, () => deleteRows(selectedRows));
                    } else {
                        // Si aucune ligne sélectionnée, essayer de supprimer la ligne active
                        const activeRow = document.querySelector('#table-body tr:focus') || document.querySelector('#table-body tr.selected-row');
                        if (activeRow) {
                            promptKeyConfirm('Appuyez sur Entrée pour supprimer cette ligne, Échap pour annuler.', () => deleteRows([activeRow]));
                        }
                    }
                    return;
                }

                // Échap: Fermer modales
                if (e.key === 'Escape') {
                    const confirmationModal = document.getElementById('confirmation-modal');
                    if (confirmationModal && !confirmationModal.classList.contains('hidden')) {
                        confirmationModal.classList.add('hidden');
                        return;
                    }
                }
            });
        }

        // Initialiser les raccourcis clavier étendus
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize performance optimizations first
            domCache.init();
            eventManager.initTableEvents();
            
            // Initialize undo/redo button event listeners
            const undoButton = document.getElementById('undo-button');
            const redoButton = document.getElementById('redo-button');
            
            if (undoButton) {
                undoButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!undoButton.disabled) {
                        undo();
                    }
                });
            }
            
            if (redoButton) {
                redoButton.addEventListener('click', function(e) {
                    e.preventDefault(); 
                    e.stopPropagation();
                    if (!redoButton.disabled) {
                        redo();
                    }
                });
            }
            
            // Performance monitoring
            eventManager.monitor.mark('dom-ready');
            
            // Cleanup on page unload to prevent memory leaks
            window.addEventListener('beforeunload', () => {
                eventManager.cleanup();
                dataCache.data = null; // Clear data cache
                console.log('🧹 Performance optimizations cleaned up');
            });
            
            setupExtendedKeyboardShortcuts();
            
            // Adapter l'affichage du statut selon la taille d'écran initiale
            TimerManager.setTimeout(() => {
                adaptStatusDisplay();
            }, 100);
            
                    // Setup mobile viewport management
        setupMobileViewport();
        
        // Ensure button bar is visible on mobile
        ensureMobileButtonVisibility();
        
        // Debug button bar on mobile
        setTimeout(() => {
            if (window.innerWidth <= 768) {
                const buttonBar = document.getElementById('button-bar');
                if (buttonBar) {
                    console.log('📱 Button bar found:', buttonBar);
                    console.log('📱 Button bar display:', window.getComputedStyle(buttonBar).display);
                    console.log('📱 Button bar visibility:', window.getComputedStyle(buttonBar).visibility);
                    console.log('📱 Button bar position:', window.getComputedStyle(buttonBar).position);
                    console.log('📱 Button bar top:', window.getComputedStyle(buttonBar).top);
                    console.log('📱 Button bar right:', window.getComputedStyle(buttonBar).right);
                    console.log('📱 Button bar width:', window.getComputedStyle(buttonBar).width);
                    console.log('📱 Button bar height:', window.getComputedStyle(buttonBar).height);
                    console.log('📱 Button bar z-index:', window.getComputedStyle(buttonBar).zIndex);
                    
                    const buttons = buttonBar.querySelectorAll('button');
                    console.log('📱 Number of buttons found:', buttons.length);
                    buttons.forEach((btn, index) => {
                        console.log(`📱 Button ${index + 1}:`, btn.textContent || btn.innerHTML, 'Display:', window.getComputedStyle(btn).display);
                    });
                } else {
                    console.log('❌ Button bar not found!');
                }
            }
        }, 1000);
        });

        // Initialize when DOM is ready
        window.addEventListener('load', initializeApp);

        // ========================================
        // SUPPORT TACTILE MOBILE - BOUTON +
        // ========================================
        
        // Gestion des événements tactiles pour mobile - SOLUTION RECOMMANDÉE
        function addTouchSupport() {
            // ONLY target the manual snapshot button specifically
            const addButton = document.getElementById('manual-snapshot-btn');
            
            if (addButton) {
                console.log('🔍 Bouton snapshot trouvé:', addButton);
                
                // Supprimer les anciens événements pour éviter les doublons
                addButton.removeEventListener('click', handleButtonClick);
                addButton.removeEventListener('touchstart', handleTouchStart);
                addButton.removeEventListener('touchend', handleTouchEnd);
                
                // Gestion des clics (PC)
                addButton.addEventListener('click', handleButtonClick);
                
                // Gestion des événements tactiles (Mobile)
                addButton.addEventListener('touchstart', handleTouchStart);
                addButton.addEventListener('touchend', handleTouchEnd);
                
                console.log('✅ Événements tactiles ajoutés au bouton snapshot uniquement');
            } else {
                console.log('❌ Bouton snapshot non trouvé');
            }
        }

        // Gestionnaire de clic pour le bouton snapshot
        function handleButtonClick(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('✅ Clic détecté sur le bouton snapshot');
            openSnapshotBar();
        }

        // Gestionnaire de touch start pour le bouton snapshot
        function handleTouchStart(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('📱 Touch start détecté sur le bouton snapshot');
        }

        // Gestionnaire de touch end pour le bouton snapshot
        function handleTouchEnd(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('📱 Touch end détecté sur le bouton snapshot');
            
            // Petit délai pour éviter les doubles déclenchements
            TimerManager.setTimeout(() => {
                openSnapshotBar();
            }, 100);
        }

        // Fonction pour ouvrir la barre de snapshot (à adapter selon votre code)
        function openSnapshotBar() {
            console.log('🚀 Ouverture de la barre de snapshot...');
            
            // Use the proper manual snapshot function with state checking
            if (typeof handleManualSnapshotClick === 'function') {
                console.log('✅ Appel de handleManualSnapshotClick');
                handleManualSnapshotClick();
            } else if (typeof createManualSnapshot === 'function') {
                console.log('✅ Appel de createManualSnapshot (fallback)');
                createManualSnapshot();
            } else {
                console.log('⚠️ Aucune fonction de snapshot trouvée');
                showMessage('❌ Fonction de snapshot non disponible', 'error');
            }
        }



        // Fonction de débogage pour mobile
        function debugMobileButton() {
            console.log('🔍 === DÉBOGAGE MOBILE ===');
            
            const addButton = document.querySelector('.add-snapshot-btn, .btn-add-snapshot, button[onclick*="createManualSnapshot"], button[id="manual-snapshot-btn"]');
            
            if (addButton) {
                console.log('🔍 Bouton snapshot trouvé:', addButton);
                console.log('📱 Bouton visible:', addButton.offsetParent !== null);
                console.log('📏 Dimensions:', addButton.offsetWidth, 'x', addButton.offsetHeight);
                console.log('📍 Position:', addButton.offsetLeft, addButton.offsetTop);
                console.log('🎯 Z-index:', window.getComputedStyle(addButton).zIndex);
                console.log('📱 Classes:', addButton.className);
                console.log(' HTML:', addButton.outerHTML);
            } else {
                console.log('❌ Bouton snapshot non trouvé');
                
                // Recherche de tous les boutons snapshot
                const allButtons = document.querySelectorAll('button, .btn, [onclick]');
                console.log('🔍 Tous les boutons trouvés:', allButtons.length);
                
                allButtons.forEach((btn, index) => {
                    if (btn.onclick && btn.onclick.toString().includes('createManualSnapshot')) {
                        console.log(`🎯 Bouton snapshot ${index}:`, {
                            text: btn.textContent,
                            classes: btn.className,
                            onclick: btn.onclick,
                            html: btn.outerHTML
                        });
                    }
                });
            }
        }

        // Initialisation au chargement de la page
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 Initialisation du support tactile mobile...');
            
            // Attendre un peu que la page soit complètement chargée
            TimerManager.setTimeout(() => {
                addTouchSupport();
                debugMobileButton();
            }, 500);
            
            // Réessayer après un délai plus long (au cas où)
            TimerManager.setTimeout(() => {
                addTouchSupport();
            }, 2000);
        });

        // Réinitialiser lors des changements de contenu
        if (typeof MutationObserver !== 'undefined') {
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        // Vérifier si de nouveaux boutons ont été ajoutés
                        setTimeout(addTouchSupport, 100);
                    }
                });
            });
            
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        }

        // ========================================
        // FIN DU SUPPORT TACTILE MOBILE
        // ========================================
        
        // ========================================
        // FONCTIONS DE RÉACTIVATION REALTIME
        // ========================================
        
        // Function to manually reactivate realtime sync
        window.reactivateRealtimeSync = function() {
            console.log('🔄 Manually reactivating realtime sync...');
            try {
                // Check current state
                const currentMode = window.snapshotMode || 'unknown';
                const hasRealtimeSub = !!window.realtimeSubscription;
                
                console.log('📊 Current state:', {
                    mode: currentMode,
                    hasRealtimeSub: hasRealtimeSub,
                    currentSnapshotDate: window.currentSnapshotDate
                });
                
                // Force return to live mode if in snapshot mode
                if (currentMode === 'snapshot') {
                    console.log('🔄 Currently in snapshot mode, returning to live mode...');
                    if (typeof window.returnToToday === 'function') {
                        window.returnToToday();
                        return 'Returning to live mode...';
                    } else {
                        console.log('⚠️ returnToToday function not available');
                        // Fallback: manually reset state
                        window.snapshotMode = 'live';
                        window.currentSnapshotDate = null;
                        window.currentSnapshotIndex = -1;
                        console.log('✅ Manually reset to live mode');
                    }
                }
                
                // Reactivate realtime subscription
                console.log('🔄 Setting up realtime subscription...');
                if (typeof window.setupRealtimeSubscription === 'function') {
                    window.setupRealtimeSubscription();
                    console.log('✅ Realtime subscription setup called');
                } else {
                    console.log('⚠️ setupRealtimeSubscription function not available');
                    // Fallback: try to create subscription manually
                    if (window.supabase) {
                        console.log('🔄 Creating manual realtime subscription...');
                        try {
                            window.realtimeSubscription = window.supabase.channel('table-changes')
                                .on('postgres_changes', { 
                                    event: 'INSERT', 
                                    schema: 'public', 
                                    table: 'staffTable' 
                                }, (payload) => {
                                    console.log('🔄 INSERT:', payload);
                                    if (typeof window.fetchInitialData === 'function') {
                                        setTimeout(() => window.fetchInitialData(), 1000);
                                    }
                                })
                                .on('postgres_changes', { 
                                    event: 'UPDATE', 
                                    schema: 'public', 
                                    table: 'staffTable' 
                                }, (payload) => {
                                    console.log('🔄 UPDATE:', payload);
                                    if (typeof window.fetchInitialData === 'function') {
                                        setTimeout(() => window.fetchInitialData(), 1000);
                                    }
                                })
                                .on('postgres_changes', { 
                                    event: 'DELETE', 
                                    schema: 'public', 
                                    table: 'staffTable' 
                                }, (payload) => {
                                    console.log('🔄 DELETE:', payload);
                                    if (typeof window.fetchInitialData === 'function') {
                                        setTimeout(() => window.fetchInitialData(), 1000);
                                    }
                                })
                                .subscribe();
                            console.log('✅ Manual realtime subscription created');
                        } catch (error) {
                            console.error('❌ Error creating manual subscription:', error);
                        }
                    }
                }
                
                console.log('✅ Realtime sync reactivated');
                if (typeof window.showMessage === 'function') {
                    window.showMessage('Synchronisation temps réel réactivée', 'success');
                }
                
                return 'Realtime sync reactivated successfully';
            } catch (error) {
                console.error('❌ Error reactivating realtime sync:', error);
                if (typeof window.showMessage === 'function') {
                    window.showMessage('Erreur lors de la réactivation', 'error');
                }
                return 'Error: ' + error.message;
            }
        };
        
        // Function to check realtime sync status
        window.checkRealtimeStatus = function() {
            console.log('🔍 Checking realtime sync status...');
            
            const status = {
                realtimeSubscription: window.realtimeSubscription,
                snapshotMode: window.snapshotMode || 'unknown',
                currentSnapshotDate: window.currentSnapshotDate,
                hasSupabase: !!window.supabase,
                hasSetupFunction: typeof window.setupRealtimeSubscription === 'function',
                hasReturnFunction: typeof window.returnToToday === 'function'
            };
            
            console.log('📊 Status details:', status);
            
            if (window.realtimeSubscription) {
                console.log('✅ Realtime sync is active');
                if (typeof window.showMessage === 'function') {
                    window.showMessage('Synchronisation temps réel active', 'success');
                }
                return 'ACTIVE';
            } else {
                console.log('❌ Realtime sync is inactive');
                console.log('🔍 Possible reasons:');
                console.log('   - In snapshot mode:', status.snapshotMode === 'snapshot');
                console.log('   - Supabase client:', status.hasSupabase);
                console.log('   - Setup function:', status.hasSetupFunction);
                
                if (typeof window.showMessage === 'function') {
                    window.showMessage('Synchronisation temps réel inactive', 'info');
                }
                return 'INACTIVE';
            }
        };
        
        // ========================================
        // FIN DES FONCTIONS DE RÉACTIVATION
        // ========================================
        
        console.log('✅ Enhanced Excel-like save and realtime sync protection initialized');
        console.log('🛡️ Multi-level protection system active:');
        console.log('   Level 1: Local save blocking');
        console.log('   Level 2: Cursor restoration protection');
        console.log('   Level 3: Excel save process blocking');
        console.log('   Level 4: Excel save protection window (6s)');
        console.log('   Level 5: General focus protection (3s)');
        console.log('   Level 6: Active typing detection');
        console.log('🧪 Debug functions available:');
        console.log('   - debugCursorRestoration(): Complete cursor state analysis');
        console.log('   - testCursorRestoration(): Test cursor capture and restore');
        console.log('   - traceCursorIssues(): Identify cursor restoration problems');
        console.log('   - testRealtimeWithCursor(): Test realtime sync with cursor preservation');
        console.log('   - testExcelSaveWithRealtime(): Test Excel save behavior');
        console.log('   - testProtectionLevels(): Test all protection systems');
        
        // Function to scroll button bar to the beginning (leftmost position)
        function scrollToStart() {
            const buttonBar = document.getElementById('button-bar');
            if (buttonBar) {
                buttonBar.scrollLeft = 0;
                console.log('📱 Scrolled button bar to start (scrollLeft:', buttonBar.scrollLeft, ')');
                console.log('📱 Button bar scrollWidth:', buttonBar.scrollWidth, 'clientWidth:', buttonBar.clientWidth);
            }
        }
        
        // Function to scroll button bar to the end (rightmost position)
        function scrollToEnd() {
            const buttonBar = document.getElementById('button-bar');
            if (buttonBar) {
                buttonBar.scrollLeft = buttonBar.scrollWidth;
                console.log('📱 Scrolled button bar to end');
            }
        }
        
        // Add keyboard shortcuts for scrolling
        document.addEventListener('keydown', function(e) {
            // Ctrl+Left: Scroll to start
            if ((e.ctrlKey || e.metaKey) && e.key === 'ArrowLeft') {
                e.preventDefault();
                scrollToStart();
            }
            // Ctrl+Right: Scroll to end
            if ((e.ctrlKey || e.metaKey) && e.key === 'ArrowRight') {
                e.preventDefault();
                scrollToEnd();
            }
        });
        
        // Function to test and fix button bar scrolling
        function testButtonBarScrolling() {
            const buttonBar = document.getElementById('button-bar');
            if (buttonBar) {
                console.log('🔍 Button bar scroll test:');
                console.log('   - scrollWidth:', buttonBar.scrollWidth);
                console.log('   - clientWidth:', buttonBar.clientWidth);
                console.log('   - scrollLeft:', buttonBar.scrollLeft);
                console.log('   - maxScrollLeft:', buttonBar.scrollWidth - buttonBar.clientWidth);
                
                // Force a reflow to ensure proper dimensions
                buttonBar.style.display = 'none';
                buttonBar.offsetHeight; // Force reflow
                buttonBar.style.display = 'flex';
                
                console.log('   - After reflow - scrollWidth:', buttonBar.scrollWidth, 'clientWidth:', buttonBar.clientWidth);
                
                // Test scrolling to start
                buttonBar.scrollLeft = 0;
                console.log('   - Scrolled to start, scrollLeft:', buttonBar.scrollLeft);
                
                // Test scrolling to end
                buttonBar.scrollLeft = buttonBar.scrollWidth;
                console.log('   - Scrolled to end, scrollLeft:', buttonBar.scrollLeft);
                
                // Return to start
                buttonBar.scrollLeft = 0;
                console.log('   - Returned to start, scrollLeft:', buttonBar.scrollLeft);
            }
        }
        
        console.log('🎯 Button bar scroll functions added:');
        console.log('   - scrollToStart(): Scroll to leftmost buttons');
        console.log('   - scrollToEnd(): Scroll to rightmost buttons');
        console.log('   - Ctrl+Left: Scroll to start');
        console.log('   - Ctrl+Right: Scroll to end');
        console.log('   - testButtonBarScrolling(): Test and debug scrolling');
        
        // ========================================
        // iOS/ANDROID VIEWPORT ADAPTATION SYSTEM
        // ========================================
        
        // Function to update viewport height for mobile browsers
        function updateViewportHeight() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
            console.log('📱 Viewport height updated:', vh, 'px');
        }
        
        // Function to update safe area insets
        function updateSafeAreaInsets() {
            const safeAreaTop = getComputedStyle(document.documentElement).getPropertyValue('--safe-area-top');
            const safeAreaBottom = getComputedStyle(document.documentElement).getPropertyValue('--safe-area-bottom');
            const safeAreaLeft = getComputedStyle(document.documentElement).getPropertyValue('--safe-area-left');
            const safeAreaRight = getComputedStyle(document.documentElement).getPropertyValue('--safe-area-right');
            
            console.log('📱 Safe area insets updated:');
            console.log('   - Top:', safeAreaTop);
            console.log('   - Bottom:', safeAreaBottom);
            console.log('   - Left:', safeAreaLeft);
            console.log('   - Right:', safeAreaRight);
        }
        
        // Function to ensure top elements are above navigation bars
        function ensureTopElementsVisibility() {
            const safeAreaTop = getComputedStyle(document.documentElement).getPropertyValue('--safe-area-top');
            const topElements = [
                document.querySelector('.flex.items-center.gap-2.mb-1'),
                document.getElementById('button-bar'),
                document.getElementById('table-container')
            ];
            
            topElements.forEach(element => {
                if (element) {
                    const currentTop = parseFloat(safeAreaTop) || 0;
                    const minMargin = Math.max(currentTop + 16, 16);
                    element.style.marginTop = `${minMargin}px`;
                    element.style.paddingTop = `${Math.max(currentTop, 0)}px`;
                }
            });
            
            console.log('📱 Top elements visibility ensured with safe area compensation');
        }
        
        // Function to handle viewport orientation changes
        function handleOrientationChange() {
            TimerManager.setTimeout(() => {
                updateViewportHeight();
                updateSafeAreaInsets();
                ensureTopElementsVisibility();
                console.log('📱 Orientation change handled');
            }, 100);
        }
        
        // Function to handle visual viewport changes (mobile keyboard)
        function handleVisualViewportChange() {
            if (window.visualViewport) {
                updateViewportHeight();
                ensureTopElementsVisibility();
                console.log('📱 Visual viewport change handled');
            }
        }
        
        // Initialize viewport adaptation system
        function initializeViewportAdaptation() {
            console.log('🚀 Initializing iOS/Android viewport adaptation system...');
            
            // Initial setup
            updateViewportHeight();
            updateSafeAreaInsets();
            ensureTopElementsVisibility();
            
            // Event listeners for dynamic updates
            window.addEventListener('resize', updateViewportHeight);
            window.addEventListener('orientationchange', handleOrientationChange);
            window.addEventListener('scroll', updateViewportHeight);
            
            // Visual viewport API for mobile keyboard handling
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', handleVisualViewportChange);
                window.visualViewport.addEventListener('scroll', handleVisualViewportChange);
            }
            
            // iOS Safari specific handling
            if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
                console.log('🍎 iOS device detected, applying specific adaptations');
                document.body.style.minHeight = '-webkit-fill-available';
                
                // Handle iOS Safari viewport issues
                window.addEventListener('focusin', () => {
                    setTimeout(updateViewportHeight, 100);
                });
                
                window.addEventListener('focusout', () => {
                    setTimeout(updateViewportHeight, 100);
                });
            }
            
            // Android specific handling
            if (/Android/.test(navigator.userAgent)) {
                console.log('🤖 Android device detected, applying specific adaptations');
                
                // Handle Android Chrome viewport issues
                window.addEventListener('resize', () => {
                    setTimeout(updateViewportHeight, 100);
                });
            }
            
            // Login container visibility monitoring for button bar hiding
            initializeLoginContainerMonitoring();
            
            console.log('✅ iOS/Android viewport adaptation system initialized');
        }
        
        // Function to monitor login container visibility and hide button bar
        function initializeLoginContainerMonitoring() {
            console.log('🔒 Initializing login container monitoring...');
            
            // Monitor login container visibility changes
            const loginContainer = document.getElementById('login-container');
            if (loginContainer) {
                // Initial check
                handleLoginContainerVisibility();
                
                // Create observer for class changes
                const observer = new MutationObserver(handleLoginContainerVisibility);
                observer.observe(loginContainer, { 
                    attributes: true, 
                    attributeFilter: ['class'] 
                });
                
                console.log('✅ Login container monitoring initialized');
            }
        }
        
        // Function to handle login container visibility changes
        function handleLoginContainerVisibility() {
            const loginContainer = document.getElementById('login-container');
            const buttonBar = document.getElementById('button-bar');
            
            if (loginContainer && buttonBar) {
                const isLoginVisible = !loginContainer.classList.contains('hidden');
                
                if (isLoginVisible) {
                    // Hide button bar when login is visible
                    buttonBar.style.display = 'none';
                    buttonBar.style.opacity = '0';
                    buttonBar.style.visibility = 'hidden';
                    buttonBar.style.pointerEvents = 'none';
                    console.log('🔒 Button bar hidden - login container visible');
                } else {
                    // Show button bar when login is hidden
                    buttonBar.style.display = 'flex';
                    buttonBar.style.opacity = '1';
                    buttonBar.style.visibility = 'visible';
                    buttonBar.style.pointerEvents = 'auto';
                    console.log('🔓 Button bar shown - login container hidden');
                }
            }
        }
        
        // Function to manage manual snapshot button state based on toggle
        function updateManualSnapshotButtonState() {
            const historyBarContainer = document.getElementById('history-bar-container');
            const manualSnapshotBtn = document.querySelector('button[onclick*="createManualSnapshot"]');
            
            if (!historyBarContainer || !manualSnapshotBtn) {
                console.log('⚠️ Manual snapshot button or history container not found');
                return;
            }
            
            const isHistoryBarVisible = !historyBarContainer.classList.contains('hidden') && 
                                     historyBarContainer.style.display !== 'none' && 
                                     historyBarContainer.offsetHeight > 0;
            
            if (isHistoryBarVisible) {
                // Enable manual snapshot button when toggle is on
                manualSnapshotBtn.disabled = false;
                manualSnapshotBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                manualSnapshotBtn.classList.add('hover:bg-purple-700');
                manualSnapshotBtn.title = 'Créer un snapshot manuel de la table actuelle';
                manualSnapshotBtn.setAttribute('aria-label', 'Snapshot Manuel (activé)');
                console.log('✅ Manual snapshot button enabled - toggle is on');
            } else {
                // Disable manual snapshot button when toggle is off
                manualSnapshotBtn.disabled = true;
                manualSnapshotBtn.classList.add('opacity-50', 'cursor-not-allowed');
                manualSnapshotBtn.classList.remove('hover:bg-purple-700');
                manualSnapshotBtn.title = 'Snapshot manuel désactivé - Barre d\'historique fermée';
                manualSnapshotBtn.setAttribute('aria-label', 'Snapshot Manuel (désactivé)');
                console.log('❌ Manual snapshot button disabled - toggle is off');
            }
        }
        
        // Call initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeViewportAdaptation);
        } else {
            initializeViewportAdaptation();
        }
        
        // Initialize manual snapshot button state
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                updateManualSnapshotButtonState();
                // Also ensure touch support is properly initialized
                TimerManager.setTimeout(() => {
                    addTouchSupport();
                }, 100);
            });
        } else {
            updateManualSnapshotButtonState();
            // Also ensure touch support is properly initialized
            TimerManager.setTimeout(() => {
                addTouchSupport();
            }, 100);
        }
        
        // Export functions for external use
        window.updateViewportHeight = updateViewportHeight;
        window.updateSafeAreaInsets = updateSafeAreaInsets;
        window.ensureTopElementsVisibility = ensureTopElementsVisibility;
        window.handleOrientationChange = handleOrientationChange;
        window.handleVisualViewportChange = handleVisualViewportChange;
        window.initializeViewportAdaptation = initializeViewportAdaptation;
        
        // Function to handle manual snapshot button clicks
        function handleManualSnapshotClick() {
            // 🏥 HOSPITAL PC CONFLICT PREVENTION
            const operationId = 'manual-snapshot-' + Date.now();
            
            // Register operation with hospital conflict detector
            if (window.hospitalPCSyncDetector) {
                // Check for existing snapshot operations
                const existingOps = Array.from(window.hospitalPCSyncDetector.activeOperations.entries())
                    .filter(([id, op]) => op.type === 'manual-snapshot' && Date.now() - op.startTime < 5000);
                
                if (existingOps.length > 0) {
                    console.log('🚨 HOSPITAL CONFLICT: Manual snapshot already in progress, preventing duplicate');
                    showMessage('⚠️ Création de snapshot déjà en cours - Opération bloquée pour éviter les conflits', 'warning');
                    return;
                }
                
                // Register this operation
                window.hospitalPCSyncDetector.registerOperation(operationId, 'manual-snapshot');
            }
            
            const historyBarContainer = document.getElementById('history-bar-container');
            const manualSnapshotBtn = document.getElementById('manual-snapshot-btn');
            
            if (!historyBarContainer || !manualSnapshotBtn) {
                console.log('⚠️ Manual snapshot button or history container not found');
                // Complete operation if registered
                if (window.hospitalPCSyncDetector) {
                    window.hospitalPCSyncDetector.completeOperation(operationId);
                }
                return;
            }
            
            // Check if manual snapshot is enabled
            const isHistoryBarVisible = !historyBarContainer.classList.contains('hidden') && 
                                     historyBarContainer.style.display !== 'none' && 
                                     historyBarContainer.offsetHeight > 0;
            
            if (!isHistoryBarVisible) {
                console.log('❌ Manual snapshot creation blocked - History bar is not visible');
                showMessage('❌ Création de snapshot désactivée - Barre d\'historique fermée', 'error');
                // Complete operation if registered
                if (window.hospitalPCSyncDetector) {
                    window.hospitalPCSyncDetector.completeOperation(operationId);
                }
                return;
            }
            
            try {
                // If enabled, proceed with manual snapshot creation
                console.log('✅ Manual snapshot creation allowed - proceeding...');
                createManualSnapshot();
                
                // Complete operation successfully
                if (window.hospitalPCSyncDetector) {
                    setTimeout(() => {
                        window.hospitalPCSyncDetector.completeOperation(operationId);
                    }, 1000); // Complete after snapshot creation
                }
            } catch (error) {
                console.error('❌ Error during manual snapshot creation:', error);
                // Complete operation with error
                if (window.hospitalPCSyncDetector) {
                    window.hospitalPCSyncDetector.completeOperation(operationId);
                }
                throw error;
            }
        }
        
        // Mobile toggle button debugging function
        window.debugToggleButton = function() {
            console.log('🔍 Debugging toggle button on mobile...');
            
            const historyBarContainer = document.getElementById('history-bar-container');
            const toggleBtn = document.getElementById('history-toggle-btn');
            const toggleIcon = document.getElementById('history-toggle-icon');
            
            if (!historyBarContainer || !toggleBtn || !toggleIcon) {
                console.error('❌ Required elements not found');
                return;
            }
            
            console.log('📱 Mobile device check:', isMobile());
            console.log('📱 Screen dimensions:', window.innerWidth, 'x', window.innerHeight);
            console.log('📱 Viewport dimensions:', window.visualViewport?.width, 'x', window.visualViewport?.height);
            
            const containerState = {
                element: historyBarContainer,
                hiddenClass: historyBarContainer.classList.contains('hidden'),
                display: historyBarContainer.style.display,
                computedDisplay: window.getComputedStyle(historyBarContainer).display,
                visibility: historyBarContainer.style.visibility,
                opacity: historyBarContainer.style.opacity,
                height: historyBarContainer.style.height,
                offsetHeight: historyBarContainer.offsetHeight,
                clientHeight: historyBarContainer.clientHeight,
                scrollHeight: historyBarContainer.scrollHeight,
                zIndex: window.getComputedStyle(historyBarContainer).zIndex
            };
            
            console.log('📊 History bar container state:', containerState);
            
            // Test toggle functionality
            console.log('🧪 Testing toggle functionality...');
            const originalState = containerState.hiddenClass;
            
            // Simulate toggle
            toggleHistoryBarSimple();
            
            // Check result after a short delay
            TimerManager.setTimeout(() => {
                const newState = historyBarContainer.classList.contains('hidden');
                console.log('✅ Toggle test result:', {
                    originalState,
                    newState,
                    toggleSuccessful: originalState !== newState
                });
                
                // Restore original state if needed
                if (originalState !== newState) {
                    toggleHistoryBarSimple();
                }
            }, 200);
        };
        
        console.log('🎯 iOS/Android viewport adaptation functions added:');
        console.log('   - updateViewportHeight(): Update dynamic viewport height');
        console.log('   - updateSafeAreaInsets(): Update safe area insets');
        console.log('   - ensureTopElementsVisibility(): Ensure top elements are visible');
        console.log('   - handleOrientationChange(): Handle device orientation changes');
        console.log('   - handleVisualViewportChange(): Handle mobile keyboard changes');
        console.log('   - initializeViewportAdaptation(): Initialize the entire system');
    </script>
</body>
</html>