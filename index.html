<!DOCTYPE html>
<html lang='fr'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>S-T synchronis√© - Supabase</title>
    
    <!-- Preload critical resources -->
    <link rel="preload" href="https://cdn.tailwindcss.com" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm" as="script">
    
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    

    
    <style>
        /* CSS Variables for consistent theming */
        :root {
            --primary-color: #15803d;
            --primary-hover: #16a34a;
            --primary-light: #86efac;
            --secondary-color: #3b82f6;
            --secondary-hover: #2563eb;
            --danger-color: #dc2626;
            --danger-hover: #b91c1c;
            --success-color: #16a34a;
            --warning-color: #eab308;
            --border-color: #e5e7eb;
            --border-focus: #3b82f6;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --bg-primary: #ffffff;
            --bg-secondary: #f9fafb;
            --bg-hover: #f3f4f6;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
            --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1);
            --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Base styles */
        body { 
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; 
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        /* Table styles */
        #data-table { 
            border-collapse: collapse; 
            border-spacing: 0; 
            margin-bottom: 50px; 
            width: 100%; 
            background-color: var(--bg-primary);
            box-shadow: var(--shadow-md);
            border-radius: 0.5rem;
        }
        
        #data-table th, #data-table td { 
            border: 1px solid var(--border-color); 
            transition: var(--transition);
        }
        
        #data-table thead { 
            position: sticky !important; 
            top: 0 !important; 
            z-index: 1000 !important; 
            background-color: var(--primary-color) !important;
            color: white !important;
            font-weight: 600 !important;
            text-transform: uppercase !important;
            letter-spacing: 0.05em !important;
            /* ‚úÖ GARANTIR que les en-t√™tes restent toujours visibles */
            will-change: transform !important;
            transform: translateZ(0) !important;
            /* ‚úÖ Ombre pour s√©parer visuellement les en-t√™tes */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15) !important;
            /* ‚úÖ Bordure inf√©rieure pour d√©limiter clairement */
            border-bottom: 3px solid var(--primary-hover) !important;
        }
        
        #data-table thead th {
            padding: 1rem;
            font-size: 0.875rem;
        }
        
        #data-table tbody tr {
            transition: var(--transition);
        }
        
        #data-table tbody tr:hover {
            background-color: var(--bg-hover);
            transform: scale(1.005);
            box-shadow: var(--shadow-sm);
        }
        
        #data-table tfoot {
            position: static;
            background: transparent;
            border-top: 0;
            box-shadow: none;
        }
        /* Floating + button to free vertical space */
        #fab-add {
          position: fixed;
          right: 16px;
          bottom: calc(env(safe-area-inset-bottom, 0px) + 16px);
          z-index: 60;
          width: 56px;
          height: 56px;
          border-radius: 9999px;
          display: flex;
          align-items: center;
          justify-content: center;
          box-shadow: var(--shadow-lg);
        }
        #fab-add:active { transform: scale(0.97); }
        
        /* Mobile-specific FAB button styling */
        @media (max-width: 768px) {
            #fab-add {
                width: 36px;
                height: 36px;
                opacity: 0.5;
                background-color: rgba(34, 197, 94, 0.7);
                backdrop-filter: blur(8px);
                border: 1px solid rgba(255, 255, 255, 0.15);
                transition: all 0.3s ease;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            }
            
            #fab-add:hover,
            #fab-add:focus {
                opacity: 0.9;
                transform: scale(1.05);
                background-color: rgba(34, 197, 94, 0.85);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }
            
            #fab-add:active {
                transform: scale(0.95);
                opacity: 1;
            }
            
            #fab-add svg {
                width: 18px;
                height: 18px;
                color: rgba(255, 255, 255, 0.9);
            }
            
            /* Animation d'apparition subtile */
            #fab-add {
                animation: fadeInSubtle 0.5s ease-out;
            }
            
            @keyframes fadeInSubtle {
                from {
                    opacity: 0;
                    transform: scale(0.8) translateY(10px);
                }
                to {
                    opacity: 0.5;
                    transform: scale(1) translateY(0);
                }
            }
        }
        


        /* Hide the old add-row button area to remove the white bar */
        #data-table tfoot td { padding: 0 !important; height: 0 !important; }
        #data-table tfoot button { display: none !important; }

        /* Snapshot System Styles */
        .snapshot-readonly {
            background-color: #fef3c7 !important;
            color: #92400e !important;
            cursor: not-allowed !important;
        }
        
        .snapshot-readonly:hover {
            background-color: #fde68a !important;
        }
        
        #history-bar {
            display: flex;
            transition: all 0.3s ease;
        }
        
        #history-bar button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #snapshot-banner {
            animation: slideInDown 0.3s ease-out;
            max-width: fit-content;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* History bar responsive design */
        /* Hide history bar and snapshot banner on medium and small screens */
        @media (max-width: 1023px) {
            #history-bar,
            #snapshot-banner {
                display: none !important;
            }
        }
        
        /* Utility classes */
        .hidden {
            display: none !important;
        }
        
        /* Animation classes */
        .sync-pending-animation { 
            animation: pulse 1.5s infinite; 
        }
        
        @keyframes pulse { 
            0% { opacity: 1; } 
            50% { opacity: 0.5; } 
            100% { opacity: 1; } 
        }
        
        /* Sync status dot styles */
        .sync-dot {
            transition: all 0.3s ease;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8);
            flex-shrink: 0;
            display: inline-block;
            border: 1px solid rgba(0, 0, 0, 0.1);
            cursor: help;
        }
        
        .sync-dot.animate-pulse {
            animation: dot-pulse 2s infinite;
        }
        
        @keyframes dot-pulse {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
            }
            50% { 
                opacity: 0.7; 
                transform: scale(1.1);
            }
        }
        
        /* Mobile-specific sync status adjustments */
        @media (max-width: 768px) {
            #sync-status {
                min-width: 1.5rem;
                min-height: 1.5rem;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
            }
            
            .sync-dot {
                width: 0.875rem !important;
                height: 0.875rem !important;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
            
            /* Hide title on small screens */
            #staff-title {
                transition: all 0.3s ease;
            }
            
                        #staff-title.hidden {
                opacity: 0;
                visibility: hidden;
                height: 0;
                margin: 0;
                padding: 0;
                overflow: hidden;
                transform: scale(0.8);
            }
            

        }
        

        
        /* Optimisation de l'espace */
        #table-container {
            max-width: 100%;
        }
        
        #button-bar {
            max-width: 100%;
            justify-content: flex-start;
            overflow-x: auto;
            gap: 0.3rem; /* ensure spacing between buttons */
            padding: 0 !important; /* Remove padding between buttons and container */
        }
        
        #button-bar button {
            margin: 0;
            flex-shrink: 0;
            transform: scale(1.2); /* enlarge by ~20% */
            transform-origin: center;
        }

        /* keep slight press effect while preserving 1.2 scale */
        #button-bar button:active {
            transform: scale(1.176);
        }
        
        /* R√©duction des marges sur petits √©crans */
        @media (max-width: 768px) {
            #table-container {
                margin: 0.5rem !important;
                padding: 0.5rem !important;
            }
            
            #button-bar {
                padding: 0.5rem !important;
                margin-bottom: 0.5rem !important;
            }
        }
        
        /* Message box styles */
        .message-box {
            position: fixed;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            line-height: 1rem;
            padding: 4px 8px;
            margin-top: 4px;
            border-radius: 0.5rem;
            box-shadow: var(--shadow-lg);
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            max-width: 90vw;
            word-wrap: break-word;
        }
        
        .message-box.show { 
            opacity: 1; 
            transform: translateX(-50%) translateY(0); 
        }
        
        .message-box.success { 
            background-color: #d1fae5; 
            color: #065f46; 
        }
        
        .message-box.info { 
            background-color: #dbeafe; 
            color: #1e40af; 
        }
        
        .message-box.error { 
            background-color: #fee2e2; 
            color: #991b1b; 
        }
        
        /* Button bar positioning */
        #button-bar { 
            position: absolute; 
            top: 8px; 
            right: 8px; 
            z-index: 20; 
        }
        
        /* Forcer le positionnement sur tous les √©crans non-mobiles */
        @media (min-width: 641px) {
            #button-bar {
                position: absolute !important;
                top: 8px !important;
                right: 8px !important;
                z-index: 20 !important;
                margin: 0 !important;
                margin-bottom: 0 !important;
                padding: 0 !important; /* Remove padding between buttons and container */
            }
        }

        /* Positionnement pour √©crans moyens (tablettes) */
        @media (min-width: 641px) and (max-width: 1024px) {
            #button-bar {
                position: absolute !important;
                top: 8px !important;
                right: 8px !important;
                z-index: 20 !important;
                margin: 0 !important;
                margin-bottom: 0 !important;
                transform: none !important;
            }
            
            /* Annuler les marges qui peuvent causer le d√©placement */
            #button-bar.mb-3 {
                margin-bottom: 0 !important;
            }

            /* Laisser un petit espace entre la barre et le tableau */
            #button-bar + div {
                margin-top: 6px !important; /* ~ quelques millim√®tres */
            }
        }

        /* Mobile-safe positioning for the top-right button bar */
        @media (max-width: 640px) {
            #button-bar {
                position: fixed;
                top: calc(env(safe-area-inset-top, 0px) + 8px);
                right: 8px;
                z-index: 50;
                overflow-x: auto;
            }
            
            #table-container { 
                padding-top: 56px; 
            }
            
            /* Emp√™cher que le bouton de couleur s'√©crase en largeur */
            #row-color-picker {
                min-width: 32px !important;
                min-height: 32px !important;
                width: 32px !important;
                height: 32px !important;
                flex-shrink: 0 !important;
            }
        }
        
        /* Sticky first column */
        #data-table td:first-child {
            position: sticky;
            left: 0;
            z-index: 2;
            background-color: white !important;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }

        #data-table th:first-child {
            position: sticky !important;
            left: 0 !important;
            top: 0 !important;
            z-index: 1001 !important;
            background-color: var(--primary-color) !important;
            /* ‚úÖ GARANTIR que la premi√®re colonne reste visible */
            will-change: transform !important;
            transform: translateZ(0) !important;
            /* ‚úÖ Ombre pour s√©parer visuellement */
            box-shadow: 2px 0 5px rgba(0,0,0,0.1) !important;
        }
        
        /* Frozen column classes for JavaScript */
        .frozen-column.frozen-1 {
            position: sticky !important;
            left: 0 !important;
            z-index: 2 !important;
            background-color: white !important;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        }
        
        .frozen-column-header.frozen-1 {
            position: sticky !important;
            left: 0 !important;
            top: 0 !important;
            z-index: 1001 !important;
            background-color: var(--primary-color) !important;
            /* ‚úÖ GARANTIR que les colonnes gel√©es restent visibles */
            will-change: transform !important;
            transform: translateZ(0) !important;
            /* ‚úÖ Ombre pour s√©parer visuellement */
            box-shadow: 2px 0 5px rgba(0,0,0,0.1) !important;
        }
        
        /* ‚úÖ GARANTIR que les en-t√™tes restent TOUJOURS visibles */
        #data-table thead,
        #data-table thead th,
        .frozen-column-header {
            /* ‚úÖ Forcer le comportement sticky m√™me pendant les op√©rations */
            position: sticky !important;
            top: 0 !important;
            z-index: 1000 !important;
            /* ‚úÖ Optimisations pour la performance */
            will-change: transform !important;
            transform: translateZ(0) !important;
            /* ‚úÖ Garantir la visibilit√© */
            visibility: visible !important;
            opacity: 1 !important;
            /* ‚úÖ Emp√™cher le d√©bordement */
            overflow: visible !important;
        }
        
        /* ‚úÖ En-t√™tes de colonnes gel√©es avec priorit√© maximale */
        #data-table th:first-child,
        .frozen-column-header.frozen-1 {
            z-index: 1001 !important;
            left: 0 !important;
            top: 0 !important;
        }
        
        /* ‚úÖ Styles pour les en-t√™tes pendant le t√©l√©chargement */
        #data-table thead.downloading {
            background-color: var(--primary-color) !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2) !important;
            border-bottom: 3px solid var(--warning-color) !important;
        }
        
        /* ‚úÖ Styles pour les en-t√™tes pendant la capture d'√©cran */
        #data-table thead.capturing {
            position: absolute !important;
            top: 0px !important;
            left: 0px !important;
            right: 0px !important;
            z-index: 10000 !important;
            background-color: var(--primary-color) !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
            border-bottom: 3px solid var(--warning-color) !important;
            /* ‚úÖ Garantir la visibilit√© pendant la capture */
            visibility: visible !important;
            opacity: 1 !important;
            /* ‚úÖ Emp√™cher tout d√©bordement */
            overflow: visible !important;
            /* ‚úÖ Forcer l'affichage en haut */
            transform: translateY(0) !important;
        }
        
        /* ‚úÖ Styles pour les en-t√™tes de colonnes gel√©es pendant la capture */
        #data-table thead.capturing th:first-child,
        .frozen-column-header.capturing {
            position: absolute !important;
            top: 0px !important;
            left: 0px !important;
            z-index: 10001 !important;
            background-color: var(--primary-color) !important;
            box-shadow: 2px 0 5px rgba(0,0,0,0.2) !important;
        }
        
        /* ‚úÖ Styles pour les en-t√™tes pendant la capture d'√©cran */
        #data-table thead.capturing {
            position: absolute !important;
            top: 0px !important;
            left: 0px !important;
            right: 0px !important;
            z-index: 10000 !important;
            background-color: var(--primary-color) !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
            border-bottom: 3px solid var(--warning-color) !important;
            /* ‚úÖ Garantir la visibilit√© pendant la capture */
            visibility: visible !important;
            opacity: 1 !important;
            /* ‚úÖ Emp√™cher tout d√©bordement */
            overflow: visible !important;
            /* ‚úÖ Forcer l'affichage en haut */
            transform: translateY(0) !important;
        }
        
        /* ‚úÖ Styles pour les en-t√™tes de colonnes gel√©es pendant la capture */
        #data-table thead.capturing th:first-child,
        .frozen-column-header.capturing {
            position: absolute !important;
            top: 0px !important;
            left: 0px !important;
            z-index: 10001 !important;
            background-color: var(--primary-color) !important;
            box-shadow: 2px 0 5px rgba(0,0,0,0.2) !important;
        }
        
        /* Editable cell styles */
        td.editable-cell:empty::after { 
            content: attr(data-label); 
            color: var(--text-secondary); 
            font-weight: normal; 
        }
        
        /* Texte noir fonc√© pour toutes les cellules √©ditables du tableau */
        td.editable-cell {
            color: #1a1a1a !important;
        }
        
        /* Styles sp√©cifiques pour les colonnes importantes avec police plus grande */
        td.editable-cell[data-label="Date de saisie"],
        td.editable-cell[data-label="PEC finale"],
        td.editable-cell[data-label="PEC initiale"],
        td.editable-cell[data-label="Diagnostic_initial"] {
            color: #1a1a1a !important; /* Noir fonc√© */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* L√©g√®rement plus gras */
        }
        
        /* Numero_tel avec police standard (1.1rem) */
        td.editable-cell[data-label="Numero_tel"],
        td.editable-cell[data-label="numero_tel"] {
            color: #1a1a1a !important; /* Noir fonc√© */
            font-size: 1.1rem !important; /* Police standard */
            font-weight: 500 !important; /* L√©g√®rement plus gras */
        }
        
        /* Nom_Pr√©nom et DDN en gras pour les cellules √©ditables */
        td.editable-cell[data-label="Nom_Pr√©nom"],
        td.editable-cell[data-label="DDN"] {
            color: #1a1a1a !important; /* Noir fonc√© */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 700 !important; /* Gras (bold) */
        }
        
        /* Information complementaire en rouge pour les cellules √©ditables */
        td.editable-cell[data-label="Information complementaire"],
        td.editable-cell[data-label="information complementaire"] {
            color: #dc2626 !important; /* Rouge */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* L√©g√®rement plus gras */
        }
        
        /* Patient name formatting - support line breaks */
        td.editable-cell[data-label="Nom_Pr√©nom"],
        td.editable-cell[data-label="nom prenom"],
        td.editable-cell[data-label="nom_pr√©nom"],
        td.editable-cell[data-label="nom et prenom"],
        td.editable-cell[data-label="nom et pr√©nom"],
        td.editable-cell[data-label="patient"],
        td.editable-cell[data-label="nom complet"],
        td.editable-cell[data-label="fullname"],
        td.editable-cell[data-label="name"] {
            white-space: pre-line;
            line-height: 1.2;
            vertical-align: top;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }
        
        td.editable-cell[data-label="DDN"]:empty::after { 
            content: 'JJ/MM/YYYY'; 
            color: var(--text-secondary); 
            font-weight: normal; 
        }
        
        /* Row selection */
        tr.selected-row { 
            background-color: #FEF3C7; 
        }

        /* Column text colors and font sizes for specific columns */
        #data-table td[data-label="Date de saisie"],
        #data-table td[data-label="PEC finale"],
        #data-table td[data-label="PEC initiale"],
        #data-table td[data-label="Diagnostic_initial"] {
            color: #1a1a1a !important; /* Noir fonc√© */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* L√©g√®rement plus gras */
        }
        
        /* Numero_tel avec police standard (1.1rem) */
        #data-table td[data-label="Numero_tel"],
        #data-table td[data-label="numero_tel"] {
            color: #1a1a1a !important; /* Noir fonc√© */
            font-size: 1.1rem !important; /* Police standard */
            font-weight: 500 !important; /* L√©g√®rement plus gras */
        }
        
        /* Nom_Pr√©nom et DDN en gras */
        #data-table td[data-label="Nom_Pr√©nom"],
        #data-table td[data-label="DDN"] {
            color: #1a1a1a !important; /* Noir fonc√© */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 700 !important; /* Gras (bold) */
        }
        
        /* Information complementaire en rouge */
        #data-table td[data-label="Information complementaire"],
        #data-table td[data-label="information complementaire"] {
            color: #dc2626 !important; /* Rouge */
            font-size: 1.1rem !important; /* Police plus grande */
            font-weight: 500 !important; /* L√©g√®rement plus gras */
        }

        /* Column selection visuals */
        #data-table thead th.col-selected {
            outline: 3px solid var(--secondary-color);
            position: relative;
        }
        
        #data-table thead th.col-selected::after {
            content: '‚úì';
            position: absolute; 
            right: 6px; 
            top: 4px;
            font-weight: 700; 
            font-size: 0.8em; 
            color: var(--text-primary);
        }

        /* Safe areas for iOS/Android */
        body {
            padding-top: env(safe-area-inset-top, 0px);
            padding-bottom: env(safe-area-inset-bottom, 0px);
        }
        
        /* Mobile viewport height management */
        .mobile-viewport-height {
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            min-height: 100vh;
            min-height: 100dvh;
        }
        
        /* Mobile-specific viewport adjustments */
        @media (max-width: 768px) {
            body {
                overflow-x: hidden;
                position: fixed;
                width: 100%;
                height: 100%;
            }
            
            #table-container {
                height: 100vh;
                height: 100dvh;
                height: calc(var(--vh, 1vh) * 100);
                min-height: 100vh;
                min-height: 100dvh;
                min-height: calc(var(--vh, 1vh) * 100);
                overflow: hidden;
            }
            
            /* Optimiser pour la barre de navigation mobile */
            #fab-add {
                position: fixed;
                bottom: 16px;
                right: 16px;
                z-index: 1000;
            }
            
            /* S'assurer que le contenu ne d√©borde pas */
            .overflow-auto {
                overflow: auto !important;
                -webkit-overflow-scrolling: touch;
            }
            
            /* History bar responsive adjustments */
            #history-bar-container {
                padding: 0.5rem !important;
            }
            
            #history-bar-container button {
                font-size: 0.75rem !important;
                padding: 0.25rem 0.5rem !important;
                min-height: 2rem !important;
            }
            
            #history-bar-container .fa-solid {
                width: 0.875rem !important;
                height: 0.875rem !important;
            }
        }
        
        /* Small screen adjustments (sm breakpoint) */
        @media (max-width: 640px) {
            #history-bar-container {
                gap: 0.25rem !important;
            }
            
            #history-bar-container button {
                padding: 0.25rem 0.375rem !important;
                font-size: 0.7rem !important;
            }
        }
        
        /* History controls row styling */
        .flex.justify-between.items-center.mb-3 {
            gap: 1rem;
        }
        
        /* Toggle button container styling */
        .flex.justify-start {
            min-width: fit-content;
        }
        
        /* Minimal toggle button styling */
        #history-toggle-btn {
            transition: all 0.2s ease-in-out;
        }
        
        #history-toggle-btn:hover {
            transform: scale(1.05);
        }
        
        #history-toggle-btn:active {
            transform: scale(0.95);
        }
        
        /* Perfect centering for FontAwesome icons */
        #history-toggle-btn i {
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            text-align: center !important;
            line-height: 1 !important;
            width: 100% !important;
            height: 100% !important;
        }
        
        /* History bar container styling */
        #history-bar-container {
            flex: 1;
            min-width: 0;
            display: flex;
            justify-content: flex-end;
        }
        
        /* Reduced width container styling */
        #history-bar-container > div {
            max-width: 50%;
            min-width: fit-content;
        }
        
        /* Responsive adjustments for history controls */
        @media (max-width: 768px) {
            .flex.justify-between.items-center.mb-3 {
                flex-direction: row;
                align-items: center;
                gap: 0.5rem;
            }
            
            .flex.justify-start {
                align-self: flex-start;
            }
            
            #history-bar-container {
                align-self: flex-end;
            }
            
            /* Ensure toggle button is always visible and clickable on mobile */
            #history-toggle-btn {
                min-width: 1.5rem;
                min-height: 1.5rem;
                z-index: 10;
            }
            
            /* Improve mobile touch targets */
            #history-bar-container button {
                min-height: 2.5rem;
                min-width: 2.5rem;
            }
        }
        
        /* Extra small screen adjustments */
        @media (max-width: 480px) {
            #history-bar-container {
                width: 100% !important;
                max-width: none !important;
            }
            
            #history-bar-container > div {
                width: 100% !important;
                max-width: none !important;
                justify-content: center;
            }
            
            /* Stack buttons vertically on very small screens */
            #history-bar-container .flex.flex-wrap {
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
            }
        }
        

        
        /* Current snapshot date display styling */
        #current-snapshot-date-display {
            white-space: nowrap;
            flex-shrink: 0;
            transition: all 0.2s ease-in-out;
        }
        
        #current-snapshot-date-display:hover {
            background-color: #f3f4f6;
            border-color: #9ca3af;
        }
        
        /* Mobile adjustments for date display */
        @media (max-width: 640px) {
            #current-snapshot-date-display {
                font-size: 0.7rem !important;
                padding: 0.25rem 0.375rem !important;
            }
            
            #current-snapshot-date-display .fa-solid {
                width: 0.75rem !important;
                height: 0.75rem !important;
            }
        }
        
        /* Focus styles for accessibility */
        .editable-cell:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: -2px;
            background-color: var(--bg-secondary);
            box-shadow: inset 0 0 0 1px var(--border-focus);
            color: #1a1a1a !important; /* Texte noir fonc√© quand on √©crit */
        }
        
        /* Styles de focus sp√©cifiques pour les colonnes importantes */
        .editable-cell[data-label="Date de saisie"]:focus,
        .editable-cell[data-label="PEC finale"]:focus,
        .editable-cell[data-label="PEC initiale"]:focus,
        .editable-cell[data-label="Diagnostic_initial"]:focus {
            color: #1a1a1a !important; /* Noir fonc√© maintenu en focus */
            font-size: 1.1rem !important; /* Police plus grande maintenue */
            font-weight: 500 !important; /* Gras maintenu */
        }
        
        /* Numero_tel avec police standard (1.1rem) m√™me en focus */
        .editable-cell[data-label="Numero_tel"]:focus,
        .editable-cell[data-label="numero_tel"]:focus {
            color: #1a1a1a !important; /* Noir fonc√© maintenu en focus */
            font-size: 1.1rem !important; /* Police standard maintenue */
            font-weight: 500 !important; /* Gras maintenu */
        }
        
        /* Nom_Pr√©nom et DDN en gras m√™me en focus */
        .editable-cell[data-label="Nom_Pr√©nom"]:focus,
        .editable-cell[data-label="DDN"]:focus {
            color: #1a1a1a !important; /* Noir fonc√© maintenu en focus */
            font-size: 1.1rem !important; /* Police plus grande maintenue */
            font-weight: 700 !important; /* Gras (bold) maintenu */
        }
        
        /* Information complementaire en rouge m√™me en focus */
        .editable-cell[data-label="Information complementaire"]:focus {
            color: #dc2626 !important; /* Rouge maintenu en focus */
            font-size: 1.1rem !important; /* Police plus grande maintenue */
            font-weight: 500 !important; /* Gras maintenu */
        }
        
        /* Texte noir fonc√© pour toutes les cellules √©ditables (sauf Information complementaire) */
        .editable-cell:not([data-label="Information complementaire"]) {
            color: #1a1a1a !important;
        }
        
        /* S'assurer que le texte reste noir fonc√© m√™me apr√®s avoir √©crit (sauf Information complementaire) */
        .editable-cell:not(:empty):not([data-label="Information complementaire"]) {
            color: #1a1a1a !important;
        }
        
        /* Loading states */
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        
        /* Modern form input styles */
        input[type="text"], 
        input[type="password"], 
        input[type="email"], 
        input[type="number"],
        input[type="date"],
        select {
            padding: 0.75rem 1rem;
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-size: 1rem;
            transition: var(--transition);
            background-color: var(--bg-primary);
        }
        
        input[type="text"]:focus,
        input[type="password"]:focus,
        input[type="email"]:focus,
        input[type="number"]:focus,
        input[type="date"]:focus,
        select:focus {
            outline: none;
            border-color: var(--border-focus);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Style pour le champ mot de passe en erreur */
        .password-error {
            border-color: var(--danger-color) !important;
            background-color: rgba(220, 38, 38, 0.05) !important;
            box-shadow: 0 0 0 3px rgba(220, 38, 38, 0.1) !important;
        }
        
        .password-error::placeholder {
            color: var(--danger-color);
        }
        
        /* Enhanced button styles */
        button {
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        /* Button hover effects */
        button:hover::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        button:hover::before {
            width: 300px;
            height: 300px;
        }
        
        /* Enhanced message box */
        .message-box {
            backdrop-filter: blur(10px);
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Login container enhancements */
        #login-container {
            animation: fadeInUp 0.6s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Table container animations */
        #table-container {
            animation: fadeIn 0.5s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Responsive table */
        @media (max-width: 768px) {
            #data-table {
                font-size: 0.75rem;
            }
            
            #data-table th, #data-table td {
                padding: 0.25rem 0.5rem;
            }
            
            /* Emp√™cher que le bouton de couleur s'√©crase en largeur sur les √©crans moyens */
            #row-color-picker {
                min-width: 32px !important;
                min-height: 32px !important;
                width: 32px !important;
                height: 32px !important;
                flex-shrink: 0 !important;
            }
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col h-screen overflow-hidden text-sm md:text-base lg:text-lg">

    <div id="message-box" class="message-box hidden"><p id="message-text" class="font-bold"></p></div>

    <!-- Login container -->
    <div id='login-container' class="bg-white p-8 md:p-10 lg:p-12 rounded-xl shadow-lg w-full max-w-md mx-auto my-auto flex flex-col items-center space-y-4 md:space-y-6 transition-all duration-300 ease-in-out hidden">
        <h2 class="text-2xl md:text-3xl lg:text-4xl font-bold text-gray-800">Acc√©der au tableau</h2>
        <input type='password' id='password' placeholder='Mot de passe (Appuyez sur Entr√©e)' class="w-full p-3 md:p-4 lg:p-5 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 transition-colors">
        <div class="flex items-center space-x-2 w-full">
            <input type='checkbox' id='toggle-password' class="w-4 h-4 md:w-5 md:h-5 text-green-600 bg-gray-100 border-gray-300 rounded focus:ring-green-500">
            <label for="toggle-password" class="text-sm md:text-base font-medium text-gray-700">Afficher le mot de passe</label>
        </div>
        <button onclick='checkPassword()' class="w-full bg-green-500 text-white font-bold p-3 md:p-4 lg:p-5 rounded-lg shadow-md hover:bg-green-600 transition-colors">Valider</button>
        
        <!-- Indicateur des raccourcis clavier -->
        <div class="text-center text-xs text-gray-500 mt-2">
            <p>üí° <strong>Raccourcis :</strong> Entr√©e (Valider) ‚Ä¢ G (Galerie) ‚Ä¢ N (Nouvelle ligne)</p>
        </div>
        
        <p id='error-message' class="text-red-500 font-medium text-sm md:text-base"></p>
    </div>

    <!-- Bouton d'ajout - visible sur tous les √©crans (en dehors du conteneur de tableau) -->
        <button id="fab-add"
                class="bg-green-500 text-white font-bold hover:bg-green-600 transition-colors"
                onclick="addRow()" title="Ajouter une nouvelle ligne" aria-label="Ajouter">
          <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 20 20">
            <path d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"/>
          </svg>
        </button>
        
    <!-- Table container -->
    <div id='table-container' class="bg-white relative p-2 md:p-4 lg:p-6 pt-4 md:pt-4 lg:pt-6 rounded-xl w-full flex-grow overflow-y-auto hidden transition-all duration-300 ease-in-out flex flex-col m-2 shadow-xl">
        <div class="flex flex-col md:flex-row items-start md:items-center justify-between mb-2 p-2 bg-gradient-to-r from-gray-50 to-gray-100 rounded-lg border border-gray-200">
            <div class="flex-grow">
                <div class="flex flex-wrap items-center gap-2 mb-1">
                    <h2 id="staff-title" class="text-lg md:text-xl font-bold text-gray-800 tracking-tight">S-T</h2>
                
                <!-- Box affichant le nombre de lignes - √† c√¥t√© du titre -->
                <div id="row-count-display" class="flex items-center justify-center px-2 py-1 bg-gray-100 border border-gray-300 rounded-lg text-gray-700 text-lg md:text-xl font-medium min-w-12 ml-2">
                    <span>N=</span>
                    <span id="row-count-number" class="ml-1 font-bold">0</span>
                </div>
                    <span id="sync-status" class="sync-pending-animation px-2 py-1 rounded-full text-xs font-semibold border-2 bg-white shadow-sm">
                        <span class="sync-text">Initialisation...</span>
                        <i class="sync-icon fa-solid fa-check hidden"></i>
                    </span>
                </div>

            </div>
        </div>

        <div id="error-display" class="my-2 text-red-600 font-bold hidden p-2 bg-red-50 rounded-lg border-l-4 border-red-400 text-sm md:text-base"></div>



        <!-- History Controls Row - Toggle button and history buttons on same level -->
        <div class="flex justify-between items-center mb-3">
            <!-- Toggle button container -->
            <div class="w-4 h-4">
                <button id="history-toggle-btn" onclick="toggleHistoryBarSimple()" title="Fermer/Ouvrir la barre d'historique" aria-label="Toggle historique" class="bg-gray-400 text-white p-0 rounded hover:bg-gray-500 transition-colors w-4 h-4 flex items-center justify-center">
                    <i id="history-toggle-icon" class="fa-solid fa-plus w-2 h-2 flex items-center justify-center text-center leading-none"></i>
                </button>
            </div>

            <!-- History Bar Container - This is what gets toggled -->
            <div id="history-bar-container" class="flex justify-end">
                <!-- All buttons in one responsive row with reduced width -->
                <div class="flex flex-wrap items-center gap-2 p-3 bg-blue-50 rounded-lg border border-blue-200 w-1/2">
                    <!-- Navigation buttons - Hidden on small screens -->
                    <div class="hidden md:flex items-center gap-2">
                        <button id="history-back" onclick="goToPreviousSnapshot()" disabled title="Snapshot pr√©c√©dent" aria-label="Snapshot pr√©c√©dent" class="bg-blue-500 text-white px-2 py-1 rounded text-xs hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center">
                            <i class="fa-solid fa-chevron-left w-3 h-3 mr-1"></i>
                            Pr√©c√©dent
                        </button>
            
                        <button id="history-date" onclick="openDatePicker()" title="Choisir une date de snapshot" aria-label="Choisir une date" class="bg-blue-600 text-white px-2 py-1 rounded text-xs hover:bg-blue-700 transition-colors font-medium flex items-center justify-center">
                            <span id="current-date-text">Donn√©es en direct</span>
                            <i class="fa-solid fa-calendar ml-1 w-3 h-3"></i>
                        </button>
            
                        <button id="history-next" onclick="goToNextSnapshot()" disabled title="Snapshot suivant" aria-label="Snapshot suivant" class="bg-blue-500 text-white px-2 py-1 rounded text-xs hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center">
                            <i class="fa-solid fa-chevron-right w-3 h-3 ml-1"></i>
                            Suivant
                        </button>
                    </div>
                    
                    <!-- Action buttons - Always visible, smaller on mobile -->
                    <button onclick="refreshTableData()" title="Actualiser le tableau avec les donn√©es les plus r√©centes" aria-label="Actualiser" class="bg-green-600 text-white px-2 py-1 rounded text-xs hover:bg-green-700 transition-colors font-medium flex items-center justify-center">
                        <i class="fa-solid fa-arrows-rotate mr-1 w-3 h-3"></i>
                        <span class="hidden sm:inline">Actualiser</span>
                        <span class="sm:hidden">Act</span>
                    </button>
                    
                    <!-- Calendar dropdown for snapshot dates -->
                    <div class="relative">
                        <button id="snapshot-calendar-btn" onclick="toggleSnapshotCalendar()" title="Choisir une date de snapshot" aria-label="Calendrier des snapshots" class="bg-indigo-600 text-white px-2 py-1 rounded text-xs hover:bg-indigo-700 transition-colors font-medium flex items-center justify-center">
                            <i class="fa-solid fa-calendar-days mr-1 w-3 h-3"></i>
                            <span id="calendar-btn-text" class="hidden sm:inline">Calendrier</span>
                            <span class="sm:hidden">Cal</span>
                        </button>
                        
                        <!-- Calendar dropdown -->
                        <div id="snapshot-calendar-dropdown" class="hidden absolute top-full left-0 mt-2 bg-white border border-gray-300 rounded-lg shadow-lg z-50 min-w-64 max-h-96 overflow-y-auto">
                            <div class="p-3 border-b border-gray-200">
                                <h3 class="text-sm font-semibold text-gray-700 mb-2">üìÖ Snapshots disponibles</h3>
                                <div class="text-xs text-gray-500">Cliquez sur une date pour charger le snapshot</div>
                            </div>
                            <div id="snapshot-dates-list" class="p-2">
                                <!-- Dates will be populated here -->
                            </div>
                        </div>
                    </div>

                    <!-- Current Snapshot Date Display - Next to calendar button -->
                    <div id="current-snapshot-date-display" class="flex items-center gap-1 px-2 py-1 bg-gray-100 border border-gray-300 rounded-md text-gray-700 text-xs font-medium ml-2">
                        <i class="fa-solid fa-calendar-day w-3 h-3 text-blue-600"></i>
                        <span id="current-snapshot-date-text">Donn√©es en direct</span>
                    </div>
                    

                </div>
            </div>
        </div>



        <div id="button-bar" class="flex flex-nowrap items-center gap-1 mb-3 p-1 bg-gray-50 rounded-lg border border-gray-200 overflow-x-auto">
            <button onclick='saveManually()' title="Sauvegarder (Cmd+Z/Ctrl+Z ou Cmd+S/Ctrl+S)" aria-label="Sauvegarder" class='bg-yellow-400 text-gray-800 p-1.5 rounded-lg hover:bg-yellow-500 transition-colors flex items-center justify-center w-7 h-7'>
                <i class="fa-solid fa-save w-3.5 h-3.5"></i>
            </button>
            <button id="undo-button" onclick="undo()" disabled title="Annuler (Cmd+Y / Ctrl+Y)" aria-label="Annuler" class="bg-gray-300 text-gray-700 p-1.5 rounded-lg hover:bg-gray-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-rotate-left w-3.5 h-3.5"></i>
            </button>
            <button id="redo-button" onclick="redo()" disabled title="R√©tablir (Cmd+Shift+Z / Ctrl+Y)" aria-label="R√©tablir" class="bg-gray-300 text-gray-700 p-1.5 rounded-lg hover:bg-gray-400 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-rotate-right w-3.5 h-3.5"></i>
            </button>
            

            <button onclick="downloadExcel()" title="Exporter en Excel" aria-label="Exporter en Excel" class="bg-green-600 text-white p-1.5 rounded-lg hover:bg-green-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-file-excel w-3.5 h-3.5"></i>
            </button>
            <button onclick="downloadPDF()" title="Exporter en PDF" aria-label="Exporter en PDF" class="bg-red-600 text-white p-1.5 rounded-lg hover:bg-red-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-file-pdf w-3.5 h-3.5"></i>
            </button>
            <button onclick="downloadImage()" title="Exporter en image (PNG)" aria-label="Exporter en image (PNG)" class="bg-purple-600 text-white p-1.5 rounded-lg hover:bg-purple-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-image w-3.5 h-3.5"></i>
            </button>
            <button onclick="document.getElementById('excel-input').click()" title="Importer depuis Excel" aria-label="Importer depuis Excel" class="bg-blue-600 text-white p-1.5 rounded-lg hover:bg-blue-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-upload w-3.5 h-3.5"></i>
            </button>
            <input id="excel-input" type="file" accept=".xlsx,.xls,.csv" class="hidden" onchange="importExcelFromFile(this.files[0])" />
            
            <!-- Bouton Galerie d'images -->
            <button onclick="openSimpleGallery()" title="Galerie d'images (G)" aria-label="Galerie d'images" class="bg-indigo-600 text-white p-1.5 rounded-lg hover:bg-indigo-700 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-images w-3.5 h-3.5"></i>
            </button>
            <button onclick="zoomOut()" title="R√©duire (‚àí)" aria-label="R√©duire" class="bg-gray-700 text-white p-1.5 rounded-lg hover:bg-gray-800 transition-colors flex items-center justify-center w-7 h-7">
                <i class="fa-solid fa-minus w-3.5 h-3.5"></i>
            </button>
            <button id="zoom-display" onclick="zoomReset()" title="R√©initialiser √† 100%" aria-label="R√©initialiser √† 100%" class="bg-gray-500 text-white px-2 py-2 rounded-lg hover:bg-gray-600 transition-colors text-xs w-8 h-8">100%</button>
            <button onclick="zoomIn()" title="Agrandir (+)" aria-label="Agrandir" class="bg-gray-700 text-white p-2 rounded-lg hover:bg-gray-800 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-plus w-4 h-4"></i>
            </button>
            <input id="row-color-picker"
                   type="color"
                   title="Choisir la couleur de surlignage des lignes"
                   class="w-8 h-8 p-1 border border-gray-300 rounded-lg cursor-pointer hover:border-gray-400 transition-colors" />
            <button onclick="clearAllRowColors()" title="Effacer toutes les couleurs" aria-label="Effacer toutes les couleurs" class="bg-gray-200 text-gray-800 p-2 rounded-lg hover:bg-gray-300 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-trash-can w-4 h-4"></i>
            </button>
            <button id="filter-colored-toggle"
                    onclick="toggleColoredFilter()"
                    title="Afficher seulement les lignes color√©es"
                    aria-label="Filtrer lignes color√©es"
                    class="bg-gray-200 text-gray-800 p-2 rounded-lg hover:bg-gray-300 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-filter w-4 h-4"></i>
            </button>
                        <button id="paint-mode-toggle"
                    onclick="cyclePaintMode()"
                    title="Mode de peinture: Auto/Colorer/Effacer (appuyez sur P pour changer)"
                    aria-label="Basculer le mode de peinture"
                    class="bg-gray-200 text-gray-800 p-2 rounded-lg hover:bg-gray-300 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-palette w-4 h-4"></i>
            </button>
            
            <!-- Bouton Mode Visualisation -->
            <button id="view-mode-toggle"
                    onclick="toggleViewMode()"
                    title="Basculer le mode visualisation (lecture seule)"
                    aria-label="Basculer le mode visualisation"
                    class="bg-blue-200 text-blue-800 p-2 rounded-lg hover:bg-blue-300 transition-colors flex items-center justify-center w-8 h-8">
                <i class="fa-solid fa-eye w-4 h-4"></i>
            </button>

        </div>

        <div class="overflow-auto w-full" style="max-width: 100vw; max-height: 85vh;">
            <table id='data-table' class="w-full text-left text-gray-500 text-xs md:text-sm lg:text-base">
                <thead class="text-xs text-white uppercase bg-green-700">
                    <tr>
                        <th scope="col" class="py-2 px-2 md:px-4 rounded-tl-lg frozen-column-header frozen-1">No</th>
                        <th scope="col" class="py-2 px-1 text-center">Effacer<br><input id="select-all" type="checkbox" class="align-middle"></th>
                        <th scope="col" class="py-2 px-2 md:px-4">Date de saisie</th>
                        <th scope="col" class="py-2 px-2 md:px-4">PEC finale</th>
                        <th scope="col" class="py-2 px-2 md:px-4">PEC initiale</th>
                        <th scope="col" class="py-2 px-2 md:px-4">Nom_Pr√©nom</th>
                        <th scope="col" class="py-2 px-2 md:px-4">DDN</th>
                        <th scope="col" class="py-2 px-2 md:px-4">Diagnostic_initial</th>
                        <th scope="col" class="py-2 px-2 md:px-4">information complementaire</th>
                        <th scope="col" class="py-2 px-2 md:px-4 rounded-tr-lg">Numero_tel</th>
                    </tr>
                </thead>
                <tbody id="table-body"></tbody>
                <tfoot class="bg-white border-t-2 border-gray-300">
                    <tr>
                        <td colspan="2" class="py-2 px-2">
                            <button class="bg-green-500 text-white font-bold p-2 rounded-lg hover:bg-green-600 transition-colors text-lg w-10 h-10 flex items-center justify-center mx-auto" onclick="addRow()" title="Ajouter une nouvelle ligne">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"/>
                                </svg>
                            </button>
                        </td>
                        <td colspan="8" class="bg-white"></td>
                    </tr>
                </tfoot>
            </table>
        </div>
        

        

        <div id="confirmation-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 h-full w-full hidden z-50">
            <div class="relative top-1/4 mx-auto p-5 border w-11/12 max-w-sm shadow-lg rounded-md bg-white">
                <div class="mt-3 text-center">
                    <h3 class="text-lg md:text-xl leading-6 font-medium text-gray-900" id="modal-message"></h3>
                    <div class="mt-4 flex justify-around">
                        <button id="modal-confirm-btn" class="px-4 py-2 bg-red-600 text-white text-base font-medium rounded-md w-24 shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500">Oui</button>
                        <button id="modal-cancel-btn" class="px-4 py-2 bg-gray-300 text-black text-base font-medium rounded-md w-24 shadow-sm hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500">Non</button>
                    </div>
                </div>
            </div>
        </div>


    </div>

    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Libs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>

    <!-- App -->
    <script type="module">
        // Configuration - In production, these should be environment variables
        const APP_CONFIG = { 
            password: 'p123', 
            version: '2.5.4-enter-on-login' 
        };
        
        const supabaseConfig = { 
            supabaseUrl: 'https://fiecugxopjxzqfdnaqsu.supabase.co', 
            supabaseAnonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ1MDU2NTcsImV4cCI6MjA3MDA4MTY1N30.xd9Thasg4r8Nrwxx5nFwyGB_ufPIvok4XB-78dilpsw', 
            supabaseServiceKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1NDUwNTY1NywiZXhwIjoyMDcwMDgxNjU3fQ.5m7nLHxHxOkxQf8maZis7Y7jynqu2dWqIzEbgWvOTcE',
            tableName: 'staffTable', 
            primaryKeyColumn: 'No' 
        };

        // Initialize Supabase client
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';
        const supabase = createClient(supabaseConfig.supabaseUrl, supabaseConfig.supabaseAnonKey);
        
        // Make Supabase globally available
        window.supabase = supabase;
        window.supabaseConfig = supabaseConfig;
        
        // Global state management
        const appState = { 
            isLoggedIn: false, 
            masterSource: 'supabase', 
            dataHash: null, 
            localData: null, 
            serverColumns: null 
        };
        
        // Make app state globally available
        window.appState = appState;
        
        // Application state variables
        let isDirty = false;
        let saveTimeout = null;
        let history = [];
        let historyDebounceTimeout = null;
        
        // ‚úÖ GLOBAL: Variables pour la capture et restauration du focus
        let capturedFocusState = null;
        let focusRestorationEnabled = true;
        
        // Persistent undo/redo stacks (per session)
        let operationHistory = []; // already-declared enhanced history (kept for clarity)
        let redoHistory = [];
        let isPerformingUndoRedo = false;
        let suppressRealtimeUntil = 0; // timestamp until which realtime updates are ignored
        let suppressAutosaveUntil = 0;  // timestamp until which autosave is paused
        let undoRedoSyncTimeout = null; // Timeout for automatic sync after undo/redo
        let isTyping = false;
        let lastEditAt = 0;
        let typingTimer = null;
        let isSyncing = false;
        let realtimeSubscription = null;
        let lastSaveTime = 0; // Timestamp de la derni√®re sauvegarde
        const REALTIME_COOLDOWN_MS = 2000; // 2 secondes de cooldown apr√®s sauvegarde
        
        // Enhanced undo system
        // operationHistory is declared above in the persistent stacks section
        let currentOperation = null; // Current operation being built
        let operationTimeout = null; // Timeout for operation completion
        
        // Excel-style operation types for undo/redo tracking
        const OPERATION_TYPES = {
            CELL_EDIT: 'cell_edit',           // Cell content modification
            ROW_INSERT: 'row_insert',         // Row insertion
            ROW_DELETE: 'row_delete',         // Row deletion (single or multiple)
            BULK_EDIT: 'bulk_edit'            // Multiple cell edits
        };
        
        // Only track real data changes (no colors, selections, or UI changes)
        const CONTENT_MODIFICATION_TYPES = [
            OPERATION_TYPES.CELL_EDIT,
            OPERATION_TYPES.ROW_INSERT,
            OPERATION_TYPES.ROW_DELETE,
            OPERATION_TYPES.BULK_EDIT
        ];
        
        // Cell edit grouping configuration
        const CELL_EDIT_GROUPING_DELAY = 1300; // 1.3 seconds to group typing edits
        let cellEditTimeout = null;
        let pendingCellEdit = null;
        
        // Excel-style cell edit tracking with grouping
        function trackCellEdit(cell, oldValue, newValue, columnLabel) {
            // Check if undo/redo is disabled
            if (snapshotMode === 'snapshot' || isViewMode) {
                return;
            }
            
            const row = cell.closest('tr');
            const rowKey = keyForRow(row);
            
            // Create cell edit data with stable addressing
            const cellEditData = {
                rowKey: rowKey,
                columnLabel: columnLabel,
                oldValue: oldValue,
                newValue: newValue,
                timestamp: Date.now()
            };
            
            // Clear existing timeout
            if (cellEditTimeout) {
                clearTimeout(cellEditTimeout);
            }
            
            // If we have a pending edit for the same cell, group them
            if (pendingCellEdit && 
                pendingCellEdit.rowKey === rowKey && 
                pendingCellEdit.columnLabel === columnLabel) {
                
                // Update the pending edit
                pendingCellEdit.newValue = newValue;
                pendingCellEdit.timestamp = Date.now();
                
                // Start operation if not already started
                if (!currentOperation || currentOperation.type !== OPERATION_TYPES.CELL_EDIT) {
                    startOperation(OPERATION_TYPES.CELL_EDIT, {
                        rowKey: rowKey,
                        columnLabel: columnLabel,
                        initialValue: pendingCellEdit.oldValue,
                        currentValue: newValue
                    });
                } else {
                    // Update existing operation
                    currentOperation.data.currentValue = newValue;
                    currentOperation.data.timestamp = Date.now();
                }
                
                // Clean: Removed debug log
            } else {
                // New cell edit - start fresh operation
                pendingCellEdit = cellEditData;
                
                startOperation(OPERATION_TYPES.CELL_EDIT, {
                    rowKey: rowKey,
                    columnLabel: columnLabel,
                    initialValue: oldValue,
                    currentValue: newValue
                });
                
                // Clean: Removed debug log
            }
            
            // Set timeout to complete operation after grouping delay
            cellEditTimeout = setTimeout(() => {
                if (currentOperation && currentOperation.type === OPERATION_TYPES.CELL_EDIT) {
                    // ENHANCED: Set suppression windows before completing operation
                    const SUPPRESSION_MS = 2000;
                    suppressRealtimeUntil = Date.now() + SUPPRESSION_MS;
                    suppressAutosaveUntil = Date.now() + SUPPRESSION_MS;
                    
                    // Clean: Removed debug log
                    
                    completeOperation();
                    pendingCellEdit = null;
                }
            }, CELL_EDIT_GROUPING_DELAY);
        }
        
        // Helper function to get column label for a cell
        function getColumnLabelForCell(cell) {
            const cellIndex = Array.from(cell.parentElement.cells).indexOf(cell);
            if (cellIndex >= 2) { // Skip No and Delete columns
                const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2);
                const headerIndex = cellIndex - 2;
                if (headers[headerIndex]) {
                    return headers[headerIndex].textContent;
                }
            }
            return 'Unknown Column';
        }
        
        // ENHANCED: Utility function to check if undo/redo operations are in progress
        function isUndoRedoInProgress() {
            return isPerformingUndoRedo || 
                   (currentOperation && currentOperation.type) ||
                   Date.now() < suppressAutosaveUntil ||
                   Date.now() < suppressRealtimeUntil;
        }
        
        // ENHANCED: Function to get current undo/redo status for debugging
        function getUndoRedoStatus() {
            return {
                isPerformingUndoRedo,
                hasCurrentOperation: !!(currentOperation && currentOperation.type),
                suppressAutosaveUntil: Date.now() < suppressAutosaveUntil,
                suppressRealtimeUntil: Date.now() < suppressRealtimeUntil,
                timeUntilAutosaveUnlock: Math.max(0, suppressAutosaveUntil - Date.now()),
                timeUntilRealtimeUnlock: Math.max(0, suppressRealtimeUntil - Date.now())
            };
        }
        
        // Autosave configuration
        const AUTOSAVE_DELAY_MS = 3000; // 3 seconds after last edit when idle
        let autosaveTicker = null;
        let lastShownCountdown = null;
        let lastFocusInfo = null;
        let lastCellPos = null;
        
        // Zoom functionality
        let zoomFactor = parseFloat(localStorage.getItem('zoomFactor') || '1');

        // Snapshot System State
        let snapshotMode = 'live'; // 'live' or 'snapshot'
        let currentSnapshotDate = null;
        let availableSnapshots = [];
        let currentSnapshotIndex = -1;
        
        // History bar visibility state (saved in localStorage)

        
        // Make snapshot system globally available
        window.snapshotMode = snapshotMode;
        window.currentSnapshotDate = currentSnapshotDate;
        window.availableSnapshots = availableSnapshots;
        window.currentSnapshotIndex = currentSnapshotIndex;

        window.realtimeSubscription = realtimeSubscription;
        
        // Make other important variables globally available
        window.isViewMode = false; // Will be updated in initializeApp
        window.isInitialLoad = true; // Will be set to false after initialization
        window.isRestoringFocus = false; // Flag to prevent edit events during focus restoration
        
        // Function to refresh calendar display
        function refreshSnapshotCalendar() {
            // Clean: Removed debug log
            populateSnapshotCalendar();
            updateHistoryNavigation();
        }
        
        // Function to clean storage and database completely
        async function cleanStorageAndDatabase() {
            try {
                // Clean: Removed debug log
                
                // First, clean the database
                const { error: dbError } = await supabase
                    .from('table_snapshots_index')
                    .delete()
                    .neq('id', '00000000-0000-0000-0000-000000000000');
                
                if (dbError) {
                    console.error('‚ùå Error cleaning database:', dbError);
                    return;
                }
                
                // Clean: Removed debug log
                
                // Then, clean the storage bucket
                const { data: storageFiles, error: listError } = await supabase.storage
                    .from('table-snapshots')
                    .list('', { limit: 1000 });
                
                if (listError) {
                    console.error('‚ùå Error listing storage files:', listError);
                    return;
                }
                
                if (storageFiles && storageFiles.length > 0) {
                    const fileNames = storageFiles.map(file => file.name);
                    // Clean: Removed debug log
                    
                    const { error: removeError } = await supabase.storage
                        .from('table-snapshots')
                        .remove(fileNames);
                    
                    if (removeError) {
                        console.error('‚ùå Error removing storage files:', removeError);
                    } else {
                        // Clean: Removed debug log
                    }
                } else {
                    // Clean: Removed debug log
                }
                
                // Create a fresh snapshot
                await createDemoSnapshot();
                
                showMessage('Storage et base de donn√©es compl√®tement nettoy√©s', 'success');
                
            } catch (err) {
                console.error('‚ùå Error cleaning storage and database:', err);
                showMessage('Erreur lors du nettoyage complet', 'error');
            }
        }
        
        // Add logging function
        window.log = function(message, level = 'info') {
            console.log(`[${level.toUpperCase()}] ${message}`);
        };

        
        // Row color management
        let currentRowColor = localStorage.getItem('rowColor') || '#FFF59D';
        let rowColorMap = {};
        let isRowPaintDragging = false;
        let rowPaintAction = 'color';
        let paintMode = localStorage.getItem('rowPaintMode') || 'auto';
        let showOnlyColored = false;
        let isViewMode = localStorage.getItem('viewMode') === 'true'; // Mode visualisation (lecture seule) - restaur√© depuis localStorage
        let isViewModeProtected = false; // Flag pour protection renforc√©e sur mobile
        
        // Protection globale: wrapper pour toutes les fonctions de sauvegarde
        function protectedSaveStateToHistory() {
            if (isViewMode && isMobile()) {
                console.log('üîí Global protection: saveStateToHistory BLOCKED');
                return;
            }
            return saveStateToHistory();
        }
        
        // Initialize from localStorage
        try { 
            lastFocusInfo = JSON.parse(localStorage.getItem('lastFocusInfo') || 'null'); 
            
            // Forcer l'affichage du bouton d'ajout au d√©marrage (en respectant le mode visualisation)
            const fabAdd = document.getElementById('fab-add');
            if (fabAdd) {
                fabAdd.style.display = 'flex';
                fabAdd.style.visibility = 'visible';
                
                if (isViewMode) {
                    // Mode visualisation : bouton visible mais d√©sactiv√©
                    fabAdd.style.opacity = '0.5';
                    fabAdd.style.pointerEvents = 'none';
                    fabAdd.style.cursor = 'not-allowed';
                    fabAdd.title = 'Mode visualisation actif - Ajout de lignes d√©sactiv√©';
                } else {
                    // Mode normal : bouton pleinement fonctionnel
                    fabAdd.style.opacity = '1';
                    fabAdd.style.pointerEvents = 'auto';
                    fabAdd.style.cursor = 'pointer';
                    fabAdd.title = 'Ajouter une nouvelle ligne';
                }
                
                // Clean: Removed debug log
            }
        } catch(_) { 
            lastFocusInfo = null; 
        }
        
        try { 
            lastCellPos = JSON.parse(localStorage.getItem('lastCellPos') || 'null'); 
        } catch(_) { 
            lastCellPos = null; 
        }
        
        try { 
            rowColorMap = JSON.parse(localStorage.getItem('rowColors') || '{}'); 
        } catch(_) { 
            rowColorMap = {}; 
        }

        // Excel-style operation tracking - only real data changes
        function startOperation(type, data = {}) {
            // Check if undo/redo is disabled
            if (snapshotMode === 'snapshot' || isViewMode) {
                // Clean: Removed debug log
                return;
            }
            
            // Only track operations that modify table content
            if (!CONTENT_MODIFICATION_TYPES.includes(type)) {
                // Clean: Removed debug log
                return;
            }
            
            // Clear any pending operations first
            if (currentOperation) {
                // Clean: Removed debug log
                completeOperation();
            }
            
            // Clear any operation timeout
            clearOperationTimeout();
            
            // Reset undo/redo sync timeout when starting new operations
            clearUndoRedoSyncTimeout();
            
            // For row operations, check if there are conflicting operations in history
            if (type === OPERATION_TYPES.ROW_INSERT || 
                type === OPERATION_TYPES.ROW_DELETE) {
                
                // Clean up any conflicting row operations in history
                const conflictingOps = operationHistory.filter(op => 
                    op.type === OPERATION_TYPES.ROW_INSERT || 
                    op.type === OPERATION_TYPES.ROW_DELETE
                );
                
                if (conflictingOps.length > 0) {
                    // Clean: Removed debug log
                    operationHistory = operationHistory.filter(op => 
                        op.type !== OPERATION_TYPES.ROW_INSERT && 
                        op.type !== OPERATION_TYPES.ROW_DELETE
                    );
                }
            }
            
            currentOperation = {
                type: type,
                data: data,
                timestamp: Date.now(),
                tableState: collectTableData(),
                rowColors: { ...rowColorMap }
            };
            
                            // Clean: Removed debug log
        }
        
        function addToOperation(data) {
            if (currentOperation && CONTENT_MODIFICATION_TYPES.includes(currentOperation.type)) {
                Object.assign(currentOperation.data, data);
                // Clean: Removed debug log
                
                // Excel-style: Clear redo stack on ANY modification
                redoHistory = [];
                                    // Clean: Removed debug log
            }
            persistHistoryStacks();
        }
        
        function completeOperation() {
            if (currentOperation) {
                // Only complete operations that modify table content
                if (!CONTENT_MODIFICATION_TYPES.includes(currentOperation.type)) {
                    // Clean: Removed debug log
                    currentOperation = null;
                    return;
                }
                
                // Add final table state
                currentOperation.finalState = collectTableData();
                currentOperation.finalRowColors = { ...rowColorMap };
                
                // Add to operation history
                operationHistory.push(currentOperation);
                
                // Excel-style: Clear redo stack on ANY new user modification
                redoHistory = [];
                // Clean: Removed debug log
                
                persistHistoryStacks();
                
                // Keep exactly 10 operations for circular history navigation
                if (operationHistory.length > 10) {
                    const toRemove = operationHistory.length - 10;
                    for (let i = 0; i < toRemove; i++) {
                        operationHistory.shift();
                    }
                    // Clean: Removed debug log
                }
                
                // Clean: Removed debug log
                
                // Also save to regular history for backward compatibility
                saveStateToHistory();
                
                currentOperation = null;
                updateUndoButtonState();
            }
        }
        
        function cancelOperation() {
            if (currentOperation) {
                // Clean: Removed debug log
                currentOperation = null;
            }
        }

        // Persist/restore undo/redo stacks in sessionStorage
        function persistHistoryStacks() {
            try {
                sessionStorage.setItem('operationHistory', JSON.stringify(operationHistory));
                sessionStorage.setItem('redoHistory', JSON.stringify(redoHistory));
            } catch(_) {}
        }
        function restoreHistoryStacks() {
            try {
                const ops = JSON.parse(sessionStorage.getItem('operationHistory') || '[]');
                const red = JSON.parse(sessionStorage.getItem('redoHistory') || '[]');
                if (Array.isArray(ops)) operationHistory = ops; else operationHistory = [];
                if (Array.isArray(red)) redoHistory = red; else redoHistory = [];
            } catch(_) {
                operationHistory = [];
                redoHistory = [];
            }
            updateUndoButtonState();
        }
        
        // Enhanced undo function with circular history of 10 states
        function undo() {
            if (operationHistory.length === 0) {
                log('Aucune op√©ration √† annuler.', 'info');
                return;
            }
            
            const lastOperation = operationHistory.pop();
            // Clean: Removed debug log
            
            // ENHANCED: Show detailed message about what is being undone
            const undoMessage = getDetailedOperationDescription(lastOperation, true);
            showMessage(undoMessage, 'info');
            
            try {
                isPerformingUndoRedo = true;
                // Clear any pending operations before undoing
                if (currentOperation) {
                    // Clean: Removed debug log
                    currentOperation = null;
                }
                clearOperationTimeout();
                
                // Restore table state - only if we have valid data
                if (lastOperation.tableState && lastOperation.tableState.rows && Array.isArray(lastOperation.tableState.rows) && lastOperation.tableState.rows.length > 0) {
                    // Clean: Removed debug log
                    loadTableData(lastOperation.tableState.rows);
                } else if (lastOperation.tableState && lastOperation.tableState.rows) {
                    console.warn(`‚ö†Ô∏è Table state has rows but they are invalid:`, lastOperation.tableState.rows);
                    // Don't restore if data is invalid - this prevents table clearing
                }
                
                // Special handling for cell edits - restore specific cell values using stable addressing
                if (lastOperation.type === OPERATION_TYPES.CELL_EDIT && lastOperation.data) {
                    const { rowKey, columnLabel, initialValue } = lastOperation.data;
                    if (rowKey && columnLabel) {
                        const tbody = document.getElementById('table-body');
                        const targetRow = Array.from(tbody.children).find(tr => keyForRow(tr) === rowKey);
                        
                        if (targetRow) {
                            const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                            const columnIndex = headers.indexOf(columnLabel);
                            const cells = Array.from(targetRow.querySelectorAll('td')).slice(2); // Skip No and Delete columns
                            
                            if (columnIndex >= 0 && cells[columnIndex]) {
                                cells[columnIndex].textContent = initialValue;
                                // Clean: Removed debug log
                            }
                        } else {
                            // Clean: Removed debug log
                        }
                    }
                }
                
                // Special handling for row deletions - restore rows in place
                if (lastOperation.type === OPERATION_TYPES.ROW_DELETE && lastOperation.data) {
                    const { deletedRows, rowData, rowNumbers } = lastOperation.data;
                    // Clean: Removed debug log
                    
                    if (rowData && rowData.length > 0) {
                        const tbody = document.getElementById('table-body');
                        const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                        
                        rowData.forEach((rowDataItem, index) => {
                            const newRow = document.createElement('tr');
                            newRow.className = 'bg-white hover:bg-gray-100 transition-colors cursor-pointer';
                            
                            // Create row number cell
                            const numCell = document.createElement('td');
                            numCell.textContent = rowNumbers ? rowNumbers[index] : (tbody.children.length + 1);
                            numCell.className = 'py-2 px-2 md:px-4 font-bold text-gray-800 whitespace-nowrap cursor-pointer frozen-column frozen-1';
                            numCell.setAttribute('data-label', 'No');
                            newRow.appendChild(numCell);
                            
                            // Create delete/selection cell
                            newRow.appendChild(createDeleteCell(newRow));
                            
                            // Create data cells
                            headers.forEach(header => {
                                const value = rowDataItem[header] || '';
                                newRow.appendChild(createEditableCell(header, value));
                            });
                            
                            // Insert at original position if possible
                            if (rowNumbers && rowNumbers[index]) {
                                const targetPosition = Math.min(rowNumbers[index] - 1, tbody.children.length);
                                if (targetPosition >= 0) {
                                    tbody.insertBefore(newRow, tbody.children[targetPosition]);
                                } else {
                                    tbody.appendChild(newRow);
                                }
                            } else {
                                tbody.appendChild(newRow);
                            }
                        });
                        
                        // Renumber rows after restoration
                        Array.from(tbody.children).forEach((tr, idx) => {
                            const noCell = tr.querySelector('td:first-child');
                            if (noCell) noCell.textContent = idx + 1;
                        });
                        
                        updateRowCount();
                        // Clean: Removed debug log
                    }
                }
                
                // Special handling for bulk edits
                if (lastOperation.type === OPERATION_TYPES.BULK_EDIT) {
                    if (lastOperation.data && lastOperation.data.edits) {
                        // Type 1: Bulk edits avec liste de modifications individuelles
                        // Clean: Removed debug log
                        const tbody = document.getElementById('table-body');
                        const rows = Array.from(tbody.children);
                        const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                        
                        lastOperation.data.edits.forEach(edit => {
                            if (edit.rowKey && edit.columnLabel) {
                                const targetRow = Array.from(tbody.children).find(tr => keyForRow(tr) === edit.rowKey);
                                if (targetRow) {
                                    const cells = Array.from(targetRow.querySelectorAll('td')).slice(2);
                                    const columnIndex = headers.indexOf(edit.columnLabel);
                                    if (columnIndex >= 0 && cells[columnIndex]) {
                                        cells[columnIndex].textContent = edit.initialValue;
                                        // Clean: Removed debug log
                                    }
                                }
                            }
                        });
                    } else if (lastOperation.tableState) {
                        // Type 2: Bulk edit avec √©tat complet du tableau
                        // Clean: Removed debug log
                        
                        // Sauvegarder l'√©tat actuel pour le redo si ce n'est pas d√©j√† fait
                        if (!lastOperation.finalState) {
                            lastOperation.finalState = collectTableData();
                        }
                        
                        loadTableData(lastOperation.tableState);
                    }
                }
                
                // Restore row colors
                if (lastOperation.rowColors) {
                    rowColorMap = { ...lastOperation.rowColors };
                    persistRowColors();
                    
                    // Apply colors to visible rows
                    Array.from(document.querySelectorAll('#table-body tr')).forEach(tr => {
                        const k = keyForRow(tr);
                        const c = rowColorMap[k];
                        if (c && c !== '') {
                            setRowColor(tr, c);
                        }
                    });
                }
                
                // Don't remove operations from history - just push to redo stack
                // This allows proper undo/redo cycling
                // Clean: Removed debug log

                // Push undone operation to redo stack
                redoHistory.push(lastOperation);
                
                // Keep redo stack limited to 10 operations for circular navigation
                if (redoHistory.length > 10) {
                    const toRemove = redoHistory.length - 10;
                    for (let i = 0; i < toRemove; i++) {
                        redoHistory.shift();
                    }
                    // Clean: Removed debug log
                }
                
                persistHistoryStacks();
                
                log(`Op√©ration '${lastOperation.type}' annul√©e avec succ√®s.`, 'success');
                updateUndoButtonState();
                
                // ENHANCED: Schedule automatic sync after undo operation with extended suppression
                // Extended suppression windows to prevent conflicts with autosave/realtime
                const SUPPRESSION_MS = 3000; // Increased from 2000ms to 3000ms
                const AUTOSAVE_SUPPRESSION_MS = 4000; // Separate, longer suppression for autosave
                
                suppressRealtimeUntil = Date.now() + SUPPRESSION_MS;
                suppressAutosaveUntil = Date.now() + AUTOSAVE_SUPPRESSION_MS;
                
                // Clean: Removed debug log
                
                if (typeof scheduleUndoRedoSync === 'function') {
                    clearUndoRedoSyncTimeout();
                    undoRedoSyncTimeout = setTimeout(() => {
                        if (!isPerformingUndoRedo) {
                            // Clean: Removed debug log
                            // Force manual save to bypass conflict checks
                            syncToMaster(true, true);
                            undoRedoSyncTimeout = null;
                        }
                    }, 800); // Increased delay from 500ms to 800ms for better conflict prevention
                }
                
            } catch (error) {
                console.error('‚ùå Error during undo:', error);
                log('Erreur lors de l\'annulation.', 'error');
            } finally {
                isPerformingUndoRedo = false;
            }
        }

        // Redo function with circular history of 10 states
        function redo() {
            if (redoHistory.length === 0) {
                log('Aucune op√©ration √† r√©tablir.', 'info');
                return;
            }
            
            const op = redoHistory.pop();
            // Clean: Removed debug log
            
            // ENHANCED: Show detailed message about what is being redone
            const redoMessage = getDetailedOperationDescription(op, false);
            showMessage(redoMessage, 'info');
            try {
                isPerformingUndoRedo = true;
                clearOperationTimeout();
                
                // Re-apply the final state of the operation - only if we have valid data
                if (op.finalState && op.finalState.rows && Array.isArray(op.finalState.rows) && op.finalState.rows.length > 0) {
                    // Clean: Removed debug log
                    loadTableData(op.finalState.rows);
                } else if (op.finalState && op.finalState.rows) {
                    console.warn(`‚ö†Ô∏è Final state has rows but they are invalid:`, op.finalState.rows);
                    // Don't restore if data is invalid - this prevents table clearing
                }
                
                // Special handling for cell edits - restore final cell values using stable addressing
                if (op.type === OPERATION_TYPES.CELL_EDIT && op.data) {
                    const { rowKey, columnLabel, currentValue } = op.data;
                    if (rowKey && columnLabel && currentValue) {
                        const tbody = document.getElementById('table-body');
                        const targetRow = Array.from(tbody.children).find(tr => keyForRow(tr) === rowKey);
                        
                        if (targetRow) {
                            const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                            const columnIndex = headers.indexOf(columnLabel);
                            const cells = Array.from(targetRow.querySelectorAll('td')).slice(2); // Skip No and Delete columns
                            
                            if (columnIndex >= 0 && cells[columnIndex]) {
                                cells[columnIndex].textContent = currentValue;
                                // Clean: Removed debug log
                            }
                        } else {
                            // Clean: Removed debug log
                        }
                    }
                }
                
                // Special handling for row deletions - re-delete rows
                if (op.type === OPERATION_TYPES.ROW_DELETE && op.data) {
                    const { deletedRows, rowKeys } = op.data;
                    // Clean: Removed debug log
                    
                    if (rowKeys && rowKeys.length > 0) {
                        const tbody = document.getElementById('table-body');
                        const rowsToDelete = Array.from(tbody.children).filter(tr => 
                            rowKeys.includes(keyForRow(tr))
                        );
                        
                        if (rowsToDelete.length > 0) {
                            rowsToDelete.forEach(row => row.remove());
                            
                            // Renumber remaining rows
                            Array.from(tbody.children).forEach((tr, idx) => {
                                const noCell = tr.querySelector('td:first-child');
                                if (noCell) noCell.textContent = idx + 1;
                            });
                            
                            updateRowCount();
                            // Clean: Removed debug log
                        }
                    }
                }
                
                // Special handling for bulk edits
                if (op.type === OPERATION_TYPES.BULK_EDIT) {
                    if (op.data && op.data.edits) {
                        // Type 1: Bulk edits avec liste de modifications individuelles
                        // Clean: Removed debug log
                        const tbody = document.getElementById('table-body');
                        const rows = Array.from(tbody.children);
                        const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                        
                        op.data.edits.forEach(edit => {
                            if (edit.rowKey && edit.columnLabel) {
                                const targetRow = Array.from(tbody.children).find(tr => keyForRow(tr) === edit.rowKey);
                                if (targetRow) {
                                    const cells = Array.from(targetRow.querySelectorAll('td')).slice(2);
                                    const columnIndex = headers.indexOf(edit.columnLabel);
                                    if (columnIndex >= 0 && cells[columnIndex]) {
                                        cells[columnIndex].textContent = edit.currentValue;
                                        // Clean: Removed debug log
                                    }
                                }
                            }
                        });
                    } else if (op.finalState) {
                        // Type 2: Bulk edit avec √©tat complet du tableau
                        // Clean: Removed debug log
                        loadTableData(op.finalState);
                    }
                }
                
                if (op.finalRowColors) {
                    rowColorMap = { ...op.finalRowColors };
                    persistRowColors();
                    Array.from(document.querySelectorAll('#table-body tr')).forEach(tr => {
                        const k = keyForRow(tr);
                        const c = rowColorMap[k];
                        if (c && c !== '') setRowColor(tr, c);
                    });
                }
                
                // After redoing, push back to operation history
                operationHistory.push(op);
                persistHistoryStacks();
                updateUndoButtonState();
                
                log('Op√©ration r√©tablie.', 'success');
                
                // ENHANCED: Schedule automatic sync after redo operation with extended suppression
                // Extended suppression windows to prevent conflicts with autosave/realtime
                const SUPPRESSION_MS = 3000; // Increased from 2000ms to 3000ms
                const AUTOSAVE_SUPPRESSION_MS = 4000; // Separate, longer suppression for autosave
                
                suppressRealtimeUntil = Date.now() + SUPPRESSION_MS;
                suppressAutosaveUntil = Date.now() + AUTOSAVE_SUPPRESSION_MS;
                
                // Clean: Removed debug log
                
                if (typeof scheduleUndoRedoSync === 'function') {
                    clearUndoRedoSyncTimeout();
                    undoRedoSyncTimeout = setTimeout(() => {
                        if (!isPerformingUndoRedo) {
                            // Clean: Removed debug log
                            // Force manual save to bypass conflict checks
                            syncToMaster(true, true);
                            undoRedoSyncTimeout = null;
                        }
                    }, 800); // Increased delay from 500ms to 800ms for better conflict prevention
                }
                
            } catch (e) {
                console.error('‚ùå Error during redo:', e);
                log('Erreur lors du r√©tablissement.', 'error');
            } finally {
                isPerformingUndoRedo = false;
            }
        }
        

        
        // ENHANCED: Function to get detailed operation description for display
        function getOperationDescription(operation) {
            switch (operation.type) {
                case OPERATION_TYPES.CELL_EDIT:
                    const cellInfo = operation.data.columnLabel || 'cellule';
                    const rowInfo = operation.data.rowKey ? `ligne ${operation.data.rowKey}` : '';
                    const oldValue = operation.data.initialValue || '';
                    const newValue = operation.data.currentValue || '';
                    if (oldValue && newValue) {
                        return `Modification: ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''} - "${oldValue}" ‚Üí "${newValue}"`;
                    }
                    return `Modification: ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''}`;
                case OPERATION_TYPES.ROW_INSERT:
                    return 'Insertion de ligne';
                case OPERATION_TYPES.ROW_DELETE:
                    if (operation.data.deletedRows && operation.data.deletedRows > 1) {
                        return `Suppression de ${operation.data.deletedRows} ligne(s)`;
                    }
                    return 'Suppression de ligne';
                case OPERATION_TYPES.BULK_EDIT:
                    if (operation.data.edits && operation.data.edits.length > 0) {
                        return `Modifications en lot: ${operation.data.edits.length} cellule(s) modifi√©e(s)`;
                    }
                    return 'Modifications en lot';
                default:
                    return 'Op√©ration';
            }
        }
        
        // ENHANCED: Function to get detailed operation description for undo/redo messages
        function getDetailedOperationDescription(operation, isUndo = true) {
            switch (operation.type) {
                case OPERATION_TYPES.CELL_EDIT:
                    const cellInfo = operation.data.columnLabel || 'cellule';
                    const rowInfo = operation.data.rowKey ? `ligne ${operation.data.rowKey}` : '';
                    const oldValue = operation.data.initialValue || '';
                    const newValue = operation.data.currentValue || '';
                    
                    if (isUndo) {
                        if (oldValue && newValue) {
                            return `üîÑ Annulation: ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''} - "${newValue}" ‚Üí "${oldValue}"`;
                        }
                        return `üîÑ Annulation: modification de ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''}`;
                    } else {
                        if (oldValue && newValue) {
                            return `‚è© R√©tablissement: ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''} - "${oldValue}" ‚Üí "${newValue}"`;
                        }
                        return `‚è© R√©tablissement: modification de ${cellInfo}${rowInfo ? ` (${rowInfo})` : ''}`;
                    }
                    
                case OPERATION_TYPES.ROW_INSERT:
                    if (isUndo) {
                        return `üîÑ Annulation: suppression de la ligne ins√©r√©e`;
                    } else {
                        return `‚è© R√©tablissement: insertion de ligne`;
                    }
                    
                case OPERATION_TYPES.ROW_DELETE:
                    if (operation.data.deletedRows && operation.data.deletedRows > 1) {
                        if (isUndo) {
                            return `üîÑ Annulation: restauration de ${operation.data.deletedRows} ligne(s) supprim√©e(s)`;
                        } else {
                            return `‚è© R√©tablissement: suppression de ${operation.data.deletedRows} ligne(s)`;
                        }
                    } else {
                        if (isUndo) {
                            return `üîÑ Annulation: restauration de la ligne supprim√©e`;
                        } else {
                            return `‚è© R√©tablissement: suppression de ligne`;
                        }
                    }
                    
                case OPERATION_TYPES.BULK_EDIT:
                    if (operation.data.edits && operation.data.edits.length > 0) {
                        if (isUndo) {
                            return `üîÑ Annulation: restauration de ${operation.data.edits.length} modification(s) de cellule(s)`;
                        } else {
                            return `‚è© R√©tablissement: ${operation.data.edits.length} modification(s) de cellule(s)`;
                        }
                    } else {
                        if (isUndo) {
                            return `üîÑ Annulation: restauration des modifications en lot`;
                        } else {
                            return `‚è© R√©tablissement: modifications en lot`;
                        }
                    }
                    
                default:
                    if (isUndo) {
                        return `üîÑ Annulation: ${operation.type}`;
                    } else {
                        return `‚è© R√©tablissement: ${operation.type}`;
                    }
            }
        }
        
        // Clean: Removed debug function for production
        
        // Expose undo/redo functions globally so buttons can access them
        window.undo = undo;
        window.redo = redo;
        window.getDetailedOperationDescription = getDetailedOperationDescription;
        
        // Function to clear operation timeout
        function clearOperationTimeout() {
            if (operationTimeout) {
                clearTimeout(operationTimeout);
                operationTimeout = null;
            }
        }
        
        // Function to schedule automatic sync after undo/redo operations
        function scheduleUndoRedoSync() {
            // Clear any existing timeout
            if (undoRedoSyncTimeout) {
                clearTimeout(undoRedoSyncTimeout);
            }
            
            // Schedule sync after 500ms of user inactivity
            undoRedoSyncTimeout = setTimeout(() => {
                if (!isPerformingUndoRedo) {
                    // Clean: Removed debug log
                    syncToMaster(true);
                    undoRedoSyncTimeout = null;
                }
            }, 500);
        }
        
        // Function to group multiple cell edits into a single operation
        function groupCellEdits() {
            if (currentOperation && currentOperation.type === OPERATION_TYPES.CELL_EDIT) {
                // If we have multiple cell edits, group them into a bulk edit
                if (currentOperation.data.editCount > 1) {
                    currentOperation.type = OPERATION_TYPES.BULK_EDIT;
                    currentOperation.data.description = `${currentOperation.data.editCount} modifications de cellules`;
                    // Clean: Removed debug log
                }
            }
        }
        
        // Function to clear undo/redo sync timeout
        function clearUndoRedoSyncTimeout() {
            if (undoRedoSyncTimeout) {
                clearTimeout(undoRedoSyncTimeout);
                undoRedoSyncTimeout = null;
            }
        }
        
        // Handle page unload to complete pending operations
        window.addEventListener('beforeunload', () => {
            if (currentOperation) {
                completeOperation();
            }
            clearOperationTimeout();
            clearUndoRedoSyncTimeout();
            
            // Cleanup all timers to prevent infinite loops
            cleanupAllTimers();
        });
        
        // Handle page visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && currentOperation) {
                completeOperation();
            }
            clearUndoRedoSyncTimeout();
        });
        
        // Function to reset operation history (useful for testing)
        function resetOperationHistory() {
            operationHistory = [];
            if (currentOperation) {
                currentOperation = null;
            }
            clearOperationTimeout();
            updateUndoButtonState();
            // Clean: Removed debug log
        }
        
        // Function to safely start new operations after undo
        function safeStartOperation(type, data = {}) {
            // Clear any pending operations
            if (currentOperation) {
                completeOperation();
            }
            
            // Clean up conflicting operations
            if (type === OPERATION_TYPES.ROW_ADD || 
                type === OPERATION_TYPES.ROW_DELETE || 
                type === OPERATION_TYPES.MULTIPLE_ROWS_DELETE) {
                
                operationHistory = operationHistory.filter(op => 
                    op.type !== OPERATION_TYPES.ROW_ADD && 
                    op.type !== OPERATION_TYPES.ROW_DELETE && 
                    op.type !== OPERATION_TYPES.MULTIPLE_ROWS_DELETE
                );
            }
            
            startOperation(type, data);
        }
        
        // Expose functions globally for debugging
        window.resetOperationHistory = resetOperationHistory;
        window.safeStartOperation = safeStartOperation;
        window.updateRowCount = updateRowCount;
        
        // Fonction pour forcer l'affichage du bouton d'ajout
        window.forceFabAddVisible = function() {
            const fabAdd = document.getElementById('fab-add');
            if (fabAdd) {
                fabAdd.style.display = 'flex';
                fabAdd.style.visibility = 'visible';
                
                if (isViewMode) {
                    // Mode visualisation : bouton visible mais d√©sactiv√©
                    fabAdd.style.opacity = '0.5';
                    fabAdd.style.pointerEvents = 'none';
                    fabAdd.style.cursor = 'not-allowed';
                    fabAdd.title = 'Mode visualisation actif - Ajout de lignes d√©sactiv√©';
                } else {
                    // Mode normal : bouton pleinement fonctionnel
                    fabAdd.style.opacity = '1';
                    fabAdd.style.pointerEvents = 'auto';
                    fabAdd.style.cursor = 'pointer';
                    fabAdd.title = 'Ajouter une nouvelle ligne';
                }
                
                // Clean: Removed debug log
                return true;
            } else {
                console.error('‚ùå FAB add button not found');
                return false;
            }
        };
        
        // Utility functions
        function log(message, type = 'info') { 
            console.log(`[${new Date().toLocaleTimeString()}] ${type.toUpperCase()}: ${message}`); 
        }
        
        function showMessage(message, type = 'success') { 
            const box = document.getElementById('message-box'); 
            const txt = document.getElementById('message-text'); 
            
            if (window._msgTimer) clearTimeout(window._msgTimer); 
            
            box.classList.remove('show'); 
            txt.textContent = message; 
            box.className = `message-box ${type}`; 
            
            void box.offsetWidth; // Force reflow
            box.classList.add('show'); 
            box.classList.remove('hidden'); 
            
            window._msgTimer = setTimeout(() => {
                box.classList.remove('show'); 
                setTimeout(() => box.classList.add('hidden'), 500); 
            }, 3000); 
        }
        
        function updateStatus(message, type = 'pending') { 
            const el = document.getElementById('sync-status'); 
            const textEl = el.querySelector('.sync-text');
            const iconEl = el.querySelector('.sync-icon');
            
            // Mettre √† jour le texte et l'ic√¥ne
            if (textEl) textEl.textContent = message;
            if (iconEl) {
                // Choisir l'ic√¥ne appropri√©e selon le type
                if (type === 'success') {
                    iconEl.className = 'sync-icon fa-solid fa-check';
                } else if (type === 'error') {
                    iconEl.className = 'sync-icon fa-solid fa-exclamation-triangle';
                } else if (type === 'saving') {
                    iconEl.className = 'sync-icon fa-solid fa-sync-alt fa-spin';
                } else {
                    iconEl.className = 'sync-icon fa-solid fa-clock';
                }
            }
            
            el.className = `px-3 py-1 rounded-full text-xs font-semibold border-2 bg-white shadow-sm transition-all duration-300 ${getSyncStatusClasses(type)}`;
            
            // Mettre √† jour le point color√© si il existe (pour petits √©crans)
            const dotEl = el.querySelector('.sync-dot');
            if (dotEl) {
                applyDotColor(dotEl, type);
            }
            
            // Adapter l'affichage selon la taille d'√©cran
            adaptStatusDisplay();
        }
        
        function getSyncStatusClasses(type) { 
            switch(type) { 
                case 'success': 
                    return 'bg-green-100 text-green-800 border-green-400 shadow-green-200/50'; 
                case 'error': 
                    return 'bg-red-100 text-red-800 border-red-400 shadow-red-200/50'; 
                case 'saving': 
                    return 'bg-blue-100 text-blue-800 border-blue-400 shadow-blue-200/50 sync-pending-animation'; 
                default: 
                    return 'bg-yellow-100 text-yellow-800 border-yellow-400 shadow-yellow-200/50 sync-pending-animation'; 
            } 
        }
        
        function adaptStatusDisplay() {
            const el = document.getElementById('sync-status');
            if (!el) return;
            
            const textEl = el.querySelector('.sync-text');
            const iconEl = el.querySelector('.sync-icon');
            
            if (!textEl || !iconEl) return;
            
            // Trouver le titre "Tableau de Staff" par son ID
            const titleEl = document.getElementById('staff-title');
            
            // Sur petits √©crans, afficher seulement un point color√© et cacher le titre
            if (window.innerWidth <= 768) {
                textEl.classList.add('hidden');
                iconEl.classList.add('hidden');
                
                // Cacher le titre sur petits √©crans
                if (titleEl) {
                    titleEl.classList.add('hidden');
                }
                
                // Cr√©er ou mettre √† jour le point color√©
                let dotEl = el.querySelector('.sync-dot');
                if (!dotEl) {
                    dotEl = document.createElement('div');
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full';
                    dotEl.setAttribute('aria-label', 'Statut de synchronisation');
                    dotEl.setAttribute('title', 'Statut de synchronisation');
                    el.appendChild(dotEl);
                }
                
                // S'assurer que le point est visible
                dotEl.classList.remove('hidden');
                
                // Appliquer la couleur selon le type actuel
                const currentType = getCurrentStatusType(el);
                applyDotColor(dotEl, currentType);
                
                el.classList.add('px-1', 'py-0.5'); // Padding minimal
                el.classList.remove('px-2', 'px-3');
            } else {
                // Sur grands √©crans, afficher le texte et le titre, cacher le point
                textEl.classList.remove('hidden');
                iconEl.classList.add('hidden');
                
                // Afficher le titre sur grands √©crans
                if (titleEl) {
                    titleEl.classList.remove('hidden');
                }
                
                const dotEl = el.querySelector('.sync-dot');
                if (dotEl) {
                    dotEl.classList.add('hidden');
                    // Optionnel: supprimer compl√®tement le point pour √©conomiser la m√©moire
                    // dotEl.remove();
                }
                
                el.classList.add('px-2');
                el.classList.remove('px-1', 'px-3');
            }
        }
        
        function getCurrentStatusType(el) {
            if (!el) return 'pending';
            
            // D√©tecter le type actuel bas√© sur les classes CSS
            if (el.classList.contains('bg-green-100')) return 'success';
            if (el.classList.contains('bg-red-100')) return 'error';
            if (el.classList.contains('bg-blue-100')) return 'saving';
            return 'pending';
        }
        
        function applyDotColor(dotEl, type) {
            if (!dotEl) return;
            
            // Appliquer la couleur appropri√©e au point
            switch(type) {
                case 'success':
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-green-500';
                    break;
                case 'error':
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-red-500';
                    break;
                case 'saving':
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-blue-500 animate-pulse';
                    break;
                default:
                    dotEl.className = 'sync-dot w-3 h-3 md:w-3.5 md:h-3.5 rounded-full bg-yellow-500';
                    break;
            }
        }
        

        
                function updateUndoButtonState() { 
            const undoButton = document.getElementById('undo-button');
            const redoButton = document.getElementById('redo-button');
            if (undoButton) {
                // Only count content modification operations
                const contentOperations = operationHistory.filter(op => CONTENT_MODIFICATION_TYPES.includes(op.type));
                const hasOperations = contentOperations.length > 0;
                undoButton.disabled = !hasOperations;
                
                // Update button title with operation info (keep icon unchanged)
                if (hasOperations) {
                    const lastOp = contentOperations[contentOperations.length - 1];
                    const description = getOperationDescription(lastOp);
                    undoButton.title = `Annuler: ${description} (${contentOperations.length} modification(s) de contenu disponible(s))`;
                } else {
                    undoButton.title = 'Aucune modification de contenu √† annuler';
                }
            }
            if (redoButton) {
                // Only count content modification operations
                const contentRedoOperations = redoHistory.filter(op => CONTENT_MODIFICATION_TYPES.includes(op.type));
                const hasRedo = contentRedoOperations.length > 0;
                redoButton.disabled = !hasRedo;
                if (hasRedo) {
                    const lastRedo = contentRedoOperations[contentRedoOperations.length - 1];
                    const descRedo = getOperationDescription(lastRedo);
                    redoButton.title = `R√©tablir: ${descRedo} (${contentRedoOperations.length} modification(s) de contenu disponible(s))`;
                } else {
                    redoButton.title = 'Aucune modification de contenu √† r√©tablir';
                }
            }
        }
        
        function getFormattedDate() { 
            const d = new Date(); 
            return `${String(d.getDate()).padStart(2, '0')}/${String(d.getMonth() + 1).padStart(2, '0')}/${String(d.getFullYear()).slice(-2)}`; 
        }
        
        function generateDataHash(data) { 
            return JSON.stringify(data.rows.map(r => ({...r, [supabaseConfig.primaryKeyColumn]: undefined}))).split('').reduce((a, b) => {
                a = ((a << 5) - a) + b.charCodeAt(0);
                return a & a;
            }, 0).toString(16); 
        }

        // Zoom functionality
        function updateZoomDisplay() {
            const btn = document.getElementById('zoom-display');
            if (!btn) return;
            
            const pct = Math.round(zoomFactor * 100);
            btn.textContent = pct + '%';
            btn.title = `R√©initialiser √† 100% (actuel : ${pct}%)`;
        }
        
        function applyZoom() {
            try {
                const clamped = Math.max(0.3, Math.min(2, zoomFactor));
                zoomFactor = clamped;
                document.documentElement.style.fontSize = (16 * zoomFactor) + 'px';
                localStorage.setItem('zoomFactor', String(zoomFactor));
                updateZoomDisplay();
            } catch(_) {}
        }
        
        function zoomIn() { 
            zoomFactor += 0.05; 
            applyZoom(); 
        }
        
        function zoomOut() { 
            zoomFactor -= 0.05; 
            applyZoom(); 
        }
        
        function zoomReset() { 
            zoomFactor = 1; 
            applyZoom(); 
        }

        // Row color management
        function persistRowColors() { 
            try { 
                localStorage.setItem('rowColors', JSON.stringify(rowColorMap)); 
            } catch(_) {} 
        }
        
        function setRowColor(tr, color) {
            if (!tr) return;
            
            // S'assurer que tr est bien un √©l√©ment TR
            if (tr.tagName !== 'TR') {
                console.warn('setRowColor: tr parameter is not a TR element:', tr);
                return;
            }
            
            if (color) { 
                // Colorer toute la ligne
                tr.style.backgroundColor = color; 
                tr.dataset.rowColored = '1'; 
                
                // S'assurer que toutes les cellules de la ligne h√©ritent de la couleur
                Array.from(tr.cells).forEach(cell => {
                    if (cell.style.backgroundColor !== color) {
                        cell.style.backgroundColor = color;
                    }
                });
            } else { 
                // D√©colorer toute la ligne
                tr.style.backgroundColor = ''; 
                tr.dataset.rowColored = '0'; 
                
                // S'assurer que toutes les cellules de la ligne sont d√©color√©es
                Array.from(tr.cells).forEach(cell => {
                    cell.style.backgroundColor = '';
                });
            }
        }
        
        function keyForRow(tr) {
            return tr.dataset.key || (Array.from(tr.parentElement.children).indexOf(tr) + 1);
        }

        function toggleRowColor(tr) {
            // S'assurer que tr est bien un √©l√©ment tr (ligne)
            if (!tr || tr.tagName !== 'TR') {
                console.warn('toggleRowColor: tr parameter is not a TR element:', tr);
                return;
            }
            
            const key = keyForRow(tr);
            
            // Respecter le mode de peinture actuel
            if (paintMode === 'color') {
                // Mode Colorer : toujours colorer
                setRowColor(tr, currentRowColor);
                rowColorMap[key] = currentRowColor;
            } else if (paintMode === 'clear') {
                // Mode Effacer : toujours effacer
                setRowColor(tr, null);
                delete rowColorMap[key];
            } else {
                // Mode Auto : basculer selon l'√©tat actuel
                if (tr.dataset.rowColored === '1') {
                    setRowColor(tr, null);
                    delete rowColorMap[key];
                } else {
                    setRowColor(tr, currentRowColor);
                    rowColorMap[key] = currentRowColor;
                }
            }
            
            persistRowColors();
        }

        // Drag-to-paint functionality
        function applyRowPaint(row) {
            if (!row) return;
            
            // Row color operations are NOT tracked for undo/redo (content modification only)
            // No need to start, track, or complete these operations
            
            const key = keyForRow(row);
            if (rowPaintAction === 'color') {
                setRowColor(row, currentRowColor);
                rowColorMap[key] = currentRowColor;
            } else {
                setRowColor(row, null);
                delete rowColorMap[key];
            }
            persistRowColors();
            
            // No operation timeout needed for non-tracked operations
        }
        
        function startRowPaint(row) {
            // Respecter le mode de peinture actuel
            if (paintMode === 'color') {
                rowPaintAction = 'color';
            } else if (paintMode === 'clear') {
                rowPaintAction = 'clear';
            } else {
                // Mode Auto : basculer selon l'√©tat actuel
                rowPaintAction = (row && row.dataset.rowColored === '1') ? 'clear' : 'color';
            }
            
            isRowPaintDragging = true;
            applyRowPaint(row);
            
            // Note: Row color operations are NOT tracked for undo/redo (content modification only)
        }
        
        function endRowPaint() { 
            isRowPaintDragging = false; 
            
            // Row color operations are NOT tracked for undo/redo (content modification only)
            // No need to complete or track these operations
        }

        // Paint mode management
        function getPaintActionForRow(row) {
            if (paintMode === 'auto') {
                // En mode auto : si la ligne est color√©e, on la d√©colore, sinon on la colorie
                const isColored = row && (row.dataset.rowColored === '1' || 
                                        (row.style.backgroundColor && row.style.backgroundColor !== ''));
                return isColored ? 'clear' : 'color';
            }
            return paintMode;
        }
        
        function updatePaintModeButton() {
            const btn = document.getElementById('paint-mode-toggle');
            if (!btn) return;
            
            if (paintMode === 'auto') { 
                btn.innerHTML = '<i class="fa-solid fa-arrows-rotate w-4 h-4"></i>'; 
                btn.title = 'Mode Auto: Cliquez pour colorer/d√©colorer (P pour changer)'; 
            } else if (paintMode === 'color') { 
                btn.innerHTML = '<i class="fa-solid fa-paintbrush w-4 h-4"></i>'; 
                btn.title = 'Mode Colorer (P pour changer)'; 
            } else { 
                btn.innerHTML = '<i class="fa-solid fa-eraser w-4 h-4"></i>'; 
                btn.title = 'Mode Effacer (P pour changer)'; 
            }
        }
        
        function cyclePaintMode() {
            paintMode = (paintMode === 'auto') ? 'color' : (paintMode === 'color' ? 'clear' : 'auto');
            localStorage.setItem('rowPaintMode', paintMode);
            updatePaintModeButton();
            
            let message = paintMode === 'auto' ? 'Auto' : (paintMode === 'color' ? 'Color√©' : 'Effacer');
            showMessage(message, 'info');
        }

        // Filter functionality
        function applyColoredFilter() {
            try {
                const tbody = document.getElementById('table-body');
                Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                    const colored = tr.dataset.rowColored === '1' || (tr.style.backgroundColor && tr.style.backgroundColor !== '');
                    tr.style.display = (showOnlyColored && !colored) ? 'none' : '';
                });
            } catch(_) {}
        }

        function updateFilterColoredButton() {
            const btn = document.getElementById('filter-colored-toggle');
            if (!btn) return;
            
            if (showOnlyColored) {
                btn.innerHTML = '<i class="fa-solid fa-eye w-4 h-4"></i>';
                btn.title = 'Afficher toutes les lignes';
                btn.setAttribute('aria-pressed', 'true');
            } else {
                btn.innerHTML = '<i class="fa-solid fa-filter w-4 h-4"></i>';
                btn.title = 'Afficher seulement les lignes color√©es';
                btn.setAttribute('aria-pressed', 'false');
            }
        }

        function toggleColoredFilter() {
            showOnlyColored = !showOnlyColored;
            applyColoredFilter();
            updateFilterColoredButton();
        }
        
        // Fonction pour basculer le mode visualisation
        function toggleViewMode() {
            isViewMode = !isViewMode;
            
            // Sauvegarder imm√©diatement l'√©tat dans localStorage
            localStorage.setItem('viewMode', isViewMode.toString());
            
            updateViewModeButton();
            applyViewMode();
        }
        
        // Mettre √† jour l'apparence du bouton de mode visualisation
        function updateViewModeButton() {
            const btn = document.getElementById('view-mode-toggle');
            if (!btn) return;
            
            if (isViewMode) {
                btn.className = 'bg-green-200 text-green-800 p-2 rounded-lg hover:bg-green-300 transition-colors flex items-center justify-center w-8 h-8';
                btn.title = 'D√©sactiver le mode visualisation (lecture seule)';
                btn.innerHTML = '<i class="fa-solid fa-eye-slash w-4 h-4"></i>';
            } else {
                btn.className = 'bg-blue-200 text-blue-800 p-2 rounded-lg hover:bg-blue-300 transition-colors flex items-center justify-center w-8 h-8';
                btn.title = 'Activer le mode visualisation (lecture seule)';
                btn.innerHTML = '<i class="fa-solid fa-eye w-4 h-4"></i>';
            }
        }
        
        // Appliquer le mode visualisation
        function applyViewMode() {
            const editableCells = document.querySelectorAll('.editable-cell');
            const fabAdd = document.getElementById('fab-add');
            const mobileAddButton = document.getElementById('mobile-add-button');
            
            // D√©sactiver TEMPORAIREMENT TOUTES les sauvegardes si on passe en mode visualisation
            let originalFunctions = {};
            if (isViewMode) {
                // Sauvegarder toutes les fonctions originales
                originalFunctions.markEdited = window.markEdited;
                originalFunctions.saveStateToHistory = window.saveStateToHistory;
                originalFunctions.saveLocalDraft = window.saveLocalDraft;
                
                // Remplacer par des fonctions vides
                window.markEdited = function() { return; };
                window.saveStateToHistory = function() { return; };
                window.saveLocalDraft = function() { return; };
            }
            
            editableCells.forEach(cell => {
                if (isViewMode) {
                    cell.contentEditable = 'false';
                    cell.style.backgroundColor = '#f8f9fa';
                    cell.style.cursor = 'default';
                } else {
                    cell.contentEditable = 'true';
                    cell.style.backgroundColor = '';
                    cell.style.cursor = 'text';
                }
            });
            
            // Activer la protection renforc√©e sur mobile en mode visualisation
            if (isViewMode && isMobile()) {
                isViewModeProtected = true;
            } else {
                isViewModeProtected = false;
            }
            
            // Le bouton d'ajout FAB doit toujours √™tre visible, mais d√©sactiv√© en mode visualisation
            if (fabAdd) {
                fabAdd.style.display = 'flex';
                fabAdd.style.visibility = 'visible';
                
                if (isViewMode) {
                    // Mode visualisation : bouton visible mais d√©sactiv√©
                    fabAdd.style.opacity = '0.5';
                    fabAdd.style.pointerEvents = 'none';
                    fabAdd.style.cursor = 'not-allowed';
                    fabAdd.title = 'Mode visualisation actif - Ajout de lignes d√©sactiv√©';
                } else {
                    // Mode normal : bouton pleinement fonctionnel
                    fabAdd.style.opacity = '1';
                    fabAdd.style.pointerEvents = 'auto';
                    fabAdd.style.cursor = 'pointer';
                    fabAdd.title = 'Ajouter une nouvelle ligne';
                }
            }
            
            // Sauvegarder l'√©tat dans localStorage
            localStorage.setItem('viewMode', isViewMode);
            
            // R√©activer les sauvegardes apr√®s un d√©lai adaptatif selon l'appareil
            if (isViewMode && Object.keys(originalFunctions).length > 0) {
                const restoreDelay = isMobile() ? 6000 : 3000;
                setTimeout(() => {
                    if (originalFunctions.markEdited) {
                        window.markEdited = originalFunctions.markEdited;
                    }
                    if (originalFunctions.saveStateToHistory) {
                        window.saveStateToHistory = originalFunctions.saveStateToHistory;
                    }
                    if (originalFunctions.saveLocalDraft) {
                        window.saveLocalDraft = originalFunctions.saveLocalDraft;
                    }
                }, restoreDelay);
            }
        }
        
        // Appliquer le mode visualisation apr√®s restauration des donn√©es
        function applyViewModeAfterRestore() {
            if (isViewMode) {
                const editableCells = document.querySelectorAll('.editable-cell');
                editableCells.forEach(cell => {
                    cell.contentEditable = 'false';
                    cell.style.backgroundColor = '#f8f9fa';
                    cell.style.cursor = 'default';
                });
            }
        }
        
        // D√©tecter automatiquement l'√©tat du bouton ≈ìil et agir en cons√©quence
        function detectAndApplyViewMode() {
            const btn = document.getElementById('view-mode-toggle');
            if (!btn) return;
            
            // Restaurer l'√©tat depuis localStorage
            const savedViewMode = localStorage.getItem('viewMode') === 'true';
            if (savedViewMode !== isViewMode) {
                isViewMode = savedViewMode;
            }
            
            // Mettre √† jour l'apparence du bouton selon l'√©tat sauvegard√©
            updateViewModeButton();
            
            // Appliquer le mode sauvegard√©
            applyViewMode();
        }
        
        // Fonction pour forcer le mode visualisation et emp√™cher les sauvegardes
        function forceViewMode() {
            if (isViewMode) {
                // D√©sactiver temporairement les sauvegardes automatiques
                const originalMarkEdited = window.markEdited;
                window.markEdited = function() {
                    // Ne rien faire si on est en mode visualisation
                    return;
                };
                
                // Appliquer le mode visualisation
                applyViewMode();
                
                // R√©activer les sauvegardes apr√®s un d√©lai adaptatif selon l'appareil
                const restoreDelay = isMobile() ? 4000 : 2000;
                setTimeout(() => {
                    window.markEdited = originalMarkEdited;
                }, restoreDelay);
            }
        }
        


        // Row color utilities
        function clearAllRowColors() {
            try {
                const tbody = document.getElementById('table-body');
                Array.from(tbody.querySelectorAll('tr')).forEach(tr => setRowColor(tr, null));
                rowColorMap = {};
                persistRowColors();
                showMessage('Couleurs des lignes effac√©es.', 'info');
            } catch(_) {}
        }

        // Focus management
        let isInitialLoad = true; // Flag to prevent automatic capture on initial load
        
        function captureSimplePos() {
            // Skip capture during initial load to prevent overwriting user's intended position
            if (isInitialLoad) {
                log(`üö´ captureSimplePos SKIPPED - initial load in progress`);
                return;
            }
            
            const active = document.activeElement;
            if (!(active && active.tagName === 'TD' && active.isContentEditable)) return;
            
            const rowEl = active.closest('tr');
            const tbody = document.getElementById('table-body');
            const rowIndex = Array.from(tbody.querySelectorAll('tr')).indexOf(rowEl);
            const cellIndex = Array.from(rowEl.cells).indexOf(active);
            
            // DEBUG: Log detailed information about the cell being captured
            if (active && rowEl) {
                const cellLabel = active.getAttribute('data-label') || 'NO_LABEL';
                const cellText = active.textContent.substring(0, 20) + '...';
                const totalCells = rowEl.cells.length;
                const totalRows = tbody.querySelectorAll('tr').length;
                
                log(`üîç CAPTURE DEBUG: row=${rowIndex}/${totalRows}, cell=${cellIndex}/${totalCells}, label="${cellLabel}", text="${cellText}"`);
            }
            
            if (rowIndex >= 0 && cellIndex >= 0) {
                lastCellPos = { rowIndex, cellIndex };
                
                // UNIFY: Also update lastFocusInfo to use the same position
                const colLabel = active.getAttribute('data-label') || '';
                const rowKey = rowEl ? rowEl.dataset.key || null : null;
                const caret = getCaretOffsetWithin(active);
                
                lastFocusInfo = { rowKey, rowIndex, colLabel, caret };
                log(`üîÑ UNIFIED CAPTURE: Updated both lastCellPos and lastFocusInfo with same rowIndex=${rowIndex}`);
            }
            
            if (lastCellPos) { 
                log(`captureSimplePos -> row=${lastCellPos.rowIndex}, cell=${lastCellPos.cellIndex}`); 
            }
            
            try { 
                localStorage.setItem('lastCellPos', JSON.stringify(lastCellPos)); 
                localStorage.setItem('lastFocusInfo', JSON.stringify(lastFocusInfo)); 
            } catch(_) {}
        }

        // Mobile detection and support - Enhanced version
        function isMobile() {
            try { 
                // D√©tection plus robuste
                const userAgent = navigator.userAgent;
                const mobileRegex = /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
                
                // V√©rifier la taille de l'√©cran
                const isSmallScreen = window.innerWidth <= 768;
                
                // V√©rifier les capacit√©s tactiles
                const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                
                // V√©rifier l'orientation (mobile a souvent une orientation changeante)
                const hasOrientation = 'onorientationchange' in window;
                
                // D√©tection bas√©e sur userAgent
                const userAgentMobile = mobileRegex.test(userAgent);
                
                // D√©tection bas√©e sur les capacit√©s et la taille
                const capabilitiesMobile = isSmallScreen && (hasTouch || hasOrientation);
                
                return userAgentMobile || capabilitiesMobile;
            } catch(_) { 
                return false; 
            }
        }

        function getScrollContainer() {
            return document.getElementById('table-container');
        }

        function ensureCellVisible(cell) {
            try {
                if (!cell) return;
                
                const sc = getScrollContainer();
                if (!sc) { 
                    cell.scrollIntoView({block: 'center', inline: 'nearest'}); 
                    return; 
                }
                
                const vv = window.visualViewport;
                const rect = cell.getBoundingClientRect();
                const viewportHeight = vv ? vv.height : window.innerHeight;
                const bottomSafe = viewportHeight - 64;
                
                if (rect.bottom > bottomSafe || rect.top < 0) {
                    const delta = rect.bottom - bottomSafe;
                    sc.scrollTop += Math.max(delta, -20);
                    try { 
                        cell.scrollIntoView({block: 'center', inline: 'nearest'}); 
                    } catch(_) {}
                }
            } catch(_) {}
        }

        function focusCellWithMobileSupport(cell) {
            try {
                try { 
                    cell.scrollIntoView({ block: 'center', inline: 'nearest' }); 
                } catch(_) {}
                
                setTimeout(() => {
                    try {
                        cell.dispatchEvent(new Event('pointerdown', { bubbles: true }));
                        cell.dispatchEvent(new Event('mousedown', { bubbles: true }));
                        cell.dispatchEvent(new Event('mouseup', { bubbles: true }));
                        cell.click();
                        
                        try { 
                            cell.focus({ preventScroll: true }); 
                        } catch(_) { 
                            try { 
                                cell.focus(); 
                            } catch(__) {} 
                        }
                        
                        setCaretAt(cell, null);
                        
                        try {
                            requestAnimationFrame(() => {
                                setCaretAt(cell, null);
                                requestAnimationFrame(() => { 
                                    setCaretAt(cell, null); 
                                });
                            });
                        } catch(_) {}
                        
                        setTimeout(() => { 
                            setCaretAt(cell, null); 
                        }, 250);
                    } catch(_) {
                        try { 
                            cell.focus(); 
                            setCaretAt(cell, null); 
                        } catch(__) {}
                    }
                }, 350);
                
                ensureCellVisible(cell);
                return true;
            } catch(_) { 
                return false; 
            }
        }

        // Caret management
        function getCaretOffsetWithin(el) {
            try {
                const sel = window.getSelection();
                if (!sel || sel.rangeCount === 0) return null;
                
                const range = sel.getRangeAt(0);
                if (!el.contains(range.startContainer)) return null;
                
                const preRange = range.cloneRange();
                preRange.selectNodeContents(el);
                preRange.setEnd(range.startContainer, range.startOffset);
                
                return preRange.toString().length;
            } catch(_) { 
                return null; 
            }
        }

        function setCaretAt(el, offset) {
            try {
                el.focus();
                const selection = window.getSelection();
                selection.removeAllRanges();
                const range = document.createRange();
                
                let remaining = (typeof offset === 'number' && offset >= 0) ? offset : null;
                const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
                let node = walker.nextNode();
                
                if (remaining === null) {
                    let lastNode = null;
                    while (node) { 
                        lastNode = node; 
                        node = walker.nextNode(); 
                    }
                    
                    if (lastNode) {
                        range.setStart(lastNode, lastNode.textContent.length);
                        range.collapse(true);
                        selection.addRange(range);
                    }
                    return;
                }
                
                while (node) {
                    const len = node.textContent.length;
                    if (remaining <= len) {
                        range.setStart(node, remaining);
                        range.collapse(true);
                        selection.addRange(range);
                        return;
                    }
                    remaining -= len;
                    node = walker.nextNode();
                }
                
                const endNode = el.lastChild;
                if (endNode && endNode.nodeType === Node.TEXT_NODE) {
                    range.setStart(endNode, endNode.textContent.length);
                } else {
                    range.selectNodeContents(el);
                    range.collapse(false);
                }
                selection.addRange(range);
            } catch(_) {}
        }

        function captureFocusInfo() {
            // Skip capture during initial load to prevent overwriting user's intended position
            if (isInitialLoad) {
                log(`üö´ captureFocusInfo SKIPPED - initial load in progress`);
                return;
            }
            
            const active = document.activeElement;
            if (!(active && active.tagName === 'TD' && active.isContentEditable)) return;
            
            const row = active.closest('tr');
            const tbody = document.getElementById('table-body');
            const rowIndex = Array.from(tbody.querySelectorAll('tr')).indexOf(row);
            const colLabel = active.getAttribute('data-label') || '';
            const rowKey = row ? row.dataset.key || null : null;
            const caret = getCaretOffsetWithin(active);
            
            lastFocusInfo = { rowKey, rowIndex, colLabel, caret };
            
            try { 
                localStorage.setItem('lastFocusInfo', JSON.stringify(lastFocusInfo)); 
            } catch(_) {}
        }

        function focusCellFromInfo(info) {
            if (!info) return false;
            
            log(`üîç focusCellFromInfo: Looking for rowKey="${info.rowKey}", rowIndex=${info.rowIndex}, colLabel="${info.colLabel}"`);
            
            const tbody = document.getElementById('table-body');
            let targetRow = null;
            
            if (info.rowKey) {
                targetRow = Array.from(tbody.querySelectorAll('tr')).find(tr => tr.dataset.key === String(info.rowKey));
                log(`üîç focusCellFromInfo: Found row by key: ${!!targetRow}`);
            }
            
            if (!targetRow) {
                const rows = tbody.querySelectorAll('tr');
                targetRow = rows[info.rowIndex] || null;
                log(`üîç focusCellFromInfo: Found row by index: ${!!targetRow}`);
            }
            
            if (!targetRow) {
                log(`‚ùå focusCellFromInfo: No target row found`);
                return false;
            }
            
            const cells = Array.from(targetRow.querySelectorAll('td'));
            log(`üîç focusCellFromInfo: Row has ${cells.length} cells, looking for label "${info.colLabel}"`);
            
            // Use absolute cell index like focusCellByPos, not sliced cells
            const cell = cells.find(td => (td.getAttribute('data-label') || '') === info.colLabel) || null;
            
            if (!cell) {
                log(`‚ùå focusCellFromInfo: No cell found with label "${info.colLabel}"`);
                // Debug: show all available labels
                const availableLabels = cells.map((td, i) => `${i}:"${td.getAttribute('data-label') || 'NO_LABEL'}"`).join(', ');
                log(`üîç Available labels: ${availableLabels}`);
                return false;
            }
            
            log(`‚úÖ focusCellFromInfo: Found cell at index ${cells.indexOf(cell)} with label "${info.colLabel}"`);
            
            if (isMobile()) {
                return focusCellWithMobileSupport(cell);
            }
            
            try { 
                cell.scrollIntoView({ block: 'center', inline: 'nearest' }); 
            } catch(_) {}
            
            let placed = false;
            try { 
                setCaretAt(cell, null); 
                placed = true; 
            } catch(_) {}
            
            if (!placed) { 
                setTimeout(() => { 
                    try { 
                        setCaretAt(cell, null); 
                    } catch(_) {} 
                }, 50); 
            }
            
            try {
                requestAnimationFrame(() => {
                    setCaretAt(cell, null);
                    requestAnimationFrame(() => { 
                        setCaretAt(cell, null); 
                    });
                });
            } catch(_) {}
            
            if (document.activeElement !== cell) { 
                try { 
                    cell.focus(); 
                } catch(_) {} 
            }
            
            return true;
        }

        function focusCellByPos(pos) {
            try {
                if (!pos) return false;
                
                const tbody = document.getElementById('table-body');
                const totalRows = tbody.querySelectorAll('tr').length;
                const row = tbody.querySelectorAll('tr')[pos.rowIndex];
                
                if (!row) {
                    log(`‚ùå RESTORE DEBUG: Row ${pos.rowIndex} not found (total rows: ${totalRows})`);
                    return false;
                }
                
                const totalCells = row.cells.length;
                const cell = row.cells[pos.cellIndex];
                
                if (!cell) {
                    log(`‚ùå RESTORE DEBUG: Cell ${pos.cellIndex} not found in row ${pos.rowIndex} (total cells: ${totalCells})`);
                    return false;
                }
                
                // DEBUG: Log detailed information about the cell being restored
                const cellLabel = cell.getAttribute('data-label') || 'NO_LABEL';
                const cellText = cell.textContent.substring(0, 20) + '...';
                
                log(`üîç RESTORE DEBUG: row=${pos.rowIndex}/${totalRows}, cell=${pos.cellIndex}/${totalCells}, label="${cellLabel}", text="${cellText}"`);
                
                if (isMobile()) {
                    return focusCellWithMobileSupport(cell);
                }
                
                setCaretAt(cell, null);
                
                try {
                    cell.dispatchEvent(new MouseEvent('pointerdown', { bubbles: true }));
                    cell.dispatchEvent(new MouseEvent('mousedown', { bubbles: true }));
                    cell.dispatchEvent(new MouseEvent('mouseup', { bubbles: true }));
                    cell.click();
                } catch(_) {}
                
                log(`focusCellByPos -> active=${document.activeElement === cell}`);
                
                try {
                    requestAnimationFrame(() => {
                        setCaretAt(cell, null);
                        requestAnimationFrame(() => { 
                            setCaretAt(cell, null); 
                        });
                    });
                } catch(_) {}
                
                return document.activeElement === cell;
            } catch(_) { 
                return false; 
            }
        }

        // Data collection and management
        function collectTableData() { 
            const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent); 
            const rows = []; 
            
            document.querySelectorAll('#data-table tbody tr').forEach((rowEl, index) => { 
                const rowData = {}; 
                
                // Gestion am√©lior√©e de la cl√© primaire compatible smallint
                if (rowEl.dataset.key && rowEl.dataset.key !== '') { 
                    const keyValue = parseInt(rowEl.dataset.key);
                    // S'assurer que la cl√© est dans la plage smallint (-32,768 √† 32,767)
                    if (keyValue >= -32768 && keyValue <= 32767) {
                        rowData[supabaseConfig.primaryKeyColumn] = keyValue;
                    } else {
                        // Si la cl√© est hors plage, utiliser l'index + 1
                        rowData[supabaseConfig.primaryKeyColumn] = index + 1;
                    }
                } else {
                    // Si pas de cl√©, utiliser l'index + 1 comme cl√© temporaire
                    rowData[supabaseConfig.primaryKeyColumn] = index + 1;
                }
                
                const cells = Array.from(rowEl.querySelectorAll('td')).slice(2); 
                cells.forEach((td, i) => { 
                    const label = headers[i]; 
                    const key = label; 
                    rowData[key] = td.textContent === '' ? null : td.textContent; 
                }); 
                
                rows.push(rowData); 
            }); 
            
            return { headers, rows }; 
        }
        
        function saveStateToHistory() { 
            // Clean: Removed debug logging
            
            // Protection renforc√©e : ne rien faire si on est en mode visualisation prot√©g√©
            if (isViewModeProtected || (isViewMode && isMobile()) || isPerformingUndoRedo) {
                // Clean: Removed debug log
                return;
            }
            
            if (historyDebounceTimeout) clearTimeout(historyDebounceTimeout); 
            
            historyDebounceTimeout = setTimeout(() => { 
                const s = collectTableData(); 
                const last = history[history.length - 1]; 
                
                if (!last || generateDataHash(s) !== generateDataHash(last)) { 
                    history.push(s); 
                    if (history.length > 10) history.shift(); 
                    // Pushing a new state clears redo stack
                    redoHistory = [];
                    // Also record as an operation if none in progress
                    if (!currentOperation) {
                        const op = {
                            type: OPERATION_TYPES.BULK_EDIT,
                            data: {},
                            timestamp: Date.now(),
                            tableState: s,
                            rowColors: { ...rowColorMap },
                            finalState: s,
                            finalRowColors: { ...rowColorMap }
                        };
                        operationHistory.push(op);
                        if (operationHistory.length > 50) operationHistory.shift();
                    }
                    persistHistoryStacks();
                    updateUndoButtonState(); 
                    log('√âtat de l\'historique enregistr√©.'); 
                } 
            }, 500); 
        }
        
        function saveLocalDraft() { 
            // Protection renforc√©e : ne rien faire si on est en mode visualisation prot√©g√©
            if (isViewModeProtected || (isViewMode && isMobile())) {
                return;
            }
            
            try { 
                localStorage.setItem('staffTableDraft', document.getElementById('data-table').outerHTML); 
            } catch(e) {} 
        }
        
        function restoreLocalDraft() {
            try {
                const draft = localStorage.getItem('staffTableDraft');
                if (draft) {
                    const el = document.getElementById('data-table');
                    if (el) {
                        // Sauvegarder l'√©tat du mode visualisation avant la restauration
                        const wasViewMode = isViewMode;
                        
                        // NUCLEAR OPTION: D√©sactiver TOUTES les sauvegardes si on est en mode visualisation
                        let originalFunctions = {};
                        if (wasViewMode) {
                            // Sauvegarder toutes les fonctions originales
                            originalFunctions.markEdited = window.markEdited;
                            originalFunctions.saveStateToHistory = window.saveStateToHistory;
                            originalFunctions.saveLocalDraft = window.saveLocalDraft;
                            
                            // Remplacer par des fonctions vides avec debug
                            window.markEdited = function() { 
                                // Clean: Removed debug log 
                                return; 
                            };
                            window.saveStateToHistory = function() { 
                                // Clean: Removed debug log 
                                return; 
                            };
                            window.saveLocalDraft = function() { 
                                // Clean: Removed debug log 
                                return; 
                            };
                            
                            // Activer la protection renforc√©e
                            isViewModeProtected = true;
                            // Clean: Removed debug log
                        }
                        
                        el.outerHTML = draft;
                        log('Brouillon local restaur√©.');
                        
                        // Restaurer le mode visualisation imm√©diatement apr√®s la restauration
                        if (wasViewMode) {
                            isViewMode = true;
                            
                            // D√©lai adaptatif selon l'appareil (plus long sur mobile)
                            const delay = isMobile() ? 300 : 150;
                            const restoreDelay = isMobile() ? 10000 : 6000;
                            
                            // Clean: Removed debug log
                            
                            // Appliquer le mode visualisation aux nouvelles cellules
                            setTimeout(() => {
                                // Clean: Removed debug log
                                const editableCells = document.querySelectorAll('.editable-cell');
                                editableCells.forEach(cell => {
                                    cell.contentEditable = 'false';
                                    cell.style.backgroundColor = '#f8f9fa';
                                    cell.style.cursor = 'default';
                                });
                                
                                // Mettre √† jour l'apparence du bouton
                                updateViewModeButton();
                                
                                // Le bouton d'ajout FAB doit toujours √™tre visible, mais d√©sactiv√© en mode visualisation
                                const fabAdd = document.getElementById('fab-add');
                                if (fabAdd) {
                                    fabAdd.style.display = 'flex';
                                    fabAdd.style.visibility = 'visible';
                                    
                                    if (isViewMode) {
                                        // Mode visualisation : bouton visible mais d√©sactiv√©
                                        fabAdd.style.opacity = '0.5';
                                        fabAdd.style.pointerEvents = 'none';
                                        fabAdd.style.cursor = 'not-allowed';
                                        fabAdd.title = 'Mode visualisation actif - Ajout de lignes d√©sactiv√©';
                                    } else {
                                        // Mode normal : bouton pleinement fonctionnel
                                        fabAdd.style.opacity = '1';
                                        fabAdd.style.pointerEvents = 'auto';
                                        fabAdd.style.cursor = 'pointer';
                                        fabAdd.title = 'Ajouter une nouvelle ligne';
                                    }
                                }
                                
                                // Clean: Removed debug log
                                
                                // R√©activer les sauvegardes apr√®s un d√©lai adaptatif
                                setTimeout(() => {
                                    // Clean: Removed debug log
                                    if (originalFunctions.markEdited) {
                                        window.markEdited = originalFunctions.markEdited;
                                    }
                                    if (originalFunctions.saveStateToHistory) {
                                        window.saveStateToHistory = originalFunctions.saveStateToHistory;
                                    }
                                    if (originalFunctions.saveLocalDraft) {
                                        window.saveLocalDraft = originalFunctions.saveLocalDraft;
                                    }
                                    
                                    // D√©sactiver la protection renforc√©e
                                    isViewModeProtected = false;
                                    // Clean: Removed debug log
                                }, restoreDelay);
                            }, delay);
                        }
                        
                        rebindRowNumberCells();
                        
                        try {
                            const tbody = document.getElementById('table-body');
                            Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                                const k = keyForRow(tr);
                                const col = rowColorMap[k];
                                if (col) setRowColor(tr, col);
                            });
                        } catch(_) {}
                    }
                }
            } catch(e) {}
        }
        
        function markEdited() {
            isDirty = true; 
            isTyping = true; 
            lastEditAt = Date.now();
            
            if (typingTimer) clearTimeout(typingTimer);
            scheduleAutosaveCountdown();
            typingTimer = setTimeout(() => { isTyping = false; }, 1200);
        }

        // Autosave functionality with enhanced undo/redo conflict prevention
        function scheduleAutosaveCountdown() {
            // Use enhanced version for better conflict prevention
            scheduleAutosaveCountdownEnhanced();
        }
        
        function startPeriodicSync() {
            // Use enhanced version for better conflict prevention
            startPeriodicSyncEnhanced();
        }

        // ===== Helpers & constants (DRY) =====
        const BOLD_HEADERS = ['nom_pr√©nom','pec finale','diagnostic_initial'];
        function getHeaders(){
          return Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th=>th.textContent);
        }
        
        // Fonction pour mettre √† jour l'affichage du nombre de lignes
        function updateRowCount() {
            const tbody = document.getElementById('table-body');
            const rowCountNumber = document.getElementById('row-count-number');
            
            if (tbody && rowCountNumber) {
                const rowCount = tbody.children.length;
                rowCountNumber.textContent = rowCount;
                // Clean: Removed debug log
            }
        }
        function createDeleteCell(row){
          const deleteCell=document.createElement('td');
          deleteCell.className='p-0 text-center';
          deleteCell.setAttribute('data-label','Effacer');
          const sel=document.createElement('input');
          sel.type='checkbox';
          sel.className='m-1 align-middle';
          sel.addEventListener('change',()=>{ row.classList.toggle('selected-row', sel.checked); });
          const deleteButton=document.createElement('button');
          deleteButton.className='text-red-500 hover:text-red-700 font-bold p-2 transition-colors';
          deleteButton.innerHTML='üóëÔ∏è';
          deleteButton.onclick=(e)=>{
            e.stopPropagation();
            const selected = Array.from(document.querySelectorAll('#table-body tr.selected-row'));
            if (selected.length > 0) {
              // Multiple rows selected: confirm before deleting
              promptKeyConfirm(`Supprimer ${selected.length} ligne(s) ?`, () => deleteRows(selected));
            } else {
              // Single row via trash icon: delete immediately without confirmation
              deleteRows([row]);
            }
          };
          const wrap=document.createElement('div');
          wrap.className='flex items-center justify-center gap-1';
          wrap.appendChild(sel); wrap.appendChild(deleteButton);
          deleteCell.appendChild(wrap);
          return deleteCell;
        }
        function createEditableCell(header, value=''){
          const cell=document.createElement('td');
          const dbKey=header; // names are identical (no mapping)
          cell.textContent=value||'';
          cell.contentEditable=true;
          cell.className='py-2 px-2 md:px-4 editable-cell';
          cell.setAttribute('data-label',header);
          cell.setAttribute('data-dbkey',dbKey);
          
          // Force inline red color for Information complementaire to override any cascade
          if (header === 'Information complementaire' || header === 'information complementaire') {
            cell.style.color = '#dc2626';
          }
          
          // Remove any previous inline font size for numero_tel to keep 1.1rem via CSS
          if (header === 'Numero_tel' || header === 'numero_tel') {
            cell.style.fontSize = '';
          }
          
          // S√©lection automatique du contenu lors du double-clic/double-tap
          cell.addEventListener('dblclick', (e) => {
            e.preventDefault();
            // S√©lectionner tout le contenu de la cellule
            const range = document.createRange();
            range.selectNodeContents(cell);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
          });
          
          // Gestion du double-tap sur mobile
          let lastTap = 0;
          cell.addEventListener('touchstart', (e) => {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            if (tapLength < 500 && tapLength > 0) {
              // Double-tap d√©tect√©
              e.preventDefault();
              // S√©lectionner tout le contenu de la cellule
              const range = document.createRange();
              range.selectNodeContents(cell);
              const selection = window.getSelection();
              selection.removeAllRanges();
              selection.addRange(range);
            }
            lastTap = currentTime;
          });
          
          // Stocker la valeur initiale pour d√©tecter les vraies modifications
          let initialValue = value || '';
          let hasBeenModified = false;
          
          // --- Nom_Pr√©nom auto-formatting logic ---
          if (isNomPrenomLabel(header)) {
            // Ensure initial display is formatted when creating the cell
            if (value) {
              value = formatNomPrenom(value);
              cell.textContent = value;
              initialValue = value;
            }
            
            // Format when the user leaves the cell (seulement si modifi√©)
            cell.addEventListener('blur', () => {
              const currentValue = cell.textContent;
              const formattedValue = formatNomPrenom(currentValue);
              cell.textContent = formattedValue;
              
              // Sauvegarder seulement si la valeur a vraiment chang√©
              if (hasBeenModified || formattedValue !== initialValue) {
                saveStateToHistory();
                saveLocalDraft();
                markEdited();
                // Mettre √† jour la valeur initiale pour les prochaines comparaisons
                initialValue = formattedValue;
                hasBeenModified = false;
              }
            });
            
            // G√©rer le collage (seulement si le contenu change)
            cell.addEventListener('paste', () => {
              setTimeout(() => {
                const pastedValue = cell.textContent;
                const formattedValue = formatNomPrenom(pastedValue);
                cell.textContent = formattedValue;
                
                // Sauvegarder seulement si le contenu coll√© est diff√©rent
                if (formattedValue !== initialValue) {
                  saveStateToHistory();
                  saveLocalDraft();
                  markEdited();
                  initialValue = formattedValue;
                  hasBeenModified = false;
                }
              }, 0);
            });
          } else {
            // Pour les autres colonnes, g√©rer blur et paste de mani√®re similaire
            cell.addEventListener('blur', () => {
              const currentValue = cell.textContent;
              // Sauvegarder seulement si la valeur a vraiment chang√©
              if (hasBeenModified || currentValue !== initialValue) {
                saveStateToHistory();
                saveLocalDraft();
                markEdited();
                initialValue = currentValue;
                hasBeenModified = false;
              }
            });
            
            cell.addEventListener('paste', () => {
              setTimeout(() => {
                const pastedValue = cell.textContent;
                // Sauvegarder seulement si le contenu coll√© est diff√©rent
                if (pastedValue !== initialValue) {
                  saveStateToHistory();
                  saveLocalDraft();
                  markEdited();
                  initialValue = pastedValue;
                  hasBeenModified = false;
                }
              }, 0);
            });
          }
          
          if(BOLD_HEADERS.includes(header.toLowerCase())){
            cell.style.fontWeight='bold';
            cell.style.color='#000';
          }
          cell.setAttribute('tabindex','0');
          
          // Sauvegarder seulement lors de vraies modifications (input)
          cell.oninput=()=>{
            hasBeenModified = true;
            
            // Reset undo/redo sync timeout when user starts editing
            clearUndoRedoSyncTimeout();
            
            // Start or continue operation tracking for cell edits
            if (!currentOperation || currentOperation.type !== OPERATION_TYPES.CELL_EDIT) {
                startOperation(OPERATION_TYPES.CELL_EDIT, {
                    cellLabel: header,
                    initialValue: initialValue,
                    rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                    columnLabel: header,
                    editCount: 1,
                    edits: [{
                        columnLabel: header,
                        rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                        initialValue: initialValue,
                        currentValue: cell.textContent
                    }]
                });
            } else {
                // Increment edit count and add to edits array
                currentOperation.data.editCount = (currentOperation.data.editCount || 1) + 1;
                currentOperation.data.edits.push({
                    columnLabel: header,
                    rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                    initialValue: initialValue,
                    currentValue: cell.textContent
                });
                
                addToOperation({
                    cellLabel: header,
                    currentValue: cell.textContent,
                    rowIndex: Array.from(cell.closest('tr').parentElement.children).indexOf(cell.closest('tr')),
                    columnLabel: header
                });
            }
            
            // Debounce operation completion for cell edits
            if (operationTimeout) clearTimeout(operationTimeout);
            operationTimeout = setTimeout(() => {
                completeOperation();
            }, 1000); // 1 second delay for cell edits
            
            saveStateToHistory();
            saveLocalDraft();
            markEdited();
            // keep caret/position updated while typing
            captureFocusInfo();
            captureSimplePos();
          };
          
          cell.addEventListener('keyup', (e) => {
            // update caret after navigation keys
            if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Home','End','PageUp','PageDown'].includes(e.key)) {
              captureFocusInfo();
              captureSimplePos();
            }
          });
          return cell;
        }

        // Ensure DDN column exists visually even if an older HTML version is served (Live Server/mobile cache)
        function ensureDDNHeader(){
          try {
            const theadRow = document.querySelector('#data-table thead tr');
            if (!theadRow) return;
            const labels = Array.from(theadRow.children).map(th=>th.textContent.trim());
            if (labels.includes('DDN')) return; // already there

            // Create the DDN header cell
            const th = document.createElement('th');
            th.setAttribute('scope','col');
            th.className = 'py-2 px-2 md:px-4';
            th.textContent = 'DDN';

            // Insert right after Nom_Pr√©nom if present, else before Diagnostic_initial, else at the end
            let insertIndex = labels.indexOf('Nom_Pr√©nom');
            if (insertIndex !== -1) {
              theadRow.insertBefore(th, theadRow.children[insertIndex + 1]);
            } else {
              const diagIdx = labels.indexOf('Diagnostic_initial');
              if (diagIdx !== -1) theadRow.insertBefore(th, theadRow.children[diagIdx]);
              else theadRow.appendChild(th);
            }

            // For each body row, insert a new editable DDN cell at the same index
            const headersNow = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th=>th.textContent);
            const ddnPos = headersNow.indexOf('DDN');
            if (ddnPos !== -1) {
              document.querySelectorAll('#table-body tr').forEach(tr => {
                const cell = createEditableCell('DDN', '');
                // Insert after the first two fixed cells (No, Effacer) + ddnPos offset
                const insertAt = 2 + ddnPos;
                const ref = tr.cells[insertAt];
                if (ref) tr.insertBefore(cell, ref); else tr.appendChild(cell);
              });
            }

            // Adjust tfoot colspan to match new column count
            const tfootLast = document.querySelector('#data-table tfoot td:last-child');
            const totalCols = document.querySelectorAll('#data-table thead th').length;
            if (tfootLast) {
              // first two tds in tfoot row are No/Effacer holders; last td should span the remainder
              const span = Math.max(0, totalCols - 2);
              tfootLast.setAttribute('colspan', String(span));
            }
          } catch(e) { /* noop */ }
        }

        // Keep tfoot colspan in sync with the current number of columns
        function updateTfootColspan() {
            try {
                const totalCols = document.querySelectorAll('#data-table thead th').length;
                const tfootRow = document.querySelector('#data-table tfoot tr');
                if (!tfootRow) return;
                // First cell spans the first two utility columns (No, Effacer)
                const firstTd = tfootRow.querySelector('td:first-child');
                if (firstTd) firstTd.setAttribute('colspan', '2');
                // Last cell spans the remainder
                const lastTd = tfootRow.querySelector('td:last-child');
                if (lastTd) lastTd.setAttribute('colspan', String(Math.max(0, totalCols - 2)));
            } catch(_) {}
        }
        // Align table headers with server column keys (case-insensitive)
        function reconcileHeadersWithServer() {
          try {
            if (!appState.serverColumns || appState.serverColumns.length === 0) return;
            const server = appState.serverColumns;
            const theadTh = Array.from(document.querySelectorAll('#data-table thead th')).slice(2);
            theadTh.forEach((th) => {
              const label = th.textContent;
              if (server.includes(label)) return; // exact match OK
              const found = server.find(k => k.toLowerCase() === label.toLowerCase());
              if (found) {
                th.textContent = found; // normalize header to the exact server key
              }
            });
          } catch (e) { /* no-op */ }
        }
        // === Excel import helpers ===
        function normalizeKey(k){
          if(!k) return '';
          return String(k).trim().toLowerCase().replace(/[_\-\s]+/g,' ').replace(/\s+/g,' ').normalize('NFD').replace(/[\u0300-\u036f]/g,'');
        }
        // === Name formatting helpers ===
        function _titleCasePart(s) {
          if (!s) return '';
          return s.split(' ').map(word => {
            if (word.length <= 2) return word.toLowerCase();
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
          }).join(' ');
        }
        
        function formatNomPrenom(raw){
          if(raw==null) return '';
          let s = String(raw).trim().replace(/\s+/g, ' ');
          if(!s) return '';
          // If there's a comma, interpret as "LAST, First ..."
          if(s.includes(',')){
            const [last, rest] = s.split(',');
            const nom = last.trim().toUpperCase();
            const prenom = _titleCasePart((rest||'').trim());
            return prenom ? `${nom}\n${prenom}` : nom;
          }
          // Default: first token is last name; remainder is first name(s)
          const parts = s.split(' ');
          const nom = (parts.shift()||'').toUpperCase();
          const prenom = _titleCasePart(parts.join(' ').trim());
          return prenom ? `${nom}\n${prenom}` : nom;
        }
        
        function isNomPrenomLabel(label){
          try {
            const n = normalizeKey(label);
            return n === 'nom prenom' || n.includes('nom prenom');
          } catch(_) {
            return label === 'Nom_Pr√©nom';
          }
        }
        function buildHeaderMap(sheetKeys, tableHeaders){
          const map = {};
          const nSheet = sheetKeys.map(k=>({raw:k, norm:normalizeKey(k)}));
          const nTable = tableHeaders.map(k=>({raw:k, norm:normalizeKey(k)}));

          // Raw alias definitions (human-friendly)
          const aliasesRaw = {
            'date de saisie': ['date', 'date saisie', 'date d\'entree', 'date entree', 'datesaisie', 'date d\'enregistrement'],
            'pec finale': ['pec finale', 'pec finale (definitive)', 'prise en charge finale', 'prise en charge def'],
            'pec initiale': ['pec initiale', 'prise en charge initiale', 'prise en charge init'],
            'nom_prenom': ['nom prenom', 'nom_pr√©nom', 'nom et prenom', 'nom et pr√©nom', 'patient', 'nom complet', 'fullname', 'name'],
            'ddn': ['date de naissance', 'date naissance', 'naissance', 'dob', 'date of birth', 'birth date', 'dn'],
            'diagnostic_initial': ['diagnostic initial', 'diagnostic', 'diag initial', 'diagnostic de depart'],
            'information complementaire': ['infos', 'information complementaire', 'commentaire', 'notes', 'remarques', 'obs', 'observations'],
            'numero_tel': ['tel', 'telephone', 'numero tel', 'numero telephone', 'phone', 'portable', 'gsm', 'mobile']
          };
          // Normalize alias values once for consistent matching
          const aliases = Object.fromEntries(
            Object.entries(aliasesRaw).map(([k, arr]) => [normalizeKey(k), arr.map(v => normalizeKey(v))])
          );

          nTable.forEach(t => {
            // 1) exact normalized match
            let match = nSheet.find(s => s.norm === t.norm);

            // 2) alias match (normalized)
            if(!match){
              const listNorm = aliases[t.norm] || [];
              match = nSheet.find(s => listNorm.includes(s.norm));
            }

            // 3) fuzzy for DDN ‚Äî accept any column that contains naiss/birth/dob tokens
            if(!match && t.norm === 'ddn'){
              match = nSheet.find(s => /\b(naiss|birth|dob|date naissance|date de naissance)\b/.test(s.norm))
                    || nSheet.find(s => s.norm.includes('naiss') || s.norm.includes('birth') || s.norm.includes('dob'));
            }

            if(match) map[t.raw] = match.raw; // map table header -> sheet column
          });
          return map;
        }
        function coerceCellValue(header, val){
          if(val==null) return '';
          const h = normalizeKey(header);

          // Excel serial number handling for date-like headers
          if((h.includes('date') || h==='ddn') && typeof val === 'number'){
            try {
              const epoch = new Date(Date.UTC(1899,11,30));
              const d = new Date(epoch.getTime() + val*86400000);
              const dd = String(d.getUTCDate()).padStart(2,'0');
              const mm = String(d.getUTCMonth()+1).padStart(2,'0');
              const yy = String(d.getUTCFullYear()).slice(-2);
              return `${dd}/${mm}/${yy}`;
            } catch(_) { /* fallthrough */ }
          }

          // Parse common textual date forms
          if((h.includes('date') || h==='ddn') && typeof val === 'string'){
            const s = val.trim();
            // Normalize separators
            const norm = s.replace(/[.\-]/g,'/').replace(/\s+/g,'');

            // YYYY/MM/DD or YYYY/M/D
            let m = norm.match(/^(\d{4})\/(\d{1,2})\/(\d{1,2})$/);
            if(m){
              const y = parseInt(m[1],10), mo = parseInt(m[2],10), d = parseInt(m[3],10);
              if(mo>=1 && mo<=12 && d>=1 && d<=31){
                return `${String(d).padStart(2,'0')}/${String(mo).padStart(2,'0')}/${String(y).slice(-2)}`;
              }
            }

            // DD/MM/YYYY or D/M/YY etc.
            m = norm.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
            if(m){
              const d = parseInt(m[1],10), mo = parseInt(m[2],10), y = parseInt(m[3],10);
              if(mo>=1 && mo<=12 && d>=1 && d<=31){
                return `${String(d).padStart(2,'0')}/${String(mo).padStart(2,'0')}/${String(y).toString().slice(-2)}`;
              }
            }

            // Fallback: try Date.parse cautiously
            const t = Date.parse(s);
            if(!isNaN(t)){
              const d = new Date(t);
              const dd = String(d.getUTCDate()).padStart(2,'0');
              const mm = String(d.getUTCMonth()+1).padStart(2,'0');
              const yy = String(d.getUTCFullYear()).slice(-2);
              return `${dd}/${mm}/${yy}`;
            }
          }

          return String(val);
        }
        async function importExcelFromFile(file){
          try{
            if(!file){ showMessage('Aucun fichier s√©lectionn√©','info'); return; }
            const ext = (file.name.split('.').pop()||'').toLowerCase();
            if(!['xlsx','xls','csv'].includes(ext)){
              showMessage('Format non pris en charge. Utilisez .xlsx, .xls ou .csv','info');
              return;
            }
            updateStatus('Import en cours...','saving');
            const data = await file.arrayBuffer();
            const wb = XLSX.read(data, { type:'array' });
            const sheetName = wb.SheetNames[0];
            const ws = wb.Sheets[sheetName];
            const rows = XLSX.utils.sheet_to_json(ws, { defval:'', raw:false });
            if(!Array.isArray(rows) || rows.length===0){ showMessage('Feuille vide','info'); updateStatus('Synchronis√©','success'); return; }

            // Colonnes syst√®me √† ignorer lors de l'import
            const systemColumns = ['No', 'Effacer', 'Date de saisie'];
            
            // Colonnes de donn√©es √† importer (excluant les colonnes syst√®me)
            const dataColumns = getHeaders().filter(header => !systemColumns.includes(header));
            
            // Filtrer les lignes : seulement celles avec Nom_Pr√©nom rempli
            const validRows = rows.filter(row => {
              const nomPrenom = row['Nom_Pr√©nom'] || row['Nom_Pr√©nom'] || row['Nom Pr√©nom'] || row['NomPr√©nom'];
              return nomPrenom && nomPrenom.trim() !== '';
            });

            if(validRows.length === 0){
              showMessage('Aucune ligne avec Nom_Pr√©nom rempli trouv√©e dans le fichier','info');
              updateStatus('Import termin√©','success');
              return;
            }

                            // Clean: Removed debug log

            // Construire les donn√©es d'import avec gestion intelligente
            const importData = validRows.map((row, index) => {
              const obj = {};
              
              // G√©n√©rer automatiquement une cl√© primaire unique compatible smallint
              // Utiliser un index simple pour √©viter les d√©passements de type
              obj[supabaseConfig.primaryKeyColumn] = index + 1;
              
              // Ajouter automatiquement la date de saisie
              obj['Date de saisie'] = getFormattedDate();
              
              // Importer seulement les colonnes de donn√©es (pas les colonnes syst√®me)
              dataColumns.forEach(column => {
                const sheetKey = findBestMatch(column, Object.keys(row));
                if (sheetKey && row[sheetKey] !== undefined && row[sheetKey] !== '') {
                  obj[column] = coerceCellValue(column, row[sheetKey]);
                } else {
                  obj[column] = '';
                }
              });
              
              return obj;
            });

            // Charger dans le tableau
            if(loadTableData(importData)){
              saveStateToHistory();
              saveLocalDraft();
              markEdited();
              updateStatus('Import√© (non sauvegard√©)','success');
              showMessage(`Import r√©ussi: ${importData.length} ligne(s) avec Nom_Pr√©nom. Colonnes syst√®me g√©n√©r√©es automatiquement.`);
            } else {
              updateStatus('Erreur import','error');
              showMessage('√âchec du chargement des donn√©es import√©es.','info');
            }
          } catch(err){
            console.error(err);
            updateStatus('Erreur import','error');
            showMessage('Erreur lors de l\'import. V√©rifiez le fichier.','info');
          }
        }

        // Fonction pour trouver la meilleure correspondance de colonne
        function findBestMatch(targetColumn, availableColumns) {
          // Correspondance exacte
          if (availableColumns.includes(targetColumn)) {
            return targetColumn;
          }
          
          // Correspondance sans espaces ni caract√®res sp√©ciaux
          const normalizedTarget = targetColumn.replace(/[\s\-_]/g, '').toLowerCase();
          for (const col of availableColumns) {
            const normalizedCol = col.replace(/[\s\-_]/g, '').toLowerCase();
            if (normalizedCol === normalizedTarget) {
              return col;
            }
          }
          
          // Correspondance partielle
          for (const col of availableColumns) {
            const normalizedCol = col.replace(/[\s\-_]/g, '').toLowerCase();
            if (normalizedCol.includes(normalizedTarget) || normalizedTarget.includes(normalizedCol)) {
              return col;
            }
          }
          
          return null;
        }

        function loadTableData(data) {
            if (!data) { 
                log('Structure invalide', 'error'); 
                return false; 
            }
            
            // Protection suppl√©mentaire contre l'effacement du tableau
            if (!Array.isArray(data) || data.length === 0) {
                console.warn('‚ö†Ô∏è loadTableData: data is not a valid array or is empty, refusing to clear table');
                log('Donn√©es invalides - tableau non modifi√©', 'warning');
                return false;
            }
            
            const tbody = document.getElementById('table-body');
            tbody.innerHTML = '';
            const headers = getHeaders();
            
            data.forEach((rowData, index) => {
                const row = document.createElement('tr');
                row.className = 'bg-white hover:bg-gray-100 transition-colors cursor-pointer';
                
                if (rowData[supabaseConfig.primaryKeyColumn]) {
                    row.dataset.key = rowData[supabaseConfig.primaryKeyColumn];
                }

                // Create row number cell
                const numCell = document.createElement('td');
                numCell.textContent = index + 1;
                numCell.className = 'py-2 px-2 md:px-4 font-bold text-gray-800 whitespace-nowrap cursor-pointer frozen-column frozen-1';
                numCell.setAttribute('data-label', 'No');
                numCell.title = 'Cliquer pour colorer/effacer la ligne';
                
                // Add event listeners for row painting
                            numCell.addEventListener('mousedown', (e) => { 
                if (e.button !== 0) return; 
                startRowPaint(row); 
                e.preventDefault(); 
            });
            
            numCell.addEventListener('mouseenter', () => { 
                if (isRowPaintDragging) applyRowPaint(row); 
            });
            
            numCell.addEventListener('click', (e) => { 
                e.preventDefault();
                // En mode auto, on colorie/d√©colore directement au clic
                if (paintMode === 'auto') {
                    rowPaintAction = getPaintActionForRow(row);
                    applyRowPaint(row);
                } else if (!isRowPaintDragging) {
                    // En mode manuel, on utilise l'action s√©lectionn√©e
                    rowPaintAction = getPaintActionForRow(row);
                    applyRowPaint(row);
                }
            });
                
                numCell.addEventListener('touchstart', (e) => { 
                    startRowPaint(row); 
                    e.preventDefault(); 
                }, { passive: false });
                
                numCell.addEventListener('touchmove', (e) => { 
                    const t = e.touches && e.touches[0]; 
                    if (!t) return; 
                    const el = document.elementFromPoint(t.clientX, t.clientY); 
                    const tr = el ? el.closest('#table-body tr') : null; 
                    if (tr) applyRowPaint(tr); 
                    e.preventDefault(); 
                }, { passive: false });
                
                row.appendChild(numCell);

                // Add delete/selection cell
                row.appendChild(createDeleteCell(row));

                // Add data cells
                headers.forEach(header => {
                    let value = rowData[header] || '';
                    if (isNomPrenomLabel(header)) {
                        value = formatNomPrenom(value);
                    }
                    row.appendChild(createEditableCell(header, value));
                });

                tbody.appendChild(row);
            });
            
            // Re-apply stored row colors after rebuilding the tbody
            try {
                Array.from(tbody.querySelectorAll('tr')).forEach(tr => {
                    const k = keyForRow(tr);
                    const col = rowColorMap[k];
                    if (col) setRowColor(tr, col);
                });
            } catch(_) {}
            
            log('Donn√©es du tableau charg√©es.', 'success');
            appState.localData = collectTableData();
            appState.dataHash = generateDataHash(appState.localData);
            document.dispatchEvent(new CustomEvent('table:reloaded'));
            updateTfootColspan();
            log('table:reloaded dispatched');
            
            // Mettre √† jour l'affichage du nombre de lignes
            updateRowCount();
            
            return true;
        }

        async function addRow() {
            // Emp√™cher l'ajout en mode visualisation
            if (isViewMode) {
                showMessage('Impossible d\'ajouter des lignes en mode visualisation. D√©sactivez le mode visualisation pour modifier le tableau.', 'warning');
                return;
            }
            
            // Start operation tracking for row addition
            startOperation(OPERATION_TYPES.ROW_INSERT, {
                newRowKey: Date.now() + Math.random()
            });
            
            const tbody = document.getElementById('table-body');
            const row = document.createElement('tr');
            row.className = 'bg-white hover:bg-gray-100 transition-colors cursor-pointer';
            
            // G√©n√©rer une cl√© primaire unique compatible smallint
            const existingKeys = Array.from(tbody.querySelectorAll('tr'))
                .map(tr => parseInt(tr.dataset.key) || 0)
                .filter(key => key > 0);
            
            let newKey = 1;
            if (existingKeys.length > 0) {
                newKey = Math.max(...existingKeys) + 1;
            }
            
            // S'assurer que la cl√© est dans la plage smallint
            if (newKey > 32767) {
                newKey = 1; // Recommencer √† 1 si on d√©passe la limite
            }
            
            row.dataset.key = newKey.toString();

            // Create row number cell
            const numCell = document.createElement('td');
            numCell.textContent = tbody.children.length + 1;
            numCell.className = 'py-2 px-2 md:px-4 font-bold text-gray-800 whitespace-nowrap cursor-pointer frozen-column frozen-1';
            numCell.setAttribute('data-label', 'No');
            numCell.title = 'Cliquer pour colorer/effacer la ligne';
            
                            numCell.addEventListener('mousedown', (e) => { 
                    if (e.button !== 0) return; 
                    startRowPaint(row); 
                    e.preventDefault(); 
                });
                
                numCell.addEventListener('mouseenter', () => { 
                    if (isRowPaintDragging) applyRowPaint(row); 
                });
                
                numCell.addEventListener('click', (e) => { 
                    e.preventDefault();
                    // En mode auto, on colorie/d√©colore directement au clic
                    if (paintMode === 'auto') {
                        rowPaintAction = getPaintActionForRow(row);
                        applyRowPaint(row);
                    } else if (!isRowPaintDragging) {
                        // En mode manuel, on utilise l'action s√©lectionn√©e
                        rowPaintAction = getPaintActionForRow(row);
                        applyRowPaint(row);
                    }
                });
            
            numCell.addEventListener('touchstart', (e) => { 
                startRowPaint(row); 
                e.preventDefault(); 
            }, { passive: false });
            
            numCell.addEventListener('touchmove', (e) => { 
                const t = e.touches && e.touches[0]; 
                if (!t) return; 
                const el = document.elementFromPoint(t.clientX, t.clientY); 
                const tr = el ? el.closest('#table-body tr') : null; 
                if (tr) applyRowPaint(tr); 
                e.preventDefault(); 
            }, { passive: false });
            
            row.appendChild(numCell);

            // Add delete/selection cell
            row.appendChild(createDeleteCell(row));

            // Add date cell (pre-filled)
            const dateCell = createEditableCell('Date de saisie', getFormattedDate());
            row.appendChild(dateCell);

            // Add remaining headers
            const headers = getHeaders().slice(1);
            headers.forEach(header => { 
                row.appendChild(createEditableCell(header, '')); 
            });

            tbody.appendChild(row);
            
            try { 
                const k = keyForRow(row); 
                const col = rowColorMap[k]; 
                if (col) setRowColor(row, col); 
            } catch(_) {}
            
            // Complete the operation
            completeOperation();
            
            markEdited();
            
            // Mettre √† jour l'affichage du nombre de lignes
            updateRowCount();
        }

        async function deleteRows(rows) { 
            if (!rows || rows.length === 0) return;
            
            // Emp√™cher la suppression dans les snapshots ET en mode visualisation
            if (snapshotMode === 'snapshot') {
                showMessage('Impossible de supprimer des lignes dans un snapshot. Retournez aux donn√©es en direct pour modifier le tableau.', 'warning');
                return;
            }
            
            // Emp√™cher la suppression en mode visualisation
            if (isViewMode) {
                showMessage('Impossible de supprimer des lignes en mode visualisation. D√©sactivez le mode visualisation pour modifier le tableau.', 'warning');
                return;
            }
            
            // Safety check: ensure we're not in the middle of an undo operation
            if (currentOperation && currentOperation.type.includes('undo')) {
                // Clean: Removed debug log
                return;
            }
            
            // Start operation tracking for deletion (Excel-style: single operation for multiple rows)
            startOperation(OPERATION_TYPES.ROW_DELETE, {
                deletedRows: rows.length,
                rowKeys: rows.map(r => r.dataset.key).filter(Boolean),
                rowData: rows.map(r => {
                    const rowData = {};
                    const cells = Array.from(r.querySelectorAll('td')).slice(2); // Skip No and Delete columns
                    const headers = Array.from(document.querySelectorAll('#data-table thead th')).slice(2).map(th => th.textContent);
                    cells.forEach((cell, i) => {
                        if (headers[i]) {
                            rowData[headers[i]] = rowData[headers[i]] = cell.textContent;
                        }
                    });
                    return rowData;
                }),
                rowNumbers: rows.map(r => {
                    const noCell = r.querySelector('td:first-child');
                    return noCell ? parseInt(noCell.textContent) : null;
                }).filter(n => !isNaN(n))
            });
            
            const keys = rows.map(r => r.dataset.key).filter(Boolean); 
            
            try { 
                if (keys.length > 0) { 
                    const { error } = await supabase
                        .from(supabaseConfig.tableName)
                        .delete()
                        .in(supabaseConfig.primaryKeyColumn, keys); 
                    
                    if (error) throw error; 
                    log(`Supprim√© ${keys.length} ligne(s) c√¥t√© serveur.`, 'success'); 
                } 
                

                
                // Remove rows from DOM
                rows.forEach(r => r.remove()); 
                
                // Renumber rows
                document.querySelectorAll('#table-body tr').forEach((tr, idx) => { 
                    const noCell = tr.querySelector('td:first-child'); 
                    if (noCell) noCell.textContent = idx + 1; 
                    tr.classList.remove('selected-row'); 
                });
                
                // Rebuild color map after deletions and renumbering
                rowColorMap = {};
                Array.from(document.querySelectorAll('#table-body tr')).forEach(tr => {
                    const k = keyForRow(tr);
                    const c = tr.style.backgroundColor;
                    if (c && c !== '') rowColorMap[k] = c;
                });
                
                persistRowColors();
                
                // Complete the operation
                completeOperation();
                
                saveLocalDraft(); 
                markEdited(); 
                updateStatus('Ligne(s) supprim√©e(s)', 'success'); 
                
                // Mettre √† jour l'affichage du nombre de lignes
                updateRowCount();
                
                // Immediately sync with prune to avoid server reintroducing deleted rows
                await syncToMaster(true, true);
            } catch(err) { 
                // Cancel operation on error
                cancelOperation();
                log('Erreur lors de la suppression: ' + err.message, 'error'); 
                updateStatus('Erreur de suppression', 'error'); 
            } 
        }

        // Data synchronization
        async function fetchInitialData() { 
            log('Chargement des donn√©es (full fetch)...'); 
            updateStatus('Connexion...'); 
            
            try { 
                // Restore undo/redo stacks for this session
                restoreHistoryStacks();
                const { data, error } = await supabase
                    .from(supabaseConfig.tableName)
                    .select('*')
                    .order(supabaseConfig.primaryKeyColumn, { ascending: true }); 
                
                if (error) throw error; 
                
                if (Array.isArray(data) && data.length > 0) { 
                    appState.serverColumns = Object.keys(data[0]); 
                }
                
                reconcileHeadersWithServer();
                ensureDDNHeader();
                
                if (loadTableData(data)) { 
                    updateStatus('Synchronis√©', 'success'); 
                    saveStateToHistory(); 
                }
            } catch(e) { 
                log('Erreur lors du chargement des donn√©es : ' + e.message, 'error'); 
                updateStatus('Erreur de connexion', 'error'); 
            }
        }

        async function syncToMaster(isManualSave = false, pruneMissing = false) {
            // ENHANCED: Block sync during undo/redo operations (except manual saves)
            if (!isManualSave && isPerformingUndoRedo) {
                log('üö´ Sync BLOCKED - undo/redo in progress (manual save allowed)');
                return;
            }
            
            // ENHANCED: Block sync during undo/redo sync windows (except manual saves)
            if (!isManualSave && Date.now() < suppressAutosaveUntil) {
                log('üö´ Sync BLOCKED - undo/redo sync window active (manual save allowed)');
                return;
            }
            
            try { 
                if (autosaveTicker) clearInterval(autosaveTicker); 
            } catch(_) {}
            
            lastShownCountdown = null;
            
            const modal = document.getElementById('confirmation-modal');
            if (modal && !modal.classList.contains('hidden')) { 
                log('Sync ignor√©e: modale ouverte.'); 
                return; 
            }
            
            // ‚úÖ CAPTURER LA CELLULE S√âLECTIONN√âE AVANT LA SAUVEGARDE
            const activeElement = document.activeElement;
            
            if (activeElement && activeElement.tagName === 'TD' && activeElement.contentEditable === 'true') {
                capturedFocusState = {
                    element: activeElement,
                    position: getCaretOffsetWithin(activeElement),
                    timestamp: Date.now(),
                    rowIndex: Array.from(activeElement.closest('tr').parentNode.querySelectorAll('tr')).indexOf(activeElement.closest('tr')),
                    colLabel: activeElement.getAttribute('data-label') || ''
                };
                
                log(`üìù Cellule s√©lectionn√©e captur√©e avant sauvegarde: ${capturedFocusState.colLabel}, position ${capturedFocusState.position}`, 'info');
            } else {
                log('‚ö†Ô∏è Aucune cellule active trouv√©e pour capture avant sauvegarde', 'warning');
            }
            
            // Remember which cell and caret position were active before saving (legacy)
            captureFocusInfo();
            captureSimplePos();
            
            if (isManualSave && saveTimeout) { 
                clearTimeout(saveTimeout); 
            }
            
            const current = collectTableData();
            const currentHash = generateDataHash(current);
            
            let rowsForSync = current.rows.map(row => { 
                if (!appState.serverColumns) return row; 
                
                const allowed = new Set([supabaseConfig.primaryKeyColumn, ...appState.serverColumns]); 
                const filtered = {}; 
                
                for (const k in row) { 
                    if (allowed.has(k)) filtered[k] = row[k]; 
                } 
                
                return filtered; 
            });
            
            if (!isManualSave && currentHash === appState.dataHash) { 
                log('Pas de changement d√©tect√©.'); 
                isDirty = false; 
                updateStatus('Synchronis√©', 'success'); 
                return; 
            }
            
            log('Synchronisation des donn√©es vers Supabase...');
            updateStatus('Sauvegarde en cours...', 'saving');
            isDirty = false;
            
            try {
                // Utiliser upsert pour toutes les op√©rations pour √©viter les conflits de cl√© primaire
                if (rowsForSync.length > 0) {
                    const { error: upsertError } = await supabase
                        .from(supabaseConfig.tableName)
                        .upsert(rowsForSync, { 
                            onConflict: supabaseConfig.primaryKeyColumn,
                            ignoreDuplicates: false
                        });
                    if (upsertError) {
                        console.error('‚ùå Erreur upsert:', upsertError);
                        throw upsertError;
                    }
                }

                // Optionally prune server rows that are missing locally (for undo/redo or explicit deletions)
                if (pruneMissing) {
                    try {
                        const { data: serverKeysRows, error: fetchKeysErr } = await supabase
                            .from(supabaseConfig.tableName)
                            .select(supabaseConfig.primaryKeyColumn);
                        if (fetchKeysErr) throw fetchKeysErr;
                        const localKeys = new Set(current.rows.map(r => r[supabaseConfig.primaryKeyColumn]).filter(k => k != null));
                        const serverKeys = (serverKeysRows || []).map(r => r[supabaseConfig.primaryKeyColumn]).filter(k => k != null);
                        const keysToDelete = serverKeys.filter(k => !localKeys.has(k));
                        if (keysToDelete.length > 0) {
                            const { error: delErr } = await supabase
                                .from(supabaseConfig.tableName)
                                .delete()
                                .in(supabaseConfig.primaryKeyColumn, keysToDelete);
                            if (delErr) throw delErr;
                            log(`üßπ Serveur nettoy√©: ${keysToDelete.length} ligne(s) supprim√©e(s) absentes localement.`);
                        }
                    } catch (pruneErr) {
                        console.error('‚ùå Erreur lors du prune des lignes manquantes:', pruneErr);
                    }
                }
                
                updateStatus('Sauvegard√©', 'success');
                
                // Enregistrer le timestamp de sauvegarde pour √©viter les conflits temps r√©el
                lastSaveTime = Date.now();
                log(`‚úÖ Sauvegarde r√©ussie √† ${new Date(lastSaveTime).toLocaleTimeString()} - Cooldown temps r√©el activ√© pour ${REALTIME_COOLDOWN_MS}ms`);
                
                // ‚úÖ RESTAURER LA CELLULE S√âLECTIONN√âE APR√àS LA SAUVEGARDE
                if (capturedFocusState && capturedFocusState.element) {
                    log(`üîÑ Restauration de la cellule s√©lectionn√©e apr√®s sauvegarde: ${capturedFocusState.colLabel}`, 'info');
                    
                    setTimeout(() => {
                        try {
                            // Restaurer le focus sur la cellule
                            capturedFocusState.element.focus();
                            log(`‚úÖ Focus restaur√© sur la cellule: ${capturedFocusState.colLabel}`, 'success');
                            
                            // Restaurer la position du curseur
                            if (capturedFocusState.position !== null && capturedFocusState.position !== undefined) {
                                try {
                                    setCaretAt(capturedFocusState.element, capturedFocusState.position);
                                    log(`‚úÖ Curseur restaur√© √† la position ${capturedFocusState.position} dans ${capturedFocusState.colLabel}`, 'success');
                                } catch (caretError) {
                                    log(`‚ö†Ô∏è Erreur lors de la restauration du curseur: ${caretError.message}`, 'warning');
                                    // Fallback: placer le curseur √† la fin
                                    try {
                                        setCaretAt(capturedFocusState.element, null);
                                        log(`‚úÖ Curseur plac√© √† la fin (fallback) dans ${capturedFocusState.colLabel}`, 'success');
                                    } catch (fallbackError) {
                                        log(`‚ùå Erreur fallback: ${fallbackError.message}`, 'error');
                                    }
                                }
                            } else {
                                log(`‚ö†Ô∏è Position du curseur non disponible dans ${capturedFocusState.colLabel}, placement √† la fin`, 'warning');
                                // Placer le curseur √† la fin
                                try {
                                    setCaretAt(capturedFocusState.element, null);
                                    log(`‚úÖ Curseur plac√© √† la fin dans ${capturedFocusState.colLabel}`, 'success');
                                } catch (fallbackError) {
                                    log(`‚ùå Erreur fallback: ${fallbackError.message}`, 'error');
                                }
                            }
                            
                            // Faire d√©filer vers la cellule restaur√©e (sans effet visuel)
                            capturedFocusState.element.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                            
                        } catch (error) {
                            log(`‚ùå Erreur lors de la restauration de la cellule s√©lectionn√©e: ${error.message}`, 'error');
                        }
                    }, 100);
                    
                } else {
                    log('‚ö†Ô∏è Aucune cellule s√©lectionn√©e √† restaurer apr√®s sauvegarde', 'warning');
                }
                
                // ‚úÖ NOUVELLE LOGIQUE: Si notre restauration a r√©ussi, ne pas utiliser l'ancienne
                if (capturedFocusState && capturedFocusState.element) {
                    log(`‚úÖ Restauration personnalis√©e r√©ussie, ancienne restauration ignor√©e pour √©viter les conflits`);
                } else {
                    log(`syncToMaster -> Focus restoration (lastCellPos=${JSON.stringify(lastCellPos)}, lastFocusInfo.col=${lastFocusInfo ? lastFocusInfo.colLabel : ''})`);
                    
                    // Restaurer le focus directement sans recharger les donn√©es
                    // car les donn√©es sont d√©j√† synchronis√©es avec Supabase
                    setTimeout(() => {
                        log('üîç Restauration directe du focus sans rechargement...');
                        
                        // Try simple row/cell index first
                        const posResult = focusCellByPos(lastCellPos);
                        log(`üîç focusCellByPos result: ${posResult}`);
                        
                        if (!posResult) {
                            // Fallback to the richer label+caret based restore
                            const infoResult = focusCellFromInfo(lastFocusInfo);
                            log(`üîç focusCellFromInfo result: ${infoResult}`);
                            
                            if (!infoResult) {
                                log('üîç Both focus methods failed, trying delayed retry...');
                                setTimeout(() => { 
                                    if (!focusCellByPos(lastCellPos) && !focusCellFromInfo(lastFocusInfo)) { 
                                        log('üîç Delayed retry also failed, trying final attempt...');
                                        setTimeout(() => { 
                                            const finalPos = focusCellByPos(lastCellPos);
                                            const finalInfo = focusCellFromInfo(lastFocusInfo);
                                            log(`üîç Final attempt - pos: ${finalPos}, info: ${finalInfo}`);
                                        }, 250); 
                                    } 
                                }, 50);
                            }
                        }
                    }, 100);
                }
            } catch(e) {
                log('Erreur de sauvegarde : ' + e.message, 'error');
                updateStatus('Erreur de sauvegarde', 'error');
            }
        }

        async function pullFromMaster() { 
            log('R√©cup√©ration des derni√®res donn√©es...'); 
            await fetchInitialData(); 
        }
        
        // Handle realtime updates from Supabase
        function handleRealtimeUpdate(payload) {
            console.log('üîÑ Realtime update received:', payload);
            
            // Avoid update loops
            if (window.isLocalSaveInProgress) {
                console.log('‚ö†Ô∏è Realtime update ignored (local save in progress)');
                return;
            }

            // Process update based on event type
            switch (payload.eventType) {
                case 'INSERT':
                    console.log('‚ûï New row inserted via realtime');
                    break;
                case 'UPDATE':
                    console.log('‚úèÔ∏è Row updated via realtime');
                    break;
                case 'DELETE':
                    console.log('üóëÔ∏è Row deleted via realtime');
                    break;
            }

            // ‚úÖ CORRECTION: √âviter le rechargement automatique qui peut interf√©rer avec la restauration du focus
            // Seulement recharger si c'est vraiment n√©cessaire et si aucune restauration de focus n'est en cours
            if (capturedFocusState && capturedFocusState.element) {
                console.log('‚ö†Ô∏è Realtime update ignor√© - restauration de focus en cours pour √©viter les conflits');
                return;
            }
            
            // Refresh data from Supabase after a short delay (seulement si n√©cessaire)
            setTimeout(() => {
                if (typeof fetchInitialData === 'function') {
                    console.log('üîÑ Refreshing data from Supabase via realtime update...');
                    fetchInitialData().then(() => {
                        console.log('‚úÖ Data refreshed from Supabase via realtime');
                        updateStatus('Donn√©es synchronis√©es via temps r√©el', 'success');
                    }).catch(error => {
                        console.error('‚ùå Error refreshing data via realtime:', error);
                        updateStatus('Erreur de synchronisation temps r√©el', 'error');
                    });
                } else {
                    console.warn('‚ö†Ô∏è fetchInitialData function not available for realtime sync');
                }
            }, 1000);
        }

        // Setup realtime subscription for live data synchronization
        function setupRealtimeSubscription() {
            try {
                if (realtimeSubscription) {
                    console.log('üîÑ Cleaning up existing realtime subscription...');
                    supabase.removeChannel(realtimeSubscription);
                }

                console.log('üîÑ Setting up realtime subscription...');
                
                realtimeSubscription = supabase.channel('table-changes')
                    .on('postgres_changes', { 
                        event: 'INSERT', 
                        schema: 'public', 
                        table: 'staffTable' 
                    }, handleRealtimeUpdate)
                    .on('postgres_changes', { 
                        event: 'UPDATE', 
                        schema: 'public', 
                        table: 'staffTable' 
                    }, handleRealtimeUpdate)
                    .on('postgres_changes', { 
                        event: 'DELETE', 
                        schema: 'public', 
                        table: 'staffTable' 
                    }, handleRealtimeUpdate)
                    .subscribe(status => {
                        console.log('üì° Realtime subscription status:', status);
                        if (status === 'SUBSCRIBED') {
                            console.log('‚úÖ Realtime synchronization activated');
                            updateStatus('Synchronisation temps r√©el activ√©e', 'success');
                        } else if (status === 'CHANNEL_ERROR') {
                            console.log('‚ùå Realtime synchronization error');
                            updateStatus('Erreur de synchronisation', 'error');
                        }
                    });
                    
                console.log('‚úÖ Realtime subscription configured');
            } catch (error) {
                console.error('‚ùå Error setting up realtime subscription:', error);
                updateStatus('Erreur de configuration temps r√©el', 'error');
            }
        }



        // Password authentication
        function checkPassword() { 
            const pwd = document.getElementById('password').value; 
            const err = document.getElementById('error-message'); 
            const passwordInput = document.getElementById('password');
            const togglePassword = document.getElementById('toggle-password');
            
            if (pwd === APP_CONFIG.password) { 
                appState.isLoggedIn = true; 
                sessionStorage.setItem('isLoggedIn', '1'); 
                
                // Masquer le login et afficher le tableau imm√©diatement
                document.getElementById('login-container').classList.add('hidden'); 
                document.getElementById('table-container').classList.remove('hidden'); 
                
                // S'assurer que le tableau est visible
                const tableContainer = document.getElementById('table-container');
                const table = document.getElementById('data-table');
                
                if (tableContainer) {
                    tableContainer.style.display = 'block';
                    tableContainer.style.visibility = 'visible';
                }
                
                if (table) {
                    table.style.display = 'table';
                    table.style.visibility = 'visible';
                }
                
                // Initialiser compl√®tement l'application apr√®s la connexion
                initializeApp();
                
            } else { 
                err.textContent = 'Mot de passe incorrect. Le champ est maintenant visible pour faciliter la correction.';
                
                // Transformer automatiquement le champ en texte visible pour faciliter la correction
                passwordInput.type = 'text';
                togglePassword.checked = true;
                
                // Remettre le focus dans le champ pour permettre la correction imm√©diate
                passwordInput.focus();
                
                // S√©lectionner tout le texte pour faciliter la correction
                passwordInput.select();
                
                // Ajouter une classe CSS pour indiquer visuellement l'erreur
                passwordInput.classList.add('password-error');
                
                // Retirer la classe d'erreur quand l'utilisateur commence √† taper
                passwordInput.addEventListener('input', function clearErrorStyle() {
                    passwordInput.classList.remove('password-error');
                    passwordInput.removeEventListener('input', clearErrorStyle);
                }, { once: true });
            } 
        }

        // Export functionality
        function downloadExcel() { 
            const table = document.getElementById('data-table'); 
            const ws = XLSX.utils.table_to_sheet(table); 
            const wb = XLSX.utils.book_new(); 
            XLSX.utils.book_append_sheet(wb, ws, 'Staff Data'); 
            XLSX.writeFile(wb, 'Tableau_Staff.xlsx'); 
            showMessage('Excel t√©l√©charg√©.'); 
        }
        
        function downloadPDF() { 
            const { jsPDF } = window.jspdf; 
            const doc = new jsPDF('l', 'pt', 'a4'); 
            doc.autoTable({ html: '#data-table' }); 
            doc.save('Tableau_Staff.pdf'); 
            showMessage('PDF t√©l√©charg√©.'); 
        }
        
        function downloadImage() { 
            const table = document.getElementById('data-table'); 
            
            // ‚úÖ NOUVELLE APPROCHE: Cr√©er une copie du tableau pour la capture
            const tableClone = table.cloneNode(true);
            
            // ‚úÖ Supprimer les classes et styles probl√©matiques
            tableClone.classList.remove('capturing');
            tableClone.style.position = 'static';
            tableClone.style.top = 'auto';
            tableClone.style.zIndex = 'auto';
            
            // ‚úÖ Corriger les en-t√™tes dans la copie
            const theadClone = tableClone.querySelector('thead');
            if (theadClone) {
                theadClone.style.position = 'static';
                theadClone.style.top = 'auto';
                theadClone.style.zIndex = 'auto';
                theadClone.style.backgroundColor = '#15803d'; // Couleur verte des en-t√™tes
                theadClone.style.color = 'white';
                theadClone.style.fontWeight = 'bold';
                theadClone.style.textTransform = 'uppercase';
                
                // ‚úÖ Corriger chaque cellule d'en-t√™te
                const thCells = theadClone.querySelectorAll('th');
                thCells.forEach((th, index) => {
                    th.style.position = 'static';
                    th.style.top = 'auto';
                    th.style.left = 'auto';
                    th.style.zIndex = 'auto';
                    th.style.backgroundColor = '#15803d';
                    th.style.color = 'white';
                    th.style.fontWeight = 'bold';
                    th.style.border = '1px solid #e5e7eb';
                    th.style.padding = '1rem';
                    
                    // ‚úÖ CORRECTION SP√âCIALE pour la colonne "N¬∞" (premi√®re colonne)
                    if (index === 0) {
                        th.style.backgroundColor = '#15803d !important';
                        th.style.color = 'white !important';
                        th.style.fontWeight = 'bold !important';
                        th.style.border = '1px solid #e5e7eb !important';
                        th.style.padding = '1rem !important';
                        th.style.position = 'static !important';
                        th.style.left = 'auto !important';
                        th.style.zIndex = 'auto !important';
                        // ‚úÖ S'assurer que le texte "N¬∞" est visible
                        th.style.visibility = 'visible !important';
                        th.style.opacity = '1 !important';
                        th.style.display = 'table-cell !important';
                    }
                });
            }
            
            // ‚úÖ Corriger les cellules du corps du tableau
            const tbodyClone = tableClone.querySelector('tbody');
            if (tbodyClone) {
                const rows = tbodyClone.querySelectorAll('tr');
                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    cells.forEach((td, cellIndex) => {
                        td.style.position = 'static';
                        td.style.top = 'auto';
                        td.style.left = 'auto';
                        td.style.zIndex = 'auto';
                        td.style.backgroundColor = '#ffffff';
                        td.style.border = '1px solid #e5e7eb';
                        td.style.padding = '1rem';
                        
                        // ‚úÖ CORRECTION SP√âCIALE pour la colonne "N¬∞" (premi√®re colonne)
                        if (cellIndex === 0) {
                            td.style.backgroundColor = '#ffffff !important';
                            td.style.color = '#1f2937 !important'; // Texte fonc√©
                            td.style.fontWeight = 'bold !important';
                            td.style.border = '1px solid #e5e7eb !important';
                            td.style.padding = '1rem !important';
                            td.style.position = 'static !important';
                            td.style.left = 'auto !important';
                            td.style.zIndex = 'auto !important';
                            // ‚úÖ S'assurer que le num√©ro de ligne est visible
                            td.style.visibility = 'visible !important';
                            td.style.opacity = '1 !important';
                            td.style.display = 'table-cell !important';
                            // ‚úÖ Supprimer les classes probl√©matiques
                            td.classList.remove('frozen-column', 'frozen-1');
                        }
                    });
                });
            }
            
            // ‚úÖ Ajouter la copie au DOM temporairement (hors de l'√©cran mais visible)
            tableClone.style.position = 'absolute';
            tableClone.style.left = '-9999px';
            tableClone.style.top = '0px';
            tableClone.style.zIndex = '10000';
            tableClone.style.visibility = 'visible';
            tableClone.style.opacity = '1';
            tableClone.style.display = 'table';
            document.body.appendChild(tableClone);
            
            // ‚úÖ Capture de la copie corrig√©e
            html2canvas(tableClone, {
                useCORS: true,
                allowTaint: true,
                backgroundColor: '#ffffff',
                scale: 2,
                scrollX: 0,
                scrollY: 0,
                width: table.scrollWidth,
                height: table.scrollHeight,
                logging: false,
                // ‚úÖ Options suppl√©mentaires pour garantir la capture
                ignoreElements: (element) => {
                    // Ignorer les √©l√©ments qui pourraient interf√©rer
                    return element === table || element.closest('#data-table') === table;
                },
                onclone: (clonedDoc) => {
                    // S'assurer que la copie est bien visible dans le document clon√©
                    const clonedTable = clonedDoc.querySelector('table');
                    if (clonedTable) {
                        clonedTable.style.visibility = 'visible';
                        clonedTable.style.opacity = '1';
                        clonedTable.style.display = 'table';
                    }
                }
            }).then(canvas => { 
                const link = document.createElement('a'); 
                link.href = canvas.toDataURL('image/png'); 
                link.download = 'Tableau_Staff.png'; 
                link.click(); 
                showMessage('Image t√©l√©charg√©e avec en-t√™tes en haut.'); 
                
                // ‚úÖ Nettoyer la copie temporaire
                document.body.removeChild(tableClone);
                
            }).catch(error => {
                console.error('Erreur lors de la capture:', error);
                showMessage('Erreur lors de la capture d\'√©cran.', 'error');
                
                // ‚úÖ Nettoyer m√™me en cas d'erreur
                if (document.body.contains(tableClone)) {
                    document.body.removeChild(tableClone);
                }
            });
        }

        // Manual save function
        function saveManually() { 
            syncToMaster(true); 
        }

        // Row color binding
        function rebindRowNumberCells() {
            try {
                const rows = document.querySelectorAll('#table-body tr');
                rows.forEach((row) => {
                    const numCell = row.cells && row.cells[0];
                    if (!numCell) return;
                    
                    // Ensure proper classes/title
                    if (!numCell.className.includes('cursor-pointer')) {
                        numCell.className += ' cursor-pointer';
                    }
                    if (!numCell.getAttribute('title')) {
                        numCell.title = 'Cliquer pour colorer/effacer la ligne';
                    }
                    
                    // Replace the cell to drop old listeners
                    const newCell = numCell.cloneNode(true);
                    
                    // Drag start (mouse)
                    newCell.addEventListener('mousedown', (e) => { 
                        if (e.button !== 0) return; 
                        startRowPaint(row); 
                        e.preventDefault(); 
                    });
                    
                    // Drag over other rows (mouse)
                    newCell.addEventListener('mouseenter', () => { 
                        if (isRowPaintDragging) applyRowPaint(row); 
                    });
                    
                    // Simple toggle on click when not dragging
                    newCell.addEventListener('click', (e) => { 
                        e.preventDefault();
                        if (isRowPaintDragging) return;
                        rowPaintAction = getPaintActionForRow(row);
                        applyRowPaint(row);
                    });
                    
                    // Touch support
                    newCell.addEventListener('touchstart', (e) => { 
                        startRowPaint(row); 
                        e.preventDefault(); 
                    }, { passive: false });
                    
                    newCell.addEventListener('touchmove', (e) => {
                        const t = e.touches && e.touches[0]; 
                        if (!t) return; 
                        const el = document.elementFromPoint(t.clientX, t.clientY);
                        const tr = el ? el.closest('#table-body tr') : null; 
                        if (tr) applyRowPaint(tr); 
                        e.preventDefault();
                    }, { passive: false });
                    
                    row.replaceChild(newCell, numCell);
                });
            } catch(_) {}
        }

        // First use hint
        function maybeShowFirstUseHint() {
            try {
                if (localStorage.getItem('rowPaintHintShown') === '1') return;
                showMessage('Astuce: cliquez puis faites glisser sur les num√©ros de ligne pour colorer/effacer.', 'info');
                localStorage.setItem('rowPaintHintShown', '1');
            } catch(_) {}
        }

        // Event listeners setup
        function setupEventListeners() {
            // Before unload warning
            window.addEventListener('beforeunload', function (e) { 
                if (isDirty) { 
                    e.preventDefault(); 
                    e.returnValue = 'Des modifications non sauvegard√©es seront perdues si vous quittez.'; 
                } 
            });

            // Password toggle
            document.getElementById('toggle-password').addEventListener('change', function() { 
                const el = document.getElementById('password'); 
                el.type = this.checked ? 'text' : 'password'; 
            });
            
            // Password enter key
            document.getElementById('password').addEventListener('keydown', function (e) { 
                // Stop any global keyboard shortcuts from interfering
                e.stopPropagation();
                
                if (e.key === 'Enter') { 
                    e.preventDefault(); 
                    checkPassword(); 
                } 
                
                return true;
            });
            
            // Global keyboard shortcuts
            document.addEventListener('keydown', function (e) {
                // Manual save shortcut: Cmd+Z (Mac) or Ctrl+Z (Windows/Linux)
                if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
                    e.preventDefault(); // Prevent browser undo dialog
                    
                    // Only trigger if not in password input
                    const passwordInput = document.getElementById('password');
                    if (passwordInput && document.activeElement === passwordInput) {
                        return;
                    }
                    
                    // Only trigger if not in table cells (to avoid interfering with cell editing)
                    if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                        return;
                    }
                    
                    console.log('üíæ Raccourci clavier de sauvegarde manuelle activ√© (Cmd+Z/Ctrl+Z)');
                    saveManually();
                }
                
                // Alternative save shortcut: Cmd+S (Mac) or Ctrl+S (Windows/Linux)
                if ((e.metaKey || e.ctrlKey) && e.key === 's') {
                    e.preventDefault(); // Prevent browser save dialog
                    
                    // Only trigger if not in password input
                    const passwordInput = document.getElementById('password');
                    if (passwordInput && document.activeElement === passwordInput) {
                        return;
                    }
                    
                    // Only trigger if not in table cells (to avoid interfering with cell editing)
                    if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                        return;
                    }
                    
                    console.log('üíæ Raccourci clavier de sauvegarde manuelle activ√© (Cmd+S/Ctrl+S)');
                    saveManually();
                }
                
                // Undo shortcut: Cmd+Y (Mac) or Ctrl+Y (Windows/Linux)
                if ((e.metaKey || e.ctrlKey) && e.key === 'y') {
                    e.preventDefault(); // Prevent browser history dialog
                    
                    // Only trigger if not in password input
                    const passwordInput = document.getElementById('password');
                    if (passwordInput && document.activeElement === passwordInput) {
                        return;
                    }
                    
                    // Only trigger if not in table cells (to avoid interfering with cell editing)
                    if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                        return;
                    }
                    
                    // Check if undo is available
                    if (typeof undo === 'function' && operationHistory && operationHistory.length > 0) {
                        console.log('‚Ü©Ô∏è Raccourci clavier undo activ√© (Cmd+Y/Ctrl+Y)');
                        undo();
                    } else {
                        console.log('‚ö†Ô∏è Undo non disponible - aucune action √† annuler');
                        showMessage('Aucune action √† annuler', 'info');
                    }
                }
            });
            
            // Additional password field protection
            document.getElementById('password').addEventListener('input', function (e) {
                e.stopPropagation();
                return true;
            });
            
            document.getElementById('password').addEventListener('keypress', function (e) {
                e.stopPropagation();
                return true;
            });
            
            document.getElementById('password').addEventListener('keyup', function (e) {
                e.stopPropagation();
                return true;
            });

            // Table body paste handling
            document.getElementById('table-body').addEventListener('paste', function(e) {
                const active = document.activeElement;
                if (!(active && active.tagName === 'TD' && active.isContentEditable === 'true')) return;
                
                const text = (e.clipboardData || window.clipboardData).getData('text');
                if (!text || (text.indexOf('\t') === -1 && text.indexOf('\n') === -1)) return;
                
                e.preventDefault();
                const rows = text.split(/\r?\n/).filter(r => r.length > 0).map(r => r.split('\t'));
                const startCell = active;
                const startRow = startCell.closest('tr');
                const startIndex = Array.from(startRow.cells).indexOf(startCell);
                let r = startRow;
                
                rows.forEach((cols, ridx) => {
                    if (ridx > 0) {
                        r = r.nextElementSibling;
                        if (!r) {
                            const tbody = document.getElementById('table-body');
                            r = document.createElement('tr');
                            r.className = 'bg-white hover:bg-gray-100 transition-colors cursor-pointer';
                            
                            // Create row number cell
                            const n = document.createElement('td');
                            n.textContent = tbody.children.length + 1;
                            n.className = 'py-2 px-2 md:px-4 font-bold text-gray-800 whitespace-nowrap cursor-pointer';
                            n.setAttribute('data-label', 'No');
                            n.title = 'Cliquer pour colorer/effacer la ligne';
                            
                            n.addEventListener('mousedown', (e) => { 
                                if (e.button !== 0) return; 
                                startRowPaint(r); 
                                e.preventDefault(); 
                            });
                            
                            n.addEventListener('mouseenter', () => { 
                                if (isRowPaintDragging) applyRowPaint(r); 
                            });
                            
                            n.addEventListener('click', (e) => { 
                                e.preventDefault();
                                if (isRowPaintDragging) return;
                                rowPaintAction = getPaintActionForRow(r);
                                applyRowPaint(r);
                            });
                            
                            n.addEventListener('touchstart', (e) => { 
                                startRowPaint(r); 
                                e.preventDefault(); 
                            }, { passive: false });
                            
                            n.addEventListener('touchmove', (e) => { 
                                const t = e.touches && e.touches[0]; 
                                if (!t) return; 
                                const el = document.elementFromPoint(t.clientX, t.clientY);
                                const tr = el ? el.closest('#table-body tr') : null; 
                                if (tr) applyRowPaint(tr); 
                                e.preventDefault();
                            }, { passive: false });
                            
                            r.appendChild(n);
                            
                            // Add delete/selection cell
                            r.appendChild(createDeleteCell(r));
                            
                            // Add data cells using current headers
                            const heads = getHeaders();
                            heads.forEach(h => { 
                                r.appendChild(createEditableCell(h, '')); 
                            });
                            
                            tbody.appendChild(r);
                        }
                    }
                    
                    cols.forEach((val, cidx) => {
                        const cell = r.cells[startIndex + cidx];
                        if (cell && cell.contentEditable === 'true') { 
                            cell.textContent = val; 
                        }
                    });
                    
                    // Normalize Nom_Pr√©nom in the affected row after paste
                    try {
                        const nameCell = r.querySelector('td[data-label="Nom_Pr√©nom"]');
                        if (nameCell) { 
                            nameCell.textContent = formatNomPrenom(nameCell.textContent); 
                        }
                    } catch(_) {}
                });
                
                saveStateToHistory(); 
                saveLocalDraft(); 
                markEdited();
            });

            // Double-click date input
            document.getElementById('table-body').addEventListener('dblclick', function(e) {
                const cell = e.target.closest('td');
                if (!cell) return;
                
                const label = (cell.getAttribute('data-label') || '').toLowerCase();
                if (label.includes('date de saisie') || label.includes('ddn')) {
                    if (!dateInputOverlay) {
                        dateInputOverlay = document.createElement('input');
                        dateInputOverlay.type = 'date';
                        dateInputOverlay.className = 'border rounded px-2 py-1';
                        dateInputOverlay.style.position = 'fixed';
                        dateInputOverlay.style.zIndex = '1000';
                        document.body.appendChild(dateInputOverlay);
                        
                        dateInputOverlay.addEventListener('change', () => {
                            const v = dateInputOverlay.value;
                            if (v) {
                                const [y, m, d] = v.split('-');
                                cell.textContent = `${d}/${m}/${y.slice(-2)}`;
                                saveStateToHistory();
                                saveLocalDraft();
                                markEdited();
                            }
                            dateInputOverlay.style.display = 'none';
                        });
                        
                        dateInputOverlay.addEventListener('blur', () => {
                            dateInputOverlay.style.display = 'none';
                        });
                    }
                    
                    const rect = cell.getBoundingClientRect();
                    dateInputOverlay.style.left = `${rect.left + window.scrollX}px`;
                    dateInputOverlay.style.top = `${rect.top + window.scrollY}px`;
                    dateInputOverlay.style.display = 'block';
                    dateInputOverlay.focus();
                }
            });

            // Select all checkbox
            document.addEventListener('change', function(e) { 
                if (e.target && e.target.id === 'select-all') { 
                    const checked = e.target.checked; 
                    document.querySelectorAll('#table-body tr').forEach(tr => { 
                        const cb = tr.querySelector('td:nth-child(2) input[type="checkbox"]'); 
                        if (cb) { 
                            cb.checked = checked; 
                            tr.classList.toggle('selected-row', checked); 
                        } 
                    }); 
                } 
            });

            // Focus management
            document.addEventListener('focusin', (e) => {
                if (e.target && e.target.tagName === 'TD' && e.target.contentEditable === 'true') {
                    captureSimplePos();
                }
            });

            // Mobile focus support
            document.addEventListener('focusin', (e) => {
                if (!isMobile()) return;
                const cell = (e.target && e.target.tagName === 'TD' && e.target.isContentEditable) ? e.target : null;
                if (cell) {
                    setTimeout(() => ensureCellVisible(cell), 100);
                }
            });

            // Table reloaded event
            try {
                document.addEventListener('table:reloaded', () => { 
                    if (showOnlyColored) applyColoredFilter(); 
                });
            } catch(_) {}

            // Global end-drag listeners
            try { 
                document.addEventListener('mouseup', endRowPaint, true); 
            } catch(_) {}
            
            try { 
                document.addEventListener('touchend', endRowPaint, true); 
            } catch(_) {}
            
            // Mobile touch support for history toggle button
            try {
                const toggleBtn = document.getElementById('history-toggle-btn');
                if (toggleBtn) {
                    // Touch events for better mobile compatibility
                    toggleBtn.addEventListener('touchstart', function(e) {
                        e.preventDefault();
                        console.log('üì± Touch start on toggle button');
                    }, { passive: false });
                    
                    toggleBtn.addEventListener('touchend', function(e) {
                        e.preventDefault();
                        console.log('üì± Touch end on toggle button');
                        toggleHistoryBarSimple();
                    }, { passive: false });
                    
                    // Additional mobile event handling
                    if (isMobile()) {
                        toggleBtn.addEventListener('click', function(e) {
                            console.log('üì± Click on toggle button (mobile)');
                            // Ensure proper mobile handling
                            setTimeout(() => {
                                if (window.innerWidth <= 768) {
                                    const historyBarContainer = document.getElementById('history-bar-container');
                                    if (historyBarContainer) {
                                        historyBarContainer.style.width = '100%';
                                        historyBarContainer.style.maxWidth = 'none';
                                    }
                                }
                            }, 50);
                        });
                    }
                }
            } catch(_) {}
        }

        // Keyboard navigation
        function setupKeyboardNavigation() {
            document.addEventListener('keydown', function(e) {
                const active = document.activeElement;
                if (active && active.tagName === 'TD' && active.contentEditable === 'true') {
                    const modal = document.getElementById('confirmation-modal');
                    if (modal && !modal.classList.contains('hidden')) return;
                    
                    // ‚úÖ CORRECTION: √âviter le double traitement des touches de navigation
                    if (e.defaultPrevented) return;
                    
                    const row = active.parentElement;
                    const idx = Array.from(row.cells).indexOf(active);
                    let next = null;
                    
                    if (e.key === 'ArrowRight' || (e.key === 'Tab' && !e.shiftKey)) {
                        next = row.cells[idx + 1] || (row.nextElementSibling && row.nextElementSibling.cells[2]);
                    } else if (e.key === 'ArrowLeft' || (e.key === 'Tab' && e.shiftKey)) {
                        next = row.cells[idx - 1];
                        if ((!next || idx === 2) && row.previousElementSibling) {
                            next = row.previousElementSibling.cells[row.previousElementSibling.cells.length - 1];
                        }
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        const nx = row.nextElementSibling;
                        if (nx) {
                            next = nx.cells[idx];
                        } else {
                            // Emp√™cher l'ajout en mode visualisation
                            if (isViewMode) {
                                showMessage('Impossible d\'ajouter des lignes en mode visualisation. D√©sactivez le mode visualisation pour modifier le tableau.', 'warning');
                                return;
                            }
                            addRow();
                            setTimeout(() => {
                                const nr = document.querySelector('#table-body tr:last-child');
                                if (nr && nr.cells.length > idx) nr.cells[idx].focus();
                            }, 0);
                        }
                    } else if (e.key === 'ArrowDown') {
                        const nx = row.nextElementSibling;
                        if (nx) {
                            next = nx.cells[idx];
                        } else {
                            // Emp√™cher l'ajout en mode visualisation
                            if (isViewMode) {
                                showMessage('Impossible d\'ajouter des lignes en mode visualisation. D√©sactivez le mode visualisation pour modifier le tableau.', 'warning');
                                return;
                            }
                            addRow();
                            setTimeout(() => {
                                const nr = document.querySelector('#table-body tr:last-child');
                                if (nr && nr.cells.length > idx) nr.cells[idx].focus();
                            }, 0);
                        }
                    } else if (e.key === 'ArrowUp') {
                        const pv = row.previousElementSibling;
                        if (pv) {
                            next = pv.cells[idx];
                        }
                    }
                    
                    if (next) {
                        e.preventDefault();
                        next.focus();
                        if (isMobile()) ensureCellVisible(next);
                    }
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                const active = document.activeElement;
                const inCell = active && active.tagName === 'TD' && active.contentEditable === 'true';
                
                // Check if we're in a form field (input, textarea, select, or contentEditable)
                const inFormField = active && (
                    active.tagName === 'INPUT' || 
                    active.tagName === 'TEXTAREA' || 
                    active.tagName === 'SELECT' || 
                    active.contentEditable === 'true'
                );
                
                // Shortcut: cycle paint mode with P (only when NOT in form fields)
                if (!e.ctrlKey && !e.metaKey && !e.altKey && (e.key === 'p' || e.key === 'P') && !inFormField) {
                    e.preventDefault();
                    cyclePaintMode();
                    return;
                }
                
                // Excel-style Undo/Redo shortcuts
                if ((e.ctrlKey || e.metaKey) && !e.shiftKey && (e.key === 'z' || e.key === 'Z')) {
                    e.preventDefault();
                    if (operationHistory.length > 0) {
                        undo();
                    }
                    return;
                }
                
                // Excel-style Redo shortcuts: Ctrl+Shift+Z or Ctrl+Y
                if ((e.ctrlKey || e.metaKey) && (
                    (e.shiftKey && (e.key === 'z' || e.key === 'Z')) || 
                    (e.key === 'y' || e.key === 'Y')
                )) {
                    e.preventDefault();
                    if (redoHistory.length > 0) {
                        redo();
                    }
                    return;
                }
                
                // Ctrl+D: Duplicate row
                if ((e.ctrlKey || e.metaKey) && (e.key === 'd' || e.key === 'D') && inCell) {
                    e.preventDefault();
                    
                    // Emp√™cher la duplication en mode visualisation
                    if (isViewMode) {
                        showMessage('Impossible de dupliquer des lignes en mode visualisation. D√©sactivez le mode visualisation pour modifier le tableau.', 'warning');
                        return;
                    }
                    
                    const row = active.closest('tr');
                    if (row) {
                        const clone = row.cloneNode(true);
                        delete clone.dataset.key;
                        
                        // Clear any background color on the clone
                        clone.style.backgroundColor = '';
                        
                        // Fix the No cell text and rebind click handler
                        if (clone.cells[0]) {
                            clone.cells[0].textContent = document.querySelectorAll('#table-body tr').length + 1;
                        }
                        
                        // Rebind the line-number toggle and input handlers
                        const numCell = clone.cells[0];
                        if (numCell) {
                            const newNum = numCell.cloneNode(true);
                            if (!newNum.className.includes('cursor-pointer')) {
                                newNum.className += ' cursor-pointer';
                            }
                            newNum.title = 'Cliquer pour colorer/effacer la ligne';
                            newNum.addEventListener('click', () => toggleRowColor(clone));
                            clone.replaceChild(newNum, numCell);
                        }
                        
                        Array.from(clone.cells).forEach((c, i) => {
                            if (i <= 1) return;
                            c.addEventListener('input', (e) => { 
                                const oldValue = c.dataset.originalValue || '';
                                const newValue = c.textContent;
                                const columnLabel = getColumnLabelForCell(c);
                                
                                // Track cell edit for undo/redo
                                trackCellEdit(c, oldValue, newValue, columnLabel);
                                
                                // Update original value for next edit
                                c.dataset.originalValue = newValue;
                                
                                saveStateToHistory(); 
                                saveLocalDraft(); 
                                markEdited(); 
                            });
                        });
                        
                        row.after(clone);
                        
                        // Update color map persistently
                        persistRowColors();
                        saveStateToHistory(); 
                        saveLocalDraft(); 
                        markEdited();
                    }
                }
                
                // Ctrl+Backspace/Delete: Delete row(s)
                if ((e.ctrlKey || e.metaKey) && (e.key === 'Backspace' || e.key === 'Delete') && inCell) {
                    e.preventDefault();
                    const selected = Array.from(document.querySelectorAll('#table-body tr.selected-row'));
                    if (selected.length > 0) {
                        promptKeyConfirm(`Appuyez sur Entr√©e pour supprimer ${selected.length} ligne(s), √âchap pour annuler.`, () => deleteRows(selected));
                    } else {
                        const row = active.closest('tr');
                        if (row) {
                            promptKeyConfirm('Appuyez sur Entr√©e pour supprimer cette ligne, √âchap pour annuler.', () => deleteRows([row]));
                        }
                    }
                }
            });
        }

        // Confirmation prompt
        function promptKeyConfirm(message, onConfirm) {
            // Show ephemeral banner
            showMessage(message, 'info');

            // Create (or reuse) a hidden input to trigger the mobile keyboard
            let keyCapture = document.getElementById('key-capture');
            if (!keyCapture) {
                keyCapture = document.createElement('input');
                keyCapture.type = 'text';
                keyCapture.id = 'key-capture';
                keyCapture.autocapitalize = 'off';
                keyCapture.autocomplete = 'off';
                keyCapture.spellcheck = false;
                keyCapture.style.position = 'fixed';
                keyCapture.style.opacity = '0';
                keyCapture.style.width = '1px';
                keyCapture.style.height = '1px';
                keyCapture.style.left = '-10000px';
                keyCapture.style.top = '0';
                keyCapture.style.pointerEvents = 'none';
                document.body.appendChild(keyCapture);
            }
            
            // Focus to bring up the soft keyboard on mobile
            keyCapture.value = '';
            keyCapture.focus({ preventScroll: true });
            try { 
                keyCapture.setSelectionRange(0, 0); 
            } catch(_) {}
            
            // Some mobile browsers need a second tick to reliably open the keyboard
            setTimeout(() => { 
                if (document.activeElement !== keyCapture) {
                    keyCapture.focus({ preventScroll: true }); 
                }
            }, 0);

            function handleKey(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    cleanup();
                    onConfirm();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    cleanup();
                    showMessage('Suppression annul√©e.', 'info');
                }
            }

            function cleanup() {
                document.removeEventListener('keydown', handleKey, true);
                // Blur and hide the hidden input after finishing
                const cap = document.getElementById('key-capture');
                if (cap) { 
                    try { 
                        cap.blur(); 
                    } catch(_) {} 
                }
            }

            document.addEventListener('keydown', handleKey, true);
        }

        // ===== SNAPSHOT SYSTEM FUNCTIONS =====
        
        // Fonction de nettoyage automatique des anciens snapshots
        async function cleanupOldSnapshots(keepCount = 20) {
            try {
                // R√©cup√©rer tous les snapshots tri√©s par date (plus r√©cents en premier)
                const { data: snapshots, error: fetchError } = await supabase
                    .from('table_snapshots_index')
                    .select('*')
                    .order('snapshot_date', { ascending: false });
                
                if (fetchError) {
                    console.error('‚ùå Error fetching snapshots for cleanup:', fetchError);
                    return;
                }
                
                if (snapshots.length > keepCount) {
                    // Supprimer les snapshots les plus anciens
                    const toDelete = snapshots.slice(keepCount);
                    let deletedCount = 0;
                    
                    for (const snapshot of toDelete) {
                        try {
                            // Supprimer du stockage Supabase
                            const { error: storageError } = await supabase.storage
                                .from('table-snapshots')
                                .remove([snapshot.object_path]);
                            
                            if (storageError) {
                                console.warn(`‚ö†Ô∏è Warning: Could not delete file ${snapshot.object_path}:`, storageError);
                            }
                            
                            // Supprimer de la base de donn√©es
                            const { error: dbError } = await supabase
                                .from('table_snapshots_index')
                                .delete()
                                .eq('id', snapshot.id);
                            
                            if (dbError) {
                                console.warn(`‚ö†Ô∏è Warning: Could not delete database record for ${snapshot.snapshot_date}:`, dbError);
                            } else {
                                deletedCount++;
                            }
                            
                        } catch (error) {
                            console.warn(`‚ö†Ô∏è Warning: Error deleting snapshot ${snapshot.snapshot_date}:`, error);
                        }
                    }
                    
                    if (deletedCount > 0) {
                        console.log(`üßπ Cleanup completed: ${deletedCount} old snapshots removed`);
                        if (typeof showMessage === 'function') {
                            showMessage(`üßπ Nettoyage automatique : ${deletedCount} anciens snapshots supprim√©s`, 'info');
                        }
                    }
                }
                
            } catch (error) {
                console.error('‚ùå Error in cleanupOldSnapshots:', error);
            }
        }

        // Fonction de v√©rification de la capacit√© de stockage
        async function checkStorageCapacity() {
            try {
                const { data: snapshots, error: fetchError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (fetchError) {
                    console.error('‚ùå Error checking storage capacity:', fetchError);
                    return { count: 0, needsCleanup: false };
                }
                
                const snapshotCount = snapshots.length;
                
                // Calculer la taille totale des snapshots
                let totalSize = 0;
                snapshots.forEach(snapshot => {
                    totalSize += snapshot.file_size_bytes || 0;
                });
                
                // Limite de stockage : 100 MB (100 * 1024 * 1024 bytes)
                const MAX_BUCKET_SIZE = 100 * 1024 * 1024;
                const usagePercentage = (totalSize / MAX_BUCKET_SIZE) * 100;
                
                // Si on d√©passe 95% de la capacit√©, d√©clencher le nettoyage
                if (usagePercentage >= 95) {
                    // Calculer combien de snapshots garder pour lib√©rer de l'espace
                    const targetSize = MAX_BUCKET_SIZE * 0.7; // Cibler 70% d'utilisation
                    const snapshotsToKeep = calculateOptimalSnapshotCount(snapshots, targetSize);
                    
                    return { 
                        count: snapshotCount, 
                        needsCleanup: true, 
                        target: snapshotsToKeep,
                        currentSize: totalSize,
                        maxSize: MAX_BUCKET_SIZE,
                        usagePercentage: usagePercentage
                    };
                }
                
                return { 
                    count: snapshotCount, 
                    needsCleanup: false,
                    currentSize: totalSize,
                    maxSize: MAX_BUCKET_SIZE,
                    usagePercentage: usagePercentage
                };
                
            } catch (error) {
                console.error('‚ùå Error checking storage capacity:', error);
                return { count: 0, needsCleanup: false };
            }
        }

        // Fonction pour calculer le nombre optimal de snapshots √† garder
        function calculateOptimalSnapshotCount(snapshots, targetSize) {
            // Trier les snapshots par date (plus r√©cents en premier)
            const sortedSnapshots = [...snapshots].sort((a, b) => 
                new Date(b.snapshot_date) - new Date(a.snapshot_date)
            );
            
            let currentSize = 0;
            let snapshotsToKeep = 0;
            
            // Garder les snapshots les plus r√©cents jusqu'√† atteindre la taille cible
            for (const snapshot of sortedSnapshots) {
                const snapshotSize = snapshot.file_size_bytes || 0;
                if (currentSize + snapshotSize <= targetSize) {
                    currentSize += snapshotSize;
                    snapshotsToKeep++;
                } else {
                    break;
                }
                }
            
            // Toujours garder au minimum 5 snapshots
            return Math.max(snapshotsToKeep, 5);
        }

        // Fonction de monitoring et d'alertes du stockage
        async function monitorStorageHealth() {
            try {
                const { data: snapshots, error: fetchError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (fetchError) {
                    console.error('‚ùå Error monitoring storage health:', fetchError);
                    return;
                }
                
                const snapshotCount = snapshots.length;
                
                // Calculer la taille totale des snapshots
                let totalSize = 0;
                snapshots.forEach(snapshot => {
                    totalSize += snapshot.file_size_bytes || 0;
                });
                
                const MAX_BUCKET_SIZE = 100 * 1024 * 1024; // 100 MB
                const usagePercentage = (totalSize / MAX_BUCKET_SIZE) * 100;
                
                // Alertes automatiques selon l'utilisation de l'espace
                if (usagePercentage >= 95) {
                    // üö® CRITIQUE : Stockage presque plein
                    if (typeof showMessage === 'function') {
                        showMessage(`üö® Stockage critique : ${usagePercentage.toFixed(1)}% utilis√© (${(totalSize / 1024 / 1024).toFixed(2)} MB). Nettoyage automatique en cours...`, 'error');
                    }
                } else if (usagePercentage >= 85) {
                    // ‚ö†Ô∏è ATTENTION : Stockage √©lev√©
                    if (typeof showMessage === 'function') {
                        showMessage(`‚ö†Ô∏è Stockage √©lev√© : ${usagePercentage.toFixed(1)}% utilis√© (${(totalSize / 1024 / 1024).toFixed(2)} MB). Nettoyage pr√©ventif recommand√©.`, 'warning');
                    }
                } else if (usagePercentage >= 70) {
                    // ‚ÑπÔ∏è INFO : Surveillance
                    if (typeof showMessage === 'function') {
                        showMessage(`‚ÑπÔ∏è Stockage mod√©r√© : ${usagePercentage.toFixed(1)}% utilis√© (${(totalSize / 1024 / 1024).toFixed(2)} MB).`, 'info');
                    }
                }
                
                // Log des informations de stockage
                console.log(`üìä Storage Health: ${snapshotCount} snapshots, ${(totalSize / 1024 / 1024).toFixed(2)} MB used (${usagePercentage.toFixed(1)}% of ${(MAX_BUCKET_SIZE / 1024 / 1024).toFixed(0)} MB)`);
                
            } catch (error) {
                console.error('‚ùå Error in monitorStorageHealth:', error);
            }
        }

        // Create a demo snapshot with unique date logic and automatic cleanup
        async function createDemoSnapshot(useCurrentData = false) {
            try {
                // V√âRIFICATION ET NETTOYAGE AUTOMATIQUE AVANT CR√âATION
                const capacityInfo = await checkStorageCapacity();
                if (capacityInfo.needsCleanup) {
                    await cleanupOldSnapshots(capacityInfo.target);
                }
                
                // Check current state
                const { data: existing, error: checkError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (checkError) {
                    console.error('‚ùå Error checking existing snapshots:', checkError);
                    return;
                }
                
                // Clean: Removed debug log
                
                // Generate a truly unique date
                let dateString;
                let attempts = 0;
                const maxAttempts = 50; // Increased to handle more date variations
                
                do {
                    attempts++;
                    if (attempts === 1) {
                        // First attempt: today's date
                        const today = new Date();
                        dateString = today.toISOString().split('T')[0];
                    } else if (attempts <= 10) {
                        // Next 10 attempts: dates with small offset (yesterday, day before, etc.)
                        const offsetDate = new Date();
                        offsetDate.setDate(offsetDate.getDate() - attempts + 1);
                        dateString = offsetDate.toISOString().split('T')[0];
                    } else if (attempts <= 20) {
                        // Next 10 attempts: dates with larger offset (1 week ago, 2 weeks ago, etc.)
                        const offsetDate = new Date();
                        offsetDate.setDate(offsetDate.getDate() - (attempts * 7));
                        dateString = offsetDate.toISOString().split('T')[0];
                    } else if (attempts <= 30) {
                        // Next 10 attempts: dates with month offset
                        const offsetDate = new Date();
                        offsetDate.setMonth(offsetDate.getMonth() - (attempts - 20));
                        dateString = offsetDate.toISOString().split('T')[0];
                    } else {
                        // Final attempts: use random dates from previous years
                        const randomYear = 2020 + Math.floor(Math.random() * 5); // 2020-2024
                        const randomMonth = 1 + Math.floor(Math.random() * 12);
                        const randomDay = 1 + Math.floor(Math.random() * 28);
                        dateString = `${randomYear}-${String(randomMonth).padStart(2, '0')}-${String(randomDay).padStart(2, '0')}`;
                    }
                    
                    // Check if this date already exists
                    const { data: existingDate, error: dateCheckError } = await supabase
                        .from('table_snapshots_index')
                        .select('snapshot_date')
                        .eq('snapshot_date', dateString)
                        .limit(1);
                    
                    if (dateCheckError) {
                        console.error('‚ùå Error checking date:', dateCheckError);
                        break;
                    }
                    
                    if (!existingDate || existingDate.length === 0) {
                        break;
                    }
                    
                } while (attempts < maxAttempts);
                
                if (attempts >= maxAttempts) {
                    console.error('‚ùå Unable to find unique date after 50 attempts');
                    
                    // Show message to user
                    if (typeof showMessage === 'function') {
                        showMessage('Impossible de trouver une date unique. Utilisez le bouton "Nettoyer" pour vider la base.', 'warning');
                    }
                    
                    return;
                }
                
                // Create the JSON content for the snapshot
                let snapshotData;
                let actualRowCount = 3;
                
                if (useCurrentData && window.tableData && window.tableData.length > 0) {
                    // Use current table data
                    actualRowCount = window.tableData.length;
                    snapshotData = {
                        snapshot_metadata: {
                            created_at: new Date().toISOString(),
                            row_count: actualRowCount,
                            version: "1.0",
                            description: "Snapshot des donn√©es actuelles du tableau"
                        },
                        data: window.tableData
                    };
                    // Clean: Removed debug log
                } else {
                    // Use demo data
                    snapshotData = {
                        snapshot_metadata: {
                            created_at: new Date().toISOString(),
                            row_count: 3,
                            version: "1.0",
                            description: "Demo snapshot for testing"
                        },
                        data: [
                            {
                                id: 1,
                                nom: "Dupont",
                                prenom: "Jean",
                                status: "En service",
                                specialite: "Cardiologie",
                                date_embauche: "2020-03-15",
                                salaire: 4500,
                                notes: "Excellent m√©decin, tr√®s appr√©ci√© des patients"
                            },
                            {
                                id: 2,
                                nom: "Martin",
                                prenom: "Marie",
                                status: "En service",
                                specialite: "P√©diatrie",
                                date_embauche: "2019-07-22",
                                salaire: 4200,
                                notes: "Sp√©cialiste en maladies infantiles"
                            },
                            {
                                id: 3,
                                nom: "Bernard",
                                prenom: "Pierre",
                                status: "Cong√©",
                                specialite: "Chirurgie",
                                date_embauche: "2018-11-10",
                                salaire: 5200,
                                notes: "Chirurgien exp√©riment√©"
                            }
                        ]
                    };
                    // Clean: Removed debug log
                }

                let fileName = `staff_table_${dateString}_10-00-00.json`;
                const jsonBlob = new Blob([JSON.stringify(snapshotData, null, 2)], { type: 'application/json' });

                // Check if file already exists in storage before uploading
                // Clean: Removed debug log
                const { data: existingFiles, error: listError } = await supabase.storage
                    .from('table-snapshots')
                    .list('', { limit: 100 });
                
                if (listError) {
                    console.warn('‚ö†Ô∏è Could not list storage files:', listError);
                } else {
                    const fileExists = existingFiles?.some(file => file.name === fileName);
                    if (fileExists) {
                        console.warn(`‚ö†Ô∏è File already exists in storage: ${fileName}`);
                        // Clean: Removed debug log
                        
                        // Try to remove the existing file
                        const { error: removeError } = await supabase.storage
                            .from('table-snapshots')
                            .remove([fileName]);
                        
                        if (removeError) {
                            console.error('‚ùå Error removing existing file:', removeError);
                            // If we can't remove it, try with a different filename
                            const timestamp = Date.now();
                            const newFileName = `staff_table_${dateString}_${timestamp}.json`;
                            // Clean: Removed debug log
                            fileName = newFileName;
                        } else {
                            // Clean: Removed debug log
                        }
                    }
                }

                // Upload the JSON file to storage
                // Clean: Removed debug log
                const { data: uploadData, error: uploadError } = await supabase.storage
                    .from('table-snapshots')
                    .upload(fileName, jsonBlob);

                if (uploadError) {
                    console.error('‚ùå Error uploading file to storage:', uploadError);
                    throw new Error(`Failed to upload file: ${uploadError.message}`);
                }

                                    // Clean: Removed debug log

                // Now create the database record
                const { error } = await supabase
                    .from('table_snapshots_index')
                    .insert({
                        snapshot_date: dateString,
                        object_path: fileName,
                        row_count: actualRowCount,
                        file_size_bytes: jsonBlob.size,
                        metadata: JSON.stringify({
                            table: 'staffTable',
                            version: '1.0.0',
                            description: 'Demo snapshot for testing'
                        })
                    });
                
                if (error) {
                    console.error('‚ùå Error creating snapshot:', error);
                    
                    // If it's still a key error, try with a timestamp
                    if (error.code === '23505') {
                        // Clean: Removed debug log
                        const timestamp = Date.now();
                        const uniqueDate = new Date(timestamp);
                        const uniqueDateString = uniqueDate.toISOString().split('T')[0];
                        
                        const { error: retryError } = await supabase
                            .from('table_snapshots_index')
                            .insert({
                                snapshot_date: uniqueDateString,
                                object_path: `staff_table_${uniqueDateString}_${timestamp}.json`,
                                row_count: 3,
                                file_size_bytes: 1500,
                                metadata: JSON.stringify({
                                    table: 'staffTable',
                                    version: '1.0.0',
                                    description: 'Demo snapshot for testing'
                                })
                            });
                        
                        if (retryError) {
                            console.error('‚ùå Retry error:', retryError);
                        } else {
                            // Clean: Removed debug log
                            await loadAvailableSnapshots();
                            // Update the calendar display
                            populateSnapshotCalendar();
                        }
                    }
                } else {
                    // Clean: Removed debug log
                    // Reload snapshots after creation
                    await loadAvailableSnapshots();
                    // Update the calendar display
                    populateSnapshotCalendar();
                    
                    // MONITORING : V√©rifier la sant√© du stockage apr√®s cr√©ation
                    await monitorStorageHealth();
                }
                
            } catch (err) {
                console.error('‚ùå Exception error:', err);
            }
        }
        
        // Load available snapshots from the database
        async function loadAvailableSnapshots() {
            try {
                console.log('üîÑ loadAvailableSnapshots: D√©but du chargement...');
                
                // V√©rifier que supabase est initialis√©
                if (!supabase) {
                    console.error('‚ùå Client Supabase non initialis√©');
                    return;
                }
                
                // First, test the database connection
                console.log('üîÑ Test de connexion √† la table table_snapshots_index...');
                const { data: testData, error: testError } = await supabase
                    .from('table_snapshots_index')
                    .select('*')
                    .limit(1);
                
                if (testError) {
                    console.error('‚ùå Database connection error:', testError);
                    
                    // Analyser le type d'erreur
                    if (testError.code === 'PGRST116') { // No rows returned
                        console.log('‚ö†Ô∏è Table vide, cr√©ation d\'un snapshot de d√©monstration...');
                        await createDemoSnapshot();
                        return;
                    } else if (testError.code === 'PGRST301') { // Table doesn't exist
                        console.error('‚ùå Table table_snapshots_index n\'existe pas. V√©rifiez la configuration SQL.');
                        showMessage('‚ùå Table des snapshots manquante. V√©rifiez la configuration Supabase.', 'error');
                        return;
                    } else if (testError.code === 'PGRST301' || testError.message.includes('permission')) {
                        console.error('‚ùå Probl√®me de permissions. V√©rifiez les politiques RLS.');
                        showMessage('‚ùå Probl√®me de permissions. V√©rifiez les politiques RLS Supabase.', 'error');
                        return;
                    }
                    
                    showMessage('‚ùå Erreur de connexion √† la base de donn√©es: ' + testError.message, 'error');
                    return;
                }
                
                console.log('‚úÖ Connexion √† la table r√©ussie, testData:', testData);
                
                console.log('üîÑ Chargement de tous les snapshots...');
                const { data, error } = await supabase
                    .from('table_snapshots_index')
                    .select('snapshot_date, created_at, row_count, object_path, file_size_bytes')
                    .order('snapshot_date', { ascending: false });
                
                if (error) {
                    console.error('‚ùå Error loading snapshots:', error);
                    showMessage('‚ùå Erreur lors du chargement des snapshots: ' + error.message, 'error');
                    return;
                }
                
                console.log('‚úÖ Snapshots charg√©s depuis la base:', data);
                
                availableSnapshots = data || [];
                // Update global variable
                window.availableSnapshots = availableSnapshots;
                
                console.log(`üìä ${availableSnapshots.length} snapshots disponibles:`, availableSnapshots);
                
                // If no snapshots exist, create a demo one
                if (availableSnapshots.length === 0) {
                    console.log('‚ö†Ô∏è Aucun snapshot trouv√©, cr√©ation d\'un snapshot de d√©monstration...');
                    await createDemoSnapshot();
                } else {
                    console.log('‚úÖ Snapshots trouv√©s, mise √† jour de l\'interface...');
                    updateHistoryNavigation();
                    // Update the calendar display
                    populateSnapshotCalendar();
                }
                
                // MONITORING : V√©rifier la sant√© du stockage apr√®s chargement
                await monitorStorageHealth();
        
            } catch (error) {
                console.error('‚ùå Error in loadAvailableSnapshots:', error);
                showMessage('‚ùå Erreur inattendue lors du chargement des snapshots: ' + error.message, 'error');
            }
        }

        // Fonction utilitaire pour forcer le nettoyage manuel
        async function forceStorageCleanup() {
            try {
                if (typeof showMessage === 'function') {
                    showMessage('üßπ D√©clenchement du nettoyage manuel du stockage...', 'info');
                }
                
                // V√©rifier la capacit√© actuelle
                const capacityInfo = await checkStorageCapacity();
                
                // Calculer le nombre optimal de snapshots √† garder
                const targetSize = capacityInfo.maxSize * 0.6; // Cibler 60% d'utilisation
                const snapshotsToKeep = calculateOptimalSnapshotCount(availableSnapshots, targetSize);
                
                console.log(`üßπ Manual cleanup: targeting ${snapshotsToKeep} snapshots to reach ${(targetSize / 1024 / 1024).toFixed(2)} MB usage`);
                
                // Forcer le nettoyage en gardant le nombre optimal de snapshots
                await cleanupOldSnapshots(snapshotsToKeep);
                
                // Recharger les snapshots disponibles
                await loadAvailableSnapshots();
                
                if (typeof showMessage === 'function') {
                    showMessage(`‚úÖ Nettoyage manuel termin√© ! Gard√© ${snapshotsToKeep} snapshots les plus r√©cents.`, 'success');
                }
                
            } catch (error) {
                console.error('‚ùå Error in forceStorageCleanup:', error);
                if (typeof showMessage === 'function') {
                    showMessage('‚ùå Erreur lors du nettoyage manuel', 'error');
                }
            }
        }
        
        // Update history navigation buttons state
        function updateHistoryNavigation() {
            const backBtn = document.getElementById('history-back');
            const nextBtn = document.getElementById('history-next');
            
            // Always update button states
            
            if (snapshotMode === 'live') {
                // Enable back/next if snapshots exist
                if (backBtn) backBtn.disabled = availableSnapshots.length === 0;
                if (nextBtn) nextBtn.disabled = availableSnapshots.length === 0;
            } else {
                // Update back/next button states
                if (backBtn) backBtn.disabled = currentSnapshotIndex <= 0;
                if (nextBtn) nextBtn.disabled = currentSnapshotIndex >= availableSnapshots.length - 1;
            }
            
            // Update calendar button text if calendar is open
            const calendarBtnText = document.getElementById('calendar-btn-text');
            if (calendarBtnText) {
                calendarBtnText.textContent = `Calendrier (${availableSnapshots.length})`;
            }
            
            // Update current snapshot date display
            const currentSnapshotDateText = document.getElementById('current-snapshot-date-text');
            if (currentSnapshotDateText) {
                if (snapshotMode === 'live') {
                    currentSnapshotDateText.textContent = 'Donn√©es en direct';
                } else if (currentSnapshotDate) {
                    // Format the date nicely
                    const date = new Date(currentSnapshotDate);
                    const formattedDate = date.toLocaleDateString('fr-FR', {
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric'
                    });
                    currentSnapshotDateText.textContent = `Snapshot du ${formattedDate}`;
                }
            }
        }
        
        // Check and fix inconsistencies between database and storage
        async function checkAndFixInconsistencies() {
            try {
                // Clean: Removed debug log
                
                // Get database snapshots
                const { data: dbSnapshots, error: dbError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (dbError) {
                    console.error('‚ùå Error checking database:', dbError);
                    return;
                }
                
                // Get storage files
                        const { data: storageFiles, error: storageError } = await supabase.storage
            .from('table-snapshots')
            .list('', { limit: 100 });
                
                if (storageError) {
                    console.error('‚ùå Error checking storage:', storageError);
                    return;
                }
                
                // Clean: Removed debug logs
                
                // Check for orphaned database records (no corresponding file)
                const orphanedRecords = [];
                for (const snapshot of dbSnapshots || []) {
                    const fileExists = storageFiles?.some(file => file.name === snapshot.object_path);
                    if (!fileExists) {
                        orphanedRecords.push(snapshot);
                        console.warn(`‚ö†Ô∏è Orphaned record: ${snapshot.snapshot_date} -> ${snapshot.object_path}`);
                    }
                }
                
                // Check for orphaned storage files (no corresponding database record)
                const orphanedFiles = [];
                for (const file of storageFiles || []) {
                    if (file.name.includes('staff_table_')) {
                        const recordExists = dbSnapshots?.some(s => s.object_path === file.name);
                        if (!recordExists) {
                            orphanedFiles.push(file);
                            console.warn(`‚ö†Ô∏è Orphaned file: ${file.name}`);
                        }
                    }
                }
                
                if (orphanedRecords.length > 0 || orphanedFiles.length > 0) {
                    // Clean: Removed debug log
                    showMessage(`Incoh√©rences d√©tect√©es. Utilisez le bouton "Nettoyer" pour corriger.`, 'warning');
                } else {
                    // Clean: Removed debug log
                    showMessage('Aucune incoh√©rence d√©tect√©e', 'success');
                }
                
            } catch (err) {
                console.error('‚ùå Error checking inconsistencies:', err);
            }
        }
        
                // Clean database and create fresh snapshot
        async function cleanDatabaseAndCreateSnapshot() {
            try {
                // Clean: Removed debug log
                
                // Check current state
                const { data: current, error: checkError } = await supabase
                    .from('table_snapshots_index')
                    .select('*');
                
                if (checkError) {
                    console.error('‚ùå Error checking current state:', checkError);
                    return;
                }
                
                // Clean: Removed debug log
                
                if (current && current.length > 0) {
                    // Delete all existing snapshots
                    const { error: deleteError } = await supabase
                        .from('table_snapshots_index')
                        .delete()
                        .neq('id', '00000000-0000-0000-0000-000000000000');
                    
                    if (deleteError) {
                        console.error('‚ùå Error deleting snapshots:', deleteError);
                        return;
                    }
                    
                    // Clean: Removed debug log
                }
                
                // Create new snapshot with unique date
                await createDemoSnapshot();
                
                // Reload snapshots after cleanup
                await loadAvailableSnapshots();
                
                // Update the calendar display
                populateSnapshotCalendar();
                
                showMessage('Base de donn√©es nettoy√©e et nouveau snapshot cr√©√©', 'success');
                
            } catch (err) {
                console.error('‚ùå Error cleaning database:', err);
                showMessage('Erreur lors du nettoyage de la base', 'error');
            }
        }
        
        // Enter snapshot mode for a specific date
        async function enterSnapshotMode(date) {
            if (snapshotMode === 'snapshot' && currentSnapshotDate === date) {
                return; // Already in this snapshot
            }
            
            try {
                // Clean: Removed debug log
                
                // Find snapshot info
                const snapshotInfo = availableSnapshots.find(s => s.snapshot_date === date);
                if (!snapshotInfo) {
                    showMessage(`Aucun snapshot trouv√© pour le ${formatDateForDisplay(date)}`, 'error');
                    return;
                }
                
                // Check if the file exists in storage first
                // Clean: Removed debug log
                
                        const { data: fileList, error: listError } = await supabase.storage
            .from('table-snapshots')
            .list('', { limit: 100 });
                
                if (listError) {
                    console.warn('‚ö†Ô∏è Could not list storage files:', listError);
                } else {
                    const fileExists = fileList?.some(file => file.name === snapshotInfo.object_path);
                    if (!fileExists) {
                        console.warn(`‚ö†Ô∏è File not found in storage: ${snapshotInfo.object_path}`);
                        // Clean: Removed debug log
                        
                        // Try to find a similar file or suggest cleanup
                        const similarFiles = fileList?.filter(f => f.name.includes('staff_table_'));
                        if (similarFiles && similarFiles.length > 0) {
                            console.log('üìã Similar files found:', similarFiles.map(f => f.name));
                            showMessage(`Fichier snapshot introuvable. Utilisez le bouton "Nettoyer" pour corriger.`, 'warning');
                            return;
                        }
                    }
                }
                
                // Get snapshot data from storage
                        const { data: snapshotData, error } = await supabase.storage
            .from('table-snapshots')
            .download(snapshotInfo.object_path);
                
                if (error) {
                    throw new Error(`Failed to download snapshot: ${error.message}`);
                }
                
                // Parse snapshot data
                const snapshot = JSON.parse(await snapshotData.text());
                
                // Update state
                snapshotMode = 'snapshot';
                currentSnapshotDate = date;
                currentSnapshotIndex = availableSnapshots.findIndex(s => s.snapshot_date === date);
                
                // Disable realtime updates
                if (realtimeSubscription) {
                    supabase.removeChannel(realtimeSubscription);
                    realtimeSubscription = null;
                }
                
                // Load snapshot data into table
                loadTableData(snapshot.data);
                
                // Update UI
                updateHistoryNavigation();
                updateSnapshotBanner();
                updateHistoryDateButton();
                
                // Disable editing
                disableTableEditing();
                
                showMessage(`Snapshot charg√© du ${formatDateForDisplay(date)} (${snapshot.data.length} lignes)`, 'success');
                
            } catch (error) {
                console.error('‚ùå Error entering snapshot mode:', error);
                showMessage(`Erreur lors du chargement du snapshot: ${error.message}`, 'error');
            }
        }
        
        // Return to today's live view
        async function returnToToday() {
            if (snapshotMode === 'live') {
                return; // Already in live mode
            }
            
            try {
                // Clean: Removed debug log
                
                // Update state
                snapshotMode = 'live';
                currentSnapshotDate = null;
                currentSnapshotIndex = -1;
                
                // Re-enable realtime updates
                setupRealtimeSubscription();
                
                // Refresh data from Supabase (no cache)
                await fetchInitialData();
                
                // Update UI
                updateHistoryNavigation();
                updateSnapshotBanner();
                updateHistoryDateButton();
                
                // Re-enable editing
                enableTableEditing();
                
                showMessage('Retour au mode en direct avec donn√©es actuelles', 'success');
                
            } catch (error) {
                console.error('‚ùå Error returning to today:', error);
                showMessage(`Erreur lors du retour au mode en direct: ${error.message}`, 'error');
            }
        }
        
        // Navigate to previous snapshot
        function goToPreviousSnapshot() {
            if (currentSnapshotIndex > 0) {
                const prevSnapshot = availableSnapshots[currentSnapshotIndex - 1];
                enterSnapshotMode(prevSnapshot.snapshot_date);
            }
        }
        
        // Navigate to next snapshot
        function goToNextSnapshot() {
            if (currentSnapshotIndex < availableSnapshots.length - 1) {
                const nextSnapshot = availableSnapshots[currentSnapshotIndex + 1];
                enterSnapshotMode(nextSnapshot.snapshot_date);
            }
        }
        
        // Open date picker for snapshot selection
        function openDatePicker() {
            if (availableSnapshots.length === 0) {
                showMessage('Aucun snapshot disponible', 'info');
                return;
            }
            
            // Create a simple date picker
            const dates = availableSnapshots.map(s => s.snapshot_date);
            const currentDate = snapshotMode === 'snapshot' ? currentSnapshotDate : null;
            
            // Find current index
            let currentIndex = currentDate ? dates.indexOf(currentDate) : -1;
            if (currentIndex === -1) currentIndex = 0;
            
            // Show next available date
            const nextIndex = (currentIndex + 1) % dates.length;
            const nextDate = dates[nextIndex];
            
            enterSnapshotMode(nextDate);
        }
        
        // Toggle snapshot calendar dropdown
        function toggleSnapshotCalendar() {
            const dropdown = document.getElementById('snapshot-calendar-dropdown');
            const isVisible = !dropdown.classList.contains('hidden');
            
            if (isVisible) {
                dropdown.classList.add('hidden');
            } else {
                // Populate and show calendar
                populateSnapshotCalendar();
                dropdown.classList.remove('hidden');
            }
        }
        
        // Populate snapshot calendar with available dates
        function populateSnapshotCalendar() {
            const datesList = document.getElementById('snapshot-dates-list');
            const calendarBtnText = document.getElementById('calendar-btn-text');
            
            if (!datesList) return;
            
            // Clear existing content
            datesList.innerHTML = '';
            
            if (availableSnapshots.length === 0) {
                datesList.innerHTML = `
                    <div class="p-3 text-center text-gray-500 text-sm">
                        <i class="fa-solid fa-calendar-xmark w-5 h-5 mx-auto mb-2"></i>
                        Aucun snapshot disponible
                    </div>
                `;
                calendarBtnText.textContent = 'Calendrier (0)';
                return;
            }
            
            // Update button text with count
            calendarBtnText.textContent = `Calendrier (${availableSnapshots.length})`;
            
            // Group snapshots by month/year for better organization
            const groupedSnapshots = {};
            availableSnapshots.forEach(snapshot => {
                const date = new Date(snapshot.snapshot_date);
                const monthYear = date.toLocaleDateString('fr-FR', { year: 'numeric', month: 'long' });
                
                if (!groupedSnapshots[monthYear]) {
                    groupedSnapshots[monthYear] = [];
                }
                groupedSnapshots[monthYear].push(snapshot);
            });
            
            // Create calendar entries
            Object.entries(groupedSnapshots).forEach(([monthYear, snapshots]) => {
                // Month header
                const monthHeader = document.createElement('div');
                monthHeader.className = 'px-2 py-1 bg-gray-100 text-xs font-semibold text-gray-700 rounded mb-2';
                monthHeader.textContent = monthYear;
                datesList.appendChild(monthHeader);
                
                // Dates in this month
                snapshots.forEach(snapshot => {
                    const dateItem = document.createElement('div');
                    dateItem.className = 'px-3 py-2 hover:bg-blue-50 cursor-pointer rounded text-sm transition-colors';
                    
                    const isCurrent = snapshotMode === 'snapshot' && currentSnapshotDate === snapshot.snapshot_date;
                    if (isCurrent) {
                        dateItem.className += ' bg-blue-100 border-l-4 border-blue-500';
                    }
                    
                    const date = new Date(snapshot.snapshot_date);
                    const formattedDate = date.toLocaleDateString('fr-FR', {
                        weekday: 'short',
                        day: 'numeric',
                        month: 'short'
                    });
                    
                    dateItem.innerHTML = `
                        <div class="flex items-center justify-between">
                            <span class="${isCurrent ? 'font-semibold text-blue-700' : 'text-gray-700'}">${formattedDate}</span>
                            <span class="text-xs text-gray-500">${snapshot.row_count} lignes</span>
                        </div>
                    `;
                    
                    dateItem.onclick = () => {
                        enterSnapshotMode(snapshot.snapshot_date);
                        toggleSnapshotCalendar(); // Close dropdown
                    };
                    
                    datesList.appendChild(dateItem);
                });
            });
        }
        
        // Update snapshot banner
        function updateSnapshotBanner() {
            // Note: snapshot-banner HTML element has been removed from the interface
            // This function is kept for compatibility but does nothing
            const banner = document.getElementById('snapshot-banner');
            if (!banner) {
                // Element doesn't exist anymore, silently return
                return;
            }
            
            const bannerText = document.getElementById('snapshot-banner-text');
            
            // Only show banner when actively viewing history (snapshot mode)
            if (snapshotMode === 'snapshot' && currentSnapshotDate) {
                banner.classList.remove('hidden');
                banner.classList.add('flex');
                if (bannerText) {
                    bannerText.textContent = `Snapshot du ${formatDateForDisplay(currentSnapshotDate)}`;
                }
            } else {
                // Always hidden in live mode or when no snapshot is selected
                banner.classList.add('hidden');
                banner.classList.remove('flex');
            }
        }
        
        // Update history date button
        function updateHistoryDateButton() {
            const dateText = document.getElementById('current-date-text');
            
            if (snapshotMode === 'snapshot' && currentSnapshotDate) {
                dateText.textContent = formatDateForDisplay(currentSnapshotDate);
            } else {
                dateText.textContent = 'Donn√©es en direct';
            }
        }
        
        // Disable table editing
        function disableTableEditing() {
            const cells = document.querySelectorAll('#table-body td.editable-cell');
            cells.forEach(cell => {
                cell.contentEditable = false;
                cell.classList.add('snapshot-readonly');
            });
            
            // Disable all function buttons in snapshot mode
            const functionButtons = document.querySelectorAll('#button-bar button');
            functionButtons.forEach(btn => {
                btn.disabled = true;
            });
            
            // Disable FAB add button
            const fabAdd = document.getElementById('fab-add');
            if (fabAdd) fabAdd.style.pointerEvents = 'none';
        }
        
        // Enable table editing
        function enableTableEditing() {
            const cells = document.querySelectorAll('#table-body td.editable-cell');
            cells.forEach(cell => {
                if (!isViewMode) { // Only enable if not in view mode
                    cell.contentEditable = true;
                }
                cell.classList.remove('snapshot-readonly');
            });
            
            // Re-enable function buttons
            const functionButtons = document.querySelectorAll('#button-bar button');
            functionButtons.forEach(btn => {
                btn.disabled = false;
            });
            
            // Re-enable FAB add button
            const fabAdd = document.getElementById('fab-add');
            if (fabAdd) fabAdd.style.pointerEvents = 'auto';
        }
        
        // Format date for display
        function formatDateForDisplay(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('fr-FR', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        }
        

        

        
        // Fonction pour actualiser le tableau avec les donn√©es les plus r√©centes
        function refreshTableData() {
            // Clean: Removed debug log
            
            // Si on est en mode snapshot, retourner aux donn√©es en direct
            if (snapshotMode === 'snapshot') {
                // Clean: Removed debug log
                returnToToday();
            }
            
            // Recharger les donn√©es depuis Supabase
            fetchInitialData().then(() => {
                showMessage('Tableau actualis√© avec les donn√©es les plus r√©centes', 'success');
            }).catch(error => {
                console.error('‚ùå Erreur lors de l\'actualisation:', error);
                showMessage('Erreur lors de l\'actualisation du tableau', 'error');
            });
        }
        
        // Simple and robust history bar toggle function
        function toggleHistoryBarSimple() {
            // Debug: V√©rifier que le DOM est charg√©
            if (document.readyState !== 'complete') {
                console.warn('‚ö†Ô∏è DOM not fully loaded, waiting...');
                setTimeout(toggleHistoryBarSimple, 100);
                return;
            }
            
            const historyBarContainer = document.getElementById('history-bar-container');
            const toggleBtn = document.getElementById('history-toggle-btn');
            const toggleIcon = document.getElementById('history-toggle-icon');
            
            if (!historyBarContainer || !toggleBtn || !toggleIcon) {
                console.error('‚ùå Required elements not found');
                console.error('‚ùå historyBarContainer:', historyBarContainer);
                console.error('‚ùå toggleBtn:', toggleBtn);
                console.error('‚ùå toggleIcon:', toggleIcon);
                return;
            }
            
            // Check current state - more robust detection
            const isCurrentlyVisible = !historyBarContainer.classList.contains('hidden') && 
                                    historyBarContainer.style.display !== 'none' && 
                                    historyBarContainer.offsetHeight > 0;
            
            if (isCurrentlyVisible) {
                // Hide history bar container
                historyBarContainer.classList.add('hidden');
                historyBarContainer.style.display = 'none';
                
                // Update button icon to show it can open
                toggleIcon.className = 'fa-solid fa-plus w-2 h-2 flex items-center justify-center text-center leading-none';
                
                console.log('üîΩ History bar hidden');
            } else {
                // Show history bar container
                historyBarContainer.classList.remove('hidden');
                historyBarContainer.style.display = 'flex'; // Use flex instead of block for better mobile layout
                
                // Update button icon to show it can close
                toggleIcon.className = 'fa-solid fa-minus w-2 h-2 flex items-center justify-center text-center leading-none';
                
                console.log('üîº History bar shown');
            }
            
            // Force a reflow on mobile to ensure proper rendering
            if (isMobile()) {
                // Force reflow multiple
                historyBarContainer.offsetHeight;
                
                // Additional mobile-specific adjustments
                setTimeout(() => {
                    if (window.innerWidth <= 768) {
                        // Ensure proper mobile layout
                        historyBarContainer.style.width = '100%';
                        historyBarContainer.style.maxWidth = 'none';
                        
                        // Force another reflow
                        historyBarContainer.offsetHeight;
                        
                        // Additional mobile optimization
                        if (window.innerWidth <= 480) {
                            // Very small screens - ensure vertical stacking
                            const innerContainer = historyBarContainer.querySelector('div');
                            if (innerContainer) {
                                innerContainer.style.flexDirection = 'column';
                                innerContainer.style.alignItems = 'center';
                            }
                        }
                    }
                }, 50);
            }
        }
        
        // Test function for mobile history bar functionality
        function testMobileHistoryBar() {
            const historyBarContainer = document.getElementById('history-bar-container');
            const toggleBtn = document.getElementById('history-toggle-btn');
            const toggleIcon = document.getElementById('history-toggle-icon');
            
            console.log('üß™ Testing Mobile History Bar...');
            console.log('üì± Screen size:', window.innerWidth, 'x', window.innerHeight);
            console.log('üì± User Agent:', navigator.userAgent);
            console.log('üì± isMobile():', isMobile());
            
            if (!historyBarContainer || !toggleBtn || !toggleIcon) {
                console.error('‚ùå Test failed: Required elements not found');
                return false;
            }
            
            console.log('‚úÖ All elements found');
            console.log('üîç History bar container:', historyBarContainer);
            console.log('üîç Toggle button:', toggleBtn);
            console.log('üîç Toggle icon:', toggleIcon);
            
            // Test initial state
            const initialHidden = historyBarContainer.classList.contains('hidden');
            const initialDisplay = historyBarContainer.style.display;
            const initialHeight = historyBarContainer.offsetHeight;
            
            console.log('üìä Initial state:');
            console.log('  - Hidden class:', initialHidden);
            console.log('  - Display style:', initialDisplay);
            console.log('  - Offset height:', initialHeight);
            
            // Test toggle functionality
            console.log('üîÑ Testing toggle functionality...');
            toggleHistoryBarSimple();
            
            setTimeout(() => {
                const afterToggleHidden = historyBarContainer.classList.contains('hidden');
                const afterToggleDisplay = historyBarContainer.style.display;
                const afterToggleHeight = historyBarContainer.offsetHeight;
                
                console.log('üìä After toggle:');
                console.log('  - Hidden class:', afterToggleHidden);
                console.log('  - Display style:', afterToggleDisplay);
                console.log('  - Offset height:', afterToggleHeight);
                
                // Test toggle back
                setTimeout(() => {
                    console.log('üîÑ Testing toggle back...');
                    toggleHistoryBarSimple();
                    
                    setTimeout(() => {
                        const finalHidden = historyBarContainer.classList.contains('hidden');
                        const finalDisplay = historyBarContainer.style.display;
                        const finalHeight = historyBarContainer.offsetHeight;
                        
                        console.log('üìä Final state:');
                        console.log('  - Hidden class:', finalHidden);
                        console.log('  - Display style:', finalDisplay);
                        console.log('  - Offset height:', finalHeight);
                        
                        console.log('‚úÖ Mobile History Bar test completed');
                    }, 100);
                }, 100);
            }, 100);
            
            return true;
        }

        // ===== END SNAPSHOT SYSTEM FUNCTIONS =====



        // Initialize application
        function initializeApp() {
            // Set up event listeners
            setupEventListeners();
            setupKeyboardNavigation();
            
            // Initialize zoom
            if (isMobile() && !localStorage.getItem('zoomFactor')) { 
                zoomFactor = 0.6; 
                localStorage.setItem('zoomFactor', '0.6'); 
            } 
            applyZoom();
            
            // Initialize color picker
            const picker = document.getElementById('row-color-picker');
            if (picker) {
                try { 
                    picker.value = currentRowColor; 
                } catch(_) {}
                
                picker.addEventListener('input', (e) => {
                    currentRowColor = e.target.value || '#FFF59D';
                    try { 
                        localStorage.setItem('rowColor', currentRowColor); 
                    } catch(_) {}
                });
            }
            
                        // Initialize UI state
            updatePaintModeButton();
            maybeShowFirstUseHint();
            updateFilterColoredButton();
            
            // D√©tecter automatiquement l'√©tat du bouton ≈ìil et agir en cons√©quence
            detectAndApplyViewMode();
            
            // Adapter l'affichage du statut selon la taille d'√©cran
            adaptStatusDisplay();
            window.addEventListener('resize', adaptStatusDisplay);
            
            // Configurer le clic sur les noms de patients pour les images
            setupPatientImageClick();
            
            // Initialiser l'√©tat de la barre d'historique : cach√©e par d√©faut
            const historyBarContainer = document.getElementById('history-bar-container');
            const toggleIcon = document.getElementById('history-toggle-icon');
            if (historyBarContainer && toggleIcon) {
                // S'assurer que la barre est cach√©e
                historyBarContainer.classList.add('hidden');
                historyBarContainer.style.display = 'none';
                
                // S'assurer que l'ic√¥ne est en mode "plus" (ferm√©)
                toggleIcon.className = 'fa-solid fa-plus w-2 h-2 flex items-center justify-center text-center leading-none';
                
                // V√©rification post-initialisation pour mobile
                setTimeout(() => {
                    if (isMobile()) {
                        const isHidden = historyBarContainer.classList.contains('hidden') && 
                                        historyBarContainer.style.display === 'none';
                        console.log('üîç Post-init mobile check:', isHidden ? 'Hidden' : 'Visible');
                        
                        // Force mobile-specific layout
                        if (window.innerWidth <= 768) {
                            historyBarContainer.style.width = '100%';
                            historyBarContainer.style.maxWidth = 'none';
                        }
                    }
                }, 100);
            }
            
            // Initialiser l'affichage du nombre de lignes
            updateRowCount();
            
            // Check if already logged in
            const already = sessionStorage.getItem('isLoggedIn') === '1';
            if (already) {
                document.getElementById('login-container').classList.add('hidden');
                document.getElementById('table-container').classList.remove('hidden');
                
                // D√©tecter l'√©tat du mode visualisation MAIS ne pas l'appliquer encore
                const savedViewMode = localStorage.getItem('viewMode') === 'true';
                if (savedViewMode !== isViewMode) {
                    isViewMode = savedViewMode;
                }
                
                restoreLocalDraft(); 
                ensureDDNHeader();
                
                // Consolidated cursor restoration function
                const performCursorRestoration = () => {
                    log(`üîÑ CURSOR RESTORATION: lastFocusInfo=${JSON.stringify(lastFocusInfo)}, lastCellPos=${JSON.stringify(lastCellPos)}`);
                    
                    // Try focusCellFromInfo first (more reliable)
                    let restorationSuccess = false;
                    if (lastFocusInfo && lastFocusInfo.rowIndex >= 0 && lastFocusInfo.colLabel) {
                        restorationSuccess = focusCellFromInfo(lastFocusInfo);
                        log(`üîÑ focusCellFromInfo result: ${restorationSuccess}`);
                    }
                    
                    // Fallback to focusCellByPos if focusCellFromInfo fails
                    if (!restorationSuccess && lastCellPos && lastCellPos.rowIndex >= 0 && lastCellPos.cellIndex >= 0) {
                            log(`üîÑ Trying focusCellByPos with ${JSON.stringify(lastCellPos)}`);
                        restorationSuccess = focusCellByPos(lastCellPos);
                        log(`üîÑ focusCellByPos result: ${restorationSuccess}`);
                    }
                    
                    if (restorationSuccess) {
                        log(`‚úÖ Cursor restoration successful`);
                        } else {
                        log(`‚ö†Ô∏è Cursor restoration failed - no valid position information`);
                    }
                };
                
                const restoreAfterReload = () => {
                    document.removeEventListener('table:reloaded', restoreAfterReload);
                    
                    // Wait for table to be fully rendered and image icons updated
                    // Use a longer delay to ensure all table updates are complete
                    setTimeout(() => {
                        performCursorRestoration();
                        
                        // Additional mobile retry if needed
                        if (isMobile()) {
                            setTimeout(() => { 
                                performCursorRestoration();
                            }, 350);
                        }
                    }, 200); // Increased delay to ensure table and image icons are fully ready
                };
                
                document.addEventListener('table:reloaded', restoreAfterReload, { once: true });
                fetchInitialData(); 
                setupRealtimeSubscription(); 
                startPeriodicSync(); 
                scheduleAutosaveCountdown();
                
                // Initialize snapshot system
                loadAvailableSnapshots();
                
                // Ensure snapshot banner is hidden by default
                updateSnapshotBanner();
                
                // Update calendar display after loading snapshots
                setTimeout(() => {
                    populateSnapshotCalendar();
                }, 500);
                
                // Clean: Removed debug verification for production
                
                // Force UI update to ensure everything is visible
                // Clean: Removed debug UI update for production
                

                
                // Appliquer le mode visualisation APR√àS la restauration des donn√©es
                // Clean: Removed debug view mode application for production
                
                // Adapter l'affichage apr√®s le chargement des donn√©es
                setTimeout(adaptStatusDisplay, 100);
                
                // Mettre √† jour les indicateurs d'images
                setTimeout(updateImageIndicators, 200);
                
                // Charger les images depuis Supabase
                setTimeout(loadImagesFromSupabase, 300);
                
                // Mettre √† jour les ic√¥nes de la colonne Images apr√®s le chargement
                setTimeout(updateAllImageColumnIcons, 500);
                
                // Afficher le statut de synchronisation des images
                setTimeout(showImageSyncStatus, 600);
                
                // Enable focus capture after initialization is complete
                setTimeout(() => {
                    isInitialLoad = false;
                    log(`‚úÖ Initial load complete - focus capture now enabled`);
                    
                    // Ensure cursor restoration happens after all updates are complete
                    if (lastFocusInfo || lastCellPos) {
                        // Clean: Removed debug log
                        setTimeout(() => {
                            performCursorRestoration();
                        }, 100);
                    }
                }, 1000);
                
                // Add click outside handler for calendar dropdown
                document.addEventListener('click', (e) => {
                    const calendarBtn = document.getElementById('snapshot-calendar-btn');
                    const calendarDropdown = document.getElementById('snapshot-calendar-dropdown');
                    
                    if (calendarDropdown && !calendarDropdown.classList.contains('hidden')) {
                        if (!calendarBtn?.contains(e.target) && !calendarDropdown?.contains(e.target)) {
                            calendarDropdown.classList.add('hidden');
                        }
                    }
                });
            } else {
                document.getElementById('login-container').classList.remove('hidden');
            }
            

        }
        

        

        

        

        

        
        function displayPatientImages(patientName) {
            const gallery = document.getElementById('image-gallery');
            const images = patientImages[patientName] || [];
            
            gallery.innerHTML = '';
            
            if (images.length === 0) {
                gallery.innerHTML = '<p class="text-gray-500 text-center col-span-full">Aucune image pour ce patient</p>';
                return;
            }
            
            images.forEach((image, index) => {
                const imageDiv = document.createElement('div');
                imageDiv.className = 'relative group';
                
                imageDiv.innerHTML = `
                    <img src="${image.data}" alt="${image.name}" class="w-full h-24 object-cover rounded-lg cursor-pointer hover:opacity-80 transition-opacity" 
                         onclick="viewImage('${patientName}', ${index})"
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='block';" />
                    <div class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs cursor-pointer hover:bg-red-600 opacity-0 group-hover:opacity-100 transition-opacity"
                         onclick="deleteImage('${patientName}', ${index})">√ó</div>
                    <p class="text-xs text-gray-600 mt-1 truncate">${image.name}</p>
                    <div class="hidden text-xs text-gray-400 text-center mt-2">Image corrompue</div>
                `;
                
                gallery.appendChild(imageDiv);
            });
        }
        
        function viewImage(patientName, imageIndex) {
            const images = patientImages[patientName] || [];
            if (images.length === 0) return;
            
            currentPatientImages = images;
            currentImageIndex = imageIndex;
            
            const modal = document.getElementById('image-viewer-modal');
            const currentImage = document.getElementById('current-image');
            const counter = document.getElementById('image-counter');
            
            currentImage.src = images[imageIndex].data;
            currentImage.onerror = () => {
                showMessage('Erreur lors du chargement de l\'image', 'error');
                currentImage.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzY2NzM4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vbiB0cm91dsOpZTwvdGV4dD48L3N2Zz4=';
            };
            counter.textContent = `${imageIndex + 1} / ${images.length}`;
            
            modal.classList.remove('hidden');
        }
        
        function closeImageViewer() {
            document.getElementById('image-viewer-modal').classList.add('hidden');
        }
        
        function nextImage() {
            if (currentPatientImages.length === 0) return;
            currentImageIndex = (currentImageIndex + 1) % currentPatientImages.length;
            updateImageViewer();
        }
        
        function previousImage() {
            if (currentPatientImages.length === 0) return;
            currentImageIndex = currentImageIndex === 0 ? currentPatientImages.length - 1 : currentImageIndex - 1;
            updateImageViewer();
        }
        
        function updateImageViewer() {
            const currentImage = document.getElementById('current-image');
            const counter = document.getElementById('image-counter');
            
            currentImage.src = currentPatientImages[currentImageIndex].data;
            currentImage.onerror = () => {
                showMessage('Erreur lors du chargement de l\'image', 'error');
                currentImage.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzY2NzM4MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkltYWdlIG5vbiB0cm91dsOpZTwvdGV4dD48L3N2Zz4=';
            };
            counter.textContent = `${currentImageIndex + 1} / ${currentPatientImages.length}`;
        }
        
        async function deleteImage(patientName, imageIndex) {
            try {
                // V√©rifier que l'image existe
                if (!patientImages[patientName] || !patientImages[patientName][imageIndex]) {
                    showMessage('Image non trouv√©e', 'error');
                    return;
                }

                // Demander confirmation
                if (!confirm(`Voulez-vous vraiment supprimer cette image ?`)) {
                    return;
                }

                const imageToDelete = patientImages[patientName][imageIndex];
                
                // Supprimer de Supabase si l'image a un ID
                if (imageToDelete.id) {
                    try {
                        const { error } = await supabase
                            .from('gallery_images')
                            .delete()
                            .eq('id', imageToDelete.id);
                        
                        if (error) {
                            console.error('Erreur lors de la suppression depuis Supabase:', error);
                            showMessage('Erreur lors de la suppression depuis le serveur', 'error');
                            return;
                        }
                    } catch (supabaseError) {
                        console.error('Erreur de connexion Supabase:', supabaseError);
                        showMessage('Erreur de connexion au serveur', 'error');
                        return;
                    }
                }

                // Supprimer du stockage local
                patientImages[patientName].splice(imageIndex, 1);
                
                // Si c'√©tait la derni√®re image du patient, supprimer l'entr√©e du patient
                if (patientImages[patientName].length === 0) {
                    delete patientImages[patientName];
                }
                
                // Sauvegarder les changements
                savePatientImages();
                
                // Mettre √† jour l'affichage
                displayPatientImages(patientName);
                updateAllImageColumnIcons(true); // √âviter les sauvegardes automatiques
                
                // R√©initialiser les indicateurs de modification pour √©viter l'autosave
                isDirty = false;
                lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // D√©sactiver l'autosave
                
                // Fermer le visualiseur si c'√©tait la derni√®re image
                if (!patientImages[patientName] || patientImages[patientName].length === 0) {
                    closeImageViewer();
                }
                
                showMessage('Image supprim√©e avec succ√®s', 'success');
                
            } catch (error) {
                console.error('Erreur lors de la suppression de l\'image:', error);
                showMessage('Erreur lors de la suppression de l\'image', 'error');
            }
                }

        // Fonction pour supprimer toutes les images d'un patient
        async function deleteAllImagesForPatient(patientName) {
            try {
                if (!patientImages[patientName] || patientImages[patientName].length === 0) {
                    showMessage('Aucune image √† supprimer pour ce patient', 'info');
                    return;
                }

                const imageCount = patientImages[patientName].length;
                
                // Supprimer toutes les images de Supabase
                for (const image of patientImages[patientName]) {
                    if (image.id) {
                        try {
                            const { error } = await supabase
                                .from('gallery_images')
                                .delete()
                                .eq('id', image.id);
                            
                            if (error) {
                                console.error('Erreur lors de la suppression de l\'image depuis Supabase:', error);
                            }
                        } catch (supabaseError) {
                            console.error('Erreur de connexion Supabase:', supabaseError);
                        }
                    }
                }

                // Supprimer du stockage local
                delete patientImages[patientName];
                savePatientImages();
                
                // Mettre √† jour l'affichage
                updateAllImageColumnIcons(true); // √âviter les sauvegardes automatiques
                
                // R√©initialiser les indicateurs de modification pour √©viter l'autosave
                isDirty = false;
                lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // D√©sactiver l'autosave
                
                // Fermer le visualiseur si il √©tait ouvert pour ce patient
                if (currentPatientImages && currentPatientImages.length > 0) {
                    const firstImage = currentPatientImages[0];
                    if (firstImage.patientName === patientName) {
                        closeImageViewer();
                    }
                }
                
                showMessage(`${imageCount} image(s) supprim√©e(s) pour ${patientName}`, 'success');
                
            } catch (error) {
                console.error('Erreur lors de la suppression de toutes les images:', error);
                showMessage('Erreur lors de la suppression des images', 'error');
            }
        }

        async function syncImageToSupabase(imageData) {
            try {
                // Cr√©er une entr√©e dans la table des images
                const { error } = await supabase
                    .from('gallery_images')
                    .upsert({
                        id: imageData.id,
                        patient_name: imageData.patientName,
                        image_name: imageData.name,
                        image_data: imageData.data,
                        image_type: imageData.type,
                        image_size: imageData.size,
                        upload_date: imageData.uploadDate,
                        last_sync: new Date().toISOString()
                    });
                
                if (error) {
                    console.error('Erreur Supabase:', error);
                    // Stocker pour synchronisation ult√©rieure
                    storeImageForLaterSync(imageData);
                }
            } catch (error) {
                console.error('Erreur de synchronisation:', error);
                // Stocker pour synchronisation ult√©rieure
                storeImageForLaterSync(imageData);
            }
        }
        
        function storeImageForLaterSync(imageData) {
            let pendingImages = JSON.parse(localStorage.getItem('pendingImageSync') || '[]');
            pendingImages.push(imageData);
            localStorage.setItem('pendingImageSync', JSON.stringify(pendingImages));
        }
        
        async function syncPendingImages() {
            try {
                let pendingImages = JSON.parse(localStorage.getItem('pendingImageSync') || '[]');
                if (pendingImages.length === 0) return;
                
                for (const imageData of pendingImages) {
                    await syncImageToSupabase(imageData);
                }
                
                // Vider la liste des images en attente
                localStorage.removeItem('pendingImageSync');
                
                // Mettre √† jour les ic√¥nes de la colonne Images
                updateAllImageColumnIcons(true); // √âviter les sauvegardes automatiques
                
                // R√©initialiser les indicateurs de modification pour √©viter l'autosave
                isDirty = false;
                lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // D√©sactiver l'autosave
                
                showMessage('Images synchronis√©es avec le serveur', 'success');
            } catch (error) {
                console.error('Erreur lors de la synchronisation des images en attente:', error);
            }
        }
        
        function savePatientImages() {
            try {
                localStorage.setItem('patientImages', JSON.stringify(patientImages));
            } catch (e) {
                console.error('Erreur lors de la sauvegarde des images:', e);
            }
        }
        
        // Fonction pour afficher les images au clic sur le nom du patient
        function setupPatientImageClick() {
            const tbody = document.getElementById('table-body');
            if (!tbody) return;
            
            tbody.addEventListener('click', function(e) {
                const nameCell = e.target.closest('td:nth-child(6)'); // Colonne Nom_Pr√©nom
                if (nameCell && nameCell.textContent.trim()) {
                    const patientName = nameCell.textContent.trim();
                    const images = patientImages[patientName] || [];
                    
                    if (images.length > 0) {
                        // Ouvrir directement le visualiseur d'images
                        currentPatientImages = images;
                        currentImageIndex = 0;
                        viewImage(patientName, 0);
                    } else {
                        // Aucune image pour ce patient - afficher un message
                        showMessage('Aucune image pour ce patient. Utilisez le bouton ‚ûï dans la colonne Images pour ajouter des images.', 'info');
                    }
                }
            });
        }
        
        // Fonction pour afficher le statut de synchronisation des images
        function showImageSyncStatus() {
            const pendingImages = JSON.parse(localStorage.getItem('pendingImageSync') || '[]');
            if (pendingImages.length > 0) {
                showMessage(`${pendingImages.length} image(s) en attente de synchronisation`, 'warning');
            }
        }
        
        // Fonction pour mettre √† jour les indicateurs d'images (maintenant uniquement dans la colonne Images)
        function updateImageIndicators() {
            // Cette fonction est maintenant remplac√©e par updateAllImageColumnIcons
            // qui met √† jour uniquement les ic√¥nes dans la colonne Images
            updateAllImageColumnIcons();
        }
        
        // Fonction pour charger les images depuis Supabase
        async function loadImagesFromSupabase() {
            // Skip if cursor restoration is in progress to avoid conflicts
            if (isRestoringFocus) {
                log('üîÑ loadImagesFromSupabase skipped - cursor restoration in progress');
                return;
            }
            
            try {
                const { data, error } = await supabase
                    .from('gallery_images')
                    .select('*')
                    .order('upload_date', { ascending: false });
                
                if (error) {
                    console.error('Erreur lors du chargement des images:', error);
                    return;
                }
                
                if (data && data.length > 0) {
                    // R√©organiser les images par patient
                    const newPatientImages = {};
                    data.forEach(image => {
                        if (!newPatientImages[image.patient_name]) {
                            newPatientImages[image.patient_name] = [];
                        }
                        newPatientImages[image.patient_name].push({
                            id: image.id,
                            name: image.image_name,
                            data: image.image_data,
                            type: image.image_type,
                            size: image.image_size,
                            uploadDate: image.upload_date,
                            patientName: image.patient_name
                        });
                    });
                    
                    // Mettre √† jour les images locales
                    patientImages = { ...patientImages, ...newPatientImages };
                    savePatientImages();
                    
                    // Synchroniser les images en attente
                    await syncPendingImages();
                    
                    // Mettre √† jour les ic√¥nes de la colonne Images
                    updateAllImageColumnIcons(true); // √âviter les sauvegardes automatiques
                    
                    // R√©initialiser les indicateurs de modification pour √©viter l'autosave
                    isDirty = false;
                    lastEditAt = Date.now() - AUTOSAVE_DELAY_MS - 1000; // D√©sactiver l'autosave
                    
                    showMessage(`${data.length} image(s) charg√©e(s) depuis le serveur`, 'success');
                }
            } catch (error) {
                console.error('Erreur lors du chargement des images:', error);
            }
        }

        // Fonction pour mettre √† jour toutes les ic√¥nes de la colonne Images
        function updateAllImageColumnIcons(skipAutoSave = false) {
            const tbody = document.getElementById('table-body');
            if (!tbody) return;
            
            // Skip if cursor restoration is in progress to avoid conflicts
            if (isRestoringFocus) {
                log('üîÑ updateAllImageColumnIcons skipped - cursor restoration in progress');
                return;
            }
            
            Array.from(tbody.querySelectorAll('tr')).forEach(row => {
                const imageCell = row.querySelector('[data-label="Images"]');
                if (imageCell) {
                    const mainButton = imageCell.querySelector('button:first-child');
                    const trashButton = imageCell.querySelector('button:last-child');
                    const container = imageCell.querySelector('div');
                    
                    if (mainButton && trashButton && container) {
                        const nameCell = row.querySelector('[data-label="Nom_Pr√©nom"]');
                        if (nameCell) {
                            const patientName = nameCell.textContent.trim();
                            

                            
                            // V√©rifier si l'√©tat actuel correspond √† l'√©tat souhait√© pour √©viter les modifications inutiles
                            const hasImages = patientName && patientImages[patientName] && patientImages[patientName].length > 0;
                            const currentHasImages = mainButton.innerHTML === 'üì∑';
                            
                            // Ne mettre √† jour que si l'√©tat a chang√©
                            if (hasImages !== currentHasImages) {
                                if (hasImages) {
                                    // Il y a des photos - afficher le bouton cam√©ra et la poubelle
                                    mainButton.innerHTML = 'üì∑';
                                    mainButton.title = `${patientImages[patientName].length} image(s) - Cliquez pour voir`;
                                    mainButton.onclick = (e) => {
                                        e.stopPropagation();
                                        viewImage(patientName, 0);
                                    };
                                    mainButton.className = 'p-1 rounded-full hover:bg-gray-200 transition-colors text-blue-500';
                                    
                                    // Afficher la poubelle
                                    trashButton.style.opacity = '1';
                                    trashButton.onclick = (e) => {
                                        e.stopPropagation();
                                        if (confirm(`Voulez-vous vraiment supprimer toutes les images de ${patientName} ?`)) {
                                            deleteAllImagesForPatient(patientName);
                                        }
                                    };
                                    
                                    // Ajouter un bouton + pour ajouter plus d'images (seulement s'il n'existe pas d√©j√†)
                                    let addMoreButton = container.querySelector('.add-more-button');
                                    if (!addMoreButton) {
                                        addMoreButton = document.createElement('button');
                                        addMoreButton.innerHTML = '‚ûï';
                                        addMoreButton.className = 'add-more-button p-1 rounded-full hover:bg-green-200 transition-colors text-green-600 ml-1';
                                        addMoreButton.title = 'Ajouter plus d\'images pour ce patient';
                                        addMoreButton.onclick = (e) => {
                                            e.stopPropagation();
                                            const fileInput = imageCell.querySelector('input[type="file"]');
                                            if (fileInput) fileInput.click();
                                        };
                                        container.appendChild(addMoreButton);
                                    }
                                    
                                } else {
                                // Pas de photos - afficher le bouton ajouter et cacher la poubelle
                                mainButton.innerHTML = '‚ûï';
                                mainButton.title = 'Ajouter des images pour ce patient';
                                mainButton.onclick = (e) => {
                                    e.stopPropagation();
                                    const fileInput = imageCell.querySelector('input[type="file"]');
                                    if (fileInput) fileInput.click();
                                };
                                mainButton.className = 'p-1 rounded-full hover:bg-green-200 transition-colors text-green-600';
                                
                                    // Cacher la poubelle
                                    trashButton.style.opacity = '0';
                                    trashButton.onclick = null;
                                    
                                    // Supprimer le bouton + s'il existe
                                    const addMoreButton = container.querySelector('.add-more-button');
                                    if (addMoreButton) {
                                        addMoreButton.remove();
                                    }
                                }
                            } else if (hasImages) {
                                // Mettre √† jour seulement le titre si le nombre d'images a chang√©
                                const currentTitle = mainButton.title;
                                const newTitle = `${patientImages[patientName].length} image(s) - Cliquez pour voir`;
                                if (currentTitle !== newTitle) {
                                    mainButton.title = newTitle;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Make functions globally available
        window.checkPassword = checkPassword;
        window.syncToMaster = syncToMaster;
        window.addRow = addRow;
        window.saveManually = saveManually;
        window.undo = undo;
        window.redo = redo;
        window.trackCellEdit = trackCellEdit;
        window.getColumnLabelForCell = getColumnLabelForCell;
        window.isUndoRedoInProgress = isUndoRedoInProgress;
        window.getUndoRedoStatus = getUndoRedoStatus;
        window.downloadExcel = downloadExcel;
        window.downloadPDF = downloadPDF;
        window.downloadImage = downloadImage;
        window.importExcelFromFile = importExcelFromFile;
        window.zoomIn = zoomIn;
        window.zoomOut = zoomOut;
        window.zoomReset = zoomReset;
        window.clearAllRowColors = clearAllRowColors;
        window.cyclePaintMode = cyclePaintMode;
        window.toggleColoredFilter = toggleColoredFilter;
        window.toggleViewMode = toggleViewMode;
        
        // Expose history bar toggle functions
        window.toggleHistoryBarSimple = toggleHistoryBarSimple;

        window.viewImage = viewImage;
        
        // Expose snapshot system functions
        window.loadAvailableSnapshots = loadAvailableSnapshots;
        window.enterSnapshotMode = enterSnapshotMode;
        window.returnToToday = returnToToday; // Use the existing function instead
        window.goToPreviousSnapshot = goToPreviousSnapshot;
        window.goToNextSnapshot = goToNextSnapshot;
        window.refreshTableData = refreshTableData;
        window.toggleSnapshotCalendar = toggleSnapshotCalendar;
        window.populateSnapshotCalendar = populateSnapshotCalendar;
        window.openDatePicker = openDatePicker;
        window.formatDateForDisplay = formatDateForDisplay;
        window.disableTableEditing = disableTableEditing;
        
        // Expose storage management functions globally
        window.cleanupOldSnapshots = cleanupOldSnapshots;
        window.checkStorageCapacity = checkStorageCapacity;
        window.monitorStorageHealth = monitorStorageHealth;
        window.forceStorageCleanup = forceStorageCleanup;
        window.calculateOptimalSnapshotCount = calculateOptimalSnapshotCount;
        
        // Timer cleanup function to prevent infinite loops
        function cleanupAllTimers() {
            try {
                if (autosaveTicker) {
                    clearInterval(autosaveTicker);
                    autosaveTicker = null;
                }
                if (window._syncTimer) {
                    clearInterval(window._syncTimer);
                    window._syncTimer = null;
                }
                if (window._msgTimer) {
                    clearTimeout(window._msgTimer);
                    window._msgTimer = null;
                }
                if (cellEditTimeout) {
                    clearTimeout(cellEditTimeout);
                    cellEditTimeout = null;
                }
                if (undoRedoSyncTimeout) {
                    clearTimeout(undoRedoSyncTimeout);
                    undoRedoSyncTimeout = null;
                }
                if (historyDebounceTimeout) {
                    clearTimeout(historyDebounceTimeout);
                    historyDebounceTimeout = null;
                }
                if (typingTimer) {
                    clearTimeout(typingTimer);
                    typingTimer = null;
                }
                if (operationTimeout) {
                    clearTimeout(operationTimeout);
                    operationTimeout = null;
                }
                
                console.log('üßπ All timers cleaned up successfully');
            } catch (error) {
                console.error('‚ùå Error cleaning up timers:', error);
            }
        }
        
        // Enhanced conflict detection and prevention system
        function detectAndPreventConflicts() {
            const conflicts = [];
            
            // Check for autosave conflicts
            if (autosaveTicker && isPerformingUndoRedo) {
                conflicts.push('AUTOSAVE_UNDO_REDO_CONFLICT');
            }
            
            // Check for realtime conflicts
            if (realtimeSubscription && isPerformingUndoRedo) {
                conflicts.push('REALTIME_UNDO_REDO_CONFLICT');
            }
            
            // Check for sync conflicts
            if (window._syncTimer && isPerformingUndoRedo) {
                conflicts.push('SYNC_UNDO_REDO_CONFLICT');
            }
            
            // Check for timer conflicts
            if (autosaveTicker && window._syncTimer) {
                const autosaveInterval = 250; // 250ms from scheduleAutosaveCountdown
                const syncInterval = 500; // 500ms from startPeriodicSync
                
                if (syncInterval % autosaveInterval === 0) {
                    conflicts.push('TIMER_INTERVAL_CONFLICT');
                }
            }
            
            return conflicts;
        }
        
        // Enhanced autosave with conflict prevention
        function scheduleAutosaveCountdownEnhanced() {
            try {
                // Cleanup existing timer
                if (autosaveTicker) {
                    clearInterval(autosaveTicker);
                    autosaveTicker = null;
                }
                
                // Check for conflicts before starting
                const conflicts = detectAndPreventConflicts();
                if (conflicts.length > 0) {
                    console.warn('‚ö†Ô∏è Autosave conflicts detected:', conflicts);
                    return;
                }
                
                lastShownCountdown = null;
                autosaveTicker = setInterval(() => {
                    try {
                        // Enhanced conflict prevention
                        if (isSyncing || isPerformingUndoRedo) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        const modal = document.getElementById('confirmation-modal');
                        if (modal && !modal.classList.contains('hidden')) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        if (isTyping) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        // Check suppression windows
                        if (Date.now() < suppressAutosaveUntil) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        // Check pending operations
                        if (currentOperation && currentOperation.type) {
                            lastShownCountdown = null;
                            return;
                        }
                        
                        const remaining = AUTOSAVE_DELAY_MS - (Date.now() - lastEditAt);
                        if (remaining > 0) {
                            const secs = Math.ceil(remaining / 1000);
                            if (secs !== lastShownCountdown) {
                                showMessage(`Sauvegarde dans ${secs} s`, 'info');
                                lastShownCountdown = secs;
                            }
                        } else {
                            if (lastShownCountdown !== 0) {
                                showMessage('Sauvegarde imminente‚Ä¶', 'info');
                                lastShownCountdown = 0;
                            }
                        }
                    } catch (error) {
                        console.error('‚ùå Error in autosave ticker:', error);
                    }
                }, 250);
                
                console.log('‚úÖ Enhanced autosave scheduled successfully');
            } catch (error) {
                console.error('‚ùå Error scheduling enhanced autosave:', error);
            }
        }
        
        // Enhanced periodic sync with conflict prevention
        function startPeriodicSyncEnhanced() {
            try {
                // Cleanup existing timer
                if (window._syncTimer) {
                    clearInterval(window._syncTimer);
                    window._syncTimer = null;
                }
                
                // Check for conflicts before starting
                const conflicts = detectAndPreventConflicts();
                if (conflicts.length > 0) {
                    console.warn('‚ö†Ô∏è Sync conflicts detected:', conflicts);
                    return;
                }
                
                window._syncTimer = setInterval(async () => {
                    try {
                        // Enhanced conflict prevention
                        if (isTyping || isPerformingUndoRedo) {
                            return;
                        }
                        
                        if (Date.now() - lastEditAt < AUTOSAVE_DELAY_MS) {
                            return;
                        }
                        
                        const modal = document.getElementById('confirmation-modal');
                        if (modal && !modal.classList.contains('hidden')) {
                            return;
                        }
                        
                        if (isSyncing || !isDirty) {
                            return;
                        }
                        
                        // Check suppression windows
                        if (Date.now() < suppressAutosaveUntil) {
                            return;
                        }
                        
                        // Check pending operations
                        if (currentOperation && currentOperation.type) {
                            return;
                        }
                        
                        isSyncing = true;
                        log('Auto-sync (500ms poll, 3s idle) vers Supabase‚Ä¶');
                        await syncToMaster(false);
                    } catch (error) {
                        console.error('‚ùå Error in periodic sync:', error);
                    } finally {
                        isSyncing = false;
                    }
                }, 500);
                
                console.log('‚úÖ Enhanced periodic sync started successfully');
            } catch (error) {
                console.error('‚ùå Error starting enhanced periodic sync:', error);
            }
        }
        
        // Expose timer cleanup function globally
        window.cleanupAllTimers = cleanupAllTimers;
        
        // Expose conflict detection and prevention functions globally
        window.detectAndPreventConflicts = detectAndPreventConflicts;
        window.scheduleAutosaveCountdownEnhanced = scheduleAutosaveCountdownEnhanced;
        window.startPeriodicSyncEnhanced = startPeriodicSyncEnhanced;
        
        // Function to test and report all potential conflicts
        window.testSystemConflicts = function() {
            try {
                console.log('üîç Testing system for potential conflicts...');
                
                // Test timer conflicts
                const timerConflicts = detectAndPreventConflicts();
                if (timerConflicts.length > 0) {
                    console.warn('‚ö†Ô∏è Timer conflicts detected:', timerConflicts);
                } else {
                    console.log('‚úÖ No timer conflicts detected');
                }
                
                // Test autosave state
                console.log('üìä Autosave state:', {
                    autosaveTicker: !!autosaveTicker,
                    isPerformingUndoRedo,
                    suppressAutosaveUntil: Date.now() < suppressAutosaveUntil,
                    currentOperation: !!currentOperation
                });
                
                // Test sync state
                console.log('üìä Sync state:', {
                    syncTimer: !!window._syncTimer,
                    isSyncing,
                    isDirty,
                    lastEditAt: new Date(lastEditAt).toLocaleTimeString()
                });
                
                // Test realtime state
                console.log('üìä Realtime state:', {
                    realtimeSubscription: !!realtimeSubscription,
                    suppressRealtimeUntil: Date.now() < suppressRealtimeUntil
                });
                
                // Test undo/redo state
                console.log('üìä Undo/Redo state:', {
                    operationHistoryLength: operationHistory.length,
                    redoHistoryLength: redoHistory.length,
                    isPerformingUndoRedo
                });
                
                console.log('‚úÖ System conflict test completed');
                return {
                    timerConflicts,
                    autosaveState: { autosaveTicker: !!autosaveTicker, isPerformingUndoRedo, suppressAutosaveUntil: Date.now() < suppressAutosaveUntil, currentOperation: !!currentOperation },
                    syncState: { syncTimer: !!window._syncTimer, isSyncing, isDirty, lastEditAt: new Date(lastEditAt).toLocaleTimeString() },
                    realtimeState: { realtimeSubscription: !!realtimeSubscription, suppressRealtimeUntil: Date.now() < suppressRealtimeUntil },
                    undoRedoState: { operationHistoryLength: operationHistory.length, redoHistoryLength: redoHistory.length, isPerformingUndoRedo }
                };
                
            } catch (error) {
                console.error('‚ùå Error testing system conflicts:', error);
                return null;
            }
        };
        
        // Function to test keyboard shortcuts
        window.testKeyboardShortcuts = function() {
            try {
                console.log('‚å®Ô∏è Testing keyboard shortcuts...');
                
                // Test manual save shortcuts
                console.log('üíæ Manual save shortcuts:');
                console.log('   - Cmd+Z (Mac) / Ctrl+Z (Windows/Linux)');
                console.log('   - Cmd+S (Mac) / Ctrl+S (Windows/Linux)');
                console.log('‚úÖ Both shortcuts should trigger saveManually() function');
                
                // Test undo shortcut
                console.log('‚Ü©Ô∏è Undo shortcut: Cmd+Y (Mac) / Ctrl+Y (Windows/Linux)');
                console.log('‚úÖ Shortcut should trigger undo() function');
                
                // Test other shortcuts
                console.log('‚å®Ô∏è Other shortcuts:');
                console.log('   - Enter: Add new row');
                console.log('   - Ctrl+D: Delete selected row');
                console.log('   - Arrow keys: Navigate between cells');
                
                console.log('‚úÖ Keyboard shortcuts test completed');
                return {
                    manualSave: ['Cmd+Z (Mac) / Ctrl+Z (Windows/Linux)', 'Cmd+S (Mac) / Ctrl+S (Windows/Linux)'],
                    undo: 'Cmd+Y (Mac) / Ctrl+Y (Windows/Linux)',
                    addRow: 'Enter',
                    deleteRow: 'Ctrl+D',
                    navigation: 'Arrow keys'
                };
                
            } catch (error) {
                console.error('‚ùå Error testing keyboard shortcuts:', error);
                return null;
            }
        };
        
        // Function to show keyboard shortcuts help
        window.showKeyboardShortcutsHelp = function() {
            try {
                const shortcuts = [
                    { key: 'Cmd+Z / Ctrl+Z', action: 'Sauvegarde manuelle', description: '√âquivalent au clic sur le bouton Sauvegarder' },
                    { key: 'Cmd+S / Ctrl+S', action: 'Sauvegarde manuelle', description: 'Alternative pour la sauvegarde manuelle' },
                    { key: 'Cmd+Y / Ctrl+Y', action: 'Annuler', description: 'Annuler la derni√®re action (√©quivalent au bouton Annuler)' },
                    { key: 'Enter', action: 'Nouvelle ligne', description: 'Ajouter une nouvelle ligne au tableau' },
                    { key: 'Ctrl+D', action: 'Supprimer ligne', description: 'Supprimer la ligne s√©lectionn√©e' },
                    { key: 'Fl√®ches', action: 'Navigation', description: 'Se d√©placer entre les cellules' }
                ];
                
                let helpText = '‚å®Ô∏è Raccourcis clavier disponibles:\n\n';
                shortcuts.forEach(shortcut => {
                    helpText += `üî∏ ${shortcut.key}: ${shortcut.action}\n   ${shortcut.description}\n\n`;
                });
                
                console.log(helpText);
                showMessage('Raccourcis clavier affich√©s dans la console', 'info');
                
                return shortcuts;
                
            } catch (error) {
                console.error('‚ùå Error showing keyboard shortcuts help:', error);
                return null;
            }
        };
        
        // Function to test mobile history bar functionality
        window.testMobileHistoryBar = function() {
            try {
                console.log('üì± Testing mobile history bar functionality...');
                
                // Check if we're on mobile
                const isMobileDevice = isMobile();
                console.log('üì± Is mobile device:', isMobileDevice);
                
                // Check required elements
                const toggleBtn = document.getElementById('history-toggle-btn');
                const historyBarContainer = document.getElementById('history-bar-container');
                const toggleIcon = document.getElementById('history-toggle-icon');
                
                console.log('üîç Elements found:');
                console.log('  - Toggle button:', !!toggleBtn);
                console.log('  - History bar container:', !!historyBarContainer);
                console.log('  - Toggle icon:', !!toggleIcon);
                
                if (toggleBtn && historyBarContainer && toggleIcon) {
                    // Test current state
                    const isVisible = !historyBarContainer.classList.contains('hidden') && 
                                    historyBarContainer.style.display !== 'none' && 
                                    historyBarContainer.offsetHeight > 0;
                    
                    console.log('üìä Current state:', isVisible ? 'Visible' : 'Hidden');
                    console.log('üîç CSS classes:', historyBarContainer.className);
                    console.log('üîç Inline styles:', historyBarContainer.style.display);
                    console.log('üîç Offset height:', historyBarContainer.offsetHeight);
                    
                    // Test toggle functionality
                    console.log('üß™ Testing toggle function...');
                    toggleHistoryBarSimple();
                    
                    // Check new state after toggle
                    setTimeout(() => {
                        const newState = !historyBarContainer.classList.contains('hidden') && 
                                       historyBarContainer.style.display !== 'none' && 
                                       historyBarContainer.offsetHeight > 0;
                        
                        console.log('üìä New state after toggle:', newState ? 'Visible' : 'Hidden');
                        console.log('‚úÖ Toggle test completed');
                    }, 100);
                    
                } else {
                    console.error('‚ùå Required elements not found for testing');
                }
                
                return {
                    isMobile: isMobileDevice,
                    elementsFound: {
                        toggleBtn: !!toggleBtn,
                        historyBarContainer: !!historyBarContainer,
                        toggleIcon: !!toggleIcon
                    }
                };
                
            } catch (error) {
                console.error('‚ùå Error testing mobile history bar:', error);
                return null;
            }
        };
        
        // Fonction utilitaire pour afficher les informations d√©taill√©es du stockage
        window.showStorageInfo = async function() {
            try {
                const capacityInfo = await checkStorageCapacity();
                const info = `
üìä INFORMATIONS D√âTAILL√âES DU STOCKAGE :

üî¢ Nombre de snapshots : ${capacityInfo.count}
üíæ Espace utilis√© : ${(capacityInfo.currentSize / 1024 / 1024).toFixed(2)} MB
üì¶ Capacit√© totale : ${(capacityInfo.maxSize / 1024 / 1024).toFixed(0)} MB
üìà Pourcentage utilis√© : ${capacityInfo.usagePercentage.toFixed(1)}%

${capacityInfo.needsCleanup ? 
    `‚ö†Ô∏è NETTOYAGE RECOMMAND√â : Garder ${capacityInfo.target} snapshots pour lib√©rer de l'espace` : 
    `‚úÖ Stockage en bon √©tat - Aucun nettoyage n√©cessaire`
}

üßπ Fonctions disponibles :
- window.forceStorageCleanup() : Nettoyage manuel
- window.monitorStorageHealth() : V√©rification de sant√©
- window.checkStorageCapacity() : V√©rification de capacit√©
                `;
                
                console.log(info);
                if (typeof showMessage === 'function') {
                    showMessage('üìä Informations du stockage affich√©es dans la console', 'info');
                }
                
            } catch (error) {
                console.error('‚ùå Error showing storage info:', error);
            }
        };
        window.enableTableEditing = enableTableEditing;
        window.updateHistoryNavigation = updateHistoryNavigation;
        window.updateSnapshotBanner = updateSnapshotBanner;
        window.updateHistoryDateButton = updateHistoryDateButton;
        window.fetchInitialData = fetchInitialData;
        window.loadTableData = loadTableData;
        window.showMessage = showMessage;
        window.closeImageViewer = closeImageViewer;
        window.nextImage = nextImage;
        window.previousImage = previousImage;
        window.deleteImage = deleteImage;
        window.deleteAllImagesForPatient = deleteAllImagesForPatient;
        window.syncPendingImages = syncPendingImages;
        window.loadImagesFromSupabase = loadImagesFromSupabase;
        window.updateAllImageColumnIcons = updateAllImageColumnIcons;

        // Fonction pour ouvrir la galerie simple
        function openSimpleGallery() {
            window.open('simple-gallery.html', '_blank', 'width=1200,height=800,scrollbars=yes,resizable=yes');
        }
        
        // Exposer la fonction globalement
        window.openSimpleGallery = openSimpleGallery;
        window.setupMobileViewport = setupMobileViewport;
        window.setupExtendedKeyboardShortcuts = setupExtendedKeyboardShortcuts;
        window.initializeApp = initializeApp;
        window.adaptStatusDisplay = adaptStatusDisplay;
        window.getCurrentStatusType = getCurrentStatusType;
        window.applyDotColor = applyDotColor;

        // Raccourcis clavier √©tendus

        
        function setupMobileViewport() {
            // G√©rer la hauteur dynamique du viewport sur mobile
            function updateViewportHeight() {
                if (window.innerWidth <= 768) {
                    const vh = window.innerHeight * 0.01;
                    document.documentElement.style.setProperty('--vh', `${vh}px`);
                    
                    // Ajuster la hauteur du conteneur principal
                    const tableContainer = document.getElementById('table-container');
                    if (tableContainer) {
                        tableContainer.style.height = `${window.innerHeight}px`;
                        tableContainer.style.minHeight = `${window.innerHeight}px`;
                    }
                    
                    // Ajuster la position du bouton FAB pour √©viter la barre de navigation
                    const fabButton = document.getElementById('fab-add');
                    if (fabButton) {
                        const bottomOffset = Math.max(16, window.innerHeight - window.visualViewport.height + 16);
                        fabButton.style.bottom = `${bottomOffset}px`;
                        
                        // Sur mobile, positionner le bouton plus discr√®tement
                        if (window.innerWidth <= 768) {
                            fabButton.style.right = '12px';
                            fabButton.style.bottom = `${Math.max(12, bottomOffset - 4)}px`;
                        }
                    }
                }
            }
            
            // Mettre √† jour lors du redimensionnement
            window.addEventListener('resize', updateViewportHeight);
            window.addEventListener('orientationchange', updateViewportHeight);
            
            // Mettre √† jour lors du changement de la barre de navigation mobile
            if ('visualViewport' in window) {
                window.visualViewport.addEventListener('resize', updateViewportHeight);
            }
            
            // Mise √† jour initiale
            updateViewportHeight();
            
            // Mettre √† jour p√©riodiquement pour s'assurer de la synchronisation
            setInterval(updateViewportHeight, 1000);
        }
        
        function setupExtendedKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Seulement appliquer les raccourcis quand pas dans les champs de formulaire
                const active = document.activeElement;
                const inFormField = active && (
                    active.tagName === 'INPUT' || 
                    active.tagName === 'TEXTAREA' || 
                    active.tagName === 'SELECT' || 
                    active.contentEditable === 'true'
                );

                // Ignorer les raccourcis si dans les champs de formulaire
                if (inFormField) return;

                // G: Ouvrir galerie
                if (!e.ctrlKey && !e.metaKey && !e.altKey && (e.key === 'g' || e.key === 'G')) {
                    e.preventDefault();
                    openSimpleGallery();
                    return;
                }

                // N: Ajouter nouvelle ligne
                if (!e.ctrlKey && !e.metaKey && !e.altKey && (e.key === 'n' || e.key === 'N')) {
                    e.preventDefault();
                    if (typeof addRow === 'function') {
                        addRow();
                    }
                    return;
                }

                // Supprimer: Supprimer lignes s√©lectionn√©es
                if (e.key === 'Delete') {
                    e.preventDefault();
                    
                    // Emp√™cher la suppression dans les snapshots
                    if (snapshotMode === 'snapshot') {
                        showMessage('Impossible de supprimer des lignes dans un snapshot. Retournez aux donn√©es en direct pour modifier le tableau.', 'warning');
                        return;
                    }
                    
                    // R√©cup√©rer les lignes s√©lectionn√©es
                    const selectedRows = Array.from(document.querySelectorAll('#table-body tr.selected-row'));
                    if (selectedRows.length > 0) {
                        promptKeyConfirm(`Supprimer ${selectedRows.length} ligne(s) ?`, () => deleteRows(selectedRows));
                    } else {
                        // Si aucune ligne s√©lectionn√©e, essayer de supprimer la ligne active
                        const activeRow = document.querySelector('#table-body tr:focus') || document.querySelector('#table-body tr.selected-row');
                        if (activeRow) {
                            promptKeyConfirm('Appuyez sur Entr√©e pour supprimer cette ligne, √âchap pour annuler.', () => deleteRows([activeRow]));
                        }
                    }
                    return;
                }

                // √âchap: Fermer modales
                if (e.key === 'Escape') {
                    const confirmationModal = document.getElementById('confirmation-modal');
                    if (confirmationModal && !confirmationModal.classList.contains('hidden')) {
                        confirmationModal.classList.add('hidden');
                        return;
                    }
                }
            });
        }

        // Initialiser les raccourcis clavier √©tendus
        document.addEventListener('DOMContentLoaded', function() {
            setupExtendedKeyboardShortcuts();
            
            // Adapter l'affichage du statut selon la taille d'√©cran initiale
            setTimeout(() => {
                adaptStatusDisplay();
            }, 100);
            
            // Setup mobile viewport management
            setupMobileViewport();
        });

        // Initialize when DOM is ready
        window.addEventListener('load', initializeApp);
    </script>
</body>
</html>