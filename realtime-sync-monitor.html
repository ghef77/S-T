<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîç Monitoring Synchronisation Temps R√©el</title>
    <style>
        body { 
            font-family: system-ui, -apple-system, sans-serif; 
            margin: 20px; 
            background: #f5f5f5; 
        }
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .card { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 8px; padding: 15px; }
        .card.success { border-color: #16a34a; background: #dcfce7; }
        .card.warning { border-color: #eab308; background: #fefce8; }
        .card.error { border-color: #dc2626; background: #fef2f2; }
        .button { 
            background: #16a34a; 
            color: white; 
            border: none; 
            padding: 10px 20px; 
            border-radius: 6px; 
            cursor: pointer; 
            margin: 5px;
            font-size: 14px;
        }
        .button:hover { background: #15803d; }
        .button.danger { background: #dc2626; }
        .button.danger:hover { background: #b91c1c; }
        .metrics { 
            background: #1f2937; 
            color: #f3f4f6; 
            padding: 15px; 
            border-radius: 6px; 
            margin: 10px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.4;
            max-height: 400px;
            overflow-y: auto;
        }
        .status-indicator { 
            display: inline-block; 
            width: 12px; 
            height: 12px; 
            border-radius: 50%; 
            margin-right: 8px; 
        }
        .status-online { background: #16a34a; }
        .status-warning { background: #eab308; }
        .status-offline { background: #dc2626; }
        .chart { height: 200px; background: #f3f4f6; border-radius: 4px; margin: 10px 0; position: relative; overflow: hidden; }
        .chart-line { position: absolute; bottom: 0; background: #16a34a; transition: all 0.3s; width: 2px; }
        table { width: 100%; border-collapse: collapse; font-size: 13px; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #e5e7eb; }
        th { background: #f9fafb; font-weight: 600; }
        .timeline { max-height: 300px; overflow-y: auto; }
        .event { padding: 8px; margin: 4px 0; border-radius: 4px; font-size: 12px; }
        .event.insert { background: #dcfce7; border-left: 4px solid #16a34a; }
        .event.update { background: #fefce8; border-left: 4px solid #eab308; }
        .event.delete { background: #fef2f2; border-left: 4px solid #dc2626; }
        .event.error { background: #fdf2f8; border-left: 4px solid #ec4899; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Monitoring Synchronisation Temps R√©el</h1>
        
        <div class="grid">
            <!-- √âtat de la connexion -->
            <div class="card" id="connectionCard">
                <h3><span class="status-indicator status-offline" id="connectionStatus"></span>√âtat de la Connexion</h3>
                <div id="connectionInfo">Initialisation...</div>
                <button class="button" onclick="checkConnection()">V√©rifier Connexion</button>
                <button class="button danger" onclick="forceReconnect()">Reconnecter</button>
            </div>
            
            <!-- M√©triques temps r√©el -->
            <div class="card">
                <h3>üìä M√©triques Temps R√©el</h3>
                <div id="metricsInfo">
                    <strong>√âv√©nements re√ßus:</strong> <span id="eventCount">0</span><br>
                    <strong>Derni√®re activit√©:</strong> <span id="lastActivity">Aucune</span><br>
                    <strong>Latence moyenne:</strong> <span id="avgLatency">-</span><br>
                    <strong>Erreurs:</strong> <span id="errorCount">0</span>
                </div>
            </div>
            
            <!-- Performance -->
            <div class="card">
                <h3>‚ö° Performance</h3>
                <div class="chart" id="performanceChart"></div>
                <div id="performanceInfo">
                    <strong>D√©bit:</strong> <span id="throughput">0</span> √©v√©nements/min<br>
                    <strong>Temps de r√©ponse:</strong> <span id="responseTime">-</span>
                </div>
            </div>
        </div>
        
        <!-- Timeline des √©v√©nements -->
        <div class="card">
            <h3>üìÖ Timeline des √âv√©nements Temps R√©el</h3>
            <div class="timeline" id="eventTimeline">
                <div class="event">Monitoring d√©marr√©...</div>
            </div>
            <button class="button" onclick="clearTimeline()">Vider Timeline</button>
            <button class="button" onclick="exportLogs()">Exporter Logs</button>
        </div>
        
        <!-- Diagnostic avanc√© -->
        <div class="card">
            <h3>üîß Diagnostic Avanc√©</h3>
            <div class="metrics" id="diagnosticOutput">Pr√™t pour diagnostic...</div>
            <button class="button" onclick="runAdvancedDiagnostic()">Diagnostic Complet</button>
            <button class="button" onclick="stressTest()">Test de Stress</button>
            <button class="button" onclick="networkTest()">Test R√©seau</button>
        </div>
        
        <!-- Table de surveillance -->
        <div class="card">
            <h3>üìã √âtat des Composants</h3>
            <table>
                <thead>
                    <tr>
                        <th>Composant</th>
                        <th>√âtat</th>
                        <th>Derni√®re V√©rification</th>
                        <th>D√©tails</th>
                    </tr>
                </thead>
                <tbody id="componentsTable">
                    <tr>
                        <td>Client Supabase</td>
                        <td><span class="status-indicator status-offline"></span>V√©rification...</td>
                        <td>-</td>
                        <td>-</td>
                    </tr>
                    <tr>
                        <td>Subscription Realtime</td>
                        <td><span class="status-indicator status-offline"></span>V√©rification...</td>
                        <td>-</td>
                        <td>-</td>
                    </tr>
                    <tr>
                        <td>Flags de Blocage</td>
                        <td><span class="status-indicator status-offline"></span>V√©rification...</td>
                        <td>-</td>
                        <td>-</td>
                    </tr>
                    <tr>
                        <td>Connectivit√© R√©seau</td>
                        <td><span class="status-indicator status-offline"></span>V√©rification...</td>
                        <td>-</td>
                        <td>-</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Scripts de monitoring -->
    <script type="module">
        // Import Supabase (m√™me m√©thode que votre syst√®me)
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';
        
        // Configuration
        const supabaseConfig = {
            supabaseUrl: 'https://fiecugxopjxzqfdnaqsu.supabase.co',
            supabaseAnonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpZWN1Z3hvcGp4enFmZG5hcXN1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQ1MDU2NTcsImV4cCI6MjA3MDA4MTY1N30.xd9Thasg4r8Nrwxx5nFwyGB_ufPIvok4XB-78dilpsw'
        };
        
        // Variables globales de monitoring
        window.monitoringData = {
            supabase: null,
            subscription: null,
            eventCount: 0,
            errorCount: 0,
            lastActivity: null,
            latencyTimes: [],
            events: [],
            startTime: Date.now()
        };
        
        // Initialisation du monitoring
        async function initMonitoring() {
            try {
                // Cr√©er le client Supabase
                window.monitoringData.supabase = createClient(supabaseConfig.supabaseUrl, supabaseConfig.supabaseAnonKey);
                
                // Mise √† jour de l'√©tat de connexion
                updateConnectionStatus('online', 'Client Supabase initialis√©');
                
                // D√©marrer la surveillance
                await startRealtimeMonitoring();
                await updateComponentsStatus();
                
                // D√©marrer les v√©rifications p√©riodiques
                setInterval(periodicCheck, 30000); // Toutes les 30 secondes
                setInterval(updateMetrics, 5000); // Toutes les 5 secondes
                
            } catch (error) {
                console.error('Erreur initialisation monitoring:', error);
                updateConnectionStatus('error', 'Erreur: ' + error.message);
                logEvent('error', 'Erreur initialisation: ' + error.message);
            }
        }
        
        // D√©marrer la surveillance realtime
        async function startRealtimeMonitoring() {
            try {
                const channelName = `monitoring-${Date.now()}`;
                
                window.monitoringData.subscription = window.monitoringData.supabase
                    .channel(channelName)
                    .on('postgres_changes', {
                        event: 'INSERT',
                        schema: 'public',
                        table: 'staffTable'
                    }, (payload) => {
                        const latency = Date.now() - new Date(payload.commit_timestamp).getTime();
                        handleRealtimeEvent('INSERT', payload, latency);
                    })
                    .on('postgres_changes', {
                        event: 'UPDATE',
                        schema: 'public',
                        table: 'staffTable'
                    }, (payload) => {
                        const latency = Date.now() - new Date(payload.commit_timestamp).getTime();
                        handleRealtimeEvent('UPDATE', payload, latency);
                    })
                    .on('postgres_changes', {
                        event: 'DELETE',
                        schema: 'public',
                        table: 'staffTable'
                    }, (payload) => {
                        const latency = Date.now() - new Date(payload.commit_timestamp).getTime();
                        handleRealtimeEvent('DELETE', payload, latency);
                    })
                    .subscribe((status, error) => {
                        logEvent('info', `Subscription status: ${status}`);
                        
                        if (status === 'SUBSCRIBED') {
                            updateConnectionStatus('online', `Monitoring actif (${channelName})`);
                        } else if (status === 'CHANNEL_ERROR') {
                            updateConnectionStatus('error', 'Erreur subscription: ' + (error?.message || 'Inconnue'));
                            window.monitoringData.errorCount++;
                        }
                    });
                    
            } catch (error) {
                console.error('Erreur monitoring realtime:', error);
                updateConnectionStatus('error', 'Erreur subscription: ' + error.message);
            }
        }
        
        // G√©rer les √©v√©nements realtime
        function handleRealtimeEvent(eventType, payload, latency) {
            window.monitoringData.eventCount++;
            window.monitoringData.lastActivity = new Date().toLocaleTimeString();
            window.monitoringData.latencyTimes.push(latency);
            
            // Garder seulement les 50 derni√®res latences
            if (window.monitoringData.latencyTimes.length > 50) {
                window.monitoringData.latencyTimes.shift();
            }
            
            // Log de l'√©v√©nement
            const eventInfo = {
                type: eventType,
                timestamp: new Date(),
                latency: latency,
                payload: payload,
                recordId: payload.new?.id || payload.old?.id || 'N/A'
            };
            
            window.monitoringData.events.push(eventInfo);
            logEvent(eventType.toLowerCase(), `${eventType} - ID: ${eventInfo.recordId} (${latency}ms)`);
            
            // Garder seulement les 100 derniers √©v√©nements
            if (window.monitoringData.events.length > 100) {
                window.monitoringData.events.shift();
            }
        }
        
        // Mettre √† jour les m√©triques
        function updateMetrics() {
            document.getElementById('eventCount').textContent = window.monitoringData.eventCount;
            document.getElementById('lastActivity').textContent = window.monitoringData.lastActivity || 'Aucune';
            document.getElementById('errorCount').textContent = window.monitoringData.errorCount;
            
            // Calculer la latence moyenne
            const latencies = window.monitoringData.latencyTimes;
            if (latencies.length > 0) {
                const avgLatency = latencies.reduce((a, b) => a + b, 0) / latencies.length;
                document.getElementById('avgLatency').textContent = Math.round(avgLatency) + 'ms';
            }
            
            // Calculer le d√©bit (√©v√©nements par minute)
            const elapsedMinutes = (Date.now() - window.monitoringData.startTime) / 60000;
            const throughput = elapsedMinutes > 0 ? Math.round(window.monitoringData.eventCount / elapsedMinutes) : 0;
            document.getElementById('throughput').textContent = throughput;
            
            // Temps de r√©ponse du dernier √©v√©nement
            if (latencies.length > 0) {
                document.getElementById('responseTime').textContent = latencies[latencies.length - 1] + 'ms';
            }
            
            // Mettre √† jour le graphique de performance
            updatePerformanceChart();
        }
        
        // Mettre √† jour le graphique de performance
        function updatePerformanceChart() {
            const chart = document.getElementById('performanceChart');
            const latencies = window.monitoringData.latencyTimes.slice(-20); // 20 derni√®res valeurs
            
            chart.innerHTML = '';
            const maxLatency = Math.max(...latencies, 100);
            
            latencies.forEach((latency, index) => {
                const bar = document.createElement('div');
                bar.className = 'chart-line';
                bar.style.height = (latency / maxLatency * 100) + '%';
                bar.style.left = (index / latencies.length * 100) + '%';
                bar.style.backgroundColor = latency > 1000 ? '#dc2626' : latency > 500 ? '#eab308' : '#16a34a';
                chart.appendChild(bar);
            });
        }
        
        // Log des √©v√©nements dans la timeline
        function logEvent(type, message) {
            const timeline = document.getElementById('eventTimeline');
            const event = document.createElement('div');
            event.className = `event ${type}`;
            event.innerHTML = `<strong>${new Date().toLocaleTimeString()}</strong> ${message}`;
            timeline.insertBefore(event, timeline.firstChild);
            
            // Garder seulement les 50 derniers √©v√©nements visibles
            while (timeline.children.length > 50) {
                timeline.removeChild(timeline.lastChild);
            }
        }
        
        // Mettre √† jour l'√©tat de connexion
        function updateConnectionStatus(status, message) {
            const statusElement = document.getElementById('connectionStatus');
            const infoElement = document.getElementById('connectionInfo');
            const cardElement = document.getElementById('connectionCard');
            
            statusElement.className = `status-indicator status-${status}`;
            infoElement.textContent = message;
            cardElement.className = `card ${status === 'online' ? 'success' : status === 'warning' ? 'warning' : 'error'}`;
        }
        
        // V√©rification p√©riodique
        async function periodicCheck() {
            try {
                // V√©rifier la connexion Supabase
                if (window.monitoringData.supabase) {
                    const { data, error } = await window.monitoringData.supabase.auth.getSession();
                    if (error && error.message.includes('Invalid')) {
                        logEvent('error', 'Erreur authentification: ' + error.message);
                        window.monitoringData.errorCount++;
                    }
                }
                
                // V√©rifier l'√©tat de la subscription
                if (window.monitoringData.subscription) {
                    const state = window.monitoringData.subscription.state;
                    if (state !== 'joined') {
                        logEvent('warning', `Subscription state: ${state}`);
                        updateConnectionStatus('warning', `Subscription: ${state}`);
                    }
                }
                
                await updateComponentsStatus();
                
            } catch (error) {
                console.error('Erreur v√©rification p√©riodique:', error);
                logEvent('error', 'Erreur v√©rification: ' + error.message);
            }
        }
        
        // Mettre √† jour le statut des composants
        async function updateComponentsStatus() {
            const table = document.getElementById('componentsTable');
            const rows = table.querySelectorAll('tr');
            
            // Client Supabase
            const supabaseStatus = window.monitoringData.supabase ? 'online' : 'offline';
            updateComponentRow(rows[0], supabaseStatus, 'Client initialis√© et fonctionnel');
            
            // Subscription Realtime
            const subscriptionStatus = window.monitoringData.subscription && 
                window.monitoringData.subscription.state === 'joined' ? 'online' : 'offline';
            updateComponentRow(rows[1], subscriptionStatus, 
                window.monitoringData.subscription ? `State: ${window.monitoringData.subscription.state}` : 'Non initialis√©e');
            
            // Flags de Blocage
            const hasBlocks = window.isLocalSaveInProgress || window.isExcelSaveInProgress;
            updateComponentRow(rows[2], hasBlocks ? 'warning' : 'online', 
                hasBlocks ? 'Flags actifs' : 'Aucun blocage');
            
            // Connectivit√© R√©seau
            try {
                const response = await fetch('https://httpbin.org/json', { 
                    method: 'GET', 
                    signal: AbortSignal.timeout(5000) 
                });
                updateComponentRow(rows[3], response.ok ? 'online' : 'offline', 
                    response.ok ? 'Connexion stable' : 'Probl√®me r√©seau');
            } catch (error) {
                updateComponentRow(rows[3], 'offline', 'Erreur r√©seau: ' + error.message);
            }
        }
        
        // Mettre √† jour une ligne du tableau des composants
        function updateComponentRow(row, status, details) {
            const cells = row.querySelectorAll('td');
            const statusIndicator = cells[1].querySelector('.status-indicator');
            
            statusIndicator.className = `status-indicator status-${status}`;
            cells[1].innerHTML = `<span class="status-indicator status-${status}"></span>${status === 'online' ? 'OK' : status === 'warning' ? 'Attention' : 'Erreur'}`;
            cells[2].textContent = new Date().toLocaleTimeString();
            cells[3].textContent = details;
        }
        
        // Fonctions globales pour les boutons
        window.checkConnection = async function() {
            logEvent('info', 'V√©rification manuelle de la connexion...');
            await periodicCheck();
            await updateComponentsStatus();
        };
        
        window.forceReconnect = async function() {
            logEvent('info', 'Reconnexion forc√©e...');
            try {
                if (window.monitoringData.subscription) {
                    await window.monitoringData.supabase.removeChannel(window.monitoringData.subscription);
                    window.monitoringData.subscription = null;
                }
                await startRealtimeMonitoring();
                logEvent('info', 'Reconnexion r√©ussie');
            } catch (error) {
                logEvent('error', 'Erreur reconnexion: ' + error.message);
            }
        };
        
        window.clearTimeline = function() {
            document.getElementById('eventTimeline').innerHTML = '<div class="event">Timeline vid√©e...</div>';
        };
        
        window.exportLogs = function() {
            const logs = {
                timestamp: new Date().toISOString(),
                metrics: window.monitoringData,
                events: window.monitoringData.events
            };
            
            const blob = new Blob([JSON.stringify(logs, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `realtime-sync-logs-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            logEvent('info', 'Logs export√©s');
        };
        
        window.runAdvancedDiagnostic = async function() {
            const output = document.getElementById('diagnosticOutput');
            output.textContent = 'Diagnostic avanc√© en cours...\n';
            
            try {
                // Test de latence r√©seau
                output.textContent += '\nüåê Test de latence r√©seau...\n';
                const start = performance.now();
                await fetch('https://httpbin.org/delay/0.1');
                const networkLatency = performance.now() - start;
                output.textContent += `  Latence r√©seau: ${Math.round(networkLatency)}ms\n`;
                
                // Test de la base de donn√©es
                output.textContent += '\nüóÑÔ∏è Test de la base de donn√©es...\n';
                const dbStart = performance.now();
                const { data, error } = await window.monitoringData.supabase
                    .from('staffTable')
                    .select('count')
                    .limit(1);
                const dbLatency = performance.now() - dbStart;
                
                if (error) {
                    output.textContent += `  ‚ùå Erreur DB: ${error.message}\n`;
                } else {
                    output.textContent += `  ‚úÖ DB Latence: ${Math.round(dbLatency)}ms\n`;
                }
                
                // Analyse des m√©triques
                output.textContent += '\nüìä Analyse des m√©triques:\n';
                const avgLatency = window.monitoringData.latencyTimes.length > 0 ? 
                    window.monitoringData.latencyTimes.reduce((a, b) => a + b, 0) / window.monitoringData.latencyTimes.length : 0;
                    
                output.textContent += `  Latence moyenne realtime: ${Math.round(avgLatency)}ms\n`;
                output.textContent += `  √âv√©nements trait√©s: ${window.monitoringData.eventCount}\n`;
                output.textContent += `  Taux d'erreur: ${((window.monitoringData.errorCount / Math.max(window.monitoringData.eventCount, 1)) * 100).toFixed(2)}%\n`;
                
                // Recommandations
                output.textContent += '\nüí° Recommandations:\n';
                if (avgLatency > 2000) {
                    output.textContent += '  ‚ö†Ô∏è Latence √©lev√©e - V√©rifier la connexion r√©seau\n';
                }
                if (window.monitoringData.errorCount > 0) {
                    output.textContent += '  ‚ö†Ô∏è Erreurs d√©tect√©es - V√©rifier les logs\n';
                }
                if (avgLatency < 1000 && window.monitoringData.errorCount === 0) {
                    output.textContent += '  ‚úÖ Syst√®me performant et stable\n';
                }
                
            } catch (error) {
                output.textContent += `\n‚ùå Erreur diagnostic: ${error.message}\n`;
            }
        };
        
        window.stressTest = async function() {
            logEvent('info', 'Test de stress d√©marr√©...');
            const output = document.getElementById('diagnosticOutput');
            output.textContent = 'Test de stress en cours...\n';
            
            // Simuler de multiples connexions
            for (let i = 0; i < 5; i++) {
                try {
                    const testChannel = window.monitoringData.supabase
                        .channel(`stress-test-${i}`)
                        .on('postgres_changes', { event: '*', schema: 'public', table: 'staffTable' }, () => {})
                        .subscribe();
                        
                    setTimeout(() => {
                        window.monitoringData.supabase.removeChannel(testChannel);
                    }, 10000);
                    
                    output.textContent += `  Canal ${i + 1}/5 cr√©√©\n`;
                    await new Promise(resolve => setTimeout(resolve, 1000));
                } catch (error) {
                    output.textContent += `  ‚ùå Erreur canal ${i + 1}: ${error.message}\n`;
                }
            }
            
            output.textContent += '\n‚úÖ Test de stress termin√©\n';
            logEvent('info', 'Test de stress termin√©');
        };
        
        window.networkTest = async function() {
            const output = document.getElementById('diagnosticOutput');
            output.textContent = 'Test r√©seau en cours...\n';
            
            const endpoints = [
                'https://httpbin.org/json',
                'https://fiecugxopjxzqfdnaqsu.supabase.co',
                'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/package.json'
            ];
            
            for (const endpoint of endpoints) {
                try {
                    const start = performance.now();
                    const response = await fetch(endpoint, { signal: AbortSignal.timeout(5000) });
                    const time = performance.now() - start;
                    
                    output.textContent += `  ‚úÖ ${endpoint}: ${Math.round(time)}ms\n`;
                } catch (error) {
                    output.textContent += `  ‚ùå ${endpoint}: ${error.message}\n`;
                }
            }
            
            output.textContent += '\n‚úÖ Test r√©seau termin√©\n';
        };
        
        // Initialiser au chargement
        initMonitoring();
    </script>
</body>
</html>