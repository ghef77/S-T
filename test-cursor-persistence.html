<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Persistance du Curseur - Pas de Disparition</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-cell { 
            border: 2px solid #007bff; 
            padding: 15px; 
            margin: 20px; 
            min-height: 60px;
            background: #f8f9fa;
            font-size: 16px;
        }
        .log { 
            background: #f8f9fa; 
            padding: 15px; 
            margin: 20px; 
            border-radius: 8px;
            font-family: monospace;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
        }
        .success { color: #28a745; font-weight: bold; }
        .warning { color: #ffc107; font-weight: bold; }
        .error { color: #dc3545; font-weight: bold; }
        .info { color: #17a2b8; font-weight: bold; }
        .saving { color: #6f42c1; font-weight: bold; }
        button { 
            padding: 12px 20px; 
            margin: 8px; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }
        .btn-primary { background-color: #007bff; color: white; }
        .btn-success { background-color: #28a745; color: white; }
        .instructions {
            background: #e3f2fd;
            padding: 15px;
            margin: 20px;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }
        .status {
            background: #fff3cd;
            padding: 10px;
            margin: 10px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
        }
        .highlight {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 10px;
            margin: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>üß™ Test Persistance du Curseur - Pas de Disparition</h1>
    
    <div class="instructions">
        <h3>üìã Test de la Persistance du Curseur</h3>
        <p><strong>Objectif :</strong> V√©rifier que le curseur reste visible et fonctionnel apr√®s la restauration, sans dispara√Ætre.</p>
        <ol>
            <li>Cliquez dans une cellule et placez le curseur √† une position sp√©cifique</li>
            <li>Cliquez sur "Sauvegarde Automatique" pour simuler la sauvegarde</li>
            <li>V√©rifiez que la cellule et le curseur sont restaur√©s</li>
            <li>V√©rifiez que le curseur reste visible et ne dispara√Æt pas</li>
            <li>Tapez du texte pour confirmer que le curseur fonctionne</li>
        </ol>
    </div>
    
    <div class="status" id="status">
        <strong>√âtat :</strong> Pr√™t pour le test de persistance du curseur
    </div>
    
    <div class="highlight">
        <h4>üéØ Test Principal :</h4>
        <p>1. <strong>Modifiez</strong> une cellule (tapez du texte, placez le curseur au milieu)</p>
        <p>2. <strong>Cliquez</strong> sur "Sauvegarde Automatique"</p>
        <p>3. <strong>V√©rifiez</strong> que la cellule et le curseur sont restaur√©s</p>
        <p>4. <strong>Confirmez</strong> que le curseur reste visible et fonctionnel</p>
        <p>5. <strong>Tapez du texte</strong> pour tester la fonctionnalit√© du curseur</p>
    </div>
    
    <div class="test-cell" contenteditable="true" data-label="Nom" data-original-value="Cellule Nom - Test">
        Cellule Nom - Test
    </div>
    
    <div class="test-cell" contenteditable="true" data-label="Pr√©nom" data-original-value="Cellule Pr√©nom - Test">
        Cellule Pr√©nom - Test
    </div>
    
    <div class="test-cell" contenteditable="true" data-label="Email" data-original-value="Cellule Email - Test">
        Cellule Email - Test
    </div>
    
    <div style="margin: 20px;">
        <button onclick="testAutosave()" class="btn-primary">üíæ Sauvegarde Automatique</button>
        <button onclick="testCursorPersistence()" class="btn-success">üß™ Test Persistance Curseur</button>
        <button onclick="clearLog()" class="btn-success">üóëÔ∏è Effacer Log</button>
        <button onclick="showCapturedState()" class="btn-success">üìä √âtat Captur√©</button>
    </div>
    
    <div class="log" id="log">
        <div class="info">üöÄ Test de persistance du curseur initialis√©</div>
    </div>
    
    <script>
        // ‚úÖ SYST√àME DE CAPTURE ET RESTAURATION DU FOCUS (AVEC PERSISTANCE)
        let capturedFocusState = null;
        let testResults = {
            captures: 0,
            restorations: 0,
            successes: 0,
            cursorPersistence: 0
        };
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = type;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '<div class="info">üöÄ Test de persistance du curseur initialis√©</div>';
        }
        
        function updateStatus(message) {
            document.getElementById('status').innerHTML = `<strong>√âtat :</strong> ${message}`;
        }
        
        // ‚úÖ FONCTION DE CAPTURE DU FOCUS (comme dans index.html)
        function captureFocusBeforeSave() {
            const activeElement = document.activeElement;
            
            if (activeElement && activeElement.tagName === 'TD' && activeElement.contentEditable === 'true') {
                capturedFocusState = {
                    element: activeElement,
                    position: getCaretOffsetWithin(activeElement),
                    timestamp: Date.now(),
                    rowIndex: 0, // Pour le test
                    colLabel: activeElement.getAttribute('data-label') || ''
                };
                
                log(`üìù Cellule s√©lectionn√©e captur√©e avant sauvegarde: ${capturedFocusState.colLabel}, position ${capturedFocusState.position}`, 'info');
                testResults.captures++;
                updateStatus(`Captures: ${testResults.captures}, Restaurations: ${testResults.restorations}, Succ√®s: ${testResults.successes}, Persistance: ${testResults.cursorPersistence}`);
                return true;
            } else {
                log('‚ö†Ô∏è Aucune cellule active trouv√©e pour capture avant sauvegarde', 'warning');
                return false;
            }
        }
        
        // ‚úÖ FONCTION DE RESTAURATION DU FOCUS (AVEC PERSISTANCE)
        function restoreFocusAfterSave() {
            if (!capturedFocusState || !capturedFocusState.element) {
                log('‚ö†Ô∏è Aucune cellule s√©lectionn√©e √† restaurer apr√®s sauvegarde', 'warning');
                return false;
            }
            
            log(`üîÑ Restauration de la cellule s√©lectionn√©e apr√®s sauvegarde: ${capturedFocusState.colLabel}`, 'info');
            testResults.restorations++;
            
            try {
                // Restaurer le focus sur la cellule
                capturedFocusState.element.focus();
                log(`‚úÖ Focus restaur√© sur la cellule: ${capturedFocusState.colLabel}`, 'success');
                
                // Restaurer la position du curseur
                if (capturedFocusState.position !== null && capturedFocusState.position !== undefined) {
                    try {
                        setCaretAt(capturedFocusState.element, capturedFocusState.position);
                        log(`‚úÖ Curseur restaur√© √† la position ${capturedFocusState.position} dans ${capturedFocusState.colLabel}`, 'success');
                        
                        // V√©rifier que la restauration a fonctionn√©
                        const currentPosition = getCaretOffsetWithin(capturedFocusState.element);
                        if (currentPosition === capturedFocusState.position) {
                            log('‚úÖ V√©rification: Curseur bien restaur√© √† la bonne position', 'success');
                            testResults.successes++;
                            
                            // ‚úÖ V√âRIFICATION DE PERSISTANCE: Attendre et v√©rifier que le curseur est toujours l√†
                            setTimeout(() => {
                                const persistentPosition = getCaretOffsetWithin(capturedFocusState.element);
                                if (persistentPosition === capturedFocusState.position) {
                                    log('‚úÖ PERSISTANCE: Curseur toujours visible apr√®s 500ms', 'success');
                                    testResults.cursorPersistence++;
                                    updateStatus(`Test r√©ussi! Captures: ${testResults.captures}, Restaurations: ${testResults.restorations}, Succ√®s: ${testResults.successes}, Persistance: ${testResults.cursorPersistence}`);
                                } else {
                                    log('‚ö†Ô∏è PROBL√àME: Curseur a disparu apr√®s 500ms', 'warning');
                                }
                            }, 500);
                            
                            return true;
                        } else {
                            log(`‚ö†Ô∏è V√©rification √©chou√©e: position ${currentPosition} au lieu de ${capturedFocusState.position}`, 'warning');
                            return false;
                        }
                        
                    } catch (caretError) {
                        log(`‚ö†Ô∏è Erreur lors de la restauration du curseur: ${caretError.message}`, 'warning');
                        // Fallback: placer le curseur √† la fin
                        try {
                            setCaretAt(capturedFocusState.element, null);
                            log(`‚úÖ Curseur plac√© √† la fin (fallback) dans ${capturedFocusState.colLabel}`, 'success');
                            return true;
                        } catch (fallbackError) {
                            log(`‚ùå Erreur fallback: ${fallbackError.message}`, 'error');
                            return false;
                        }
                    }
                } else {
                    log(`‚ö†Ô∏è Position du curseur non disponible dans ${capturedFocusState.colLabel}, placement √† la fin`, 'warning');
                    // Placer le curseur √† la fin
                    try {
                        setCaretAt(capturedFocusState.element, null);
                        log(`‚úÖ Curseur plac√© √† la fin dans ${capturedFocusState.colLabel}`, 'success');
                        return true;
                    } catch (fallbackError) {
                        log(`‚ùå Erreur fallback: ${fallbackError.message}`, 'error');
                        return false;
                    }
                }
                
            } catch (error) {
                log(`‚ùå Erreur lors de la restauration de la cellule s√©lectionn√©e: ${error.message}`, 'error');
                return false;
            }
        }
        
        // ‚úÖ SIMULATION DE LA SAUVEGARDE AUTOMATIQUE
        async function testAutosave() {
            log('üß™ Test de sauvegarde automatique...', 'info');
            
            // ‚úÖ CORRECTION: Utiliser l'√©tat d√©j√† captur√© automatiquement
            if (!capturedFocusState) {
                log('‚ùå Test √©chou√©: Aucune cellule n\'a √©t√© modifi√©e et captur√©e', 'error');
                log('üí° Conseil: Modifiez d\'abord une cellule (tapez du texte, placez le curseur)', 'info');
                return;
            }
            
            log(`‚úÖ Cellule captur√©e trouv√©e: ${capturedFocusState.colLabel}`, 'success');
            
            // √âtape 2: Simuler la sauvegarde
            log('üíæ Sauvegarde automatique en cours...', 'saving');
            updateStatus('Sauvegarde en cours...');
            
            // Simuler le temps de sauvegarde
            await new Promise(resolve => setTimeout(resolve, 500));
            
            log('‚úÖ Sauvegarde automatique r√©ussie !', 'success');
            updateStatus('Sauvegarde r√©ussie, restauration en cours...');
            
            // √âtape 3: Restaurer la cellule s√©lectionn√©e apr√®s la sauvegarde
            setTimeout(() => {
                const success = restoreFocusAfterSave();
                if (success) {
                    log('üéâ Test de sauvegarde automatique R√âUSSI !', 'success');
                    updateStatus(`Test r√©ussi! Captures: ${testResults.captures}, Restaurations: ${testResults.restorations}, Succ√®s: ${testResults.successes}, Persistance: ${testResults.cursorPersistence}`);
                } else {
                    log('‚ùå Test de sauvegarde automatique √âCHOU√â', 'error');
                    updateStatus('Test √©chou√© - V√©rifiez les logs');
                }
            }, 100);
        }
        
        // ‚úÖ TEST SP√âCIAL: V√©rifier la persistance du curseur
        function testCursorPersistence() {
            if (!capturedFocusState || !capturedFocusState.element) {
                log('‚ùå Test de persistance √©chou√©: Aucune cellule captur√©e', 'error');
                return;
            }
            
            log('üß™ Test de persistance du curseur...', 'info');
            
            // V√©rifier la position actuelle
            const currentPosition = getCaretOffsetWithin(capturedFocusState.element);
            log(`üìä Position actuelle du curseur: ${currentPosition}`, 'info');
            
            // V√©rifier que le focus est toujours l√†
            if (document.activeElement === capturedFocusState.element) {
                log('‚úÖ Focus toujours actif sur la cellule', 'success');
            } else {
                log('‚ö†Ô∏è Focus perdu sur la cellule', 'warning');
            }
            
            // V√©rifier que le curseur est visible
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                log('‚úÖ Curseur visible et s√©lection active', 'success');
            } else {
                log('‚ö†Ô∏è Curseur non visible ou s√©lection perdue', 'warning');
            }
            
            // Test de frappe pour confirmer la fonctionnalit√©
            log('üí° Test de frappe pour confirmer la fonctionnalit√© du curseur...', 'info');
            capturedFocusState.element.focus();
            setCaretAt(capturedFocusState.element, capturedFocusState.position);
            
            updateStatus(`Test de persistance termin√© - V√©rifiez que le curseur est visible et fonctionnel`);
        }
        
        // Afficher l'√©tat captur√©
        function showCapturedState() {
            log('üìä √âtat de focus captur√©:', 'info');
            if (capturedFocusState) {
                log(`   Cellule: ${capturedFocusState.colLabel}`, 'info');
                log(`   Position: ${capturedFocusState.position}`, 'info');
                log(`   Timestamp: ${new Date(capturedFocusState.timestamp).toLocaleTimeString()}`, 'info');
                log(`   √âl√©ment: ${capturedFocusState.element.textContent.substring(0, 30)}...`, 'info');
            } else {
                log('   Aucun √©tat captur√©', 'info');
            }
        }
        
        // ‚úÖ FONCTIONS UTILITAIRES (simul√©es comme dans index.html)
        
        // Fonction pour obtenir la position du curseur
        function getCaretOffsetWithin(element) {
            if (!element || element.contentEditable !== 'true') {
                return 0;
            }
            
            try {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    
                    if (element.contains(range.startContainer)) {
                        const preCaretRange = range.cloneRange();
                        preCaretRange.selectNodeContents(element);
                        preCaretRange.setEnd(range.endContainer, range.endOffset);
                        const position = preCaretRange.toString().length;
                        return position;
                    }
                }
            } catch (error) {
                log(`‚ùå Erreur lors de la capture de la position: ${error.message}`, 'error');
            }
            
            return 0;
        }
        
        // Fonction pour placer le curseur √† une position sp√©cifique
        function setCaretAt(element, position) {
            if (!element || element.contentEditable !== 'true') {
                return false;
            }
            
            try {
                const range = document.createRange();
                const selection = window.getSelection();
                
                if (element.firstChild) {
                    const safeOffset = position !== null && position !== undefined 
                        ? Math.min(position, element.textContent.length) 
                        : element.textContent.length;
                    
                    range.setStart(element.firstChild, safeOffset);
                    range.collapse(true);
                    
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    return true;
                } else {
                    // Si pas de firstChild, placer √† la fin
                    range.selectNodeContents(element);
                    range.collapse(false);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    return true;
                }
            } catch (error) {
                log(`‚ùå Erreur lors du placement du curseur: ${error.message}`, 'error');
                return false;
            }
        }
        
        // Gestion des √©v√©nements pour chaque cellule
        function setupCellEvents() {
            const cells = document.querySelectorAll('.test-cell');
            
            cells.forEach((cell, index) => {
                let hasBeenModified = false;
                
                // ‚úÖ √âv√©nement input (pendant la frappe) - CAPTURE AUTOMATIQUE
                cell.addEventListener('input', () => {
                    log(`üìù Input d√©tect√© sur ${cell.getAttribute('data-label')}`, 'info');
                    
                    // ‚úÖ CAPTURE AUTOMATIQUE D√àS LA MODIFICATION (comme dans l'app principale)
                    if (!hasBeenModified) {
                        hasBeenModified = true;
                        
                        // ‚úÖ CAPTURER L'√âTAT DE FOCUS AUTOMATIQUEMENT
                        capturedFocusState = {
                            element: cell,
                            position: getCaretOffsetWithin(cell),
                            timestamp: Date.now(),
                            rowIndex: 0, // Pour le test
                            colLabel: cell.getAttribute('data-label') || ''
                        };
                        
                        log(`üìù Modification d√©tect√©e sur ${cell.getAttribute('data-label')}`, 'info');
                        log(`üìù √âtat de focus captur√© automatiquement: ${capturedFocusState.colLabel}, position ${capturedFocusState.position}`, 'success');
                        
                        // Mettre √† jour les statistiques
                        testResults.captures++;
                        updateStatus(`Captures: ${testResults.captures}, Restaurations: ${testResults.restorations}, Succ√®s: ${testResults.successes}, Persistance: ${testResults.cursorPersistence}`);
                        
                    } else {
                        // ‚úÖ Mettre √† jour la position si la cellule est toujours active
                        if (document.activeElement === cell) {
                            capturedFocusState.position = getCaretOffsetWithin(cell);
                            log(`üìù Position mise √† jour: ${capturedFocusState.position}`, 'info');
                        }
                    }
                });
                
                // √âv√©nement focus
                cell.addEventListener('focus', () => {
                    log(`üìç Focus sur ${cell.getAttribute('data-label')}`, 'info');
                });
                
                // √âv√©nement blur
                cell.addEventListener('blur', () => {
                    log(`üö™ Blur sur ${cell.getAttribute('data-label')}`, 'info');
                    hasBeenModified = false;
                });
            });
        }
        
        // Initialisation
        log('‚úÖ Test de persistance du curseur initialis√© avec succ√®s', 'success');
        log('üéØ Objectif: Capture avant sauvegarde, restauration apr√®s, curseur persistant', 'success');
        log('üí° Le curseur doit rester visible et fonctionnel apr√®s restauration', 'info');
        
        // Configurer les √©v√©nements
        setupCellEvents();
        
        // Afficher l'√©tat initial
        log('üìä √âtat initial:', 'info');
        log('   - 3 cellules de test configur√©es', 'info');
        log('   - Syst√®me de capture int√©gr√© (captureFocusBeforeSave)', 'info');
        log('   - Syst√®me de restauration int√©gr√© (restoreFocusAfterSave)', 'info');
        log('   - Test de persistance du curseur', 'info');
        log('   - V√©rification automatique des positions restaur√©es', 'info');
        
        updateStatus('Pr√™t pour le test - Cliquez dans une cellule et placez le curseur');
    </script>
</body>
</html>
