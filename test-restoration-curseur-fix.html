<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Restauration Curseur Fix</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-cell { 
            border: 2px solid #007bff; 
            padding: 15px; 
            margin: 20px; 
            min-height: 60px;
            background: #f8f9fa;
            font-size: 16px;
        }
        .log { 
            background: #f8f9fa; 
            padding: 15px; 
            margin: 20px; 
            border-radius: 8px;
            font-family: monospace;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
        }
        .success { color: #28a745; font-weight: bold; }
        .warning { color: #ffc107; font-weight: bold; }
        .error { color: #dc3545; font-weight: bold; }
        .info { color: #17a2b8; font-weight: bold; }
        .saving { color: #6f42c1; font-weight: bold; }
        .focus-restored {
            background-color: #d4edda !important;
            border: 3px solid #28a745 !important;
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.4);
            animation: focusRestored 2s ease-in-out;
        }
        @keyframes focusRestored {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        button { 
            padding: 12px 20px; 
            margin: 8px; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }
        .btn-primary { background-color: #007bff; color: white; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-warning { background-color: #ffc107; color: black; }
        .instructions {
            background: #e3f2fd;
            padding: 15px;
            margin: 20px;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }
    </style>
</head>
<body>
    <h1>üß™ Test Restauration Curseur Fix</h1>
    
    <div class="instructions">
        <h3>üìã Instructions de Test</h3>
        <p><strong>Objectif :</strong> V√©rifier que la restauration du curseur fonctionne apr√®s la sauvegarde.</p>
        <ol>
            <li>Cliquez dans une cellule et tapez du texte</li>
            <li>Cliquez dans une autre cellule (changement de focus)</li>
            <li>Observez que la sauvegarde se d√©clenche</li>
            <li>Cliquez de nouveau dans la premi√®re cellule</li>
            <li>V√©rifiez que le curseur est restaur√© √† la bonne position</li>
        </ol>
    </div>
    
    <div class="test-cell" contenteditable="true" data-original-value="Cellule 1 - Test restauration">
        Cellule 1 - Test restauration
    </div>
    
    <div class="test-cell" contenteditable="true" data-original-value="Cellule 2 - Changement de focus">
        Cellule 2 - Changement de focus
    </div>
    
    <div style="margin: 20px;">
        <button onclick="testRestoration()" class="btn-primary">üß™ Test Restauration</button>
        <button onclick="testCycleComplet()" class="btn-success">üöÄ Test Cycle Complet</button>
        <button onclick="clearLog()" class="btn-warning">üóëÔ∏è Effacer Log</button>
    </div>
    
    <div class="log" id="log">
        <div class="info">üöÄ Test de restauration du curseur initialis√©</div>
    </div>
    
    <script>
        let logCount = 0;
        let savedFocusStates = new Map(); // Stocker les √©tats de focus par cellule
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = type;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
            logCount++;
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '<div class="info">üöÄ Test de restauration du curseur initialis√©</div>';
            logCount = 0;
        }
        
        // Simulation de getCursorPosition
        function getCursorPosition(element) {
            if (!element || element.contentEditable !== 'true') {
                return 0;
            }
            
            try {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    if (element.contains(range.startContainer)) {
                        const preCaretRange = range.cloneRange();
                        preCaretRange.selectNodeContents(element);
                        preCaretRange.setEnd(range.endContainer, range.endOffset);
                        const position = preCaretRange.toString().length;
                        log(`‚úÖ Position captur√©e: ${position}`, 'success');
                        return position;
                    }
                }
            } catch (error) {
                log(`‚ùå Erreur getCursorPosition: ${error.message}`, 'error');
            }
            return 0;
        }
        
        // Simulation de syncToMaster
        async function syncToMaster(isManualSave = false) {
            log(`üîÑ syncToMaster appel√© (isManualSave: ${isManualSave})`, 'saving');
            log('üíæ Sauvegarde en cours...', 'saving');
            
            // Simuler la sauvegarde
            await new Promise(resolve => setTimeout(resolve, 500));
            
            log('‚úÖ Sauvegarde r√©ussie !', 'success');
            return true;
        }
        
        // Fonction restoreFocusAfterAutosave am√©lior√©e
        function restoreFocusAfterAutosave(focusState) {
            if (!focusState || !focusState.element) {
                log('‚ö†Ô∏è focusState invalide', 'warning');
                return;
            }

            try {
                log('üîÑ D√©but restauration focus...', 'info');
                
                // Restaurer le focus sur l'√©l√©ment
                focusState.element.focus();
                log('‚úÖ Focus restaur√© sur l\'√©l√©ment', 'success');
                
                // Restaurer la position du curseur
                if (focusState.position !== null && focusState.position !== undefined) {
                    const range = document.createRange();
                    const selection = window.getSelection();
                    
                    if (focusState.element.firstChild) {
                        const safeOffset = Math.min(focusState.position, focusState.element.textContent.length);
                        
                        try {
                            range.setStart(focusState.element.firstChild, safeOffset);
                            range.collapse(true);
                            
                            selection.removeAllRanges();
                            selection.addRange(range);
                            
                            log(`‚úÖ Curseur restaur√© √† la position ${safeOffset}`, 'success');
                        } catch (rangeError) {
                            log(`‚ö†Ô∏è Erreur lors de la restauration du curseur: ${rangeError.message}`, 'warning');
                            // Fallback: placer le curseur √† la fin
                            try {
                                range.selectNodeContents(focusState.element);
                                range.collapse(false);
                                selection.removeAllRanges();
                                selection.addRange(range);
                                log('‚úÖ Curseur plac√© √† la fin (fallback)', 'success');
                            } catch (fallbackError) {
                                log(`‚ùå Erreur fallback: ${fallbackError.message}`);
                            }
                        }
                    } else {
                        log('‚ö†Ô∏è Pas de firstChild, tentative de fallback', 'warning');
                        // Fallback: s√©lectionner tout le contenu
                        try {
                            range.selectNodeContents(focusState.element);
                            range.collapse(false);
                            selection.removeAllRanges();
                            selection.addRange(range);
                            log('‚úÖ Contenu s√©lectionn√© (fallback)', 'success');
                        } catch (fallbackError) {
                            log(`‚ùå Erreur fallback: ${fallbackError.message}`);
                        }
                    }
                } else {
                    log('‚ö†Ô∏è Position du curseur non disponible, placement √† la fin', 'warning');
                    // Placer le curseur √† la fin
                    try {
                        const range = document.createRange();
                        const selection = window.getSelection();
                        range.selectNodeContents(focusState.element);
                        range.collapse(false);
                        selection.removeAllRanges();
                        selection.addRange(range);
                        log('‚úÖ Curseur plac√© √† la fin', 'success');
                    } catch (fallbackError) {
                        log(`‚ùå Erreur fallback: ${fallbackError.message}`);
                    }
                }
                
                // Ajouter une classe visuelle pour indiquer la restauration
                focusState.element.classList.add('focus-restored');
                setTimeout(() => {
                    focusState.element.classList.remove('focus-restored');
                }, 2000);
                
                // S'assurer que l'√©l√©ment est visible
                focusState.element.scrollIntoView({ block: 'nearest', inline: 'nearest' });
                
                log('‚úÖ Restauration du focus termin√©e avec succ√®s', 'success');
                
            } catch (error) {
                log(`‚ùå Erreur lors de la restauration du focus: ${error.message}`, 'error');
            }
        }
        
        // Gestion des √©v√©nements pour chaque cellule
        function setupCellEvents() {
            const cells = document.querySelectorAll('.test-cell');
            
            cells.forEach((cell, index) => {
                let initialValue = cell.dataset.originalValue;
                
                // √âv√©nement blur (changement de focus)
                cell.addEventListener('blur', () => {
                    const currentValue = cell.textContent;
                    const normalizedCurrent = currentValue.trim();
                    const normalizedInitial = initialValue.trim();
                    
                    if (normalizedCurrent !== normalizedInitial) {
                        log(`üíæ Changement de focus d√©tect√© sur Cellule ${index + 1}`, 'saving');
                        
                        // Capturer l'√©tat du focus avant la sauvegarde
                        const focusState = {
                            element: cell,
                            position: getCursorPosition(cell)
                        };
                        
                        // ‚úÖ Stocker l'√©tat de focus pour restauration ult√©rieure
                        savedFocusStates.set(cell, focusState);
                        log(`üìù Focus captur√© et stock√© pour Cellule ${index + 1}: position ${focusState.position}`, 'success');
                        
                        // Sauvegarder au changement de focus
                        syncToMaster(false).then(() => {
                            log(`‚úÖ Sauvegarde au changement de focus r√©ussie pour Cellule ${index + 1}`, 'success');
                            
                            // Mettre √† jour la valeur initiale
                            initialValue = currentValue;
                            cell.dataset.originalValue = currentValue;
                            
                            log(`üíæ √âtat de focus sauvegard√© pour Cellule ${index + 1}`, 'info');
                        }).catch((error) => {
                            log(`‚ùå Erreur sauvegarde: ${error.message}`, 'error');
                        });
                    } else {
                        log(`üö´ Blur ignor√© sur Cellule ${index + 1} - aucun changement`, 'warning');
                    }
                });
                
                // √âv√©nement focus (retour sur la cellule)
                cell.addEventListener('focus', () => {
                    log(`üìç Focus sur Cellule ${index + 1}`, 'info');
                    
                    // ‚úÖ V√©rifier s'il y a un √©tat de focus sauvegard√© √† restaurer
                    const savedFocusState = savedFocusStates.get(cell);
                    if (savedFocusState) {
                        log(`üîÑ √âtat de focus trouv√© pour Cellule ${index + 1}, restauration...`, 'info');
                        
                        // Restaurer le focus et le curseur
                        setTimeout(() => {
                            restoreFocusAfterAutosave(savedFocusState);
                        }, 100);
                        
                        // Nettoyer l'√©tat sauvegard√© apr√®s restauration
                        setTimeout(() => {
                            savedFocusStates.delete(cell);
                            log(`üßπ √âtat de focus nettoy√© pour Cellule ${index + 1}`, 'info');
                        }, 2000);
                    } else {
                        log(`‚ÑπÔ∏è Aucun √©tat de focus sauvegard√© pour Cellule ${index + 1}`, 'info');
                    }
                });
                
                // √âv√©nement input (pendant la frappe)
                cell.addEventListener('input', () => {
                    log(`üìù Input d√©tect√© sur Cellule ${index + 1}`, 'info');
                });
            });
        }
        
        // Test de restauration
        function testRestoration() {
            log('üß™ Test de restauration...', 'info');
            log('üìã Instructions:', 'info');
            log('   1. Cliquez dans la Cellule 1', 'info');
            log('   2. Tapez du texte et placez le curseur au milieu', 'info');
            log('   3. Cliquez dans la Cellule 2 (changement de focus)', 'info');
            log('   4. Cliquez de nouveau dans la Cellule 1', 'info');
            log('   5. V√©rifiez que le curseur est restaur√© √† la bonne position', 'info');
        }
        
        // Test du cycle complet
        function testCycleComplet() {
            log('üöÄ Test du cycle complet...', 'info');
            log('üìã Instructions:', 'info');
            log('   1. Testez la restauration sur plusieurs cellules', 'info');
            log('   2. V√©rifiez que chaque cellule garde sa position de curseur', 'info');
            log('   3. Observez les logs pour comprendre le processus', 'info');
        }
        
        // Initialisation
        log('‚úÖ Test initialis√© avec succ√®s', 'success');
        log('üéØ Objectif: Restauration du curseur apr√®s sauvegarde', 'success');
        
        // Configurer les √©v√©nements
        setupCellEvents();
        
        // Afficher l'√©tat initial
        log('üìä √âtat initial:', 'info');
        log('   - 2 cellules de test configur√©es', 'info');
        log('   - Syst√®me de sauvegarde d\'√©tat de focus actif', 'info');
        log('   - Restauration automatique au retour sur cellule', 'info');
    </script>
</body>
</html>
