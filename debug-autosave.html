<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Autosave</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .debug-panel { 
            background: #f0f0f0; 
            padding: 15px; 
            margin: 10px; 
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        .status { 
            padding: 5px; 
            margin: 2px; 
            border-radius: 3px;
            font-family: monospace;
        }
        .status.true { background: #d4edda; color: #155724; }
        .status.false { background: #f8d7da; color: #721c24; }
        .status.undefined { background: #fff3cd; color: #856404; }
        .log { 
            background: #000; 
            color: #0f0; 
            padding: 10px; 
            margin: 10px; 
            border-radius: 5px;
            font-family: monospace;
            max-height: 400px;
            overflow-y: auto;
        }
        button { 
            margin: 5px; 
            padding: 8px 16px; 
            background: #007bff; 
            color: white; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer;
        }
        button:hover { background: #0056b3; }
    </style>
</head>
<body>
    <h1>üîç Debug Autosave</h1>
    
    <div class="debug-panel">
        <h3>√âtat des Variables Critiques</h3>
        <div id="debug-status"></div>
    </div>
    
    <div class="debug-panel">
        <h3>Actions de Test</h3>
        <button onclick="testMarkEdited()">Test markEdited()</button>
        <button onclick="testAutosaveConditions()">Test Conditions Autosave</button>
        <button onclick="forceAutosave()">Forcer Autosave</button>
        <button onclick="clearLog()">Effacer Log</button>
    </div>
    
    <div class="debug-panel">
        <h3>Log de Debug</h3>
        <div class="log" id="debug-log"></div>
    </div>
    
    <script>
        let logCount = 0;
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('debug-log');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
            logCount++;
        }
        
        function clearLog() {
            document.getElementById('debug-log').innerHTML = '';
            logCount = 0;
        }
        
        function updateDebugStatus() {
            const statusDiv = document.getElementById('debug-status');
            
            // R√©cup√©rer les variables depuis la fen√™tre principale
            const mainWindow = window.opener || window;
            
            try {
                const status = {
                    'isTyping': mainWindow.isTyping,
                    'isDirty': mainWindow.isDirty,
                    'isSyncing': mainWindow.isSyncing,
                    'isPerformingUndoRedo': mainWindow.isPerformingUndoRedo,
                    'lastEditAt': mainWindow.lastEditAt ? new Date(mainWindow.lastEditAt).toLocaleTimeString() : 'undefined',
                    'AUTOSAVE_DELAY_MS': mainWindow.AUTOSAVE_DELAY_MS,
                    'suppressAutosaveUntil': mainWindow.suppressAutosaveUntil ? new Date(mainWindow.suppressAutosaveUntil).toLocaleTimeString() : 'undefined',
                    'currentOperation': mainWindow.currentOperation ? mainWindow.currentOperation.type : 'undefined',
                    'autosaveTicker': !!mainWindow.autosaveTicker,
                    'syncTimer': !!mainWindow._syncTimer
                };
                
                let html = '';
                for (const [key, value] of Object.entries(status)) {
                    const valueClass = value === true ? 'true' : (value === false ? 'false' : 'undefined');
                    html += `<div class="status ${valueClass}"><strong>${key}:</strong> ${value}</div>`;
                }
                
                statusDiv.innerHTML = html;
                
            } catch (error) {
                statusDiv.innerHTML = `<div class="status undefined">Erreur: ${error.message}</div>`;
            }
        }
        
        function testMarkEdited() {
            log('üß™ Test de markEdited()...');
            
            try {
                const mainWindow = window.opener || window;
                
                if (typeof mainWindow.markEdited === 'function') {
                    log('‚úÖ Fonction markEdited() trouv√©e');
                    
                    // Simuler une modification
                    mainWindow.isDirty = false;
                    mainWindow.lastEditAt = null;
                    
                    log('üìù Avant markEdited():');
                    log(`   isDirty: ${mainWindow.isDirty}`);
                    log(`   lastEditAt: ${mainWindow.lastEditAt}`);
                    
                    // Appeler markEdited
                    mainWindow.markEdited();
                    
                    log('üìù Apr√®s markEdited():');
                    log(`   isDirty: ${mainWindow.isDirty}`);
                    log(`   lastEditAt: ${mainWindow.lastEditAt ? new Date(mainWindow.lastEditAt).toLocaleTimeString() : 'undefined'}`);
                    
                } else {
                    log('‚ùå Fonction markEdited() non trouv√©e');
                }
                
            } catch (error) {
                log(`‚ùå Erreur lors du test: ${error.message}`);
            }
        }
        
        function testAutosaveConditions() {
            log('üß™ Test des conditions d\'autosave...');
            
            try {
                const mainWindow = window.opener || window;
                
                if (!mainWindow) {
                    log('‚ùå Fen√™tre principale non accessible');
                    return;
                }
                
                const conditions = {
                    'isTyping': mainWindow.isTyping,
                    'isPerformingUndoRedo': mainWindow.isPerformingUndoRedo,
                    'lastEditAt < AUTOSAVE_DELAY_MS': mainWindow.lastEditAt ? (Date.now() - mainWindow.lastEditAt < mainWindow.AUTOSAVE_DELAY_MS) : 'undefined',
                    'isDirty': mainWindow.isDirty,
                    'suppressAutosaveUntil': mainWindow.suppressAutosaveUntil ? (Date.now() < mainWindow.suppressAutosaveUntil) : false,
                    'currentOperation': mainWindow.currentOperation && mainWindow.currentOperation.type
                };
                
                log('üìä Conditions d\'autosave:');
                for (const [condition, value] of Object.entries(conditions)) {
                    const status = value ? '‚ùå BLOQUE' : '‚úÖ AUTORISE';
                    log(`   ${condition}: ${value} - ${status}`);
                }
                
                // V√©rifier si toutes les conditions sont remplies
                const allConditionsMet = Object.values(conditions).every(condition => !condition);
                log(`üéØ R√©sultat: ${allConditionsMet ? '‚úÖ Autosave AUTORIS√â' : '‚ùå Autosave BLOQU√â'}`);
                
            } catch (error) {
                log(`‚ùå Erreur lors du test: ${error.message}`);
            }
        }
        
        function forceAutosave() {
            log('üöÄ Tentative de for√ßage de l\'autosave...');
            
            try {
                const mainWindow = window.opener || window;
                
                if (typeof mainWindow.syncToMaster === 'function') {
                    log('‚úÖ Fonction syncToMaster() trouv√©e');
                    
                    // Forcer les conditions
                    mainWindow.isTyping = false;
                    mainWindow.isDirty = true;
                    mainWindow.lastEditAt = Date.now() - mainWindow.AUTOSAVE_DELAY_MS - 1000;
                    
                    log('üìù Conditions forc√©es:');
                    log(`   isTyping: ${mainWindow.isTyping}`);
                    log(`   isDirty: ${mainWindow.isDirty}`);
                    log(`   lastEditAt: ${new Date(mainWindow.lastEditAt).toLocaleTimeString()}`);
                    
                    // Appeler syncToMaster
                    mainWindow.syncToMaster(false).then(() => {
                        log('‚úÖ syncToMaster() ex√©cut√© avec succ√®s');
                    }).catch((error) => {
                        log(`‚ùå Erreur syncToMaster(): ${error.message}`);
                    });
                    
                } else {
                    log('‚ùå Fonction syncToMaster() non trouv√©e');
                }
                
            } catch (error) {
                log(`‚ùå Erreur lors du for√ßage: ${error.message}`);
            }
        }
        
        // Mise √† jour automatique du statut
        setInterval(updateDebugStatus, 1000);
        
        // Initialisation
        log('üöÄ Debug Autosave initialis√©');
        log('Ouvrez ce fichier dans une fen√™tre popup de votre application principale');
        log('Utilisez les boutons pour tester les diff√©rentes fonctions');
        
        // Premi√®re mise √† jour
        updateDebugStatus();
    </script>
</body>
</html>
